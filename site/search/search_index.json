{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to NT98336/NT98633 Documents \u00b6","title":"Welcome to NT98336/NT98633 Documents"},{"location":"index.html#welcome-to-nt98336nt98633-documents","text":"","title":"Welcome to NT98336/NT98633 Documents"},{"location":"NT9833X_IVE_User_Guide_en.html","text":"1 IVE Introduction \u00b6 1.1 API List \u00b6 l NVT_IVE_Filter : General filter function l NVT_IVE_Median : 3x3 Median filter function l NVT_IVE_Min : 3x3 Min filter function l NVT_IVE_Max : 3x3 Max filter function l NVT_IVE_Sobel : 5x5 Sobel filter function l NVT_IVE_Thresh : Image thresholding function l NVT_IVE_Dilate : Image dilate function l NVT_IVE_Erode : Image erode function l NVT_IVE_Integ : Integral image function l NVT_IVE_Canny : Canny edge function l NVT_IVE_CSC : Color Space Conversion(CSC) function l NVT_IVE_Histo : Histogram function l NVT_IVE_NCC : Normalized Cross Correlation(NCC) function 2 API \u00b6 2.1 NVT_IVE_Filter \u00b6 \u3010Description\u3011 Applying 7x7 general filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Filter (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst, IVE_FILTER_CTRL_S* pstFltCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstFltCtrl General filter control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~16383x8191 pstDst U8C1 4 byte Same as pstSrc IVE_FILTER_CTRL_S Parameter Data Type Description u8Mask[10] UINT8 General filter Mask, range : 0~15 \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l Filter index number as following Figure 2.2?1 Figure 2.2?1 ??????????????? u8Mask[0]~ u8Mask[9] corresponds to index 0~9 l For image border pixels, mirror padding is applied in general filter process. \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_filter\\alg_ive_filter.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Filter is 634 , estimated by a sample (image resolution 516x376). 2.2 NVT_IVE_Median \u00b6 \u3010Description\u3011 Applying 3x3 Median filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Median (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~16383x8191 pstDst U8C1 4 byte Same as pstSrc \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l For image border pixels, mirror padding is applied in median filter process. \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_median\\alg_ive_median.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Median is 634 , estimated by sample (image resolution 516x376). 2.3 NVT_IVE_Min \u00b6 \u3010Description\u3011 Applying 3x3 Min filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Min (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~16383x8191 pstDst U8C1 4 byte Same as pstSrc \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l For image border pixels, mirror padding is applied in min filter process. \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_min\\alg_ive_min.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Min is 634 , estimated by sample (image resolution 516x376). 2.4 NVT_IVE_Max \u00b6 \u3010Description\u3011 ???????? Applying 3x3 Max filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Max (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~16383x8191 pstDst U8C1 4 byte Same as pstSrc \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l For image border pixels, mirror padding is applied in max filter process. \u3010Sample\u3011 hdal\\samples\\alg_ive_max\\alg_ive_max.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Max is 636 , estimated by sample (image resolution 516x376). 2.5 NVT_IVE_Sobel \u00b6 \u3010Description\u3011 ???????? Applying 5x5 Sobel filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Sobel (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst, IVE_SOBEL_CTRL_S* pstSobelCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output gradient x/y packed image pointer Output pstSobelCtrl Edge filter parameter pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~16383x8191 pstDst S16C1 4 byte 16x16~16383x8191 IVE_SOBEL_CTRL_S Parameter Data Type Description s8Mask[25] S8 Edge filter Mask, range : -15~15 \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l ??????? User can set s8Mask for calculating gradient x, and the library will transpose and flip the mask for calculating gradient y. The mask index is shown as below: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 l User can set pstDst format as S16C1. If user set as S16C1, the output will be signed 8 bit gradient x/y packed format(gradient x signed 8bit + gradient y signed 8bit per pixel). \u3010Sample\u3011 hdal\\samples\\alg_ive_sobel\\alg_ive_sobel.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Sobel is 657 , estimated by sample (image resolution 516x376). 2.6 NVT_IVE_Thresh \u00b6 \u3010Description\u3011 NVT_IVE_Thresh applies two user-defined thresholds to partition an input image into a tenary image. \u3010Function\u3011 INT32 NVT_IVE_Thresh (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst, IVE_THRESH_CTRL_S* pstThrCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstThrCtrl Thresholding control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 64x64~1920x1080 pstDst U8C1 4 byte Same as pstSrc IVE_THRESH_CTRL_S Parameter Data type Description u8LutThresh[15] U8 15 threshold levels: 0-255 (strictly increasing) \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l NVT_IVE_Thresh partitions image pixels into a 4bits image by LutThresh. The value of each output pixel could be 0-15. Each output pixel (U8C1) is the packed format by two neighbor pixel (LSB 4bit represent odd pixel, MSB 4bit represent even pixel). l Packed output format is shown as: \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_thresh\\alg_ive_thresh.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Thresh is 657 , estimated by sample (image resolution 316x316). 2.7 NVT_IVE_Dilate \u00b6 \u3010Description\u3011 Image dilation uses a 5x5 structural element to expand the shapes contained in input image. \u3010Function\u3011 INT32 NVT_IVE_Dilate (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst, IVE_MORPH_CTRL_S* pstDilateCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstDilateCtrl Dilation control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~16383x8191 pstDst U8C1 4 byte Same as pstSrc IVE_MORPH_CTRL_S Parameter Data Type Description u8Mask[24] U8 Structural element coefficients \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l The coefficients of structural element must be 0 or 1. l The 5x5 structural element is described by array u8Mask which contains 24 coefficients and the corresponding position in 2D space is Dilation uses a specified structural element to slide whole image and the process can be described as below for each image pixel p in input image I in { max = I in( p ) for(i=0; i<24; i++) { if(mask(i)==1 && I in_( q (i)) > max)?_ // q (i) is the corresponding pixel of coefficient i // max = I in_( q (i))_ } I out_( p ) = max_ } l For image border pixels, mirror padding is applied in dilation process. \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_dilate\\alg_ive_dilate.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Dilate is 440 , estimated by sample (image resolution 316x316). 2.8 NVT_IVE_Erode \u00b6 \u3010Description\u3011 Image erosion uses a 5x5 structural element to reduce the shapes contained in input image. \u3010Function\u3011 INT32 NVT_IVE_Erode (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst, IVE_MORPH_CTRL_S* pstErodeCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image Input pstDst Output image Output pstErodeCtrl Erosion control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~16383x8191 pstDst U8C1 4 byte Same as pstSrc IVE_MORPH_CTRL_S Parameter Data Type Description u8Mask[24] U8 Structural element coefficients \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l ??????? The coefficients of structural element must be 0 or 1. l The 5x5 structural element is described by array u8Mask which contains 24 coefficients and the corresponding position in 2D space is Erosion uses a specified structural element to slide whole image and the process can be described as below for each image pixel p in input image I in { min = I in( p ) for(i=0; i<24; i++) { if(mask(i)==1 && I in_( q (i)) < min)?_ // q (i) is the corresponding pixel of coefficient i // min = I in_( q (i))_ } I out_( p ) = min_ } l For image border pixels, mirror padding is applied in erosion process. \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_erode\\alg_ive_erode.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Erode is 465 , estimated by sample (image resolution 316x316). 2.9 NVT_IVE_Integ \u00b6 \u3010Description\u3011 This function calculates the sum of values in a rectangular subset of a grid: \u3010Function\u3011 INT32 NVT_IVE_Integ (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst, IVE_INTEG_CTRL_S *pstIntegCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstIntegCtrl Integral control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~1920x8191 pstDst U32C1 4 byte Same as pstSrc IVE_INTEG_CTRL_S Parameter Data Type Description enInFormat LIB_IVE_INTEGRAL_IN_FMT 0: 1 channel 1: 2 channel packed enOutFormat LIB_IVE_INTEGRAL_OUT_FMT 0: sum \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 ???????? The input format supports 1 channel 8 bit / 2 channel 8 bit packed. The output format supports integral sum (32bit). \u3010Sample\u3011 ???????? Sample code : samples\\alg_ive_integral\\alg_ive_integral.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Integral is 10652 , estimated by sample (image resolution 316x316). 2.10 NVT_IVE_Canny \u00b6 \u3010Description\u3011 NVT_IVE_Canny extract edges in a gray scale image by following steps l Image smoothing l Image gradient and gradient magnitude calculation l Non-maximun suppression \u3010Function\u3011 INT32 NVT_IVE_Canny (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst, IVE_CANNY_CTRL_S* pstCannyCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstCannyCtrl Edge detection control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~16383x8191 pstDst U8C1 4 byte Same as pstSrc \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l The edge detection process uses a 7x7 kernel to smooth input image. The smoothing kernel is described by an array with 10 elements, s8Mask , and the corresponding position in 2D space is The valid value range of s8Mask is [-15, 15]. \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_canny\\alg_ive_canny.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Canny is 458 , estimated by sample (image resolution 316x316). 2.11 NVT_IVE_CSC \u00b6 \u3010Description\u3011 NVT_IVE_CSC can do color space conversion from YUV to RGB or HSV or LAB. \u3010Function\u3011 INT32 NVT_IVE_CSC (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst, IVE_CSC_CTRL_S* pstCscCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstCscCtrl CSC control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~4096x8191 pstDst U8C1 4 byte Same as pstSrc IVE_CSC_CTRL_S Parameter Data Type Description enCSCMode LIB_IVE_CSC_MODE 0: YUV2RGB 1: YUV2HSV 2: YUV2LAB enOutFmt LIB_IVE_CSC_OUT_FMT 0: PLANAR 1: PACKED enLabFmt LIB_IVE_CSC_LAB_FMT 0: D65 1: D50 enRgbFmt LIB_IVE_CSC_RGB_FMT 0: BT601 1: BT709 2: JPG encoder \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l Only support YUV420SP(NV12)/YVU420SP(NV21)/YUV422 input YUV420SP(NV12): YVU420SP(NV21): YUV422 support UYVY\u3001YUYV\u3001VYUY\u3001YVYU 4 types. l Output format PLANAR/ PACKED as following figure PLANAR: pstDst->u32Stride = width PACKED: pstDst->u32Stride = 3*width l YUV2RGB : YUV->RGB ->Gamma Correction YUV2HSV : YUV ->RGB ->Gamma correction ->HSV YUV2LAB : YUV ->RGB ->Gamma correction ->LAB enRgbFmt should be set for all enCSCMode. \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_csc\\alg_ive_csc.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Canny is 458 , estimated by sample (image resolution 512x376). 2.12 NVT_IVE_Histo \u00b6 \u3010Description\u3011 ???????? NVT_IVE_Histo can calculate histogram for input image. \u3010Function\u3011 INT32 NVT_IVE_Histo (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output histogram result pointer Output Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 64x64~1920x1080 pstDst U8C1 4 byte 1024 byte \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l Histogram output size = 256(bin) x 4(byte) = 1024(byte) \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_histo\\alg_ive_histo.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Histo is 756 , estimated by a sample (image resolution 512x376). 2.13 NVT_IVE_NCC \u00b6 \u3010Description\u3011 ???????? NVT_IVE_NCC can calculate normalized cross correlation. The formula is shown below: \u3010Function\u3011 INT32 NVT_IVE_NCC (IVE_SRC_IMAGE_S pstSrc1, IVE_SRC_IMAGE_S pstSrc2, IVE_NCC_INFO_S* pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc1 Input image pointer Input pstSrc2 Input image pointer Input pstDst Ouput NCC result pointer Output Parameter Data type Alignment Resolution pstSrc1 U8C1 4 byte 32x32~1920x1080 pstSrc2 U8C1 4 byte Same as pstSrc1 pstDst Data structure - - IVE_NCC_INFO_S Parameter Data Type Description u64Numerator UINT64 NCC numerator u64QuadSum1 UINT64 NCC quad sum from pstSrc1 u64QuadSum2 UINT64 NCC quad sum from pstSrc2 \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l After trigger NVT_IVE_NCC, calculation result is stored in pstDst. \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_ncc\\alg_ive_ncc.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_NCC is 625 , estimated by a sample (image resolution 512x376). 3 Error Code \u00b6 Return value Description LIB_IVE_OK Execute success LIB_IVE_ERR_PARAM Lib IVE param setting failure LIB_IVE_ERR_INIT IVE hardware init failure LIB_IVE_ERR_LOCK IVE hardware lock failure LIB_IVE_ERR_SET IVE hardware set param failure LIB_IVE_ERR_GET IVE hardware get param failure LIB_IVE_ERR_TRIG IVE hardware trigger failure LIB_IVE_ERR_UNLOCK IVE hardware unlock failure LIB_IVE_ERR_UNINIT IVE hardware uninit failure 4 Revision History \u00b6 Revision Date Author Changes 1.0 2022/5/9 Ethan Wang First Version.","title":"IVE User Guide"},{"location":"NT9833X_IVE_User_Guide_en.html#1-ive-introduction","text":"","title":"1 IVE Introduction"},{"location":"NT9833X_IVE_User_Guide_en.html#11-api-list","text":"l NVT_IVE_Filter : General filter function l NVT_IVE_Median : 3x3 Median filter function l NVT_IVE_Min : 3x3 Min filter function l NVT_IVE_Max : 3x3 Max filter function l NVT_IVE_Sobel : 5x5 Sobel filter function l NVT_IVE_Thresh : Image thresholding function l NVT_IVE_Dilate : Image dilate function l NVT_IVE_Erode : Image erode function l NVT_IVE_Integ : Integral image function l NVT_IVE_Canny : Canny edge function l NVT_IVE_CSC : Color Space Conversion(CSC) function l NVT_IVE_Histo : Histogram function l NVT_IVE_NCC : Normalized Cross Correlation(NCC) function","title":"1.1 API List"},{"location":"NT9833X_IVE_User_Guide_en.html#2-api","text":"","title":"2 API"},{"location":"NT9833X_IVE_User_Guide_en.html#21-nvt_ive_filter","text":"\u3010Description\u3011 Applying 7x7 general filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Filter (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst, IVE_FILTER_CTRL_S* pstFltCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstFltCtrl General filter control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~16383x8191 pstDst U8C1 4 byte Same as pstSrc IVE_FILTER_CTRL_S Parameter Data Type Description u8Mask[10] UINT8 General filter Mask, range : 0~15 \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l Filter index number as following Figure 2.2?1 Figure 2.2?1 ??????????????? u8Mask[0]~ u8Mask[9] corresponds to index 0~9 l For image border pixels, mirror padding is applied in general filter process. \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_filter\\alg_ive_filter.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Filter is 634 , estimated by a sample (image resolution 516x376).","title":"2.1 NVT_IVE_Filter"},{"location":"NT9833X_IVE_User_Guide_en.html#22-nvt_ive_median","text":"\u3010Description\u3011 Applying 3x3 Median filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Median (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~16383x8191 pstDst U8C1 4 byte Same as pstSrc \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l For image border pixels, mirror padding is applied in median filter process. \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_median\\alg_ive_median.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Median is 634 , estimated by sample (image resolution 516x376).","title":"2.2 NVT_IVE_Median"},{"location":"NT9833X_IVE_User_Guide_en.html#23-nvt_ive_min","text":"\u3010Description\u3011 Applying 3x3 Min filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Min (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~16383x8191 pstDst U8C1 4 byte Same as pstSrc \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l For image border pixels, mirror padding is applied in min filter process. \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_min\\alg_ive_min.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Min is 634 , estimated by sample (image resolution 516x376).","title":"2.3 NVT_IVE_Min"},{"location":"NT9833X_IVE_User_Guide_en.html#24-nvt_ive_max","text":"\u3010Description\u3011 ???????? Applying 3x3 Max filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Max (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~16383x8191 pstDst U8C1 4 byte Same as pstSrc \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l For image border pixels, mirror padding is applied in max filter process. \u3010Sample\u3011 hdal\\samples\\alg_ive_max\\alg_ive_max.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Max is 636 , estimated by sample (image resolution 516x376).","title":"2.4 NVT_IVE_Max"},{"location":"NT9833X_IVE_User_Guide_en.html#25-nvt_ive_sobel","text":"\u3010Description\u3011 ???????? Applying 5x5 Sobel filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Sobel (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst, IVE_SOBEL_CTRL_S* pstSobelCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output gradient x/y packed image pointer Output pstSobelCtrl Edge filter parameter pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~16383x8191 pstDst S16C1 4 byte 16x16~16383x8191 IVE_SOBEL_CTRL_S Parameter Data Type Description s8Mask[25] S8 Edge filter Mask, range : -15~15 \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l ??????? User can set s8Mask for calculating gradient x, and the library will transpose and flip the mask for calculating gradient y. The mask index is shown as below: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 l User can set pstDst format as S16C1. If user set as S16C1, the output will be signed 8 bit gradient x/y packed format(gradient x signed 8bit + gradient y signed 8bit per pixel). \u3010Sample\u3011 hdal\\samples\\alg_ive_sobel\\alg_ive_sobel.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Sobel is 657 , estimated by sample (image resolution 516x376).","title":"2.5 NVT_IVE_Sobel"},{"location":"NT9833X_IVE_User_Guide_en.html#26-nvt_ive_thresh","text":"\u3010Description\u3011 NVT_IVE_Thresh applies two user-defined thresholds to partition an input image into a tenary image. \u3010Function\u3011 INT32 NVT_IVE_Thresh (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst, IVE_THRESH_CTRL_S* pstThrCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstThrCtrl Thresholding control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 64x64~1920x1080 pstDst U8C1 4 byte Same as pstSrc IVE_THRESH_CTRL_S Parameter Data type Description u8LutThresh[15] U8 15 threshold levels: 0-255 (strictly increasing) \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l NVT_IVE_Thresh partitions image pixels into a 4bits image by LutThresh. The value of each output pixel could be 0-15. Each output pixel (U8C1) is the packed format by two neighbor pixel (LSB 4bit represent odd pixel, MSB 4bit represent even pixel). l Packed output format is shown as: \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_thresh\\alg_ive_thresh.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Thresh is 657 , estimated by sample (image resolution 316x316).","title":"2.6 NVT_IVE_Thresh"},{"location":"NT9833X_IVE_User_Guide_en.html#27-nvt_ive_dilate","text":"\u3010Description\u3011 Image dilation uses a 5x5 structural element to expand the shapes contained in input image. \u3010Function\u3011 INT32 NVT_IVE_Dilate (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst, IVE_MORPH_CTRL_S* pstDilateCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstDilateCtrl Dilation control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~16383x8191 pstDst U8C1 4 byte Same as pstSrc IVE_MORPH_CTRL_S Parameter Data Type Description u8Mask[24] U8 Structural element coefficients \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l The coefficients of structural element must be 0 or 1. l The 5x5 structural element is described by array u8Mask which contains 24 coefficients and the corresponding position in 2D space is Dilation uses a specified structural element to slide whole image and the process can be described as below for each image pixel p in input image I in { max = I in( p ) for(i=0; i<24; i++) { if(mask(i)==1 && I in_( q (i)) > max)?_ // q (i) is the corresponding pixel of coefficient i // max = I in_( q (i))_ } I out_( p ) = max_ } l For image border pixels, mirror padding is applied in dilation process. \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_dilate\\alg_ive_dilate.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Dilate is 440 , estimated by sample (image resolution 316x316).","title":"2.7 NVT_IVE_Dilate"},{"location":"NT9833X_IVE_User_Guide_en.html#28-nvt_ive_erode","text":"\u3010Description\u3011 Image erosion uses a 5x5 structural element to reduce the shapes contained in input image. \u3010Function\u3011 INT32 NVT_IVE_Erode (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst, IVE_MORPH_CTRL_S* pstErodeCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image Input pstDst Output image Output pstErodeCtrl Erosion control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~16383x8191 pstDst U8C1 4 byte Same as pstSrc IVE_MORPH_CTRL_S Parameter Data Type Description u8Mask[24] U8 Structural element coefficients \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l ??????? The coefficients of structural element must be 0 or 1. l The 5x5 structural element is described by array u8Mask which contains 24 coefficients and the corresponding position in 2D space is Erosion uses a specified structural element to slide whole image and the process can be described as below for each image pixel p in input image I in { min = I in( p ) for(i=0; i<24; i++) { if(mask(i)==1 && I in_( q (i)) < min)?_ // q (i) is the corresponding pixel of coefficient i // min = I in_( q (i))_ } I out_( p ) = min_ } l For image border pixels, mirror padding is applied in erosion process. \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_erode\\alg_ive_erode.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Erode is 465 , estimated by sample (image resolution 316x316).","title":"2.8 NVT_IVE_Erode"},{"location":"NT9833X_IVE_User_Guide_en.html#29-nvt_ive_integ","text":"\u3010Description\u3011 This function calculates the sum of values in a rectangular subset of a grid: \u3010Function\u3011 INT32 NVT_IVE_Integ (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst, IVE_INTEG_CTRL_S *pstIntegCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstIntegCtrl Integral control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~1920x8191 pstDst U32C1 4 byte Same as pstSrc IVE_INTEG_CTRL_S Parameter Data Type Description enInFormat LIB_IVE_INTEGRAL_IN_FMT 0: 1 channel 1: 2 channel packed enOutFormat LIB_IVE_INTEGRAL_OUT_FMT 0: sum \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 ???????? The input format supports 1 channel 8 bit / 2 channel 8 bit packed. The output format supports integral sum (32bit). \u3010Sample\u3011 ???????? Sample code : samples\\alg_ive_integral\\alg_ive_integral.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Integral is 10652 , estimated by sample (image resolution 316x316).","title":"2.9 NVT_IVE_Integ"},{"location":"NT9833X_IVE_User_Guide_en.html#210-nvt_ive_canny","text":"\u3010Description\u3011 NVT_IVE_Canny extract edges in a gray scale image by following steps l Image smoothing l Image gradient and gradient magnitude calculation l Non-maximun suppression \u3010Function\u3011 INT32 NVT_IVE_Canny (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst, IVE_CANNY_CTRL_S* pstCannyCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstCannyCtrl Edge detection control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~16383x8191 pstDst U8C1 4 byte Same as pstSrc \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l The edge detection process uses a 7x7 kernel to smooth input image. The smoothing kernel is described by an array with 10 elements, s8Mask , and the corresponding position in 2D space is The valid value range of s8Mask is [-15, 15]. \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_canny\\alg_ive_canny.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Canny is 458 , estimated by sample (image resolution 316x316).","title":"2.10 NVT_IVE_Canny"},{"location":"NT9833X_IVE_User_Guide_en.html#211-nvt_ive_csc","text":"\u3010Description\u3011 NVT_IVE_CSC can do color space conversion from YUV to RGB or HSV or LAB. \u3010Function\u3011 INT32 NVT_IVE_CSC (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst, IVE_CSC_CTRL_S* pstCscCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstCscCtrl CSC control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16~4096x8191 pstDst U8C1 4 byte Same as pstSrc IVE_CSC_CTRL_S Parameter Data Type Description enCSCMode LIB_IVE_CSC_MODE 0: YUV2RGB 1: YUV2HSV 2: YUV2LAB enOutFmt LIB_IVE_CSC_OUT_FMT 0: PLANAR 1: PACKED enLabFmt LIB_IVE_CSC_LAB_FMT 0: D65 1: D50 enRgbFmt LIB_IVE_CSC_RGB_FMT 0: BT601 1: BT709 2: JPG encoder \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l Only support YUV420SP(NV12)/YVU420SP(NV21)/YUV422 input YUV420SP(NV12): YVU420SP(NV21): YUV422 support UYVY\u3001YUYV\u3001VYUY\u3001YVYU 4 types. l Output format PLANAR/ PACKED as following figure PLANAR: pstDst->u32Stride = width PACKED: pstDst->u32Stride = 3*width l YUV2RGB : YUV->RGB ->Gamma Correction YUV2HSV : YUV ->RGB ->Gamma correction ->HSV YUV2LAB : YUV ->RGB ->Gamma correction ->LAB enRgbFmt should be set for all enCSCMode. \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_csc\\alg_ive_csc.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Canny is 458 , estimated by sample (image resolution 512x376).","title":"2.11 NVT_IVE_CSC"},{"location":"NT9833X_IVE_User_Guide_en.html#212-nvt_ive_histo","text":"\u3010Description\u3011 ???????? NVT_IVE_Histo can calculate histogram for input image. \u3010Function\u3011 INT32 NVT_IVE_Histo (IVE_SRC_IMAGE_S pstSrc, IVE_DST_IMAGE_S pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output histogram result pointer Output Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 64x64~1920x1080 pstDst U8C1 4 byte 1024 byte \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l Histogram output size = 256(bin) x 4(byte) = 1024(byte) \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_histo\\alg_ive_histo.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_Histo is 756 , estimated by a sample (image resolution 512x376).","title":"2.12 NVT_IVE_Histo"},{"location":"NT9833X_IVE_User_Guide_en.html#213-nvt_ive_ncc","text":"\u3010Description\u3011 ???????? NVT_IVE_NCC can calculate normalized cross correlation. The formula is shown below: \u3010Function\u3011 INT32 NVT_IVE_NCC (IVE_SRC_IMAGE_S pstSrc1, IVE_SRC_IMAGE_S pstSrc2, IVE_NCC_INFO_S* pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc1 Input image pointer Input pstSrc2 Input image pointer Input pstDst Ouput NCC result pointer Output Parameter Data type Alignment Resolution pstSrc1 U8C1 4 byte 32x32~1920x1080 pstSrc2 U8C1 4 byte Same as pstSrc1 pstDst Data structure - - IVE_NCC_INFO_S Parameter Data Type Description u64Numerator UINT64 NCC numerator u64QuadSum1 UINT64 NCC quad sum from pstSrc1 u64QuadSum2 UINT64 NCC quad sum from pstSrc2 \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 ???????? Header file: libive.h ???????? Library file: libvendor_cv.a \u3010Notice\u3011 l After trigger NVT_IVE_NCC, calculation result is stored in pstDst. \u3010Sample\u3011 ???????? hdal\\samples\\alg_ive_ncc\\alg_ive_ncc.c \u3010Efficiency\u3011 l The execution time is proportional to the resolution of an image. l The execution time of NVT_IVE_NCC is 625 , estimated by a sample (image resolution 512x376).","title":"2.13 NVT_IVE_NCC"},{"location":"NT9833X_IVE_User_Guide_en.html#3-error-code","text":"Return value Description LIB_IVE_OK Execute success LIB_IVE_ERR_PARAM Lib IVE param setting failure LIB_IVE_ERR_INIT IVE hardware init failure LIB_IVE_ERR_LOCK IVE hardware lock failure LIB_IVE_ERR_SET IVE hardware set param failure LIB_IVE_ERR_GET IVE hardware get param failure LIB_IVE_ERR_TRIG IVE hardware trigger failure LIB_IVE_ERR_UNLOCK IVE hardware unlock failure LIB_IVE_ERR_UNINIT IVE hardware uninit failure","title":"3 Error Code"},{"location":"NT9833X_IVE_User_Guide_en.html#4-revision-history","text":"Revision Date Author Changes 1.0 2022/5/9 Ethan Wang First Version.","title":"4 Revision History"},{"location":"NT9833X_MD_User_Guide_en.html","text":"NT9833X MD User Guide 1 Introduction \u00b6 1.1 Overview \u00b6 The motion detection supports applications including global motion detection, sub-region motion detection, motion object detection and tamper detection. l Global motion detection By using a fixed camera, global motion detection issues alarm if the area of moving objects is larger than the user-defined threshold. Figure 1? Global motion detection l Sub-region motion detection By using a fixed camera, this function issues a sub-region motion alarm if the area of moving objects in the user-defined regions is larger than the user-defined threshold. Figure 2? Sub-region motion alarm l Motion objects detection By using a fixed camera, it detects moving objects if their areas are larger than a user-defined threshold.? It also reports the sizes and coordinates of detected moving objects. Figure 3? Motion objects detection l Tamper detection By using a fixed camera, it issues a tamper alarm if the occlusion area is larger than a user-defined area threshold. Figure 4: Tamper Detection 1.2 Motion detection steps \u00b6 The steps of motion detection functions are Step. 1: Generating a initial background model by using the first few frames. Step. 2: Micro block (MB) map is used in motion detection. The size of each MB can be 32x32 or 16x16. The algorithm determines a MB as a motion block if the variance of blocks is higher than a predefined threshold. Step. 3: Updating the background model by using current frame information. Figure 5. The flowchart of MD algoritm 1.3 Process Flow \u00b6 Figure 6. The process flow of MD 1.4 Parameters \u00b6 MD has two major parameter types, as listed below l The parameters of vendor MD are used to control MD hardware. l The parameters of libmd are used to control MD software application. l Please notice that the parameters of vendor MD should be set before setting the parameters of libmd. 1.4.1 Parameters of vendor MD \u00b6 l VENDOR_MD_CTRL: trigger setting of MD hardware Parameter Range Comment Value engine_enabled 0, 1 HW trigger setting 0: close 1: open l VENDOR_MD_MDT_INFO: size information of MD hardware Parameter Range Comment Value phy_width 32~3840 Sensor resolution (width) \u2013 phy_height 16~2160 Sensor resolution (height) \u2013 phy_mb_x_size 16, 32 The x-size of micro-block (MB) for HW Set 32 when the phy_height is bigger than 1088. Set 16 when the phy_height is smaller than or equal to 1088. phy_mb_y_size 16, 32 The y-size of MB for HW Same value of phy_mb_x_size. phy_mb_x_num The number of MB in the MB-map at x-direction phy_width/ phy_mb_x_size phy_mb_y_num The number of MB in the MB-map at y-direction phy_height/ phy_mb_y_size l VENDOR_MD_MDT_PARAM_IDX: index of MD background model parameters id Comment VENDOR_MD_MDT_PARAM_RST Background model reset VENDOR_MD_MDT_PARAM_TYPE The method to construct background model VENDOR_MD_MDT_PARAM_TIME_PERIOD update time of background model (only for MD2) VENDOR_MD_MDT_PARAM_TBG Weight threshold of background model VENDOR_MD_MDT_PARAM_LVL_ALPHA Learning rate for the fitting background model VENDOR_MD_MDT_PARAM_LVL_ONE_MIN_ALPHA Learning rate for the nun-fitting background model VENDOR_MD_MDT_PARAM_LVL_INIT_WEIGHT Initial weight of background model VENDOR_MD_MDT_PARAM_LVL_MODEL_UPDATE Update constraint of background model VENDOR_MD_MDT_PARAM_LVL_TB Threshold of foreground detection VENDOR_MD_MDT_PARAM_LVL_SIGMA Variance threshold of background model VENDOR_MD_MDT_PARAM_LVL_TG Threshold of background model update VENDOR_MD_MDT_PARAM_LVL_PRUNE Threshold to decrease weight for nun-fitting background model VENDOR_MD_MDT_PARAM_LVL_LUMA_DIFF_THRES Luminance variance threshold at refine stage (only for MD1) VENDOR_MD_MDT_PARAM_LVL_TEXT_DIFF_THRES Texture variance threshold at refine stage (only for MD1) VENDOR_MD_MDT_PARAM_LVL_TEXT_THRES Texture strength threshold at refine stage (only for MD1) VENDOR_MD_MDT_PARAM_LVL_TEXT_RATIO_THRES Texture coverage ratio threshold at refine stage (only for MD1) VENDOR_MD_MDT_PARAM_LVL_GM_MD2_THRES Background threshold (only for MD2) l VENDOR_MD_MDT_PARAM: parameters of MD background model Parameter Comment out_id Path id level Choose the selective model id VENDOR_MD_MDT_PARAM_IDX value Parameter value l Value range of the VENDOR_MD_MDT_PARAM VENDOR_MD_MDT_PARAM_IDX Range Comment Value VENDOR_MD_MDT_PARAM_RST 0, 1 Reset MD background model 0: no reset 1: reset VENDOR_MD_MDT_PARAM_TYPE 0, 1 MD method type 0: MD1 (HW) (learning-based) 1: MD2 (HW) difference-based) VENDOR_MD_MDT_PARAM_TIME_PERIOD - Background update frame threshold (only for MD2) 10 VENDOR_MD_MDT_PARAM_TBG 1~32767 Background model weight threshold Suggest not to modify the value. 29490 VENDOR_MD_MDT_PARAM_LVL_ALPHA 1~32767 Background learning rate threshold when input fits model. Please set higher value when AE change obviously to avoid false alarm. 32 VENDOR_MD_MDT_PARAM_LVL_ONE_MIN_ALPHA 1~32767 Background learning rate threshold when input doesn\u2019t fit model. 32736 VENDOR_MD_MDT_PARAM_LVL_INIT_WEIGHT 1~32767 Background model initial weight 32 VENDOR_MD_MDT_PARAM_LVL_MODEL_UPDATE 0, 1 Background model constraint update Suggest not to modify the value. 0 VENDOR_MD_MDT_PARAM_LVL_TB 1~31 Background model fitting threshold. The MD is more sensitive when the value is lower. 25 VENDOR_MD_MDT_PARAM_LVL_SIGMA 1~31 Background model variance threshold. Set larger value to avoid false alarm when background luminance changes large. Please set the value lower when the MD result of detected object is broken. 25 VENDOR_MD_MDT_PARAM_LVL_TG 1~31 Background model count threshold. Suggest not to modify the value. 9 VENDOR_MD_MDT_PARAM_LVL_PRUNE 1~32767 Weight decrease threshold for un-fitting model 51 VENDOR_MD_MDT_PARAM_LVL_LUMA_DIFF_THRES 0~255 Luminance variance threshold at refine stage (only for MD1) 0 VENDOR_MD_MDT_PARAM_LVL_TEXT_DIFF_THRES 0~255 Texture variance threshold at refine stage (only for MD1) 0 VENDOR_MD_MDT_PARAM_LVL_TEXT_THRES 0~255 Texture strength threshold at refine stage (only for MD1) 0 VENDOR_MD_MDT_PARAM_LVL_TEXT_RATIO_THRES 0~127 Texture coverage ratio threshold at refine stage (only for MD1) 127 VENDOR_MD_MDT_PARAM_LVL_GM_MD2_THRES 0~255 Background threshold (only for MD2) 10 l VENDOR_MD_MDT_MB_LEVEL: region setting of the background model Parameter Range Comment x 0~max_width x position of the left upper corner of the region (physical plane, Unit: pixel) y 0~max_height y position of the left upper corner of the region (physical plane, Unit: pixel) width 1~max_width width of the left upper corner of the region (physical plane, Unit: pixel) height 1~max_height height of the left upper corner of the region (physical plane, Unit: pixel) level 0~3 The selective background model of the region l VENDOR_MD_TDT_PARAM_IDX: index of the tamper detection parameters id Comment VENDOR_MD_TDT_PARAM_TYPE Tamper detection method type VENDOR_MD_TDT_PARAM_EDGE_TEX_THRES Texture strength threshold VENDOR_MD_TDT_PARAM_EDGE_WIN_THRES Coverage of low texture strength threshold VENDOR_MD_TDT_PARAM_AVG_TEX_THRES Luminance strength threshold VENDOR_MD_TDT_PARAM_AVG_WIN_THRES Coverage of low luminance strength threshold l VENDOR_MD_MDT_PARAM: tamper detection parameters Parameter Comment out_id Path id id VENDOR_MD_TDT_PARAM_IDX value Parameter value l Value range of the tamper detection parameters VENDOR_MD_TDT_PARAM_IDX Range Comment Default VENDOR_MD_TDT_PARAM_TYPE 0, 1 Tamper detection method 0: edge-based 1: intensity based VENDOR_MD_TDT_PARAM_EDGE_TEX_THRES 0~255 Texture strength threshold 25 VENDOR_MD_TDT_PARAM_EDGE_WIN_THRES 0~127 Coverage of low texture strength threshold 100 VENDOR_MD_TDT_PARAM_AVG_TEX_THRES 0~255 Luminance strength threshold 65 VENDOR_MD_TDT_PARAM_AVG_WIN_THRES 0~127 Coverage of low luminance strength threshold 100 l VENDOR_BUFFER : buffer information structure Parameter Comment paddr Physical address size Buffer size ddr_id DDR_IDX l VENDOR_MD_BUFFER: buffer information of MD hardware Parameter Comment mb_x_num_max Maximum width of the MB number(Unit: MB number) mb_y_num_max Maximum height of the MB number(Unit: MB number) sta MD HW statistics value buffer event MD HWmotion bitmap buffer level MD HW selective background model buffer l VENDOR_MD_PARAM_ID: index of vendor_md function id Comment VENDOR_MD_CTRL_PARAM MD HW control structure VENDOR_MD_MOTION_DETECT_INFO MD HW process size unit structure VENDOR_MD_MOTION_DETECT_PARAM MD HW background model parameter structure VENDOR_MD_MOTION_DETECT_MB_LEVEL MD HW background model selective model structure VENDOR_MD_MOTION_DETECT_BUFFER MD HW buffer structure VENDOR_MD_TAMPER_DETECT_PARAM MD HW tamper parameter structure VENDOR_MD_RESULT_INFO MD HW result structure VENDOR_MD_REASSIGN_BUFFERS MD reassign buffer API. When max MB num is larger than (1920/16, 1080/16) or want to shrink MD buffer size. Note: hdal default pool buffer size for MD is (120,67) and 8 channel. If you use reassign buffer, you should change the hdal default pool buffer size. 1.4.2 Parameters of libmd \u00b6 l LIB_MD_AP_ENABLE: trigger setting of MD application:? Parameter Range Comment globel_md_alarm_detect_en 0, 1 Global motion alarm enable subregion_md_alarm_detect_en 0, 1 Sub-region motion alarm enable md_obj_detect_en 0, 1 Objects detection enable md_postprocess_en 0, 1 Motionbitmap postprocess enable l LIB_MD_EVT_INFO: results of motion detection Parameter Comment p_evt_map MD HW event bimap buffer evt_sz MD HW event bimap buffer size timestamp MD event timestamp l LIB_MD_MDT_INFO: size setting information of libmd Parameter Range Comment Default md_enabled 0, 1 Libmd enable vendor_md engine_enabled should be enable firstly vp_width 1~3840 User plane width suggest to set as sensor setting vp_height 1~2160 User plane height suggest to set as sensor setting vp_mb_x_size 16, 32 Width of MB size in the user plane suggest to set the same value of phy_mb_x_size vp_mb_y_size 16, 32 Height of MB size in the user plane suggest to set the same value of phy_mb_y_size vp_mb_x_num - Width of MB number in the user plane vp_width / vp_mb_x_size vp_mb_y_num - Height of MB number in the user plane vp_height / vp_mb_y_size phy_mb_x_size 16, 32 HW width of MB size set the same as vendor_md phy_mb_y_size 16, 32 HW height of MB size set the same as vendor_md phy_mb_x_num Sensor_width/ phy_mb_x_size set the same as vendor_md phy_mb_y_num Sensor_height/ phy_mb_y_size set the same as vendor_md l LIB_MD_AP_POSTPROCESS: post-process type of libmd event Parameter Range Comment Default evt_postprocess_type 0~7 Motion event postprocess 0: no 1: one erosion + two dilation 2: two dilation + one erosion 3: two dilation 4: one dilation 5: one erosion 6: one dilation + one erosion 7: one erosion + one dilation l LIB_MD_AP_GLOBAL_MOTION_ALARM: parameters of global motion alarm detection Parameter Range Comment motion_alarm_th 0~100 Global motion detection alarm area coverage ratio threshold (%). MD is more sensitive when the value is lower. ref_cell_en 0, 1 The detection result will reference p_cell_map or not. When the value is 1, the global motion alarm/ sub-region motion alarm/ object detection result will reference the p_cell_map. p_cell_map 0, 1 The detection result will reference the buffer when the ref_cell_en=1. cell_map_sz vp_mb_x_num* vp_mb_y_num The buffer size of the p_cell_map l LIB_MD_AP_SUBREGION: parameters of specified sub-region structure Parameter Range Comment enabled 0, 1 Sub-region motion detection alarm enable x_start 0~mb_w_num-1 x position of the left upper corner of the region (virtual plane\uff0cUnit: macro block) y_start 0~mb_h_num-1 y position of the left upper corner of the region (virtual plane\uff0cUnit: macro block) x_end 0~mb_w_num-1 x position of the right under corner of the region (virtual plane\uff0cUnit: macro block) y_end 0~mb_h_num-1 y position of the right under corner of the region (virtual plane\uff0cUnit: macro block) alarm_th 0~100 Sub-region motion detection alarm area coverage ratio threshold (%). MD is more sensitive when the value is lower. l LIB_MD_AP_SUBREGION_MOTION_ALARM: parameters of sub-region motion alarm detection Parameter Range Comment sub_region_num 0~4 Specified sub-region number sub_region - Specified sub-region structure l LIB_MD_AP_OBJ: size setting of minmum motion object Parameter Range Comment object_size - Minimum size of detected moing objects (Unit: macro block) l LIB_MD_AP_OBJ_INFO: information of motion objects Parameter Range Comment start_x 0~ vp_width x position of the left upper corner of the motion object (virtual plane\uff0cUnit:pixel) start_y 0~vp_height y position of the left upper corner of the motion object (virtual plane\uff0cUnit:pixel) end_x 0~ vp_width x position of the right under corner of the motion object (virtual plane\uff0cUnit: macro block) end_y 0~vp_height y position of the right under corner of the motion object (virtual plane\uff0cUnit: macro block) label 0~128 Motion obect index l LIB_MD_MDT_RESULT_INFO: results information of the libmd Parameter Range Comment Value global_motion_alarm 0, 1 Global motion detection alarm 0: no alarm 1: alarm global_motion_alarm_num 0~ vp_mb_x_num* vp_mb_y_num Motion MB number sub_motion_alarm 0, 1 Sub-region motion detection alarm 0: no alarm 1: alarm obj_num 0~128 Motion object number obj - Motion object structure vp_evt_info - Motion detection event map in the user plane l LIB_MD_PARAM_ID: index of libmd function Parameter Comment LIB_MD_MOTION_DETECT_INFO Libmd set virtual/physical plane evt bitmap addr. Physical plane should be set the same as vendor_md. Physical evt bitmap address is vendor_md output result motion bitmap address. evt bitmap addr\u70bavendor_md output result Libmd all detection application enable port LIB_MD_AP_ENABLE_PARAM Libmd postprocess enable LIB_MD_AP_POSTPROCESS_PARAM Libmd global motion detection enable LIB_MD_AP_GLOBAL_MOTION_ALARM_PARAM Libmd sub-region motion detection enable LIB_MD_AP_SUBREGION_MOTION_ALARM_PARAM Libmd motion object detection enable LIB_MD_AP_OBJ_PARAM Libmd result information Note: The MD model can lean the stable change of scene, such as river or twinkle light. If the user want to detect this kind of events, the parameters can be set as following: l Model parameters o tg=3 o tb=19 o alpha = 1024 l Refine process o lum_diff_th=75 o tex_diff_th=50 o tex_ratio_th=50 1.5 Initilization of MD \u00b6 l Vendor MD The buffer of vender MD and HW internal parametesrs should be set by the API as following: HD_RESULT md_init(void) ; l Libmd The buffer of libmd and software parametesrs should be set by the API as following: HD_RESULT motion_set_ap_param(UINT32 path_id) ; HD_RESULT lib_md_init(HD_PATH_ID path_id); // libmd buffer setting shoule be set after HW MD size setting which set through motion_set_ap_param. 1.6 Parameters Setting of MD \u00b6 l Vendor MD Vendor MD parameters should be set by the following API. ret = vendor_md_set(video_cap[ch], VENDOR_MD_CTRL_PARAM, &md_cfg); The content of VENDOR_MD_PARAM_ID is list in the section1.4.1. l Libmd The parameters of libmd should be set by the following API. ret = lib_md_set(path_id, LIB_MD_AP_ENABLE_PARAM, &mdt_lib_param[idx].mdt_enable); The content of LIB_MD_PARAM_ID is list in the section1.4.2. 1.7 Execution of MD \u00b6 1.7.1 vendor MD \u00b6 Vendor MD application should be set by the following API. // buffer and parameters intial setting HD_RESULT md_init(void); // create md_thread static void *md_thread(void *arg); //set and get vendor md API ret = vendor_md_get(path_id, VENDOR_MD_MOTION_DETECT_INFO, &mdt_info); ret = vendor_md_set(path_id, VENDOR_MD_RESULT_INFO, &result_info); ret = vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info); 1.7.2 libmd \u00b6 libmd application should be set by the following API. // buffer and parameters intial setting HD_RESULT motion_set_ap_param(UINT32 path_id); HD_RESULT lib_md_init(HD_PATH_ID path_id); // create md_thread static void *md_thread(void *arg); //set and get libmd API ret = vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info); //libmd process should use vendor_md result as input vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info) ret = lib_md_set(path_id, LIB_MD_MOTION_DETECT_INFO, &lib_md_info); ret = lib_md_get(path_id, LIB_MD_RESULT_INFO, &lib_md_rst); 1.8 Requirement of MD \u00b6 l MD funtions only be applied by CPU and HW. 1.9 Limitation of MD \u00b6 l MD shoud be used in the fixed-camera. If camera has been moved, MD function might output a false alarm event. l MD function might output a false alarm event because of the zoom in/out of camera or the adjustment of auto white balance. l The size of moving object should be larger than 1 micro-block (MB) 1.10 Test Flow of MD \u00b6 l Check MD use in the fixed-camera scene l Check MD event bitmap to check MD flow l MD should be used after 3 frames to create initial background. 2 Output \u00b6 2.1 Get Output Results of MD \u00b6 l vendor MD Vendor MD result should be set/got by the following API. ret = vendor_md_set(path_id, VENDOR_MD_RESULT_INFO, &result_info); ret = vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info); The structure of MD hardware result lists as following. typedef struct _VENDOR_MD_MDT_RESULT_INFO { UINT8???? ? *p_evt_map; ///< motion detection bitmap, size is evt_sz UINT32????? evt_sz; ///< phy_mb_x_num*phy_mb_y_num MB UINT8?????? tp_result; ///< tamper alarm ???? UINT32??? ? timestamp; } VENDOR_MD_MDT_RESULT_INFO; l libmd libmd result should be set/got by the following API. vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info) ret = lib_md_set(path_id, LIB_MD_MOTION_DETECT_INFO, &lib_md_info); ret = lib_md_get(path_id, LIB_MD_RESULT_INFO, &lib_md_rst); libmd result structure lists as following. typedef struct _LIB_MD_MDT_RESULT_INFO { UINT8???????? global_motion_alarm; ///< global motion alarm ???? UINT32??? ??? global_motion_alarm_num;?????? ???? ?????????///< global motion alarm num UINT32??????? sub_motion_alarm[LIB_MD_MAX_SUB_REGION_NUM]; ///< sub-region motion alarm UINT32??????? obj_num; ///< detect object number (max=128) ???? LIB_MD_AP_OBJ_INFO? obj[LIB_MD_MAX_OBJ_NUM];?????????? ????///< detect object info ???? LIB_MD_EVT_INFO vp_evt_info; } LIB_MD_MDT_RESULT_INFO; typedef struct _LIB_MD_EVT_INFO { UINT8???? ?? *p_evt_map; ///< motion detection bitmap, size is evt_sz UINT32?????? evt_sz; ///< mb_x_num*mb_y_num MB ???? UINT32??? ?? timestamp; } LIB_MD_EVT_INFO; typedef struct _LIB_MD_AP_OBJ_INFO { UINT32??????? start_x; ///< obj rectangle left upper x position (virtual pixel)? UINT32??????? start_y; ///< obj rectangle left upper y position (virtual pixel)? UINT32??????? end_x; ///< obj rectangle right down x position (virtual pixel)? UINT32??????? end_y; ///< obj rectangle right down y position (virtual pixel)? UINT32??????? label; ///< obj label } LIB_MD_AP_OBJ_INFO; 2.2 Print Output Results of MD \u00b6 l Output Result of Global Motion Detection UART will print the results as following when motion area in the whole scene is larger than user-defined threshold. > global motion alarm on ch (specified channel) . l Output Result of Sub-region Motion Detection UART will print the results as following when the motion area in one or more sub-regions is larger than user-defined threshold. > sub_region[ specified region index ] motion alarm on ch( specified channel ) . l Output Result of Motion Object Detection UART will print the results as following when motion objects area are larger than minimum object user-defined threshold. > obj num:Motion object number and obj[object index]: start_xy=[left upper corner position of motion object], end_xy = [right under corner position of motion object], label = object label. l Output Result of Tamper Detection UART will print the results as following when occlusion area is larger than user-defined threshold. > tamper_result: 1 on ch (specified channel) . 2.3 Limitation MD Hardware \u00b6 l Maximum sensor resolution is 3840x2160. l Maximum MB number of MD hardware are (mb_x_num, mb_y_num) = (256, 128) and minimum MB number of MD hardware are (mb_x_num, mb_y_num) = (2, 1). l In the Vcap flow, MD doesn\u2019t support the scale function. 2.4 Requirement of MD System \u00b6 l The efficiency of MD function is associated with system loading. The ouput result of MD may be delayed when system is overloading. 2.5 Tuning of MD Parameters \u00b6 l In the scene with the shortly changing of light, such as AE adjustment or turn-on and turn-off the light, please set the value of alpha higher. The side effect is that moving slowly object might be detected as background. l Please set tb to be higher for shadow. The side effect is that the detected forground of moving obeject might be broken. In this case, please also set \u201csigma\u201d to be lower to fix the broken forground issue. l The distance between moving object and camera should be farer than 30 cm. If the moving objects is too close to the camera, there might cause the false alarm of shadow. l Please set lower tb when foreground luminance is similar background. However, the side effect is that the false alarm of shadow may be increase. l Please see section 1.5 when you need to detect stable motion case. l The MD function doesn\u2019t support night view with IR-cut. In this case, there might be similar between background and foreground. l There is no motion event when MD is creating intial background model. Also, MD will need longer time to create initial backgroung model if there are some moving objects in the initial scene. l The size of moving object should be larger than 1 MB. 3 Q&A \u00b6 (1) How to check vendor MD version? Ans: echo md > /proc/hdal/flow Execute AP cat /proc/hdal/flow (2) How to set the md sensitive? Ans: I. Use vendor_md_set API (the details describe in the 1.6 section and the section 1.4.1. II. Tuning Guide document provide the tuning parameter suggestion. If any more question, please provide the video and parameters. (3) How to solve sensor resolution change error? Ans: If you want to chage sensor reolution, please vendor_md_unint & vendor_md_int at fisrt and you might see liveview_with_md_ctrl.c or liveview_with_md_resolution.c (4) How to check sensor interlace case? Ans: MD is field input. If input is interlace, please set the half of the sensor input height. You can see interlace case through command as following cat /proc/vcap316/vcap0/vg_info. (5) Check AD mode (960H and 720) case Ans: I. Check AD output is full frame. II. MD input size is the same as the AD output size. phy_width andphy_height should be calculate by AD output (might not be the size of sensor). The size setting check by /proc/vcap316/vcap0/vg_info?and vcap md (detal describe in question 6 ). (6) If any setting question of the vendor_md flow, please provide the log of vendor_md flow by the following command. Ans: echo md > /proc/hdal/flow Execute AP cat /proc/hdal/flow (7) How to check vcap md setting Ans: echo vcap_ch > /proc/vcap316/vcap0/vcap0.CHIP/md/event (vcap_ch and CHIP according to vg_info) cat /proc/vcap316/vcap0/vcap0. CHIP /md/region cat /proc/vcap316/vcap0/vcap0. CHIP /md/param (8) How to solve the mb num >(120,67)? Ans: I. modify hdal excel buffer size setting II. open reassign_buffer (9) How to use the level setting ? Ans: Each MB can be setted different level. Each level is mapping the set of background model. In nomal scene, all scene use the same level. In the scene which include both indoor and outdoor, you can set two level of the scene. (10) Where is the tamper sample code? Ans: tamper sample code is liveview_with_md.c. 4 Revision History \u00b6 Revision Date Author Changes 0.1 2021/06/30 Sophia First formal version 0.2 2021/07/02 Sophia Update document format and description 0.3 2022/06/24 Hunter Modify the description of mb size and some wrong information.","title":"MD User Guide"},{"location":"NT9833X_MD_User_Guide_en.html#1-introduction","text":"","title":"1 Introduction"},{"location":"NT9833X_MD_User_Guide_en.html#11-overview","text":"The motion detection supports applications including global motion detection, sub-region motion detection, motion object detection and tamper detection. l Global motion detection By using a fixed camera, global motion detection issues alarm if the area of moving objects is larger than the user-defined threshold. Figure 1? Global motion detection l Sub-region motion detection By using a fixed camera, this function issues a sub-region motion alarm if the area of moving objects in the user-defined regions is larger than the user-defined threshold. Figure 2? Sub-region motion alarm l Motion objects detection By using a fixed camera, it detects moving objects if their areas are larger than a user-defined threshold.? It also reports the sizes and coordinates of detected moving objects. Figure 3? Motion objects detection l Tamper detection By using a fixed camera, it issues a tamper alarm if the occlusion area is larger than a user-defined area threshold. Figure 4: Tamper Detection","title":"1.1 Overview"},{"location":"NT9833X_MD_User_Guide_en.html#12-motion-detection-steps","text":"The steps of motion detection functions are Step. 1: Generating a initial background model by using the first few frames. Step. 2: Micro block (MB) map is used in motion detection. The size of each MB can be 32x32 or 16x16. The algorithm determines a MB as a motion block if the variance of blocks is higher than a predefined threshold. Step. 3: Updating the background model by using current frame information. Figure 5. The flowchart of MD algoritm","title":"1.2 Motion detection steps"},{"location":"NT9833X_MD_User_Guide_en.html#13-process-flow","text":"Figure 6. The process flow of MD","title":"1.3 Process Flow"},{"location":"NT9833X_MD_User_Guide_en.html#14-parameters","text":"MD has two major parameter types, as listed below l The parameters of vendor MD are used to control MD hardware. l The parameters of libmd are used to control MD software application. l Please notice that the parameters of vendor MD should be set before setting the parameters of libmd.","title":"1.4 Parameters"},{"location":"NT9833X_MD_User_Guide_en.html#141-parameters-of-vendor-md","text":"l VENDOR_MD_CTRL: trigger setting of MD hardware Parameter Range Comment Value engine_enabled 0, 1 HW trigger setting 0: close 1: open l VENDOR_MD_MDT_INFO: size information of MD hardware Parameter Range Comment Value phy_width 32~3840 Sensor resolution (width) \u2013 phy_height 16~2160 Sensor resolution (height) \u2013 phy_mb_x_size 16, 32 The x-size of micro-block (MB) for HW Set 32 when the phy_height is bigger than 1088. Set 16 when the phy_height is smaller than or equal to 1088. phy_mb_y_size 16, 32 The y-size of MB for HW Same value of phy_mb_x_size. phy_mb_x_num The number of MB in the MB-map at x-direction phy_width/ phy_mb_x_size phy_mb_y_num The number of MB in the MB-map at y-direction phy_height/ phy_mb_y_size l VENDOR_MD_MDT_PARAM_IDX: index of MD background model parameters id Comment VENDOR_MD_MDT_PARAM_RST Background model reset VENDOR_MD_MDT_PARAM_TYPE The method to construct background model VENDOR_MD_MDT_PARAM_TIME_PERIOD update time of background model (only for MD2) VENDOR_MD_MDT_PARAM_TBG Weight threshold of background model VENDOR_MD_MDT_PARAM_LVL_ALPHA Learning rate for the fitting background model VENDOR_MD_MDT_PARAM_LVL_ONE_MIN_ALPHA Learning rate for the nun-fitting background model VENDOR_MD_MDT_PARAM_LVL_INIT_WEIGHT Initial weight of background model VENDOR_MD_MDT_PARAM_LVL_MODEL_UPDATE Update constraint of background model VENDOR_MD_MDT_PARAM_LVL_TB Threshold of foreground detection VENDOR_MD_MDT_PARAM_LVL_SIGMA Variance threshold of background model VENDOR_MD_MDT_PARAM_LVL_TG Threshold of background model update VENDOR_MD_MDT_PARAM_LVL_PRUNE Threshold to decrease weight for nun-fitting background model VENDOR_MD_MDT_PARAM_LVL_LUMA_DIFF_THRES Luminance variance threshold at refine stage (only for MD1) VENDOR_MD_MDT_PARAM_LVL_TEXT_DIFF_THRES Texture variance threshold at refine stage (only for MD1) VENDOR_MD_MDT_PARAM_LVL_TEXT_THRES Texture strength threshold at refine stage (only for MD1) VENDOR_MD_MDT_PARAM_LVL_TEXT_RATIO_THRES Texture coverage ratio threshold at refine stage (only for MD1) VENDOR_MD_MDT_PARAM_LVL_GM_MD2_THRES Background threshold (only for MD2) l VENDOR_MD_MDT_PARAM: parameters of MD background model Parameter Comment out_id Path id level Choose the selective model id VENDOR_MD_MDT_PARAM_IDX value Parameter value l Value range of the VENDOR_MD_MDT_PARAM VENDOR_MD_MDT_PARAM_IDX Range Comment Value VENDOR_MD_MDT_PARAM_RST 0, 1 Reset MD background model 0: no reset 1: reset VENDOR_MD_MDT_PARAM_TYPE 0, 1 MD method type 0: MD1 (HW) (learning-based) 1: MD2 (HW) difference-based) VENDOR_MD_MDT_PARAM_TIME_PERIOD - Background update frame threshold (only for MD2) 10 VENDOR_MD_MDT_PARAM_TBG 1~32767 Background model weight threshold Suggest not to modify the value. 29490 VENDOR_MD_MDT_PARAM_LVL_ALPHA 1~32767 Background learning rate threshold when input fits model. Please set higher value when AE change obviously to avoid false alarm. 32 VENDOR_MD_MDT_PARAM_LVL_ONE_MIN_ALPHA 1~32767 Background learning rate threshold when input doesn\u2019t fit model. 32736 VENDOR_MD_MDT_PARAM_LVL_INIT_WEIGHT 1~32767 Background model initial weight 32 VENDOR_MD_MDT_PARAM_LVL_MODEL_UPDATE 0, 1 Background model constraint update Suggest not to modify the value. 0 VENDOR_MD_MDT_PARAM_LVL_TB 1~31 Background model fitting threshold. The MD is more sensitive when the value is lower. 25 VENDOR_MD_MDT_PARAM_LVL_SIGMA 1~31 Background model variance threshold. Set larger value to avoid false alarm when background luminance changes large. Please set the value lower when the MD result of detected object is broken. 25 VENDOR_MD_MDT_PARAM_LVL_TG 1~31 Background model count threshold. Suggest not to modify the value. 9 VENDOR_MD_MDT_PARAM_LVL_PRUNE 1~32767 Weight decrease threshold for un-fitting model 51 VENDOR_MD_MDT_PARAM_LVL_LUMA_DIFF_THRES 0~255 Luminance variance threshold at refine stage (only for MD1) 0 VENDOR_MD_MDT_PARAM_LVL_TEXT_DIFF_THRES 0~255 Texture variance threshold at refine stage (only for MD1) 0 VENDOR_MD_MDT_PARAM_LVL_TEXT_THRES 0~255 Texture strength threshold at refine stage (only for MD1) 0 VENDOR_MD_MDT_PARAM_LVL_TEXT_RATIO_THRES 0~127 Texture coverage ratio threshold at refine stage (only for MD1) 127 VENDOR_MD_MDT_PARAM_LVL_GM_MD2_THRES 0~255 Background threshold (only for MD2) 10 l VENDOR_MD_MDT_MB_LEVEL: region setting of the background model Parameter Range Comment x 0~max_width x position of the left upper corner of the region (physical plane, Unit: pixel) y 0~max_height y position of the left upper corner of the region (physical plane, Unit: pixel) width 1~max_width width of the left upper corner of the region (physical plane, Unit: pixel) height 1~max_height height of the left upper corner of the region (physical plane, Unit: pixel) level 0~3 The selective background model of the region l VENDOR_MD_TDT_PARAM_IDX: index of the tamper detection parameters id Comment VENDOR_MD_TDT_PARAM_TYPE Tamper detection method type VENDOR_MD_TDT_PARAM_EDGE_TEX_THRES Texture strength threshold VENDOR_MD_TDT_PARAM_EDGE_WIN_THRES Coverage of low texture strength threshold VENDOR_MD_TDT_PARAM_AVG_TEX_THRES Luminance strength threshold VENDOR_MD_TDT_PARAM_AVG_WIN_THRES Coverage of low luminance strength threshold l VENDOR_MD_MDT_PARAM: tamper detection parameters Parameter Comment out_id Path id id VENDOR_MD_TDT_PARAM_IDX value Parameter value l Value range of the tamper detection parameters VENDOR_MD_TDT_PARAM_IDX Range Comment Default VENDOR_MD_TDT_PARAM_TYPE 0, 1 Tamper detection method 0: edge-based 1: intensity based VENDOR_MD_TDT_PARAM_EDGE_TEX_THRES 0~255 Texture strength threshold 25 VENDOR_MD_TDT_PARAM_EDGE_WIN_THRES 0~127 Coverage of low texture strength threshold 100 VENDOR_MD_TDT_PARAM_AVG_TEX_THRES 0~255 Luminance strength threshold 65 VENDOR_MD_TDT_PARAM_AVG_WIN_THRES 0~127 Coverage of low luminance strength threshold 100 l VENDOR_BUFFER : buffer information structure Parameter Comment paddr Physical address size Buffer size ddr_id DDR_IDX l VENDOR_MD_BUFFER: buffer information of MD hardware Parameter Comment mb_x_num_max Maximum width of the MB number(Unit: MB number) mb_y_num_max Maximum height of the MB number(Unit: MB number) sta MD HW statistics value buffer event MD HWmotion bitmap buffer level MD HW selective background model buffer l VENDOR_MD_PARAM_ID: index of vendor_md function id Comment VENDOR_MD_CTRL_PARAM MD HW control structure VENDOR_MD_MOTION_DETECT_INFO MD HW process size unit structure VENDOR_MD_MOTION_DETECT_PARAM MD HW background model parameter structure VENDOR_MD_MOTION_DETECT_MB_LEVEL MD HW background model selective model structure VENDOR_MD_MOTION_DETECT_BUFFER MD HW buffer structure VENDOR_MD_TAMPER_DETECT_PARAM MD HW tamper parameter structure VENDOR_MD_RESULT_INFO MD HW result structure VENDOR_MD_REASSIGN_BUFFERS MD reassign buffer API. When max MB num is larger than (1920/16, 1080/16) or want to shrink MD buffer size. Note: hdal default pool buffer size for MD is (120,67) and 8 channel. If you use reassign buffer, you should change the hdal default pool buffer size.","title":"1.4.1 Parameters of vendor MD"},{"location":"NT9833X_MD_User_Guide_en.html#142-parameters-of-libmd","text":"l LIB_MD_AP_ENABLE: trigger setting of MD application:? Parameter Range Comment globel_md_alarm_detect_en 0, 1 Global motion alarm enable subregion_md_alarm_detect_en 0, 1 Sub-region motion alarm enable md_obj_detect_en 0, 1 Objects detection enable md_postprocess_en 0, 1 Motionbitmap postprocess enable l LIB_MD_EVT_INFO: results of motion detection Parameter Comment p_evt_map MD HW event bimap buffer evt_sz MD HW event bimap buffer size timestamp MD event timestamp l LIB_MD_MDT_INFO: size setting information of libmd Parameter Range Comment Default md_enabled 0, 1 Libmd enable vendor_md engine_enabled should be enable firstly vp_width 1~3840 User plane width suggest to set as sensor setting vp_height 1~2160 User plane height suggest to set as sensor setting vp_mb_x_size 16, 32 Width of MB size in the user plane suggest to set the same value of phy_mb_x_size vp_mb_y_size 16, 32 Height of MB size in the user plane suggest to set the same value of phy_mb_y_size vp_mb_x_num - Width of MB number in the user plane vp_width / vp_mb_x_size vp_mb_y_num - Height of MB number in the user plane vp_height / vp_mb_y_size phy_mb_x_size 16, 32 HW width of MB size set the same as vendor_md phy_mb_y_size 16, 32 HW height of MB size set the same as vendor_md phy_mb_x_num Sensor_width/ phy_mb_x_size set the same as vendor_md phy_mb_y_num Sensor_height/ phy_mb_y_size set the same as vendor_md l LIB_MD_AP_POSTPROCESS: post-process type of libmd event Parameter Range Comment Default evt_postprocess_type 0~7 Motion event postprocess 0: no 1: one erosion + two dilation 2: two dilation + one erosion 3: two dilation 4: one dilation 5: one erosion 6: one dilation + one erosion 7: one erosion + one dilation l LIB_MD_AP_GLOBAL_MOTION_ALARM: parameters of global motion alarm detection Parameter Range Comment motion_alarm_th 0~100 Global motion detection alarm area coverage ratio threshold (%). MD is more sensitive when the value is lower. ref_cell_en 0, 1 The detection result will reference p_cell_map or not. When the value is 1, the global motion alarm/ sub-region motion alarm/ object detection result will reference the p_cell_map. p_cell_map 0, 1 The detection result will reference the buffer when the ref_cell_en=1. cell_map_sz vp_mb_x_num* vp_mb_y_num The buffer size of the p_cell_map l LIB_MD_AP_SUBREGION: parameters of specified sub-region structure Parameter Range Comment enabled 0, 1 Sub-region motion detection alarm enable x_start 0~mb_w_num-1 x position of the left upper corner of the region (virtual plane\uff0cUnit: macro block) y_start 0~mb_h_num-1 y position of the left upper corner of the region (virtual plane\uff0cUnit: macro block) x_end 0~mb_w_num-1 x position of the right under corner of the region (virtual plane\uff0cUnit: macro block) y_end 0~mb_h_num-1 y position of the right under corner of the region (virtual plane\uff0cUnit: macro block) alarm_th 0~100 Sub-region motion detection alarm area coverage ratio threshold (%). MD is more sensitive when the value is lower. l LIB_MD_AP_SUBREGION_MOTION_ALARM: parameters of sub-region motion alarm detection Parameter Range Comment sub_region_num 0~4 Specified sub-region number sub_region - Specified sub-region structure l LIB_MD_AP_OBJ: size setting of minmum motion object Parameter Range Comment object_size - Minimum size of detected moing objects (Unit: macro block) l LIB_MD_AP_OBJ_INFO: information of motion objects Parameter Range Comment start_x 0~ vp_width x position of the left upper corner of the motion object (virtual plane\uff0cUnit:pixel) start_y 0~vp_height y position of the left upper corner of the motion object (virtual plane\uff0cUnit:pixel) end_x 0~ vp_width x position of the right under corner of the motion object (virtual plane\uff0cUnit: macro block) end_y 0~vp_height y position of the right under corner of the motion object (virtual plane\uff0cUnit: macro block) label 0~128 Motion obect index l LIB_MD_MDT_RESULT_INFO: results information of the libmd Parameter Range Comment Value global_motion_alarm 0, 1 Global motion detection alarm 0: no alarm 1: alarm global_motion_alarm_num 0~ vp_mb_x_num* vp_mb_y_num Motion MB number sub_motion_alarm 0, 1 Sub-region motion detection alarm 0: no alarm 1: alarm obj_num 0~128 Motion object number obj - Motion object structure vp_evt_info - Motion detection event map in the user plane l LIB_MD_PARAM_ID: index of libmd function Parameter Comment LIB_MD_MOTION_DETECT_INFO Libmd set virtual/physical plane evt bitmap addr. Physical plane should be set the same as vendor_md. Physical evt bitmap address is vendor_md output result motion bitmap address. evt bitmap addr\u70bavendor_md output result Libmd all detection application enable port LIB_MD_AP_ENABLE_PARAM Libmd postprocess enable LIB_MD_AP_POSTPROCESS_PARAM Libmd global motion detection enable LIB_MD_AP_GLOBAL_MOTION_ALARM_PARAM Libmd sub-region motion detection enable LIB_MD_AP_SUBREGION_MOTION_ALARM_PARAM Libmd motion object detection enable LIB_MD_AP_OBJ_PARAM Libmd result information Note: The MD model can lean the stable change of scene, such as river or twinkle light. If the user want to detect this kind of events, the parameters can be set as following: l Model parameters o tg=3 o tb=19 o alpha = 1024 l Refine process o lum_diff_th=75 o tex_diff_th=50 o tex_ratio_th=50","title":"1.4.2 Parameters of libmd"},{"location":"NT9833X_MD_User_Guide_en.html#15-initilization-of-md","text":"l Vendor MD The buffer of vender MD and HW internal parametesrs should be set by the API as following: HD_RESULT md_init(void) ; l Libmd The buffer of libmd and software parametesrs should be set by the API as following: HD_RESULT motion_set_ap_param(UINT32 path_id) ; HD_RESULT lib_md_init(HD_PATH_ID path_id); // libmd buffer setting shoule be set after HW MD size setting which set through motion_set_ap_param.","title":"1.5 Initilization of MD"},{"location":"NT9833X_MD_User_Guide_en.html#16-parameters-setting-of-md","text":"l Vendor MD Vendor MD parameters should be set by the following API. ret = vendor_md_set(video_cap[ch], VENDOR_MD_CTRL_PARAM, &md_cfg); The content of VENDOR_MD_PARAM_ID is list in the section1.4.1. l Libmd The parameters of libmd should be set by the following API. ret = lib_md_set(path_id, LIB_MD_AP_ENABLE_PARAM, &mdt_lib_param[idx].mdt_enable); The content of LIB_MD_PARAM_ID is list in the section1.4.2.","title":"1.6 Parameters Setting of MD"},{"location":"NT9833X_MD_User_Guide_en.html#17-execution-of-md","text":"","title":"1.7 Execution of MD"},{"location":"NT9833X_MD_User_Guide_en.html#171-vendor-md","text":"Vendor MD application should be set by the following API. // buffer and parameters intial setting HD_RESULT md_init(void); // create md_thread static void *md_thread(void *arg); //set and get vendor md API ret = vendor_md_get(path_id, VENDOR_MD_MOTION_DETECT_INFO, &mdt_info); ret = vendor_md_set(path_id, VENDOR_MD_RESULT_INFO, &result_info); ret = vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info);","title":"1.7.1 vendor MD"},{"location":"NT9833X_MD_User_Guide_en.html#172-libmd","text":"libmd application should be set by the following API. // buffer and parameters intial setting HD_RESULT motion_set_ap_param(UINT32 path_id); HD_RESULT lib_md_init(HD_PATH_ID path_id); // create md_thread static void *md_thread(void *arg); //set and get libmd API ret = vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info); //libmd process should use vendor_md result as input vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info) ret = lib_md_set(path_id, LIB_MD_MOTION_DETECT_INFO, &lib_md_info); ret = lib_md_get(path_id, LIB_MD_RESULT_INFO, &lib_md_rst);","title":"1.7.2 libmd"},{"location":"NT9833X_MD_User_Guide_en.html#18-requirement-of-md","text":"l MD funtions only be applied by CPU and HW.","title":"1.8 Requirement of MD"},{"location":"NT9833X_MD_User_Guide_en.html#19-limitation-of-md","text":"l MD shoud be used in the fixed-camera. If camera has been moved, MD function might output a false alarm event. l MD function might output a false alarm event because of the zoom in/out of camera or the adjustment of auto white balance. l The size of moving object should be larger than 1 micro-block (MB)","title":"1.9 Limitation of MD"},{"location":"NT9833X_MD_User_Guide_en.html#110-test-flow-of-md","text":"l Check MD use in the fixed-camera scene l Check MD event bitmap to check MD flow l MD should be used after 3 frames to create initial background.","title":"1.10 Test Flow of MD"},{"location":"NT9833X_MD_User_Guide_en.html#2-output","text":"","title":"2 Output"},{"location":"NT9833X_MD_User_Guide_en.html#21-get-output-results-of-md","text":"l vendor MD Vendor MD result should be set/got by the following API. ret = vendor_md_set(path_id, VENDOR_MD_RESULT_INFO, &result_info); ret = vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info); The structure of MD hardware result lists as following. typedef struct _VENDOR_MD_MDT_RESULT_INFO { UINT8???? ? *p_evt_map; ///< motion detection bitmap, size is evt_sz UINT32????? evt_sz; ///< phy_mb_x_num*phy_mb_y_num MB UINT8?????? tp_result; ///< tamper alarm ???? UINT32??? ? timestamp; } VENDOR_MD_MDT_RESULT_INFO; l libmd libmd result should be set/got by the following API. vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info) ret = lib_md_set(path_id, LIB_MD_MOTION_DETECT_INFO, &lib_md_info); ret = lib_md_get(path_id, LIB_MD_RESULT_INFO, &lib_md_rst); libmd result structure lists as following. typedef struct _LIB_MD_MDT_RESULT_INFO { UINT8???????? global_motion_alarm; ///< global motion alarm ???? UINT32??? ??? global_motion_alarm_num;?????? ???? ?????????///< global motion alarm num UINT32??????? sub_motion_alarm[LIB_MD_MAX_SUB_REGION_NUM]; ///< sub-region motion alarm UINT32??????? obj_num; ///< detect object number (max=128) ???? LIB_MD_AP_OBJ_INFO? obj[LIB_MD_MAX_OBJ_NUM];?????????? ????///< detect object info ???? LIB_MD_EVT_INFO vp_evt_info; } LIB_MD_MDT_RESULT_INFO; typedef struct _LIB_MD_EVT_INFO { UINT8???? ?? *p_evt_map; ///< motion detection bitmap, size is evt_sz UINT32?????? evt_sz; ///< mb_x_num*mb_y_num MB ???? UINT32??? ?? timestamp; } LIB_MD_EVT_INFO; typedef struct _LIB_MD_AP_OBJ_INFO { UINT32??????? start_x; ///< obj rectangle left upper x position (virtual pixel)? UINT32??????? start_y; ///< obj rectangle left upper y position (virtual pixel)? UINT32??????? end_x; ///< obj rectangle right down x position (virtual pixel)? UINT32??????? end_y; ///< obj rectangle right down y position (virtual pixel)? UINT32??????? label; ///< obj label } LIB_MD_AP_OBJ_INFO;","title":"2.1 Get Output Results of MD"},{"location":"NT9833X_MD_User_Guide_en.html#22-print-output-results-of-md","text":"l Output Result of Global Motion Detection UART will print the results as following when motion area in the whole scene is larger than user-defined threshold. > global motion alarm on ch (specified channel) . l Output Result of Sub-region Motion Detection UART will print the results as following when the motion area in one or more sub-regions is larger than user-defined threshold. > sub_region[ specified region index ] motion alarm on ch( specified channel ) . l Output Result of Motion Object Detection UART will print the results as following when motion objects area are larger than minimum object user-defined threshold. > obj num:Motion object number and obj[object index]: start_xy=[left upper corner position of motion object], end_xy = [right under corner position of motion object], label = object label. l Output Result of Tamper Detection UART will print the results as following when occlusion area is larger than user-defined threshold. > tamper_result: 1 on ch (specified channel) .","title":"2.2 Print Output Results of MD"},{"location":"NT9833X_MD_User_Guide_en.html#23-limitation-md-hardware","text":"l Maximum sensor resolution is 3840x2160. l Maximum MB number of MD hardware are (mb_x_num, mb_y_num) = (256, 128) and minimum MB number of MD hardware are (mb_x_num, mb_y_num) = (2, 1). l In the Vcap flow, MD doesn\u2019t support the scale function.","title":"2.3 Limitation MD Hardware"},{"location":"NT9833X_MD_User_Guide_en.html#24-requirement-of-md-system","text":"l The efficiency of MD function is associated with system loading. The ouput result of MD may be delayed when system is overloading.","title":"2.4 Requirement of MD System"},{"location":"NT9833X_MD_User_Guide_en.html#25-tuning-of-md-parameters","text":"l In the scene with the shortly changing of light, such as AE adjustment or turn-on and turn-off the light, please set the value of alpha higher. The side effect is that moving slowly object might be detected as background. l Please set tb to be higher for shadow. The side effect is that the detected forground of moving obeject might be broken. In this case, please also set \u201csigma\u201d to be lower to fix the broken forground issue. l The distance between moving object and camera should be farer than 30 cm. If the moving objects is too close to the camera, there might cause the false alarm of shadow. l Please set lower tb when foreground luminance is similar background. However, the side effect is that the false alarm of shadow may be increase. l Please see section 1.5 when you need to detect stable motion case. l The MD function doesn\u2019t support night view with IR-cut. In this case, there might be similar between background and foreground. l There is no motion event when MD is creating intial background model. Also, MD will need longer time to create initial backgroung model if there are some moving objects in the initial scene. l The size of moving object should be larger than 1 MB.","title":"2.5 Tuning of MD Parameters"},{"location":"NT9833X_MD_User_Guide_en.html#3-qa","text":"(1) How to check vendor MD version? Ans: echo md > /proc/hdal/flow Execute AP cat /proc/hdal/flow (2) How to set the md sensitive? Ans: I. Use vendor_md_set API (the details describe in the 1.6 section and the section 1.4.1. II. Tuning Guide document provide the tuning parameter suggestion. If any more question, please provide the video and parameters. (3) How to solve sensor resolution change error? Ans: If you want to chage sensor reolution, please vendor_md_unint & vendor_md_int at fisrt and you might see liveview_with_md_ctrl.c or liveview_with_md_resolution.c (4) How to check sensor interlace case? Ans: MD is field input. If input is interlace, please set the half of the sensor input height. You can see interlace case through command as following cat /proc/vcap316/vcap0/vg_info. (5) Check AD mode (960H and 720) case Ans: I. Check AD output is full frame. II. MD input size is the same as the AD output size. phy_width andphy_height should be calculate by AD output (might not be the size of sensor). The size setting check by /proc/vcap316/vcap0/vg_info?and vcap md (detal describe in question 6 ). (6) If any setting question of the vendor_md flow, please provide the log of vendor_md flow by the following command. Ans: echo md > /proc/hdal/flow Execute AP cat /proc/hdal/flow (7) How to check vcap md setting Ans: echo vcap_ch > /proc/vcap316/vcap0/vcap0.CHIP/md/event (vcap_ch and CHIP according to vg_info) cat /proc/vcap316/vcap0/vcap0. CHIP /md/region cat /proc/vcap316/vcap0/vcap0. CHIP /md/param (8) How to solve the mb num >(120,67)? Ans: I. modify hdal excel buffer size setting II. open reassign_buffer (9) How to use the level setting ? Ans: Each MB can be setted different level. Each level is mapping the set of background model. In nomal scene, all scene use the same level. In the scene which include both indoor and outdoor, you can set two level of the scene. (10) Where is the tamper sample code? Ans: tamper sample code is liveview_with_md.c.","title":"3 Q&amp;A"},{"location":"NT9833X_MD_User_Guide_en.html#4-revision-history","text":"Revision Date Author Changes 0.1 2021/06/30 Sophia First formal version 0.2 2021/07/02 Sophia Update document format and description 0.3 2022/06/24 Hunter Modify the description of mb size and some wrong information.","title":"4 Revision History"},{"location":"NT9833x_LCD_IQ_Tuning_Guide_en.html","text":"1 Overview \u00b6 LCD310 is the LCD controller of NT9833x. The following image processing modules are insided. l Y Gamma l YUV Adjustment l Local Contrast Enhance l Sharpen 2 IQ Tuning Guide \u00b6 2.1 Y Gamma \u00b6 This feature is tone mapping and can be used to adjust the contrast, brightness and dynamic range of the image. 2.1.1 Parameters \u00b6 LCD310 Y Gamma divides the Y channel range from the darkest to the brightest and is equally divided into 16 blocks. Each block can be divided into up to 8 sub-blocks. The total number of all blocks must not exceed 32. Parameter Range Def Description gm_en 0~1 1 enable Y gamma blk_idx[16] 0~31 0 Block first index blk_split[16] 0~3 0 Block[x], Sub-block split 00 : no split. 01 : split to 2 sub-blocks 10 : split to 4 sub-blocks 11 : split to 8-blocks Y_gm[32] 0~4095 Gamma table l gm_en: Y gamma enable/disable l blk_idx: Sub-block index in each macro block. Corresponds to the index of the gamma table. l blk_split: Each block is divided into sub-blocks. Ex. 1 \uff1a Block0 is divided into 8 sub-block Block1 is divided into 8 sub-block Block2 is divided into 8 sub-block Block3 is divided into 8 sub-block Total Block no: 8 + 8 + 2 + 2 + 12(Block4~15) = 32 The parameter settings are as follows\uff1a blk_idx[16] = {0, 8, 16, 18, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31}; blk_split[16] = {3, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; Y_gm[32] = {32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 480, 512, 640, 768, 896, 1024, 1280, 1536, 1792, 2048, 2304, 2560, 2816, 3072, 3328, 3584, 3840, 4095}; Ex. 2 \uff1a Block0 is divided into 4 sub-block Block1 is divided into 4 sub-block Block14 is divided into 4 sub-block Block15 is divided into 4 sub-block Total block no: 4 + 4 + 12(Block2~13) + 4 + 4 = 28 ?//\u203bnot necessary to equal to 32 The parameter settings are as follows\uff1a blk_idx[16] = {0, 4, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 24}; blk_split[16] = {2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2}; Y_gm[32] = {64, 128, 192, 256,320, 384, 448, 512, 768, 1024, 1280, 1536, 1792, 2048, 2304, 2560, 2816, 3072, 3328, 3584, 3648, 3712, 3776, 3840, 3904, 3968, 4032, 4095, 4095, 4095, 4095, 4095}; \u203bThe last for value will be dummy. 2.1.2 Tuning Interface \u00b6 Proc Command: \u00b6 echo 0 1 0 \u201c0x300,0x108,0x10a,0xc,0xd,0xe,0xf,0x10,0x11,0x12,0x13,0x14,0x15,0x116,0x218,0x21c\u201d > ygamma echo 0 1 1 \u201c80,128,176,224,256,304,336,368,528,688,832,1008,1344,1680,2016,2336\u201d > ygamma echo 0 1 2 \u201c2640,2912,3152,3376,3552,3712,3776,3840,3872,3904,3936,3968,4000,4032,4064,4080\u201d > ygamma 2.2 YUV Adjustment \u00b6 This function includes adjustments for brightness, contrast, hue, saturation, etc., as follows: l Brightness: n Setting Interface\uff1a proc Read : cat /proc/flcd310/brightness Write: echo <plane 0> <brightness -127~127> > brightness Parameter Description plane Image plane. Fixed to be 0 (Video plane) brightness Brightness value. The larger value corressponds to brighter image. n Result\uff1a Brightness = 0 Brightness = 25 Brightness = -25 l Contrast: Map the image Y channel to adjust the image contrast. n Setting Interface\uff1a /proc/flcd310/contrast Read: cat /proc/flcd310/contrast Write: echo <plane 0~0> <contrast_ratio 0~255> <contrast_mode 0~2> > /proc/flcd310/contrast Parameter Description plane Image plane. Fixed to be 0 (Video plane) contrast_ratio Default = 128, The lager value corressponds to higher contrast. contrast_mode Mapping mode, explained as following: contrast_mode mapping mode (contrast=150) Feature 0 l No loss of shadow details, loss of highlight detail l Overall brightness may increase. 1 l Dark details and highlight details are likely to be loss. l Overall brightness will not be changed. 2 l No loss of detail in the highlights, details of the shadows and possible loss. l The overall brightness may be dimmed. n Result\uff1a contrast = 170 Contrast = 80 l Hue: LCD310 divides the color picture into six blocks, which can adjust the hue and saturation for specific color blocks. Index 0 ~ 5 respectively: Magenta, Red, Yellow, Green, Cyan, Blue. n Setting Interface: ?/proc/flcd310/hue Read: cat /proc/flcd310/hue Write: echo <plane 0~0> <hue_sat state 0/1> <hue0 -45~45> <hue1 -45~45> <hue2 -45~45> <hue3 -45~45> <hue4 -45~45> <hue5 -45~45> > /proc/flcd310/hue Parameter Description plane Image plane. Fixed to be 0 (Video plane) hue_sat state 1: enable, 0: diable hue saturation hue0~5 They are the rotation adjustment values of the following 6 large hue blocks. The preset value of 0 means no adjustment, and the positive/negative values are respectively inverse/clockwise rotation of the hue block. Magenta, Red, Yellow, Green, Cyan, Blue l Saturation: Adjust the saturation of the picture. LCD310 divides the color picture into six blocks, which can adjust the hue and saturation for specific color blocks. Index 0 ~ 5 respectively: Magenta, Red, Yellow, Green, Cyan, Blue. n Setting Interface\uff1a /proc/flcd310/hue_sat Read: cat /proc/flcd310/hue_sat Write: echo <plane 0~0> <hue_sat state 0/1> <hue_sat0> <hue_sat1> <hue_sat2> <hue_sat3> <hue_sat4> <hue_sat5> > /proc/flcd310/hue_sat Parameter Description plane Image plane. Fixed to be 0 (Video plane) hue_sat state 1: enable, 0: diable hue saturation hue_sat0~5 The saturation adjustment values of the following six color. Set to 128 to indicate no adjustment. The larger the value, the higher the saturation. Magenta, Red, Yellow, Green, Cyan, Blue n Result\uff1a hue_sat = 64 hue_sat = 128 hue_sat=164 2.3 Local Contrast Enhance \u00b6 This feature enhances regional contrast. Setting Interface\uff1a /proc/flcd310/ce Read: cat /proc/flcd310/ce Write: echo <plane 0~0> <ce_state 0/1> <strength 0~1023> > /proc/flcd310/ ce Parameter Description plane Image plane. Fixed to be 0 (Video plane) ce_state 1: enable, 0: diable strength The strength of local contrast enhancement. n Result\uff1a strength = 0 strength = 30 2.4 Sharpen \u00b6 This function is an edge enhancement function that enhances the sharpness of the picture. Two-level sharpness enhancement core for reinforcement of thin and thick edges n Setting Interface: /proc/flcd310/sharpness Read: cat /proc/flcd310/sharpness Write: echo <plane 0> <enable 0/1> <hpf0_5x5_gain 0~1024> <hpf1_5x5_gain 0~1024> > /proc/flcd310/sharpness Parameter Description plane Image plane. Fixed to be 0 (Video plane) enable 1: enable, 0: diable hpf0_5x5_gain Enhance strength of thick edge. hpf1_5x5_gain Enhance strength of thin edge. n Result\uff1a Thin edge enhancement Thick edge enhancement Revision Historys \u00b6 Revision Date Author Changes 0.1.0 2021/01/20 Allen Hsu First version.","title":"LCD IQ Tuning Guide"},{"location":"NT9833x_LCD_IQ_Tuning_Guide_en.html#1-overview","text":"LCD310 is the LCD controller of NT9833x. The following image processing modules are insided. l Y Gamma l YUV Adjustment l Local Contrast Enhance l Sharpen","title":"1 Overview"},{"location":"NT9833x_LCD_IQ_Tuning_Guide_en.html#2-iq-tuning-guide","text":"","title":"2 IQ Tuning Guide"},{"location":"NT9833x_LCD_IQ_Tuning_Guide_en.html#21-y-gamma","text":"This feature is tone mapping and can be used to adjust the contrast, brightness and dynamic range of the image.","title":"2.1 Y Gamma"},{"location":"NT9833x_LCD_IQ_Tuning_Guide_en.html#211-parameters","text":"LCD310 Y Gamma divides the Y channel range from the darkest to the brightest and is equally divided into 16 blocks. Each block can be divided into up to 8 sub-blocks. The total number of all blocks must not exceed 32. Parameter Range Def Description gm_en 0~1 1 enable Y gamma blk_idx[16] 0~31 0 Block first index blk_split[16] 0~3 0 Block[x], Sub-block split 00 : no split. 01 : split to 2 sub-blocks 10 : split to 4 sub-blocks 11 : split to 8-blocks Y_gm[32] 0~4095 Gamma table l gm_en: Y gamma enable/disable l blk_idx: Sub-block index in each macro block. Corresponds to the index of the gamma table. l blk_split: Each block is divided into sub-blocks. Ex. 1 \uff1a Block0 is divided into 8 sub-block Block1 is divided into 8 sub-block Block2 is divided into 8 sub-block Block3 is divided into 8 sub-block Total Block no: 8 + 8 + 2 + 2 + 12(Block4~15) = 32 The parameter settings are as follows\uff1a blk_idx[16] = {0, 8, 16, 18, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31}; blk_split[16] = {3, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; Y_gm[32] = {32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 480, 512, 640, 768, 896, 1024, 1280, 1536, 1792, 2048, 2304, 2560, 2816, 3072, 3328, 3584, 3840, 4095}; Ex. 2 \uff1a Block0 is divided into 4 sub-block Block1 is divided into 4 sub-block Block14 is divided into 4 sub-block Block15 is divided into 4 sub-block Total block no: 4 + 4 + 12(Block2~13) + 4 + 4 = 28 ?//\u203bnot necessary to equal to 32 The parameter settings are as follows\uff1a blk_idx[16] = {0, 4, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 24}; blk_split[16] = {2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2}; Y_gm[32] = {64, 128, 192, 256,320, 384, 448, 512, 768, 1024, 1280, 1536, 1792, 2048, 2304, 2560, 2816, 3072, 3328, 3584, 3648, 3712, 3776, 3840, 3904, 3968, 4032, 4095, 4095, 4095, 4095, 4095}; \u203bThe last for value will be dummy.","title":"2.1.1 Parameters"},{"location":"NT9833x_LCD_IQ_Tuning_Guide_en.html#212-tuning-interface","text":"","title":"2.1.2 Tuning Interface"},{"location":"NT9833x_LCD_IQ_Tuning_Guide_en.html#proc-command","text":"echo 0 1 0 \u201c0x300,0x108,0x10a,0xc,0xd,0xe,0xf,0x10,0x11,0x12,0x13,0x14,0x15,0x116,0x218,0x21c\u201d > ygamma echo 0 1 1 \u201c80,128,176,224,256,304,336,368,528,688,832,1008,1344,1680,2016,2336\u201d > ygamma echo 0 1 2 \u201c2640,2912,3152,3376,3552,3712,3776,3840,3872,3904,3936,3968,4000,4032,4064,4080\u201d > ygamma","title":"Proc Command:"},{"location":"NT9833x_LCD_IQ_Tuning_Guide_en.html#22-yuv-adjustment","text":"This function includes adjustments for brightness, contrast, hue, saturation, etc., as follows: l Brightness: n Setting Interface\uff1a proc Read : cat /proc/flcd310/brightness Write: echo <plane 0> <brightness -127~127> > brightness Parameter Description plane Image plane. Fixed to be 0 (Video plane) brightness Brightness value. The larger value corressponds to brighter image. n Result\uff1a Brightness = 0 Brightness = 25 Brightness = -25 l Contrast: Map the image Y channel to adjust the image contrast. n Setting Interface\uff1a /proc/flcd310/contrast Read: cat /proc/flcd310/contrast Write: echo <plane 0~0> <contrast_ratio 0~255> <contrast_mode 0~2> > /proc/flcd310/contrast Parameter Description plane Image plane. Fixed to be 0 (Video plane) contrast_ratio Default = 128, The lager value corressponds to higher contrast. contrast_mode Mapping mode, explained as following: contrast_mode mapping mode (contrast=150) Feature 0 l No loss of shadow details, loss of highlight detail l Overall brightness may increase. 1 l Dark details and highlight details are likely to be loss. l Overall brightness will not be changed. 2 l No loss of detail in the highlights, details of the shadows and possible loss. l The overall brightness may be dimmed. n Result\uff1a contrast = 170 Contrast = 80 l Hue: LCD310 divides the color picture into six blocks, which can adjust the hue and saturation for specific color blocks. Index 0 ~ 5 respectively: Magenta, Red, Yellow, Green, Cyan, Blue. n Setting Interface: ?/proc/flcd310/hue Read: cat /proc/flcd310/hue Write: echo <plane 0~0> <hue_sat state 0/1> <hue0 -45~45> <hue1 -45~45> <hue2 -45~45> <hue3 -45~45> <hue4 -45~45> <hue5 -45~45> > /proc/flcd310/hue Parameter Description plane Image plane. Fixed to be 0 (Video plane) hue_sat state 1: enable, 0: diable hue saturation hue0~5 They are the rotation adjustment values of the following 6 large hue blocks. The preset value of 0 means no adjustment, and the positive/negative values are respectively inverse/clockwise rotation of the hue block. Magenta, Red, Yellow, Green, Cyan, Blue l Saturation: Adjust the saturation of the picture. LCD310 divides the color picture into six blocks, which can adjust the hue and saturation for specific color blocks. Index 0 ~ 5 respectively: Magenta, Red, Yellow, Green, Cyan, Blue. n Setting Interface\uff1a /proc/flcd310/hue_sat Read: cat /proc/flcd310/hue_sat Write: echo <plane 0~0> <hue_sat state 0/1> <hue_sat0> <hue_sat1> <hue_sat2> <hue_sat3> <hue_sat4> <hue_sat5> > /proc/flcd310/hue_sat Parameter Description plane Image plane. Fixed to be 0 (Video plane) hue_sat state 1: enable, 0: diable hue saturation hue_sat0~5 The saturation adjustment values of the following six color. Set to 128 to indicate no adjustment. The larger the value, the higher the saturation. Magenta, Red, Yellow, Green, Cyan, Blue n Result\uff1a hue_sat = 64 hue_sat = 128 hue_sat=164","title":"2.2 YUV Adjustment"},{"location":"NT9833x_LCD_IQ_Tuning_Guide_en.html#23-local-contrast-enhance","text":"This feature enhances regional contrast. Setting Interface\uff1a /proc/flcd310/ce Read: cat /proc/flcd310/ce Write: echo <plane 0~0> <ce_state 0/1> <strength 0~1023> > /proc/flcd310/ ce Parameter Description plane Image plane. Fixed to be 0 (Video plane) ce_state 1: enable, 0: diable strength The strength of local contrast enhancement. n Result\uff1a strength = 0 strength = 30","title":"2.3 Local Contrast Enhance"},{"location":"NT9833x_LCD_IQ_Tuning_Guide_en.html#24-sharpen","text":"This function is an edge enhancement function that enhances the sharpness of the picture. Two-level sharpness enhancement core for reinforcement of thin and thick edges n Setting Interface: /proc/flcd310/sharpness Read: cat /proc/flcd310/sharpness Write: echo <plane 0> <enable 0/1> <hpf0_5x5_gain 0~1024> <hpf1_5x5_gain 0~1024> > /proc/flcd310/sharpness Parameter Description plane Image plane. Fixed to be 0 (Video plane) enable 1: enable, 0: diable hpf0_5x5_gain Enhance strength of thick edge. hpf1_5x5_gain Enhance strength of thin edge. n Result\uff1a Thin edge enhancement Thick edge enhancement","title":"2.4 Sharpen"},{"location":"NT9833x_LCD_IQ_Tuning_Guide_en.html#revision-historys","text":"Revision Date Author Changes 0.1.0 2021/01/20 Allen Hsu First version.","title":"Revision Historys"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html","text":"1 Development Environment \u00b6 1.1 VirtualBox/Ubuntu OS installation \u00b6 This section will introduce how to install Ubuntu on Windows OS, ignore this section if your environment is under single OS. Please download from VirtualBox official website ( https://www.virtualbox.org/wiki/Downloads ) and follow below instructions to install. This step will install device driver, please select \u201cInstall\u201d: Create virtual machine (Version: Ubuntu 64-Bit): Select virtual machine memory size: Create virtual machine (If you have an existed Ubuntu image, you can select \u201cUse an existing virtual hard disk file\u201d): To configure virtual disk space (At least 40GB size): Select Optical drive and using Ubuntu ISO (Ubuntu 12.04/14.04/16.04/18.04 64-bit) startup: 1.2 Linux environment setup \u00b6 In order to prevent some complaints in the SDK compilation of the 32 Bits OS, we will use 64 Bits Ubuntu OS as our development environment. The first of all, you should install an Ubuntu based server or Ubuntu on VirtualBox which is introduced in previous section, please download the image from ( http://releases.ubuntu.com/ ) to get Ubuntu 12.04/14.04/16.04/18.04 Desktop AMD64 version ISO image and use the following instructions to install necessary Ubuntu packages. Ubuntu 12.04: $ sudo apt-get install bc build-essential libc6-dev libncurses5-dev libgl1-mesa-dev g++-multilib mingw32 tofrodos ia32-libs uboot-mkimage zlib1g-dev mtd-utils vim squashfs-tools gawk cmake cmake-data libstdc++6 device-tree-compiler android-tools-fsutils texinfo libssl-dev python3-crypto python3-pyelftools python3-pycrypto $ sudo add-apt-repository ppa:nathan-renniewaldock/ppa $ sudo apt-get update $ sudo apt-get install liblz4-tool To install make-4.1 ( This will replace your original /bin/make tool ): Download https://ftp.gnu.org/gnu/make/make-4.1.tar.bz2 $ tar -jxvf make-4.1.tar.bz2 $ cd make-4.1; ./configure; make -j4 $ make install Ubuntu 14.04: $ sudo apt-get install bc build-essential libc6-dev lib32ncurses5 libncurses5-dev libncurses5:i386 libgl1-mesa-dev g++-multilib mingw32 tofrodos lib32z1 lib32bz2-1.0 u-boot-tools zlib1g-dev bison libbison-dev flex mtd-utils vim squashfs-tools gawk cmake cmake-data liblz4-tool libmpc3 libstdc++6 device-tree-compiler android-tools-fsutils texinfo libssl-dev python3-crypto python3-pyelftools python3-pycrypto To install make-4.1 ( This will replace your original /bin/make tool ): Download https://ftp.gnu.org/gnu/make/make-4.1.tar.bz2 $ tar -jxvf make-4.1.tar.bz2 $ cd make-4.1; ./configure; make -j4 $ make install Ubuntu 16.04: $ sudo apt-get install bc build-essential libc6-dev lib32ncurses5 libncurses5-dev libncurses5:i386 libgl1-mesa-dev g++-multilib mingw-w64 tofrodos lib32z1 u-boot-tools zlib1g-dev bison libbison-dev flex mtd-utils vim squashfs-tools gawk cmake cmake-data liblz4-tool libmpc3 libstdc++6 device-tree-compiler android-tools-fsutils texinfo libssl-dev python3-crypto python3-pyelftools python3-pycrypto Ubuntu 18.04: $ sudo apt-get install bc build-essential libc6-dev lib32ncurses5 libncurses5-dev libncurses5:i386 libgl1-mesa-dev g++-multilib mingw-w64 tofrodos lib32z1 u-boot-tools zlib1g-dev bison libbison-dev flex mtd-utils vim squashfs-tools gawk cmake cmake-data liblz4-tool libmpc3 libstdc++6 device-tree-compiler android-tools-fsutils texinfo libssl-dev python3-crypto python3-pyelftools python3-pycrypto Ubuntu default shell is dash, please reconfigure the default shell with bash: $ sudo dpkg-reconfigure dash, and choose \u201cNo\u201d in the window Or $ sudo rm /bin/sh && sudo ln -s /bin/bash /bin/sh Besides, the openssh-server is used to provide Windows Host PC connected to Linux server and remote building the Linux SDK, and the Samba server is to provide client get Linux SDK image from Linux server. l $ apt-get install openssh-server l $ apt-get install samba l $ vim /etc/samba/smb.conf o Please reference to related Samba configuration as below: https://help.ubuntu.com/12.04/serverguide/samba-fileserver.html Windows Host PC will also need Teraterm or putty to connect to Target board UART2 port with 115200/8/1/n configuration. Figure 1-1 Linux Development Environment 1.3 How to install NT9833x Linux SDK \u00b6 Using the following instructions to decompress SDK pack under Linux: $ tar -jxvf na51090_linux_sdk_{version}.tar.bz2 You will get the folder tree as below: \u251c\u2500\u2500 na51090_linux_sdk?????????????????????? Used to put unpacked SDK source code \u251c\u2500\u2500 BSP????????????????????????????????????????? Including linux, busybox, uboot and rootfs source \u251c\u2500\u2500 build???????????????????????????????????????? scripts for the environment setup \u251c\u2500\u2500 code???????????????????????????????????????? HDAL, linux drivers and sample code \u251c\u2500\u2500 configs???????????????????????????????????? Model settings \u251c\u2500\u2500 Makefile?????????????????????????????????? Top level Makefile \u2514\u2500\u2500 tools????????????????????????????????????????? target board tool \u251c\u2500\u2500 toolchains??????????????? ??????????????? Toolchain folder \u251c\u2500\u2500 aarch64-ca53-linux-gnueabihf-8.4.tar.bz2 \u2514\u2500\u2500 aarch64-ca53-linux-uclibcgnueabihf-8.4.tar.bz2 1.4 How to install Cross compiler \u00b6 We support both glibc and uclibc cross compiler toolchain, please choose and install it by using below instructions: $ cd toolchain $ sudo tar -jxvf aarch64-ca53-linux-gnueabihf-8.4.tar.bz2 -C /opt/arm or $ sudo tar -jxvf aarch64-ca53-linux-uclibcgnueabihf-8.4.tar.bz2 -C /opt/arm 2 Introduction to Compilation \u00b6 2.1 Environment setup \u00b6 Before each opened a new Terminal window needs to do compiler environment setting, the relevant variables set up, please follow the below instructions to finish it. $ cd na51090_linux_sdk/ $ source build/envsetup.sh 2.2 Compilation \u00b6 Please do a complete compilation for first time. Select your model: $ lunch List your nvt build setting: ??????? $ get_stuff_for_environment Build overall system: $ make all It will generate the images under na51090_linux_sdk/output after the compilation. The details are listed as below. |-- na51090_linux_sdk??????????????????????????????? ??????? Put unpacked source code and image |?? |-- Makefile???????????????????????????? ??????? ??????????????? Top level Makefile |?? |-- output???????????????????????????????? ??????? ??????????????? Compiled output images |????? |-- packed???????????????????????? ??????????????? ??????? |????? ???|-- FW(SOC)A.bin????????????? ??????? ??????? nvtpack image (All-in-one image) |????? |-- atf.bin ???????????????????????????????? ??????? ??????? ATF image |????? |-- Image.bin???????????????????????????????????????????? Linux Image |????? |-- u-boot.bin???????????????????????????????????????????? uboot image with NVT checksum |????? |-- u-boot.lz.bin???????????????????????????????????????? uboot image (LZ compressed) |????? |-- rootfs.ramdisk.bin?????????????????????????????? ramdisk image (rootfs) |????? `-- rootfs_1.rw.ubifs.bin?????????????????????????? rootfs overlay 2.3 Top level Makefile \u00b6 na51090_linux_sdk folder has a top level Makefile, it supports many of the make command, such as \u201cmake linux\u201d is to compile linux-kernel, \u201cmake uboot\u201d can compile u-boot, \u201cmake rootfs\u201d can compile root-fs \u2026 and so on, you can use \u201cmake help\u201d to find what its commands are supported. Please use top level Makefile to do SDK compilation to avoid some link error occurred. Its help description is as follows: $ make help ===================================================== make help???????????? -> show make command info make all????????????? -> build all make linux??????????? -> build linux-kernel make linuxram???????? -> build linux-kernel with ramdisk support make modules????????? -> build built-in kernel modules make driver?????????? -> build NVT linux driver modules make atf????????????? -> build ARM trusted firmware make uboot??????????? -> build loader(uboot) make optee_os???????? -> build OPTEE kernel make optee_client??? ??-> build OPTEE client make library???????? ??-> build library make busybox????????? -> build busybox make rootfs?????????? ?-> build rootfs make app????????????? -> build applications make tools??????????? ?-> build tools make sample?????????? -> build sample code make post???????????? ?-> run postprocessing script make pack???????????? -> Generate nvtpack image and preburn images make publish????????? ?-> remove some sources for publish ===================================================== make linux_config???? -> config linux-kernel make linux_config_gcov-> modify kernel config for code coverage tool make uboot_config???? -> config uboot make busybox_config?? -> config busybox make linux_header???? -> generate linux-kernel out of tree headers ===================================================== make clean??????????? -> clean all make linux_clean ?????-> clean linux-kernel & built-in kernel modules make driver_clean???? -> clean NVT linux driver modules make atf_clean??????? -> clean ARM trusted firmware make uboot_clean????? -> clean loader(uboot) make optee_os_clean?? -> clean optee kernel make optee_client_clean?? -> clean optee client application make library_clean??? -> clean library make busybox_clean??? -> clean busybox make rootfs_clean???? -> clean rootfs make app_clean??????? -> clean applications make tools_clean????? -> clean tools make sample_clean???? -> clean sample code make post_clean?????? -> run postprocessing clean script make pack_clean?????? -> Remove nvtpack image ===================================================== 2.4 Project configuration \u00b6 We provide the following file to control functionalities enable or disable, please refer to the below procedures to configure. Check model type: $ get_stuff_for_environment ======================================== NVT Setting ======================================== NVT_PRJCFG_MODEL_CFG = /home/user1/na51090_linux_sdk/configs/Linux/cfg_xxx_NAND_EVB/ModelConfig.mk NVT_PRJCFG_CFG = Linux NVT_PRJCFG_MODEL_MK = ??????? The ModelConfig.mk will be generated from configs/cfg_gen/nvt-info.dtsi Enable/disable function: $ cd na51090_linux_sdk/ $ vi configs/cfg_gen/nvt-info.dtsi To find Linux related options: /* ?* Novatek Ltd. BSP part of dts ?*/ / { ??????? nvt_info {????????????????????????????????????????????? / Get from ModelConfig.txt / ??????????????? BIN_NAME = \u201cFW98336A\u201d; ?? ?????????????BIN_NAME_T = \u201cFW98336T\u201d; ??????????????? /* EMBMEM_BLK_SIZE, Normally, 2KPageNand=0x20000, 512PageNand=0x4000, SPI=0x10000 */ ??????????????? EMBMEM_BLK_SIZE = \u201c0x20000\u201d; ??????????????? /* ???????????????? * [EMBMEM] ???????????????? * EMBMEM_NONE ???????????????? * EMBMEM_NAND ???????????????? * EMBMEM_SPI_NOR ???????????????? * EMBMEM_SPI_NAND ???????????????? * EMBMEM_EMMC ???????????????? */ ??????????????? EMBMEM = \u201d EMBMEM_SPI_NAND\u201d; ??????????????? /* ???????????????? * ======= Linux common ========= ???????????????? * application/external ???????????????? */ ??????????????? NVT_CFG_APP_EXTERNAL = \u201cdhd_priv\u201d; ??????????????? /* application include list */ ??????????????? NVT_CFG_APP = \u201c\u201d; ??????????????? /* rootfs etc folder */ ??????? ????????NVT_ROOTFS_ETC = \u201c\u201d; ??????????????? /* strip executable binary and library files: yes/no */ ??????????????? NVT_BINARY_FILE_STRIP = \u201cyes\u201d; ??????????????? /* Using customized kernel config */ ??????????????? NVT_CFG_KERNEL_CFG = \u201c\u201d; ??????????????? /* Using customized uboot config */ ??????????????? NVT_CFG_UBOOT_CFG = \u201c\u201d; ??????????????? /* ???????????????? * ======= Linux for different code setting ========= ???????????????? * [NVT_LINUX_SMP] ???????????????? * NVT_LINUX_SMP_ON ?? ??????????????* NVT_LINUX_SMP_OFF ???????????????? */ ??????????????? NVT_LINUX_SMP = \u201cNVT_LINUX_SMP_ON\u201d; ??????????????? /* ???????????????? * [NVT_DEFAULT_NETWORK_BOOT_PROTOCOL] ???????????????? * NVT_DEFAULT_NETWORK_BOOT_PROTOCOL_DHCP_SERVER ????????? ???????* NVT_DEFAULT_NETWORK_BOOT_PROTOCOL_DHCP_CLIENT ???????????????? * NVT_DEFAULT_NETWORK_BOOT_PROTOCOL_STATIC_IP ???????????????? */ ??????????????? NVT_DEFAULT_NETWORK_BOOT_PROTOCOL = \u201cNVT_DEFAULT_NETWORK_BOOT_PROTOCOL_STATIC_IP\u201d; ??????????????? /* ???????????????? * [NVT_ROOTFS_TYPE] ???????????????? * NVT_ROOTFS_TYPE_NAND_UBI ???????????????? * NVT_ROOTFS_TYPE_NAND_SQUASH ???????????????? * NVT_ROOTFS_TYPE_NAND_JFFS2 ???????????????? * NVT_ROOTFS_TYPE_NOR_SQUASH ???????????????? * NVT_ROOTFS_TYPE_NOR_JFFS2 ???????????????? * NVT_ROOTFS_TYPE_RAMDISK ???????????????? * NVT_ROOTFS_TYPE_EMMC ???????????????? * NVT_ROOTFS_TYPE_NAND_SQUASH_NEW ???????????????? */ ??????????????? NVT_ROOTFS_TYPE = \u201cNVT_ROOTFS_TYPE_RAMDISK\u201d; ??????????????? /* ???????????????? * [NVT_ETHERNET] ???????????????? * NVT_ETHERNET_NONE ???????????????? * NVT_ETHERNET_EQOS ???????????????? */ ??????????????? NVT_ETHERNET = \u201cNVT_ETHERNET_EQOS\u201d; ??????????????? /* ???????????????? * [NVT_SDIO_WIFI]: Remember to update root-fs/rootfs/etc/init.d/S05_Net ???????????????? * NVT_SDIO_WIFI_NONE ???????????????? * NVT_SDIO_WIFI_RTK ???????????????? * NVT_SDIO_WIFI_BRCM ???????????????? * NVT_SDIO_WIFI_NVT ???????????????? */ ??????????????? NVT_SDIO_WIFI = \u201cNVT_SDIO_WIFI_NONE\u201d; ??????????????? /* ???????????????? * [NVT_USB_WIFI] ???????????????? * NVT_USB_WIFI_NONE ???????????????? */ ??????????????? NVT_USB_WIFI = \u201cNVT_USB_WIFI_NONE\u201d; ??????????????? /* ???????????????? * [NVT_USB_4G] ???????????????? * NVT_USB_4G_NONE ???????????????? */ ??????????????? NVT_USB_4G = \u201cNVT_USB_4G_NONE\u201d; ??????????????? /* ???????????????? * [WIFI_RTK_MDL]? : sub item for NVT_SDIO_WIFI_RTK ???????????????? * WIFI_RTK_MDL_NONE ???????????????? * WIFI_RTK_MDL_8189 ???????????????? */ ??????????????? WIFI_RTK_MDL = \u201cWIFI_RTK_MDL_8189\u201d; ??????????????? /* ???????????????? * [WIFI_BRCM_MDL]? : sub item for NVT_SDIO_WIFI_BRCM ???????????????? * WIFI_BRCM_MDL_43438a1_ampk6212axtal26 ???????????????? * WIFI_BRCM_MDL_43455c0_ampk6255c0 ???????????????? */ ??????????????? WIFI_BRCM_MDL = \u201cWIFI_BRCM_MDL_43438a1_ampk6212axtal26\u201d; ??????????????? /* ???????????????? * [WIFI_NVT_MDL]? : sub item for NVT_SDIO_WIFI_NVT ???????????????? * WIFI_NVT_MDL_18202 ???????????? ????* WIFI_NVT_MDL_18211 ???????????????? */ ??????????????? WIFI_NVT_MDL = \u201cWIFI_NVT_MDL_18211\u201d; ??????????????? /* ???????????????? * [NVT_CURL_SSL] ???????????????? * NVT_CURL_SSL_OPENSSL ???????????????? * NVT_CURL_SSL_WOLFSSL ???????????????? */ ??????????????? NVT_CURL_SSL = \u201cNVT_CURL_SSL_OPENSSL\u201d; ??????????????? /* ???????????????? * [NVT_UBOOT_ENV_IN_STORG_SUPPORT] ???????????????? * NVT_UBOOT_ENV_IN_STORG_SUPPORT_NAND ???????????????? * NVT_UBOOT_ENV_IN_STORG_SUPPORT_NOR ???????????????? * NVT_UBOOT_ENV_IN_STORG_SUPPORT_MMC ???????????????? * NVT_UBOOT_ENV_IN_STORG_SUPPORT_OFF ???????????????? */ ??????????????? NVT_UBOOT_ENV_IN_STORG_SUPPORT = \u201cNVT_UBOOT_ENV_IN_STORG_SUPPORT_OFF\u201d; ??????? }; }; 3 Build U-boot \u00b6 3.1 Compilation \u00b6 The Uboot source code is placed on \u201cna51090_linux_sdk/u-boot\u201d, typing \u201cmake uboot\u201d can be used to compile Uboot, and we provide two images are u-boot.bin(non-compressed) and u-boot.lz.bin(compressed) under na51090_linux_sdk/output. U-boot build: $ cd na51090_linux_sdk/ $ make uboot U-boot config: $ cd na51090_linux_sdk/ $ make uboot_config U-boot clean build: $ make uboot_clean 3.2 User customization \u00b6 The uboot have two config files will have different configured properties. One is for common function, the other is for the low level setting. The low level setting can modify this file \u201cinclude/configs/nvt-na51090-evb-a64.h\u201d directly when you have request for the Uboot related configuration. e.g. Uboot passed to Linux\u2019s cmdline can be changed with this variable define CONFIG_USE_BOOTARGS \u00b6 define CONFIG_BOOTARGS_COMMON??? ??\u201dearlycon=nvt_serial,0x2f0280000 rootwait console=ttyS0,115200 debug_boot_weak_hash? \u201c \u00b6 define CONFIG_BOOTARGS????????????? ?CONFIG_BOOTARGS_COMMON \u201croot=/dev/ram0 rootfstype=ramfs rdinit=/linuxrc \u201c \u00b6 Please reference to \u201cSDK_UBoot_Programming_Guide_en\u201d for more details. 4 Build Kernel Code \u00b6 4.1 Compilation \u00b6 The Linux kernel source code is placed on \u201cna51090_linux_sdk/linux-kernel\u201d, typing \u201cmake linux\u201d can be used to compile Linux kernel, and the image name is Image.bin under na51090_linux_sdk. $ cd na51090_linux_sdk/ $ make linux Linux clean build: $ make linux_clean 4.2 System configuration \u00b6 4.2.1 Menu configuration \u00b6 Top Makefile is already integrated the formal Linux menuconfig, to use the following instruction can do the function selection. Please avoid using formal Linux \u201cmake menuconfig\u201d under linux-kernel directly; it will cause error because the important variables are not set correctly. $ make linux_config Choose \u201cSave\u201d after finished function selection; it can generate a new .config for the Linux compilation usage. NA51090 SDK provides two Kernel configuration file under \u201cna51090_linux_sdk/BSP/linux-kernel/arch/arm64/configs/\u201d, one is for the debug mode, and the other is for the release mode. l na51090_XXX_defconfig_debug, the debug mode will enable most of the functions for the development stage l na51090_XXX_defconfig_release, the release mode will only enable boot necessary parts. Edit Top Makefile to switch the configuration file: $ cd na51090_linux_sdk/ $ vi Makefile # kernel & modules CUSTBOARDCONFIG := $(strip $(shell echo $(NVT_PRJCFG_MODEL_CFG) | grep NVT_CFG_KERNEL_CFG | awk -F\u2019=\u2019 \u2018{print $$NF;}\u2019)) ifeq ($(EMBMEM), EMBMEM_SPI_NOR) BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_nor_debug; fi) \u00b6 BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_nor_release; fi) else ifeq ($(EMBMEM), EMBMEM_EMMC) BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_emmc_debug; fi) \u00b6 BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_emmc_release; fi) else BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_debug; fi) \u00b6 BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_release; fi) endif Figure 4-1 Menu configuration 4.2.2 Device tree \u00b6 The device tree can be generated by dtc(device tree compiler) tool as below, you can find the *.dtsi in \u201cna51090_linux_sdk/configs/cfg_xxx\u201d and users can set command \u201cmake cfg\u201d at \u201cna51090_linux_sdk/\u201d. Config items detail description put at na51090_linux_sdk/configs/doc. It can be used to compile device tree, and we will output image nvt-evb.dtb under na51090_linux_sdk/output. The merge method is Union, for example: configs/cfg_gen/nvt-basic.dtsi User can modify CPU clock-frequency from 1200000000(1.2GHz) to 1000000000(1GHz), or 1100000000(1.1GHz), or 1300000000(1.3GHz), or 1350000000(1.35GHz), and compiler again. Users can use new image to boot at new CPU clock-frequency. include <dt-bindings/gpio/gpio.h> \u00b6 include <dt-bindings/interrupt-controller/arm-gic.h> \u00b6 / { ???? model = \u201cNovatek NA51090\u201d; ???? compatible = \u201cnovatek,na51090\u201d, \u201cnvt,ca53\u201d; ???? interrupt-parent = <&gic>; ???? #address-cells = <2>; ???? #size-cells = <2>; ???? psci { ???????? compatible = \u201carm,psci-0.2\u201d; ???????? method = \u201csmc\u201d; ???? }; ???? cpus { ???????? #address-cells = <2>; ???????? #size-cells = <0>; ???????? cpu0: cpu@0 { ????????????? device_type = \u201ccpu\u201d; ????????????? compatible = \u201carm,cortex-a53\u201d, \u201carm,armv8\u201d; ????????????? reg = <0x0 0x0>; ????????????? next-level-cache = <&A53_L2>; ????????????? clock-frequency = <1200000000>; ????????????? enable-method = \u201cpsci\u201d; ???????? }; ???????? cpu1: cpu@1 { ????????????? device_type = \u201ccpu\u201d; ????????????? compatible = \u201carm,cortex-a53\u201d, \u201carm,armv8\u201d; ????????????? reg = <0x0 0x1>; ????????????? next-level-cache = <&A53_L2>; ????????????? clock-frequency = <1200000000>; ????????????? enable-method = \u201cpsci\u201d; ???????? }; ???????? cpu2: cpu@2 { ????????????? device_type = \u201ccpu\u201d; ????????????? compatible = \u201carm,cortex-a53\u201d, \u201carm,armv8\u201d; ????????????? reg = <0x0 0x2>; ????????????? next-level-cache = <&A53_L2>; ????????????? clock-frequency = <1200000000>; ????????????? enable-method = \u201cpsci\u201d; ???????? }; ???????? cpu3: cpu@3 { ????????????? device_type = \u201ccpu\u201d; ????????????? compatible = \u201carm,cortex-a53\u201d, \u201carm,armv8\u201d; ????????????? reg = <0x0 0x3>; ????????????? next-level-cache = <&A53_L2>; ????????????? clock-frequency = <1200000000>; ????????????? enable-method = \u201cpsci\u201d; ???????? }; ???????? A53_L2: l2-cache0 { ????????????? compatible = \u201ccache\u201d; ???????? }; ???? }; ????? \u2026 configs/cfg_gen/nvt-peri.dtsi include <dt-bindings/gpio/nvt-gpio.h> \u00b6 include \u201cnvt-basic.dtsi\u201d \u00b6 / { ???? chosen { ???????? bootargs = \u201d \u201c; ???????? stdout-path = \u201cserial0:115200n8\u201d; ???? }; ???? aliases { ???????? serial0 = &uart0; ???????? serial1 = &uart1; ???????? serial2 = &uart2; ???????? serial3 = &uart3; ???????? serial4 = &uart4; ???????? mmc0 = &mmc0;? / Fixed to mmcblk0 for sdio1 / ???? }; ???? uart0: uart@f0280000 { ???????? compatible = \u201cns16550a\u201d; ???????? reg = <0x2 0xf0280000 0x0 0x1000>; ???????? interrupts = <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>; ???????? baud = <115200>; ???????? reg-shift = <2>; ???????? reg-io-width = <4>; ???????? no-loopback-test = <1>; ???????? clock-frequency = <24000000>; ???????? rx_trig_level = <3>; ???????? hw_flowctrl = <0>; ???? }; ???? uart1: uart@f0290000 { ???????? compatible = \u201cns16550a\u201d; ???????? reg = <0x2 0xf0290000 0x0 0x1000>; ???????? interrupts = <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>; ???????? baud = <115200>; ???????? reg-shift = <2>; ???????? reg-io-width = <4>; ???????? no-loopback-test = <1>; ???????? clock-frequency = <48000000>; ???????? rx_trig_level = <3>; ???????? hw_flowctrl = <0>; ???? }; ???? uart2: uart@f02a0000 { ???????? compatible = \u201cns16550a\u201d; ???????? reg = <0x2 0xf02a0000 0x0 0x1000>; ???????? interrupts = <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>; ???????? baud = <115200>; ???????? reg-shift = <2>; ???????? reg-io-width = <4>; ???????? no-loopback-test = <1>; ???????? clock-frequency = <48000000>; ???????? rx_trig_level = <3>; ???? }; ???? uart3: uart@f02b0000 { ???????? compatible = \u201cns16550a\u201d; ???????? reg = <0x2 0xf02b0000 0x0 0x1000>; ???????? interrupts = <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>; ???????? baud = <115200>; ???????? reg-shift = <2>; ???????? reg-io-width = <4>; ???????? no-loopback-test = <1>; ???????? clock-frequency = <48000000>; ???????? rx_trig_level = <3>; ???? }; ???? uart4: uart@f02c0000 { ???????? compatible = \u201cns16550a\u201d; ???????? reg = <0x2 0xf02c0000 0x0 0x1000>; ???????? interrupts = <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>; ???????? baud = <115200>; ???????? reg-shift = <2>; ???????? reg-io-width = <4>; ???????? no-loopback-test = <1>; ???????? clock-frequency = <48000000>; ???????? rx_trig_level = <3>; ???? }; 4.2.3 Partition table \u00b6 The Nand/EMMC driver of kernel will do for the set partition initialization process as shown below, Uboot will read the partition info(nvt-storage-partition.dtsi) from dts, and then the Kernel also read it from dts to do basic initialization. If you want to change flash partition size or add a partition, please configure device tree nvt-storage-partition.dtsi and build dtb image, burn into flash or load to dram again(default address at 0x1f00000). Figure 4-2 Partition initialization SPI NAND partition example: nvt-storage-partition.dtsi for flash partition &nand { ???? partition_loader {????? label = \u201cloader\u201d;?????? reg = <0x0 0x0000000 0x0 0x40000>; }; / Fixed / ???? partition_fdt {???? ??????? label = \u201cfdt\u201d;??? ??????? reg = <0x0 0x40000?? 0x0 0x40000>; }; / Fixed / ???? partition_fdt.restore {? label = \u201cfdt.restore\u201d;?? reg = <0x0 0x80000?? 0x0 0x40000>; }; / Fixed / ???? partition_atf {???????? label = \u201catf\u201d;????????? reg = <0x0 0x0C0000? 0x0 0x40000>; }; ???? partition_uboot {?????? label = \u201cuboot\u201d;??????? reg = <0x0 0x100000? 0x0 0x1C0000>; }; ???? partition_uenv {??????? label = \u201cuenv\u201d;???????? reg = <0x0 0x2C0000? 0x0 0x40000>; }; ???? partition_kernel {????? label = \u201ckernel\u201d;?????? reg = <0x0 0x300000? 0x0 0x0500000>; }; ???? partition_rootfs {????? label = \u201crootfs\u201d;?????? reg = <0x0 0x800000? 0x0 0x5100000>; }; ???? partition_rootfs1 {???? label = \u201crootfs1\u201d;????? reg = <0x0 0x5900000 0x0 0x2700000>; }; }; If you want to change the partition size or add a partition, please configure it from the dts info. If users want to add user partition such as app1, users can add such as follow: partition_app1 {? ? label = \u201capp1\u201d;????????? reg = <0x0 start_addr 0x0 size>; }; 4.3 Debug \u00b6 To debug the Kernel, you will need System.map or objects for the debug symbol loading, please get them from \u201clinux-kernel/\u201d as shown below: |-- linux-kernel |?????? ??????? |-- Makefile |?????????????? |-- Module.symvers |?????????????? |-- System.map |?????????????? |-- arch |?????????????? |-- block |?????????????? |-- crypto |?????????????? |-- drivers |?????????????? |-- firmware |?????????????? |-- fs |?????????????? |-- include |?????????????? |-- init |?????????????? |-- ipc |?????????????? |-- kernel |?????????????? |-- lib |?????????????? |-- mm |?????????????? |-- modules.builtin |?????????????? |-- modules.order |?????????????? |-- net |?????????????? |-- scripts |?????????????? |-- security |?????????????? |-- sound |?????????????? |-- source |?????????????? |-- usr |?????????????? |-- vmlinux |?????????????? `-- vmlinux.o To add more debug information, we can turn on CONFIG_DEBUG_INFO option before compiling Linux kernel as below. \u201cKernel Hacking > Compile-time checks and compiler options > Compile the kernel with debug info\u201d $ cd na51090_linux_sdk/ $ make linux_config Rebuild all; this binary will contain debug symbol information. |-- linux-kernel |?????? ??????? |-- vmlinux 5 Build Kernel Modules \u00b6 In addition to build-in drivers, Linux had also provided an external load mode called Kernel module, can be loaded by \u201cmodprobe\u201d or \u201cinsmod\u201d. The below will introduce to build-in modules and the out-of-tree modules. 5.1 Build-in module compilation \u00b6 Typing \u201cmake modules\u201d under na51090_linux_sdk can do build-in modules compilation and install path is root-fs/rootfs/lib/modules/{KER_VER}/kernel/. $ cd na51090_linux_sdk/ $ make modules 5.2 Out-of-Tree module compilation \u00b6 This folder under \u201cna51090_linux_sdk/code\u201d provides NVT platform drivers, typing \u201cmake supplement\u201d to do the Out-of Tree modules compilation as below. And the modules will be installed on na51090_linux_sdk/BSP/root-fs/rootfs/lib/modules/{KER_VER}/extra/. $ cd na51090_linux_sdk/ $ make driver Linux Out-of-Tree driver module clean build: $ make driver_clean 5.3 HDAL \u00b6 HDAL is the hardware abstraction layer driver and sample code, this one can be used to build proprietary driver modules, such as video process, video capture and video codec\u2026etc. We provide the following instructions to build. ??????? $ make hdal Clean build: ??????? $ make hdal_clean Please refer to the other documents for details. 5.4 Installation \u00b6 The modules can be installed by \u201cmodprobe\u201d or \u201cinsmod/rmmod\u201d to install or uninstall, besides the modprobe will also install related modules automatically. Example: modprobe (Only needs the module name) modprobe ehci-hcd insmod/rmmod (This method needs a full path) insmod /lib/modules/{KER_VER}/extra/crypto/cryptodev-linux/cryptodev.ko 6 Build tools \u00b6 This folder will integrate some Linux open source tools as the following description: htop????????????????? - Linux process monitoring, to provide more than top information gdb?????????????????? - gdb server for the application debug ethtool????????????? - Utility for controlling network drivers and hardware bonnie++???????? - A benchmark suite that is aimed at performing a number of simple tests of hard drive and file system performance memtester??????? - A userspace utility for testing the memory subsystem for faults mtd-utils?????????? - MTD device utilities procps????????????? - A tool set to provide system analysis tools (vmstat, slabtop,\u2026etc) stress??????????????? - System performance testing tool stress-ng????????? - Advanced system performance testing tool sdcard_test.sh- To do sd driver r/w testing iozone????????????? - IO r/w performance testing VDBench???????? - CPU/io performance testing 6.1 Compilation \u00b6 To select the tools what you want: mtd-utils, memtester, bonnie, ethtool, gdb, htop, netperf, iperf and procps and running below instructions: e.g. $ cd na51090_linux_sdk/ $ cd tools/ $ make stress Tools clean build: $ make clean 6.2 Installation \u00b6 $ make install The tools will be installed on \u201cna51090_linux_sdk/BSP/root-fs\u201d. 7 Build root-fs \u00b6 7.1 Introduction \u00b6 The root file system will be mounted by Linux kernel, the first process of the kernel is /sbin/init (PID=1). We provide several root file systems support for selection, the following are the summary features: l UBIFS: readable/writable file system, support Nor and Nand flash, fast mounting speed, best bad block management and better IO performance. Suitable for low memory size and large flash size use condition. We have a detail introduction in OSDRV/NT9833x_UBI_Filesystem_User_Guide_en.doc l Squashfs: read-only file system, high compression rate. Suitable for small size flash and readonly use condition. l JFFS2: It is a log-structured file system which can support Nand and Nor flash devices. Providing zlib, lzo and rtime compression methods. Suitable for small flash size and readable/writable use condition. l RAMDISK: To provide a ram based file system. 7.2 Configuration \u00b6 The root file system will generate Nand flash type image format, we support squashfs and ubifs, please follow the Nand flash specification to modify the parameters: $ cd na51090_linux_sdk/BSP/root-fs/ $ vi ubi_max_leb.py To find below lines: W = 1024 SP = 128 * 1024 SL = 124 * 1024 According the Nand flash to modify the parameters: l W is the entire flash chip Physical eraseblocks numbers l SP is the Size of block page l SL= (Size of block -2) * Size of page. e.g. 128MB Nand flash = 1024 eraseblocks = 1024 * 128KB W = 1024 SP = 64 * 2048 = 128 * 1024 SL = (64 \u2013 2) * 2048 = 124 * 1024 $ vi mtd_cfg.txt ??????? We can support two mtd_cfg.txt in BSP/root-fs/ and configs/cfg_gen, the build tool will search configs/cfg_gen/mtd_cfg.txt firstly, and the second is BSP/root-fs/mtd_cfg.txt. To find below lines: ROOTFS_UBI_SUB_PAGE_SIZE=2048????????? # Same as page size ROOTFS_UBI_PAGE_SIZE=2048???? ???????? # Nand page size ROOTFS_UBI_ERASE_BLK_SIZE=126976?????? # (64-2) * Page size=126976 ROOTFS_UBI_MAX_LEB_COUNT=361?????????? # Size = UBI_MAX_LEB_COUNT * UBI_BLK_SIZE; It\u2019s calculated by \u201cpython ubi_max_leb.py Bytes\u201d ROOTFS_UBI_RW_MAX_LEB_COUNT=258???????????? # Size = UBI_MAX_LEB_COUNT * UBI_BLK_SIZE; It\u2019s calculated by \u201cpython ubi_max_leb.py Bytes\u201d ROOTFS_UBI_BLK_SIZE=\u201d128KiB\u201d?????????? # UBIFS Nand flash block size (KiB) ROOTFS_UBI_COMPRESS_MODE=\u201dlzo\u201d????????????? # UBIFS compression type: \u201clzo\u201d, \u201cfavor_lzo\u201d, \u201czlib\u201d \u201cnone\u201d ROOTFS_SQ_COMPRESS_MODE=\u201dxz\u201d?????????? # Squashfs compression type: \u201cgzip\u201d, \u201clzo\u201d and \u201cxz\u201d ROOTFS_SQ_BLK_SIZE=\u201d128K\u201d????????????? # Squashfs Nand flash block size (KiB): e.g. spinand: 128K, spinor: 64K ROOTFS_JFFS2_COMPRESS_MODE=\u201dlzo\u201d?????? # jffs2 compression type: \u201clzo\u201d \u201czlib\u201d \u201crtime\u201d ROOTFS_JFFS2_SIZE=0x3200000??????????? # jffs2 partition size: get from /proc/mtd ROOTFS_JFFS2_RW_SIZE=0x2500000????????????? # jffs2 partition size: get from /proc/mtd ROOTFS_JFFS2_BLK_SIZE=\u201d128KiB\u201d????????????? # jffs2 block size (KiB): spinand: 128KiB, spinor: 64KiB ROOTFS_JFFS2_PAGE_SIZE=\u201d2048\u201d????????? # jffs2 page size (Bytes): only used by nand, nor flash can be ignored. ROOTFS_EXT4_SIZE=$(shell printf \u201c%d\\n\u201d 0x0A000000) ROOTFS_FAT_CACHE_SIZE=$(shell printf \u201c%d\\n\u201d 0x0A000000) APPFS \u00b6 ROOTFS_JFFS2_APP_SIZE=0x01E0000 ROOTFS_JFFS2_APP_NOR_SIZE=0x0E20000 ROOTFS_UBI_APP_MAX_LEB_COUNT=231 The necessary parameters need to be modified as below description: l ROOTFS_UBI_SUB_PAGE_SIZE: The sub-page size of the Nand flash l ROOTFS_UBI_PAGE_SIZE: The page size of the Nand flash l ROOTFS_UBI_ERASE_BLK_SIZE: (Nand flash block size \u2013 2) * Page size l ROOTFS_UBI_MAX_LEB_COUNT: Use ubi_max_leb.py to calculate it $ Usage: ubi_max_leb.py PartitionSize (Bytes) l ROOTFS_UBI_RW_MAX_LEB_COUNT: Use ubi_max_leb.py to calculate it $ Usage: ubi_max_leb.py PartitionSize (Bytes) l ROOTFS_UBI_BLK_SIZE: Nand flash block size l ROOTFS_UBI_COMPRESS_MODE: Compression method = LZO l ROOTFS_SQ_COMPRESS_MODE: Squashfs compression mode l ROOTFS_SQ_BLK_SIZE: Squashfs nand flsh block size l ROOTFS_JFFS2_COMPRESS_MODE: jffs2 compression type: \u201clzo\u201d \u201czlib\u201d \u201crtime\u201d l ROOTFS_JFFS2_SIZE: Rootfs partition size l ROOTFS_EXT4_SIZE: EMMC boot partition size l ROOTFS_FAT_CACHE_SIZE: EMMC boot FAT partition size (Optional) l ROOTFS_JFFS2_APP_SIZE: The size of the app partition in nand flash l ROOTFS_JFFS2_APP_NOR_SIZE: The size of the app partition in nor flash l ROOTFS_UBI_APP_MAX_LEB_COUNT: The ubi image size in app partition (Use ubi_max_leb.py to calculate it) You can modify the ubi mount parameters with your requirement, e.g. BSP/root-fs/ubi_max_leb.py def get_ubifs_max_leb(partition_size):????????? #Unit: Bytes ??????? P = partition_size/SP ??????? BR = math.ceil( 30 * W/float(1024))????? # Sync with kernel ??????? B = max(BB, BR) ??????? ubi_overhead = (( B - BB + 4 ) * SP + O * ( P - B - 4 ))/float(SP) ? ??????ubi_overhead = math.ceil(ubi_overhead) ??????? ubi_overhead = math.floor(((P - ubi_overhead) * SP) / float(SL)) ???? ? if ubi_overhead < 0: ???????? return -1 ???? ? else: ???????? return (ubi_overhead - 1) Note: linux menuconfig Maximum expected bad eraseblock count per 1024 eraseblocks value \u201c30\u201d must be the same with ubi_max_leb.py value \u201c30\u201d. This parameter will affect the bad block management, please reserve enough blocks(e.g. 10, 20) per 1024 erase blocks. 7.3 Modify flash filesystem partition size \u00b6 Users must check mtd config definiton in configs/cfg_gen/mtd_cfg.txt, the parameters: ROOTFS_UBI_MAX_LEB_COUNT, ROOTFS_UBI_RW_MAX_LEB_COUNT and ?ROOTFS_UBI_APP_MAX_LEB_COUNT value must use ubi_max_leb.py to calculate. 7.4 Compilation \u00b6 Using \u201cmake rootfs\u201d instruction to generate rootfs bin, the image type can be selected by nvt-info.dtsi in configs folder. They can be produced into \u201cna51090_linux_sdk/output/rootfs.ubifs.bin\u201d, \u201cna51090_linux_sdk/output/rootfs.squash.bin\u201d and \u201cna51090_linux_sdk/output/rootfs.jffs2.bin\u201d separately. The command \u201cmr\u201d also can be used to compile rootfs if you are not in na51090_linux_sdk root folder. $ cd na51090_linux_sdk/ $ source build/envsetup.sh $ make rootfs Rootfs clean build: $ make rootfs_clean This command will remove busybox tools, kernel modules\u2026etc., please follow below procedure to generate rootfs image: $ make busybox $ make app ($ make library if necessary) $ make hdal $ make rootfs 7.5 Folder description \u00b6 l Architecture Folder Description bin User binaries dev Device files etc System management configuration files home User home directories init -> bin/busybox It is used to kernel boot necessary init process, for the initial environment setup. lib Standard system libraries linuxrc -> bin/busybox mnt External storage device mount folder (/mnt/sd, /mnt/usb) proc RAM based FS to provide process information root Root\u2019s folder (The default shell will login here) sbin System management binaries srv Service data sys RAM based FS to provide user space and kernel space attribute/properties link. tmp RAM based temp folder usr User libraries, binaries var Service log message, including kernel, application, web server default folder(/var/www) and service\u2026etc l /etc/passwd This file can setup user account environment, below is to introduce how to enable login password. $ vi /etc/inittab ::respawn:-/bin/login Replace \u201c::respawn:-/bin/login -f root\u201d with \u201c::respawn:-/bin/login\u201d as below Fill in the red part with the encryption password which can be generated by openssl tool: $ vi /etc/passwd root:EncryptionCode:0:0:root:/root:/bin/sh Openssl generation: $ openssl passwd -crypt YourPWD l /etc/init.d System will execute the following shell scripts according sequence. rcS -> S00_PreReady -> S05_Net -> S10_SysInit -> S10_hdal_init -> S99_Sysctl Moreover, power off will execute deinitialization process as below. rcK -> K00_Sys -> K99_Sys l /etc/sysctl.conf This file is handle sysctl parameters setup. 7.6 UBIFS \u00b6 The UBIFS is our default rootfs format, UBIFS (Unsorted Block Image File System) was originally called JFFS3, is JFFS2 next generation version. The main capabilities are faster mounting, quicker access to large files, and improved write speeds. UBIFS also preserves or improves upon JFFS2\u2019s on-the-fly compression, recoverability and power fail tolerance, and data compression allows zlib or LZO. The filename is UBI.IMG after compilation. 7.7 Squashfs \u00b6 Squashfs is a read-only file system which can support gzip, lzo and xz compression modes. The main features are high compression rate, stores full 32bits uid/gids and creation time, support block size up to 1Mbytes. The filename is SQ_ROOTFS.IMG after compilation. 7.8 Jffs2 \u00b6 JFFS2 was developed by Red Hat, based on the work started in the original JFFS by Axis Communications, AB, it is a readable and writable file system. JFFS2 will scan rootfs partition during mounting; the mount time depends on the rootfs size. The main features are listed as below: l Support compression mode l Mounting time will be affected by flash size l Not support all Nand flash devices with HW ecc, please refer to Linux driver application note The filename is rootfs.jffs2.bin after compilation. For the kernel configuration to add jffs2 support, you must add below configurations: File systems -> Miscellaneous filesystems -> [*] Journalling Flash File System v2 (JFFS2) support -> [*] Advanced compression options for JFFS2 -> [*] JFFS2 LZO compression support For the uboot configuration to choose root file system type, please refer to the UBoot_Programing_Guide. 7.9 HDAL sample code \u00b6 We will pack one partition named DVR_xxx.bin is under na51090_linux_sdk/configs/Linux/cfg_xxx/nvt-nvtpack.dtsi partition_name = \u201capp\u201d field. You could modify the partition size and recalculate the related parameters to fill in the nvt -storage-partition.dtsi partition_app field. Please refer to 7.2 for mtd_cfg.txt description. 8 Build App \u00b6 8.1 Compilation \u00b6 NVT platform needs the necessary applications to perform the requested actions, please using below instructions to compile (This part doesn\u2019t provide source code). $ cd na51090_linux_sdk/code/application $ make install Please execute \u201csource build/envsetup.sh\u201d firstly when you start to build it. Please reference to Application Note for the other details. We have fine-tuned some functions and the fpu related setting, please add $(PLATFORM_CFLAGS) to your Makefile to get more performance. e.g. nvt02854@oaalnx13:~/na51090_linux_sdk/na51090_linux_sdk$ get_stuff_for_environment ======================================== NVT Setting ======================================== NVT_PRJCFG_CFG = Linux NVT_PRJCFG_MODEL_CFG = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/configs/Linux/cfg_TEST_FPGA_a64/ModelConfig.mk LINUX_BUILD_TOP = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk UBOOT_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/u-boot OPTEE_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/optee KERNELDIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/linux-kernel BUSYBOX_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/busybox TOYBOX_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/toybox ROOTFS_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/root-fs APP_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/application LIBRARY_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/lib INCLUDE_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/lib/include NVT_DRIVER_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/driver NVT_HDAL_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/hdal NVT_VOS_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/vos NVT_RTOS_MAIN_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/rtos-main SAMPLE_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/sample TOOLS_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/tools OUTPUT_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/output LOGS_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/logs BUILD_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/build CONFIG_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/configs PLATFORM_CFLAGS = -march=armv8-a -mtune=cortex-a53 -ftree-vectorize -fno-builtin -fno-common -Wformat=1 -D_BSP_NA51090_ PLATFORM_AFLAGS = march=armv8-a -mtune=cortex-a53 -D_BSP_NA51090_ NVT_HOST = aarch64-ca53-linux-uclibc LINUX_CPU_TYPE = cortex-a53x64 NVT_LINUX_VER = 4.19.148 NVT_MULTI_CORES_FLAG = -j80 CROSS_COMPILE = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc- CROSS_TOOLCHAIN_PATH = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4 CROSS_TOOLCHAIN_BIN_PATH = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin SYSROOT_PATH = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/aarch64-ca53-linux-uclibc/sysroot UBOOT_CROSS_COMPILE = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc- AS = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-as CC = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-gcc CXX = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-g++ LD = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-ld LDD = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-ldd AR = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-ar NM = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-nm GDB = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-gdb STRIP = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-strip OBJCOPY = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-objcopy OBJDUMP = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-objdump PATH = /opt/CEVA-ToolBox/V17/XM4/CEVA-XM4:/opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin:/opt/utility/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/snap/bin:. LD_LIBRARY_PATH = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/local/lib ============================================================================================= 9 Build Libraries \u00b6 9.1 Compilation \u00b6 na51090_linux_sdk provides some proprietary libraries and header files for the product customization (this part doesn\u2019t involve source code, we only provide you *.so), please according the following instruction to compile it. $ cd na51090_linux_sdk/ $ make library Libraries clean build: $ make library_clean Please execute \u201csource build/envsetup.sh\u201d firstly when you start to build it. Please reference to Application Note for the other details. 10 Build busybox \u00b6 10.1 Compilation \u00b6 Busybox can provide rootfs necessary tools, using below instruction can compile it. And the tools will be installed to na51090_linux_sdk/BSP/root-fs. $ cd na51090_linux_sdk/ $ make busybox mybusybox clean build: $ make busybox_clean 10.2 Menu configuration \u00b6 SDK will provide two busybox configuration files, one is normal version (busybox_cfg_normal), and the other is minimized version (busybox_cfg_small). Edit Top Makefile can change the busybox configuration, the default is normal version. Edit Top Makefile to switch the configuration file: $ cd na51090_linux_sdk/ $ vi Makefile BUSYBOX_CFG:=busybox_cfg_full BUSYBOX_CFG:=busybox_cfg_small \u00b6 Below instruction can handle busybox features selection: $ make busybox_config Choose \u201cExit/Save\u201d after you finished function selection, it can generate new .config for the Busybox compilation usage. 11 Build sample code \u00b6 11.1 Compilation \u00b6 The device driver testing applications will be used to test NVT peripheral devices; the following instructions can compile it. And it will be installed to na51090_linux_sdk/BSP/root-fs. $ cd na51090_linux_sdk/ $ make sample Driver test clean build: ??????? $ make sample_clean 12 Update Firmware \u00b6 We provide two OS version nvtpack image could be used, one is Linux version will be generate by Linux version nvtpack tool, the images will be generated under the output folder. Another is Windows vesion nvtpack tool, the following section can get more clearly description. 12.1 Linux version nvtpack for all-in-one image \u00b6 The nvt-nvtpack.dtsi is used to control what kinds of images want to be involved, and which files will be packed by all-in-one tool. If source_file = \u201c\u201d, it means we don\u2019t want to pack this image into all-in-one image. If id1 \u2026 source_file = \u201cnvt-evb.bin\u201d, it means nvt-evb.bin file will pack into all-in-one image partition 1, partition setting we can reference nvt-storage-partition.dtsi file. nvtpack { ???? ver = \u201cNVTPACK_FW_INI_16072017\u201d; / Fixed / ???? method = <1>; / Fixed / ???? index { ????????????? id0 { partition_name = \u201cloader\u201d;????? source_file = \u201c\u201d; }; / Fixed / ????????????? id1 { partition_name = \u201cfdt\u201d;???????? source_file = \u201cnvt-all.bin\u201d; }; / Fixed / ????????????? id2 { partition_name = \u201cfdt.restore\u201d; source_file = \u201c\u201d;???? }; / Fixed / ????????????? id3 { partition_name = \u201catf\u201d;???????? source_file = \u201catf.bin\u201d; }; ????????????? id4 { partition_name = \u201cuboot\u201d;??? ????? source_file = \u201cu-boot.bin\u201d; }; ????????????? id5 { partition_name = \u201cuenv\u201d;???? ????? source_file = \u201c\u201d; }; ????????????? id6 { partition_name = \u201ckernel\u201d;????? source_file = \u201cImage.bin\u201d; }; ????????????? id7 { partition_name = \u201crootfs\u201d;????? source_file = \u201crootfs.ramdisk.bin\u201d; }; ????????????? id8 { partition_name = \u201crootfs1\u201d;???? source_file = \u201crootfs_1.rw.ubifs.bin\u201d; }; ???? }; }; ??????? Using \u201cmake all\u201d or \u201cmake pack\u201d can generate the packed image is under output/packed/FW(SOC).bin. 12.2 Update Firmware \u00b6 Insert SD card including All-in-One bin to the target board and power on can update firmware. 12.3 Update Loader \u00b6 For a blank Nand flash, you need to burn loader (LD98336A.bin), by first SD card format (be sure to format), and then immediately put LD98336A.bin, then placed all in one bin (FW98336A.bin). 13 Power on \u00b6 13.1 How to power on \u00b6 To follow update steps to burn the desired Image, remove SD card can boot up directly. 14 Debug \u00b6 The following list provides comparison and classification of the debugging tools. Name Classification Description Coredump AP debug Generated file for the further analysis when the program has terminated abnormally Messages AP/Kernel debug To record Linux kernel and AP booting log GDB AP debug To debug target board application from remote server printk Kernel debug Basic kernel/module debug usage kmemleak Kernel debug To analyze if Linux kernel has memory leak issue. OPENOCD Kernel debug To debug/ trace kernel or uboot 14.1 Coredump \u00b6 Provide analytical application error log, the application does not properly terminated, it generates a file in /var/log. It can record the program name, PID and time, can be loaded for analysis through a cross compiler. You should build it with debug mode when you start application analysis. The following is related setting: $ cd na51090_linux_sdk/root-fs/rootfs/ $ vi etc/profile # coredump setting echo 1 > /proc/sys/kernel/core_uses_pid ulimit -c unlimited echo \u201c/var/log/core-%e-%p-%t\u201d > /proc/sys/kernel/core_pattern 14.2 Messages \u00b6 The boot log of the Linux will be stored in /var/log/messages, this file can involve Kernel and user space app. If the kernel crash occurred, please provide this file for the further analysis. 14.3 GDB \u00b6 GDB (GNU Project Debugger) can support Remote and Target mode to debug AP. Target mode gdb/gdbserver can be generated by the following command: $ cd na51090_linux_sdk/tools $ make gdb The connection diagram as shown below, Figure 13-1: Figure 14-1 Target debug connection Remote mode can debug user space application through GDB server, and the connection architecture as below. Linux server is x86_64 compile server, target board is the EVB, they can be connected by serial or TCP/IP. Linux server will use cross compiler toolchain GDB to debug target board AP, this AP must be enabled debug symbol, and target board also needs to execute gdbserver which can be find in toolchain. The serial connection can connect USB-to-Serial cable to target board USB port, and check if there is /dev/ttyUSB0 existed. TCP/IP connection can use Wi-Fi or Ethernet, install necessary drivers and confirm whether it can ping to server. Figure 14-2 Remote debug connection GDB server needs to be executed on EVB. $ cp tools/__install/bin/gdbserver root-fs/rootfs/bin/ $ cp tools/__install/bin/gdb root-fs/rootfs/bin/ And then, running below procedures can debug your AP. Target Board target > gdbserver comm prog [args\u2026] The gdbserver doesn\u2019t loading debug symbol, all of the symbols will be loaded by the Linux server cross compiler gdb. It can reduce memory space in this way. Serial: target > gdbserver /dev/ttyUSB0 hello_world Net: target > gdbserver Host _IP:1234 hello_world Linux Server Serial: Server > {CROSS_COMPILE}-gdb hello_world Server > set remotebaud 115200 Server > target remote /dev/ttyUSB0 Net: Server > {CROSS_COMPILE}-gdb hello_world Server > target remote localhost:1234 Reference to below link can show you how to use command debug your AP: http://sourceware.org/gdb/current/onlinedocs/gdb/index.html In addition to command mode debug you also can use DDD, it is a framework on top of GDB debug visualization software, you can install and use by below command: $ sudo apt-get install ddd $ sudo ddd \u2013debugger aarch64-ca53-linux-uclibc-gdb 14.4 Printk \u00b6 Linux provides seven levels of Log printk available in the following table: Level Description Usage (0) KERN_EMERG system is unusable pr_emerg (1) KERN_ALERT action must be taken immediately pr_alert (2) KERN_CRIT critical conditions pr_crit (3) KERN_ERR error conditions pr_err (4) KERN_WARNING warning conditions pr_warning (5) KERN_NOTICE normal but significant condition pr_notice (6) KERN_INFO Informational pr_info (7) KERN_DEBUG debug-level messages pr_debug Above the printk level is used to decide whether or not to print the message console, the below instruction can show you the printk level, current representative of the level of the boot to be printed, default is the default level, minimum is the lowest possible print level, boot-time-default is boot stage log: root@NVTEVM:~$ cat /proc/sys/kernel/printk ??????????????????????????????????????? 7?????? 4?????? 1?????? 7 current??? default??? minimum??????? boot-time-default Kernel will compare the printed message log level, if the value is less than the current will be printed out. Therefore, to change the output level so that all messages are printed out can use this command:Kernel hui qu b?jiao yin ch? xunxi de log level, rugu? xi?oyu current de zhi jiu hui yin ch?lai. Y?nc?, yao g?ibian sh?ch? jibie rang su?y?u xunxi d?u k?y? yin ch?lai k?y? yong d?xia f?ngshi:\u60a8\u662f\u4e0d\u662f\u8981\u67e5\uff1a Linux\u9664\u4e86_Built_-in\u7684Driver\u4e4b\u5916,\u9084\u6709\u63d0\u4f9b\u5916\u90e8\u8f09\u5165\u7684\u65b9\u5f0f\u7a31\u4e4b\u70baKernel module,\u53ef\u900f\u904einsmod\u6216\u662fmodprobe\u505a\u8f09\u5165,\u5e95\u4e0b\u5206\u70babuild-in module\u8207out-of-tree module\u505a\u7de8\u8b6f\u4ecb\u7d39\u3002 root@NVTEVM:~$ echo 8 > /proc/sys/kernel/printk 14.5 Kmemleak \u00b6 Linux Kmemleak is provided for detecting a memory leak tool, it will record detect report in /sys/kernel/debug/kmemleak, to use this function as long as enable the \u201cKernel Hacking\u201d, \u201cKernel Memory Leak Detector\u201d (CONFIG_DEBUG_KMEMLEAK) in the kernel option, and configure the \u201cMaximum kmemleak early log entires\u201d with 1200. Clear current record: root@NVTEVM:~$ echo clear > /sys/kernel/debug/kmemleak Testing your driver: root@NVTEVM:~$ insert YourModule.ko Scan: root@NVTEVM:~$ echo scan > /sys/kernel/debug/kmemleak Check the resules: root@NVTEVM:~$ cat /sys/kernel/debug/kmemleak 15 FAQ \u00b6 This section will list frequently problems. 15.1 Toolchain can\u2019t be found \u00b6 We have two toolchains to build overall SDK, one is for itron, another is for Linux. First, please use below command to check your environment setting. $ get_stuff_for_environment 15.2 Operation not permitted \u00b6 The SDK installation path should be under your home folder, you should use the same owner to decompressing and building, otherwise you will get \u201c operation not permitted \u201d related message. Please use below command to check permission and owner. $ ls -al YOUR_FOLDER 15.3 Linux kernel uImage can\u2019t be generated \u00b6 This is because our default setting is lz4 compression format, you should follow section 1.2 to check lz4 tool is installed. Try to use lz4 command to check your compiling environment. $ lz4","title":"Linux Programming Guide"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#1-development-environment","text":"","title":"1 Development Environment"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#11-virtualboxubuntu-os-installation","text":"This section will introduce how to install Ubuntu on Windows OS, ignore this section if your environment is under single OS. Please download from VirtualBox official website ( https://www.virtualbox.org/wiki/Downloads ) and follow below instructions to install. This step will install device driver, please select \u201cInstall\u201d: Create virtual machine (Version: Ubuntu 64-Bit): Select virtual machine memory size: Create virtual machine (If you have an existed Ubuntu image, you can select \u201cUse an existing virtual hard disk file\u201d): To configure virtual disk space (At least 40GB size): Select Optical drive and using Ubuntu ISO (Ubuntu 12.04/14.04/16.04/18.04 64-bit) startup:","title":"1.1 VirtualBox/Ubuntu OS installation"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#12-linux-environment-setup","text":"In order to prevent some complaints in the SDK compilation of the 32 Bits OS, we will use 64 Bits Ubuntu OS as our development environment. The first of all, you should install an Ubuntu based server or Ubuntu on VirtualBox which is introduced in previous section, please download the image from ( http://releases.ubuntu.com/ ) to get Ubuntu 12.04/14.04/16.04/18.04 Desktop AMD64 version ISO image and use the following instructions to install necessary Ubuntu packages. Ubuntu 12.04: $ sudo apt-get install bc build-essential libc6-dev libncurses5-dev libgl1-mesa-dev g++-multilib mingw32 tofrodos ia32-libs uboot-mkimage zlib1g-dev mtd-utils vim squashfs-tools gawk cmake cmake-data libstdc++6 device-tree-compiler android-tools-fsutils texinfo libssl-dev python3-crypto python3-pyelftools python3-pycrypto $ sudo add-apt-repository ppa:nathan-renniewaldock/ppa $ sudo apt-get update $ sudo apt-get install liblz4-tool To install make-4.1 ( This will replace your original /bin/make tool ): Download https://ftp.gnu.org/gnu/make/make-4.1.tar.bz2 $ tar -jxvf make-4.1.tar.bz2 $ cd make-4.1; ./configure; make -j4 $ make install Ubuntu 14.04: $ sudo apt-get install bc build-essential libc6-dev lib32ncurses5 libncurses5-dev libncurses5:i386 libgl1-mesa-dev g++-multilib mingw32 tofrodos lib32z1 lib32bz2-1.0 u-boot-tools zlib1g-dev bison libbison-dev flex mtd-utils vim squashfs-tools gawk cmake cmake-data liblz4-tool libmpc3 libstdc++6 device-tree-compiler android-tools-fsutils texinfo libssl-dev python3-crypto python3-pyelftools python3-pycrypto To install make-4.1 ( This will replace your original /bin/make tool ): Download https://ftp.gnu.org/gnu/make/make-4.1.tar.bz2 $ tar -jxvf make-4.1.tar.bz2 $ cd make-4.1; ./configure; make -j4 $ make install Ubuntu 16.04: $ sudo apt-get install bc build-essential libc6-dev lib32ncurses5 libncurses5-dev libncurses5:i386 libgl1-mesa-dev g++-multilib mingw-w64 tofrodos lib32z1 u-boot-tools zlib1g-dev bison libbison-dev flex mtd-utils vim squashfs-tools gawk cmake cmake-data liblz4-tool libmpc3 libstdc++6 device-tree-compiler android-tools-fsutils texinfo libssl-dev python3-crypto python3-pyelftools python3-pycrypto Ubuntu 18.04: $ sudo apt-get install bc build-essential libc6-dev lib32ncurses5 libncurses5-dev libncurses5:i386 libgl1-mesa-dev g++-multilib mingw-w64 tofrodos lib32z1 u-boot-tools zlib1g-dev bison libbison-dev flex mtd-utils vim squashfs-tools gawk cmake cmake-data liblz4-tool libmpc3 libstdc++6 device-tree-compiler android-tools-fsutils texinfo libssl-dev python3-crypto python3-pyelftools python3-pycrypto Ubuntu default shell is dash, please reconfigure the default shell with bash: $ sudo dpkg-reconfigure dash, and choose \u201cNo\u201d in the window Or $ sudo rm /bin/sh && sudo ln -s /bin/bash /bin/sh Besides, the openssh-server is used to provide Windows Host PC connected to Linux server and remote building the Linux SDK, and the Samba server is to provide client get Linux SDK image from Linux server. l $ apt-get install openssh-server l $ apt-get install samba l $ vim /etc/samba/smb.conf o Please reference to related Samba configuration as below: https://help.ubuntu.com/12.04/serverguide/samba-fileserver.html Windows Host PC will also need Teraterm or putty to connect to Target board UART2 port with 115200/8/1/n configuration. Figure 1-1 Linux Development Environment","title":"1.2 Linux environment setup"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#13-how-to-install-nt9833x-linux-sdk","text":"Using the following instructions to decompress SDK pack under Linux: $ tar -jxvf na51090_linux_sdk_{version}.tar.bz2 You will get the folder tree as below: \u251c\u2500\u2500 na51090_linux_sdk?????????????????????? Used to put unpacked SDK source code \u251c\u2500\u2500 BSP????????????????????????????????????????? Including linux, busybox, uboot and rootfs source \u251c\u2500\u2500 build???????????????????????????????????????? scripts for the environment setup \u251c\u2500\u2500 code???????????????????????????????????????? HDAL, linux drivers and sample code \u251c\u2500\u2500 configs???????????????????????????????????? Model settings \u251c\u2500\u2500 Makefile?????????????????????????????????? Top level Makefile \u2514\u2500\u2500 tools????????????????????????????????????????? target board tool \u251c\u2500\u2500 toolchains??????????????? ??????????????? Toolchain folder \u251c\u2500\u2500 aarch64-ca53-linux-gnueabihf-8.4.tar.bz2 \u2514\u2500\u2500 aarch64-ca53-linux-uclibcgnueabihf-8.4.tar.bz2","title":"1.3 How to install NT9833x  Linux SDK"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#14-how-to-install-cross-compiler","text":"We support both glibc and uclibc cross compiler toolchain, please choose and install it by using below instructions: $ cd toolchain $ sudo tar -jxvf aarch64-ca53-linux-gnueabihf-8.4.tar.bz2 -C /opt/arm or $ sudo tar -jxvf aarch64-ca53-linux-uclibcgnueabihf-8.4.tar.bz2 -C /opt/arm","title":"1.4 How to install Cross compiler"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#2-introduction-to-compilation","text":"","title":"2 Introduction to Compilation"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#21-environment-setup","text":"Before each opened a new Terminal window needs to do compiler environment setting, the relevant variables set up, please follow the below instructions to finish it. $ cd na51090_linux_sdk/ $ source build/envsetup.sh","title":"2.1 Environment setup"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#22-compilation","text":"Please do a complete compilation for first time. Select your model: $ lunch List your nvt build setting: ??????? $ get_stuff_for_environment Build overall system: $ make all It will generate the images under na51090_linux_sdk/output after the compilation. The details are listed as below. |-- na51090_linux_sdk??????????????????????????????? ??????? Put unpacked source code and image |?? |-- Makefile???????????????????????????? ??????? ??????????????? Top level Makefile |?? |-- output???????????????????????????????? ??????? ??????????????? Compiled output images |????? |-- packed???????????????????????? ??????????????? ??????? |????? ???|-- FW(SOC)A.bin????????????? ??????? ??????? nvtpack image (All-in-one image) |????? |-- atf.bin ???????????????????????????????? ??????? ??????? ATF image |????? |-- Image.bin???????????????????????????????????????????? Linux Image |????? |-- u-boot.bin???????????????????????????????????????????? uboot image with NVT checksum |????? |-- u-boot.lz.bin???????????????????????????????????????? uboot image (LZ compressed) |????? |-- rootfs.ramdisk.bin?????????????????????????????? ramdisk image (rootfs) |????? `-- rootfs_1.rw.ubifs.bin?????????????????????????? rootfs overlay","title":"2.2 Compilation"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#23-top-level-makefile","text":"na51090_linux_sdk folder has a top level Makefile, it supports many of the make command, such as \u201cmake linux\u201d is to compile linux-kernel, \u201cmake uboot\u201d can compile u-boot, \u201cmake rootfs\u201d can compile root-fs \u2026 and so on, you can use \u201cmake help\u201d to find what its commands are supported. Please use top level Makefile to do SDK compilation to avoid some link error occurred. Its help description is as follows: $ make help ===================================================== make help???????????? -> show make command info make all????????????? -> build all make linux??????????? -> build linux-kernel make linuxram???????? -> build linux-kernel with ramdisk support make modules????????? -> build built-in kernel modules make driver?????????? -> build NVT linux driver modules make atf????????????? -> build ARM trusted firmware make uboot??????????? -> build loader(uboot) make optee_os???????? -> build OPTEE kernel make optee_client??? ??-> build OPTEE client make library???????? ??-> build library make busybox????????? -> build busybox make rootfs?????????? ?-> build rootfs make app????????????? -> build applications make tools??????????? ?-> build tools make sample?????????? -> build sample code make post???????????? ?-> run postprocessing script make pack???????????? -> Generate nvtpack image and preburn images make publish????????? ?-> remove some sources for publish ===================================================== make linux_config???? -> config linux-kernel make linux_config_gcov-> modify kernel config for code coverage tool make uboot_config???? -> config uboot make busybox_config?? -> config busybox make linux_header???? -> generate linux-kernel out of tree headers ===================================================== make clean??????????? -> clean all make linux_clean ?????-> clean linux-kernel & built-in kernel modules make driver_clean???? -> clean NVT linux driver modules make atf_clean??????? -> clean ARM trusted firmware make uboot_clean????? -> clean loader(uboot) make optee_os_clean?? -> clean optee kernel make optee_client_clean?? -> clean optee client application make library_clean??? -> clean library make busybox_clean??? -> clean busybox make rootfs_clean???? -> clean rootfs make app_clean??????? -> clean applications make tools_clean????? -> clean tools make sample_clean???? -> clean sample code make post_clean?????? -> run postprocessing clean script make pack_clean?????? -> Remove nvtpack image =====================================================","title":"2.3 Top level Makefile"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#24-project-configuration","text":"We provide the following file to control functionalities enable or disable, please refer to the below procedures to configure. Check model type: $ get_stuff_for_environment ======================================== NVT Setting ======================================== NVT_PRJCFG_MODEL_CFG = /home/user1/na51090_linux_sdk/configs/Linux/cfg_xxx_NAND_EVB/ModelConfig.mk NVT_PRJCFG_CFG = Linux NVT_PRJCFG_MODEL_MK = ??????? The ModelConfig.mk will be generated from configs/cfg_gen/nvt-info.dtsi Enable/disable function: $ cd na51090_linux_sdk/ $ vi configs/cfg_gen/nvt-info.dtsi To find Linux related options: /* ?* Novatek Ltd. BSP part of dts ?*/ / { ??????? nvt_info {????????????????????????????????????????????? / Get from ModelConfig.txt / ??????????????? BIN_NAME = \u201cFW98336A\u201d; ?? ?????????????BIN_NAME_T = \u201cFW98336T\u201d; ??????????????? /* EMBMEM_BLK_SIZE, Normally, 2KPageNand=0x20000, 512PageNand=0x4000, SPI=0x10000 */ ??????????????? EMBMEM_BLK_SIZE = \u201c0x20000\u201d; ??????????????? /* ???????????????? * [EMBMEM] ???????????????? * EMBMEM_NONE ???????????????? * EMBMEM_NAND ???????????????? * EMBMEM_SPI_NOR ???????????????? * EMBMEM_SPI_NAND ???????????????? * EMBMEM_EMMC ???????????????? */ ??????????????? EMBMEM = \u201d EMBMEM_SPI_NAND\u201d; ??????????????? /* ???????????????? * ======= Linux common ========= ???????????????? * application/external ???????????????? */ ??????????????? NVT_CFG_APP_EXTERNAL = \u201cdhd_priv\u201d; ??????????????? /* application include list */ ??????????????? NVT_CFG_APP = \u201c\u201d; ??????????????? /* rootfs etc folder */ ??????? ????????NVT_ROOTFS_ETC = \u201c\u201d; ??????????????? /* strip executable binary and library files: yes/no */ ??????????????? NVT_BINARY_FILE_STRIP = \u201cyes\u201d; ??????????????? /* Using customized kernel config */ ??????????????? NVT_CFG_KERNEL_CFG = \u201c\u201d; ??????????????? /* Using customized uboot config */ ??????????????? NVT_CFG_UBOOT_CFG = \u201c\u201d; ??????????????? /* ???????????????? * ======= Linux for different code setting ========= ???????????????? * [NVT_LINUX_SMP] ???????????????? * NVT_LINUX_SMP_ON ?? ??????????????* NVT_LINUX_SMP_OFF ???????????????? */ ??????????????? NVT_LINUX_SMP = \u201cNVT_LINUX_SMP_ON\u201d; ??????????????? /* ???????????????? * [NVT_DEFAULT_NETWORK_BOOT_PROTOCOL] ???????????????? * NVT_DEFAULT_NETWORK_BOOT_PROTOCOL_DHCP_SERVER ????????? ???????* NVT_DEFAULT_NETWORK_BOOT_PROTOCOL_DHCP_CLIENT ???????????????? * NVT_DEFAULT_NETWORK_BOOT_PROTOCOL_STATIC_IP ???????????????? */ ??????????????? NVT_DEFAULT_NETWORK_BOOT_PROTOCOL = \u201cNVT_DEFAULT_NETWORK_BOOT_PROTOCOL_STATIC_IP\u201d; ??????????????? /* ???????????????? * [NVT_ROOTFS_TYPE] ???????????????? * NVT_ROOTFS_TYPE_NAND_UBI ???????????????? * NVT_ROOTFS_TYPE_NAND_SQUASH ???????????????? * NVT_ROOTFS_TYPE_NAND_JFFS2 ???????????????? * NVT_ROOTFS_TYPE_NOR_SQUASH ???????????????? * NVT_ROOTFS_TYPE_NOR_JFFS2 ???????????????? * NVT_ROOTFS_TYPE_RAMDISK ???????????????? * NVT_ROOTFS_TYPE_EMMC ???????????????? * NVT_ROOTFS_TYPE_NAND_SQUASH_NEW ???????????????? */ ??????????????? NVT_ROOTFS_TYPE = \u201cNVT_ROOTFS_TYPE_RAMDISK\u201d; ??????????????? /* ???????????????? * [NVT_ETHERNET] ???????????????? * NVT_ETHERNET_NONE ???????????????? * NVT_ETHERNET_EQOS ???????????????? */ ??????????????? NVT_ETHERNET = \u201cNVT_ETHERNET_EQOS\u201d; ??????????????? /* ???????????????? * [NVT_SDIO_WIFI]: Remember to update root-fs/rootfs/etc/init.d/S05_Net ???????????????? * NVT_SDIO_WIFI_NONE ???????????????? * NVT_SDIO_WIFI_RTK ???????????????? * NVT_SDIO_WIFI_BRCM ???????????????? * NVT_SDIO_WIFI_NVT ???????????????? */ ??????????????? NVT_SDIO_WIFI = \u201cNVT_SDIO_WIFI_NONE\u201d; ??????????????? /* ???????????????? * [NVT_USB_WIFI] ???????????????? * NVT_USB_WIFI_NONE ???????????????? */ ??????????????? NVT_USB_WIFI = \u201cNVT_USB_WIFI_NONE\u201d; ??????????????? /* ???????????????? * [NVT_USB_4G] ???????????????? * NVT_USB_4G_NONE ???????????????? */ ??????????????? NVT_USB_4G = \u201cNVT_USB_4G_NONE\u201d; ??????????????? /* ???????????????? * [WIFI_RTK_MDL]? : sub item for NVT_SDIO_WIFI_RTK ???????????????? * WIFI_RTK_MDL_NONE ???????????????? * WIFI_RTK_MDL_8189 ???????????????? */ ??????????????? WIFI_RTK_MDL = \u201cWIFI_RTK_MDL_8189\u201d; ??????????????? /* ???????????????? * [WIFI_BRCM_MDL]? : sub item for NVT_SDIO_WIFI_BRCM ???????????????? * WIFI_BRCM_MDL_43438a1_ampk6212axtal26 ???????????????? * WIFI_BRCM_MDL_43455c0_ampk6255c0 ???????????????? */ ??????????????? WIFI_BRCM_MDL = \u201cWIFI_BRCM_MDL_43438a1_ampk6212axtal26\u201d; ??????????????? /* ???????????????? * [WIFI_NVT_MDL]? : sub item for NVT_SDIO_WIFI_NVT ???????????????? * WIFI_NVT_MDL_18202 ???????????? ????* WIFI_NVT_MDL_18211 ???????????????? */ ??????????????? WIFI_NVT_MDL = \u201cWIFI_NVT_MDL_18211\u201d; ??????????????? /* ???????????????? * [NVT_CURL_SSL] ???????????????? * NVT_CURL_SSL_OPENSSL ???????????????? * NVT_CURL_SSL_WOLFSSL ???????????????? */ ??????????????? NVT_CURL_SSL = \u201cNVT_CURL_SSL_OPENSSL\u201d; ??????????????? /* ???????????????? * [NVT_UBOOT_ENV_IN_STORG_SUPPORT] ???????????????? * NVT_UBOOT_ENV_IN_STORG_SUPPORT_NAND ???????????????? * NVT_UBOOT_ENV_IN_STORG_SUPPORT_NOR ???????????????? * NVT_UBOOT_ENV_IN_STORG_SUPPORT_MMC ???????????????? * NVT_UBOOT_ENV_IN_STORG_SUPPORT_OFF ???????????????? */ ??????????????? NVT_UBOOT_ENV_IN_STORG_SUPPORT = \u201cNVT_UBOOT_ENV_IN_STORG_SUPPORT_OFF\u201d; ??????? }; };","title":"2.4 Project configuration"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#3-build-u-boot","text":"","title":"3 Build U-boot"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#31-compilation","text":"The Uboot source code is placed on \u201cna51090_linux_sdk/u-boot\u201d, typing \u201cmake uboot\u201d can be used to compile Uboot, and we provide two images are u-boot.bin(non-compressed) and u-boot.lz.bin(compressed) under na51090_linux_sdk/output. U-boot build: $ cd na51090_linux_sdk/ $ make uboot U-boot config: $ cd na51090_linux_sdk/ $ make uboot_config U-boot clean build: $ make uboot_clean","title":"3.1 Compilation"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#32-user-customization","text":"The uboot have two config files will have different configured properties. One is for common function, the other is for the low level setting. The low level setting can modify this file \u201cinclude/configs/nvt-na51090-evb-a64.h\u201d directly when you have request for the Uboot related configuration. e.g. Uboot passed to Linux\u2019s cmdline can be changed with this variable","title":"3.2 User customization"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#define-config_use_bootargs","text":"","title":"define CONFIG_USE_BOOTARGS"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#define-config_bootargs_common-earlyconnvt_serial0x2f0280000-rootwait-consolettys0115200-debug_boot_weak_hash","text":"","title":"define CONFIG_BOOTARGS_COMMON??? ??\"earlycon=nvt_serial,0x2f0280000 rootwait console=ttyS0,115200 debug_boot_weak_hash? \""},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#define-config_bootargs-config_bootargs_common-rootdevram0-rootfstyperamfs-rdinitlinuxrc","text":"Please reference to \u201cSDK_UBoot_Programming_Guide_en\u201d for more details.","title":"define CONFIG_BOOTARGS????????????? ?CONFIG_BOOTARGS_COMMON \"root=/dev/ram0 rootfstype=ramfs rdinit=/linuxrc \""},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#4-build-kernel-code","text":"","title":"4 Build Kernel Code"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#41-compilation","text":"The Linux kernel source code is placed on \u201cna51090_linux_sdk/linux-kernel\u201d, typing \u201cmake linux\u201d can be used to compile Linux kernel, and the image name is Image.bin under na51090_linux_sdk. $ cd na51090_linux_sdk/ $ make linux Linux clean build: $ make linux_clean","title":"4.1 Compilation"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#42-system-configuration","text":"","title":"4.2 System configuration"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#421-menu-configuration","text":"Top Makefile is already integrated the formal Linux menuconfig, to use the following instruction can do the function selection. Please avoid using formal Linux \u201cmake menuconfig\u201d under linux-kernel directly; it will cause error because the important variables are not set correctly. $ make linux_config Choose \u201cSave\u201d after finished function selection; it can generate a new .config for the Linux compilation usage. NA51090 SDK provides two Kernel configuration file under \u201cna51090_linux_sdk/BSP/linux-kernel/arch/arm64/configs/\u201d, one is for the debug mode, and the other is for the release mode. l na51090_XXX_defconfig_debug, the debug mode will enable most of the functions for the development stage l na51090_XXX_defconfig_release, the release mode will only enable boot necessary parts. Edit Top Makefile to switch the configuration file: $ cd na51090_linux_sdk/ $ vi Makefile # kernel & modules CUSTBOARDCONFIG := $(strip $(shell echo $(NVT_PRJCFG_MODEL_CFG) | grep NVT_CFG_KERNEL_CFG | awk -F\u2019=\u2019 \u2018{print $$NF;}\u2019)) ifeq ($(EMBMEM), EMBMEM_SPI_NOR)","title":"4.2.1 Menu configuration"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#boardconfig-shell-if-z-nvt_cfg_kernel_cfg-then-echo-nvt_cfg_kernel_cfg-else-echo-sdk_codename_evb_defconfig_nor_debug-fi","text":"BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_nor_release; fi) else ifeq ($(EMBMEM), EMBMEM_EMMC)","title":"BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_nor_debug; fi)"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#boardconfig-shell-if-z-nvt_cfg_kernel_cfg-then-echo-nvt_cfg_kernel_cfg-else-echo-sdk_codename_evb_defconfig_emmc_debug-fi","text":"BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_emmc_release; fi) else","title":"BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_emmc_debug; fi)"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#boardconfig-shell-if-z-nvt_cfg_kernel_cfg-then-echo-nvt_cfg_kernel_cfg-else-echo-sdk_codename_evb_defconfig_debug-fi","text":"BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_release; fi) endif Figure 4-1 Menu configuration","title":"BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_debug; fi)"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#422-device-tree","text":"The device tree can be generated by dtc(device tree compiler) tool as below, you can find the *.dtsi in \u201cna51090_linux_sdk/configs/cfg_xxx\u201d and users can set command \u201cmake cfg\u201d at \u201cna51090_linux_sdk/\u201d. Config items detail description put at na51090_linux_sdk/configs/doc. It can be used to compile device tree, and we will output image nvt-evb.dtb under na51090_linux_sdk/output. The merge method is Union, for example: configs/cfg_gen/nvt-basic.dtsi User can modify CPU clock-frequency from 1200000000(1.2GHz) to 1000000000(1GHz), or 1100000000(1.1GHz), or 1300000000(1.3GHz), or 1350000000(1.35GHz), and compiler again. Users can use new image to boot at new CPU clock-frequency.","title":"4.2.2 Device tree"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#include-dt-bindingsgpiogpioh","text":"","title":"include &lt;dt-bindings/gpio/gpio.h&gt;"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#include-dt-bindingsinterrupt-controllerarm-gich","text":"/ { ???? model = \u201cNovatek NA51090\u201d; ???? compatible = \u201cnovatek,na51090\u201d, \u201cnvt,ca53\u201d; ???? interrupt-parent = <&gic>; ???? #address-cells = <2>; ???? #size-cells = <2>; ???? psci { ???????? compatible = \u201carm,psci-0.2\u201d; ???????? method = \u201csmc\u201d; ???? }; ???? cpus { ???????? #address-cells = <2>; ???????? #size-cells = <0>; ???????? cpu0: cpu@0 { ????????????? device_type = \u201ccpu\u201d; ????????????? compatible = \u201carm,cortex-a53\u201d, \u201carm,armv8\u201d; ????????????? reg = <0x0 0x0>; ????????????? next-level-cache = <&A53_L2>; ????????????? clock-frequency = <1200000000>; ????????????? enable-method = \u201cpsci\u201d; ???????? }; ???????? cpu1: cpu@1 { ????????????? device_type = \u201ccpu\u201d; ????????????? compatible = \u201carm,cortex-a53\u201d, \u201carm,armv8\u201d; ????????????? reg = <0x0 0x1>; ????????????? next-level-cache = <&A53_L2>; ????????????? clock-frequency = <1200000000>; ????????????? enable-method = \u201cpsci\u201d; ???????? }; ???????? cpu2: cpu@2 { ????????????? device_type = \u201ccpu\u201d; ????????????? compatible = \u201carm,cortex-a53\u201d, \u201carm,armv8\u201d; ????????????? reg = <0x0 0x2>; ????????????? next-level-cache = <&A53_L2>; ????????????? clock-frequency = <1200000000>; ????????????? enable-method = \u201cpsci\u201d; ???????? }; ???????? cpu3: cpu@3 { ????????????? device_type = \u201ccpu\u201d; ????????????? compatible = \u201carm,cortex-a53\u201d, \u201carm,armv8\u201d; ????????????? reg = <0x0 0x3>; ????????????? next-level-cache = <&A53_L2>; ????????????? clock-frequency = <1200000000>; ????????????? enable-method = \u201cpsci\u201d; ???????? }; ???????? A53_L2: l2-cache0 { ????????????? compatible = \u201ccache\u201d; ???????? }; ???? }; ????? \u2026 configs/cfg_gen/nvt-peri.dtsi","title":"include &lt;dt-bindings/interrupt-controller/arm-gic.h&gt;"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#include-dt-bindingsgpionvt-gpioh","text":"","title":"include &lt;dt-bindings/gpio/nvt-gpio.h&gt;"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#include-nvt-basicdtsi","text":"/ { ???? chosen { ???????? bootargs = \u201d \u201c; ???????? stdout-path = \u201cserial0:115200n8\u201d; ???? }; ???? aliases { ???????? serial0 = &uart0; ???????? serial1 = &uart1; ???????? serial2 = &uart2; ???????? serial3 = &uart3; ???????? serial4 = &uart4; ???????? mmc0 = &mmc0;? / Fixed to mmcblk0 for sdio1 / ???? }; ???? uart0: uart@f0280000 { ???????? compatible = \u201cns16550a\u201d; ???????? reg = <0x2 0xf0280000 0x0 0x1000>; ???????? interrupts = <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>; ???????? baud = <115200>; ???????? reg-shift = <2>; ???????? reg-io-width = <4>; ???????? no-loopback-test = <1>; ???????? clock-frequency = <24000000>; ???????? rx_trig_level = <3>; ???????? hw_flowctrl = <0>; ???? }; ???? uart1: uart@f0290000 { ???????? compatible = \u201cns16550a\u201d; ???????? reg = <0x2 0xf0290000 0x0 0x1000>; ???????? interrupts = <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>; ???????? baud = <115200>; ???????? reg-shift = <2>; ???????? reg-io-width = <4>; ???????? no-loopback-test = <1>; ???????? clock-frequency = <48000000>; ???????? rx_trig_level = <3>; ???????? hw_flowctrl = <0>; ???? }; ???? uart2: uart@f02a0000 { ???????? compatible = \u201cns16550a\u201d; ???????? reg = <0x2 0xf02a0000 0x0 0x1000>; ???????? interrupts = <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>; ???????? baud = <115200>; ???????? reg-shift = <2>; ???????? reg-io-width = <4>; ???????? no-loopback-test = <1>; ???????? clock-frequency = <48000000>; ???????? rx_trig_level = <3>; ???? }; ???? uart3: uart@f02b0000 { ???????? compatible = \u201cns16550a\u201d; ???????? reg = <0x2 0xf02b0000 0x0 0x1000>; ???????? interrupts = <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>; ???????? baud = <115200>; ???????? reg-shift = <2>; ???????? reg-io-width = <4>; ???????? no-loopback-test = <1>; ???????? clock-frequency = <48000000>; ???????? rx_trig_level = <3>; ???? }; ???? uart4: uart@f02c0000 { ???????? compatible = \u201cns16550a\u201d; ???????? reg = <0x2 0xf02c0000 0x0 0x1000>; ???????? interrupts = <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>; ???????? baud = <115200>; ???????? reg-shift = <2>; ???????? reg-io-width = <4>; ???????? no-loopback-test = <1>; ???????? clock-frequency = <48000000>; ???????? rx_trig_level = <3>; ???? };","title":"include \"nvt-basic.dtsi\""},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#423-partition-table","text":"The Nand/EMMC driver of kernel will do for the set partition initialization process as shown below, Uboot will read the partition info(nvt-storage-partition.dtsi) from dts, and then the Kernel also read it from dts to do basic initialization. If you want to change flash partition size or add a partition, please configure device tree nvt-storage-partition.dtsi and build dtb image, burn into flash or load to dram again(default address at 0x1f00000). Figure 4-2 Partition initialization SPI NAND partition example: nvt-storage-partition.dtsi for flash partition &nand { ???? partition_loader {????? label = \u201cloader\u201d;?????? reg = <0x0 0x0000000 0x0 0x40000>; }; / Fixed / ???? partition_fdt {???? ??????? label = \u201cfdt\u201d;??? ??????? reg = <0x0 0x40000?? 0x0 0x40000>; }; / Fixed / ???? partition_fdt.restore {? label = \u201cfdt.restore\u201d;?? reg = <0x0 0x80000?? 0x0 0x40000>; }; / Fixed / ???? partition_atf {???????? label = \u201catf\u201d;????????? reg = <0x0 0x0C0000? 0x0 0x40000>; }; ???? partition_uboot {?????? label = \u201cuboot\u201d;??????? reg = <0x0 0x100000? 0x0 0x1C0000>; }; ???? partition_uenv {??????? label = \u201cuenv\u201d;???????? reg = <0x0 0x2C0000? 0x0 0x40000>; }; ???? partition_kernel {????? label = \u201ckernel\u201d;?????? reg = <0x0 0x300000? 0x0 0x0500000>; }; ???? partition_rootfs {????? label = \u201crootfs\u201d;?????? reg = <0x0 0x800000? 0x0 0x5100000>; }; ???? partition_rootfs1 {???? label = \u201crootfs1\u201d;????? reg = <0x0 0x5900000 0x0 0x2700000>; }; }; If you want to change the partition size or add a partition, please configure it from the dts info. If users want to add user partition such as app1, users can add such as follow: partition_app1 {? ? label = \u201capp1\u201d;????????? reg = <0x0 start_addr 0x0 size>; };","title":"4.2.3 Partition table"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#43-debug","text":"To debug the Kernel, you will need System.map or objects for the debug symbol loading, please get them from \u201clinux-kernel/\u201d as shown below: |-- linux-kernel |?????? ??????? |-- Makefile |?????????????? |-- Module.symvers |?????????????? |-- System.map |?????????????? |-- arch |?????????????? |-- block |?????????????? |-- crypto |?????????????? |-- drivers |?????????????? |-- firmware |?????????????? |-- fs |?????????????? |-- include |?????????????? |-- init |?????????????? |-- ipc |?????????????? |-- kernel |?????????????? |-- lib |?????????????? |-- mm |?????????????? |-- modules.builtin |?????????????? |-- modules.order |?????????????? |-- net |?????????????? |-- scripts |?????????????? |-- security |?????????????? |-- sound |?????????????? |-- source |?????????????? |-- usr |?????????????? |-- vmlinux |?????????????? `-- vmlinux.o To add more debug information, we can turn on CONFIG_DEBUG_INFO option before compiling Linux kernel as below. \u201cKernel Hacking > Compile-time checks and compiler options > Compile the kernel with debug info\u201d $ cd na51090_linux_sdk/ $ make linux_config Rebuild all; this binary will contain debug symbol information. |-- linux-kernel |?????? ??????? |-- vmlinux","title":"4.3 Debug"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#5-build-kernel-modules","text":"In addition to build-in drivers, Linux had also provided an external load mode called Kernel module, can be loaded by \u201cmodprobe\u201d or \u201cinsmod\u201d. The below will introduce to build-in modules and the out-of-tree modules.","title":"5 Build Kernel Modules"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#51-build-in-module-compilation","text":"Typing \u201cmake modules\u201d under na51090_linux_sdk can do build-in modules compilation and install path is root-fs/rootfs/lib/modules/{KER_VER}/kernel/. $ cd na51090_linux_sdk/ $ make modules","title":"5.1 Build-in module compilation"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#52-out-of-tree-module-compilation","text":"This folder under \u201cna51090_linux_sdk/code\u201d provides NVT platform drivers, typing \u201cmake supplement\u201d to do the Out-of Tree modules compilation as below. And the modules will be installed on na51090_linux_sdk/BSP/root-fs/rootfs/lib/modules/{KER_VER}/extra/. $ cd na51090_linux_sdk/ $ make driver Linux Out-of-Tree driver module clean build: $ make driver_clean","title":"5.2 Out-of-Tree module compilation"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#53-hdal","text":"HDAL is the hardware abstraction layer driver and sample code, this one can be used to build proprietary driver modules, such as video process, video capture and video codec\u2026etc. We provide the following instructions to build. ??????? $ make hdal Clean build: ??????? $ make hdal_clean Please refer to the other documents for details.","title":"5.3 HDAL"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#54-installation","text":"The modules can be installed by \u201cmodprobe\u201d or \u201cinsmod/rmmod\u201d to install or uninstall, besides the modprobe will also install related modules automatically. Example: modprobe (Only needs the module name) modprobe ehci-hcd insmod/rmmod (This method needs a full path) insmod /lib/modules/{KER_VER}/extra/crypto/cryptodev-linux/cryptodev.ko","title":"5.4 Installation"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#6-build-tools","text":"This folder will integrate some Linux open source tools as the following description: htop????????????????? - Linux process monitoring, to provide more than top information gdb?????????????????? - gdb server for the application debug ethtool????????????? - Utility for controlling network drivers and hardware bonnie++???????? - A benchmark suite that is aimed at performing a number of simple tests of hard drive and file system performance memtester??????? - A userspace utility for testing the memory subsystem for faults mtd-utils?????????? - MTD device utilities procps????????????? - A tool set to provide system analysis tools (vmstat, slabtop,\u2026etc) stress??????????????? - System performance testing tool stress-ng????????? - Advanced system performance testing tool sdcard_test.sh- To do sd driver r/w testing iozone????????????? - IO r/w performance testing VDBench???????? - CPU/io performance testing","title":"6 Build tools"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#61-compilation","text":"To select the tools what you want: mtd-utils, memtester, bonnie, ethtool, gdb, htop, netperf, iperf and procps and running below instructions: e.g. $ cd na51090_linux_sdk/ $ cd tools/ $ make stress Tools clean build: $ make clean","title":"6.1 Compilation"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#62-installation","text":"$ make install The tools will be installed on \u201cna51090_linux_sdk/BSP/root-fs\u201d.","title":"6.2 Installation"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#7-build-root-fs","text":"","title":"7 Build root-fs"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#71-introduction","text":"The root file system will be mounted by Linux kernel, the first process of the kernel is /sbin/init (PID=1). We provide several root file systems support for selection, the following are the summary features: l UBIFS: readable/writable file system, support Nor and Nand flash, fast mounting speed, best bad block management and better IO performance. Suitable for low memory size and large flash size use condition. We have a detail introduction in OSDRV/NT9833x_UBI_Filesystem_User_Guide_en.doc l Squashfs: read-only file system, high compression rate. Suitable for small size flash and readonly use condition. l JFFS2: It is a log-structured file system which can support Nand and Nor flash devices. Providing zlib, lzo and rtime compression methods. Suitable for small flash size and readable/writable use condition. l RAMDISK: To provide a ram based file system.","title":"7.1 Introduction"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#72-configuration","text":"The root file system will generate Nand flash type image format, we support squashfs and ubifs, please follow the Nand flash specification to modify the parameters: $ cd na51090_linux_sdk/BSP/root-fs/ $ vi ubi_max_leb.py To find below lines: W = 1024 SP = 128 * 1024 SL = 124 * 1024 According the Nand flash to modify the parameters: l W is the entire flash chip Physical eraseblocks numbers l SP is the Size of block page l SL= (Size of block -2) * Size of page. e.g. 128MB Nand flash = 1024 eraseblocks = 1024 * 128KB W = 1024 SP = 64 * 2048 = 128 * 1024 SL = (64 \u2013 2) * 2048 = 124 * 1024 $ vi mtd_cfg.txt ??????? We can support two mtd_cfg.txt in BSP/root-fs/ and configs/cfg_gen, the build tool will search configs/cfg_gen/mtd_cfg.txt firstly, and the second is BSP/root-fs/mtd_cfg.txt. To find below lines: ROOTFS_UBI_SUB_PAGE_SIZE=2048????????? # Same as page size ROOTFS_UBI_PAGE_SIZE=2048???? ???????? # Nand page size ROOTFS_UBI_ERASE_BLK_SIZE=126976?????? # (64-2) * Page size=126976 ROOTFS_UBI_MAX_LEB_COUNT=361?????????? # Size = UBI_MAX_LEB_COUNT * UBI_BLK_SIZE; It\u2019s calculated by \u201cpython ubi_max_leb.py Bytes\u201d ROOTFS_UBI_RW_MAX_LEB_COUNT=258???????????? # Size = UBI_MAX_LEB_COUNT * UBI_BLK_SIZE; It\u2019s calculated by \u201cpython ubi_max_leb.py Bytes\u201d ROOTFS_UBI_BLK_SIZE=\u201d128KiB\u201d?????????? # UBIFS Nand flash block size (KiB) ROOTFS_UBI_COMPRESS_MODE=\u201dlzo\u201d????????????? # UBIFS compression type: \u201clzo\u201d, \u201cfavor_lzo\u201d, \u201czlib\u201d \u201cnone\u201d ROOTFS_SQ_COMPRESS_MODE=\u201dxz\u201d?????????? # Squashfs compression type: \u201cgzip\u201d, \u201clzo\u201d and \u201cxz\u201d ROOTFS_SQ_BLK_SIZE=\u201d128K\u201d????????????? # Squashfs Nand flash block size (KiB): e.g. spinand: 128K, spinor: 64K ROOTFS_JFFS2_COMPRESS_MODE=\u201dlzo\u201d?????? # jffs2 compression type: \u201clzo\u201d \u201czlib\u201d \u201crtime\u201d ROOTFS_JFFS2_SIZE=0x3200000??????????? # jffs2 partition size: get from /proc/mtd ROOTFS_JFFS2_RW_SIZE=0x2500000????????????? # jffs2 partition size: get from /proc/mtd ROOTFS_JFFS2_BLK_SIZE=\u201d128KiB\u201d????????????? # jffs2 block size (KiB): spinand: 128KiB, spinor: 64KiB ROOTFS_JFFS2_PAGE_SIZE=\u201d2048\u201d????????? # jffs2 page size (Bytes): only used by nand, nor flash can be ignored. ROOTFS_EXT4_SIZE=$(shell printf \u201c%d\\n\u201d 0x0A000000) ROOTFS_FAT_CACHE_SIZE=$(shell printf \u201c%d\\n\u201d 0x0A000000)","title":"7.2 Configuration"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#appfs","text":"ROOTFS_JFFS2_APP_SIZE=0x01E0000 ROOTFS_JFFS2_APP_NOR_SIZE=0x0E20000 ROOTFS_UBI_APP_MAX_LEB_COUNT=231 The necessary parameters need to be modified as below description: l ROOTFS_UBI_SUB_PAGE_SIZE: The sub-page size of the Nand flash l ROOTFS_UBI_PAGE_SIZE: The page size of the Nand flash l ROOTFS_UBI_ERASE_BLK_SIZE: (Nand flash block size \u2013 2) * Page size l ROOTFS_UBI_MAX_LEB_COUNT: Use ubi_max_leb.py to calculate it $ Usage: ubi_max_leb.py PartitionSize (Bytes) l ROOTFS_UBI_RW_MAX_LEB_COUNT: Use ubi_max_leb.py to calculate it $ Usage: ubi_max_leb.py PartitionSize (Bytes) l ROOTFS_UBI_BLK_SIZE: Nand flash block size l ROOTFS_UBI_COMPRESS_MODE: Compression method = LZO l ROOTFS_SQ_COMPRESS_MODE: Squashfs compression mode l ROOTFS_SQ_BLK_SIZE: Squashfs nand flsh block size l ROOTFS_JFFS2_COMPRESS_MODE: jffs2 compression type: \u201clzo\u201d \u201czlib\u201d \u201crtime\u201d l ROOTFS_JFFS2_SIZE: Rootfs partition size l ROOTFS_EXT4_SIZE: EMMC boot partition size l ROOTFS_FAT_CACHE_SIZE: EMMC boot FAT partition size (Optional) l ROOTFS_JFFS2_APP_SIZE: The size of the app partition in nand flash l ROOTFS_JFFS2_APP_NOR_SIZE: The size of the app partition in nor flash l ROOTFS_UBI_APP_MAX_LEB_COUNT: The ubi image size in app partition (Use ubi_max_leb.py to calculate it) You can modify the ubi mount parameters with your requirement, e.g. BSP/root-fs/ubi_max_leb.py def get_ubifs_max_leb(partition_size):????????? #Unit: Bytes ??????? P = partition_size/SP ??????? BR = math.ceil( 30 * W/float(1024))????? # Sync with kernel ??????? B = max(BB, BR) ??????? ubi_overhead = (( B - BB + 4 ) * SP + O * ( P - B - 4 ))/float(SP) ? ??????ubi_overhead = math.ceil(ubi_overhead) ??????? ubi_overhead = math.floor(((P - ubi_overhead) * SP) / float(SL)) ???? ? if ubi_overhead < 0: ???????? return -1 ???? ? else: ???????? return (ubi_overhead - 1) Note: linux menuconfig Maximum expected bad eraseblock count per 1024 eraseblocks value \u201c30\u201d must be the same with ubi_max_leb.py value \u201c30\u201d. This parameter will affect the bad block management, please reserve enough blocks(e.g. 10, 20) per 1024 erase blocks.","title":"APPFS"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#73-modify-flash-filesystem-partition-size","text":"Users must check mtd config definiton in configs/cfg_gen/mtd_cfg.txt, the parameters: ROOTFS_UBI_MAX_LEB_COUNT, ROOTFS_UBI_RW_MAX_LEB_COUNT and ?ROOTFS_UBI_APP_MAX_LEB_COUNT value must use ubi_max_leb.py to calculate.","title":"7.3 Modify flash filesystem partition size"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#74-compilation","text":"Using \u201cmake rootfs\u201d instruction to generate rootfs bin, the image type can be selected by nvt-info.dtsi in configs folder. They can be produced into \u201cna51090_linux_sdk/output/rootfs.ubifs.bin\u201d, \u201cna51090_linux_sdk/output/rootfs.squash.bin\u201d and \u201cna51090_linux_sdk/output/rootfs.jffs2.bin\u201d separately. The command \u201cmr\u201d also can be used to compile rootfs if you are not in na51090_linux_sdk root folder. $ cd na51090_linux_sdk/ $ source build/envsetup.sh $ make rootfs Rootfs clean build: $ make rootfs_clean This command will remove busybox tools, kernel modules\u2026etc., please follow below procedure to generate rootfs image: $ make busybox $ make app ($ make library if necessary) $ make hdal $ make rootfs","title":"7.4 Compilation"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#75-folder-description","text":"l Architecture Folder Description bin User binaries dev Device files etc System management configuration files home User home directories init -> bin/busybox It is used to kernel boot necessary init process, for the initial environment setup. lib Standard system libraries linuxrc -> bin/busybox mnt External storage device mount folder (/mnt/sd, /mnt/usb) proc RAM based FS to provide process information root Root\u2019s folder (The default shell will login here) sbin System management binaries srv Service data sys RAM based FS to provide user space and kernel space attribute/properties link. tmp RAM based temp folder usr User libraries, binaries var Service log message, including kernel, application, web server default folder(/var/www) and service\u2026etc l /etc/passwd This file can setup user account environment, below is to introduce how to enable login password. $ vi /etc/inittab ::respawn:-/bin/login Replace \u201c::respawn:-/bin/login -f root\u201d with \u201c::respawn:-/bin/login\u201d as below Fill in the red part with the encryption password which can be generated by openssl tool: $ vi /etc/passwd root:EncryptionCode:0:0:root:/root:/bin/sh Openssl generation: $ openssl passwd -crypt YourPWD l /etc/init.d System will execute the following shell scripts according sequence. rcS -> S00_PreReady -> S05_Net -> S10_SysInit -> S10_hdal_init -> S99_Sysctl Moreover, power off will execute deinitialization process as below. rcK -> K00_Sys -> K99_Sys l /etc/sysctl.conf This file is handle sysctl parameters setup.","title":"7.5 Folder description"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#76-ubifs","text":"The UBIFS is our default rootfs format, UBIFS (Unsorted Block Image File System) was originally called JFFS3, is JFFS2 next generation version. The main capabilities are faster mounting, quicker access to large files, and improved write speeds. UBIFS also preserves or improves upon JFFS2\u2019s on-the-fly compression, recoverability and power fail tolerance, and data compression allows zlib or LZO. The filename is UBI.IMG after compilation.","title":"7.6 UBIFS"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#77-squashfs","text":"Squashfs is a read-only file system which can support gzip, lzo and xz compression modes. The main features are high compression rate, stores full 32bits uid/gids and creation time, support block size up to 1Mbytes. The filename is SQ_ROOTFS.IMG after compilation.","title":"7.7 Squashfs"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#78-jffs2","text":"JFFS2 was developed by Red Hat, based on the work started in the original JFFS by Axis Communications, AB, it is a readable and writable file system. JFFS2 will scan rootfs partition during mounting; the mount time depends on the rootfs size. The main features are listed as below: l Support compression mode l Mounting time will be affected by flash size l Not support all Nand flash devices with HW ecc, please refer to Linux driver application note The filename is rootfs.jffs2.bin after compilation. For the kernel configuration to add jffs2 support, you must add below configurations: File systems -> Miscellaneous filesystems -> [*] Journalling Flash File System v2 (JFFS2) support -> [*] Advanced compression options for JFFS2 -> [*] JFFS2 LZO compression support For the uboot configuration to choose root file system type, please refer to the UBoot_Programing_Guide.","title":"7.8 Jffs2"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#79-hdal-sample-code","text":"We will pack one partition named DVR_xxx.bin is under na51090_linux_sdk/configs/Linux/cfg_xxx/nvt-nvtpack.dtsi partition_name = \u201capp\u201d field. You could modify the partition size and recalculate the related parameters to fill in the nvt -storage-partition.dtsi partition_app field. Please refer to 7.2 for mtd_cfg.txt description.","title":"7.9 HDAL sample code"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#8-build-app","text":"","title":"8 Build App"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#81-compilation","text":"NVT platform needs the necessary applications to perform the requested actions, please using below instructions to compile (This part doesn\u2019t provide source code). $ cd na51090_linux_sdk/code/application $ make install Please execute \u201csource build/envsetup.sh\u201d firstly when you start to build it. Please reference to Application Note for the other details. We have fine-tuned some functions and the fpu related setting, please add $(PLATFORM_CFLAGS) to your Makefile to get more performance. e.g. nvt02854@oaalnx13:~/na51090_linux_sdk/na51090_linux_sdk$ get_stuff_for_environment ======================================== NVT Setting ======================================== NVT_PRJCFG_CFG = Linux NVT_PRJCFG_MODEL_CFG = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/configs/Linux/cfg_TEST_FPGA_a64/ModelConfig.mk LINUX_BUILD_TOP = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk UBOOT_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/u-boot OPTEE_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/optee KERNELDIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/linux-kernel BUSYBOX_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/busybox TOYBOX_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/toybox ROOTFS_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/root-fs APP_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/application LIBRARY_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/lib INCLUDE_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/lib/include NVT_DRIVER_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/driver NVT_HDAL_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/hdal NVT_VOS_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/vos NVT_RTOS_MAIN_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/rtos-main SAMPLE_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/sample TOOLS_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/tools OUTPUT_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/output LOGS_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/logs BUILD_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/build CONFIG_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/configs PLATFORM_CFLAGS = -march=armv8-a -mtune=cortex-a53 -ftree-vectorize -fno-builtin -fno-common -Wformat=1 -D_BSP_NA51090_ PLATFORM_AFLAGS = march=armv8-a -mtune=cortex-a53 -D_BSP_NA51090_ NVT_HOST = aarch64-ca53-linux-uclibc LINUX_CPU_TYPE = cortex-a53x64 NVT_LINUX_VER = 4.19.148 NVT_MULTI_CORES_FLAG = -j80 CROSS_COMPILE = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc- CROSS_TOOLCHAIN_PATH = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4 CROSS_TOOLCHAIN_BIN_PATH = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin SYSROOT_PATH = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/aarch64-ca53-linux-uclibc/sysroot UBOOT_CROSS_COMPILE = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc- AS = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-as CC = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-gcc CXX = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-g++ LD = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-ld LDD = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-ldd AR = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-ar NM = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-nm GDB = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-gdb STRIP = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-strip OBJCOPY = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-objcopy OBJDUMP = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-objdump PATH = /opt/CEVA-ToolBox/V17/XM4/CEVA-XM4:/opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin:/opt/utility/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/snap/bin:. LD_LIBRARY_PATH = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/local/lib =============================================================================================","title":"8.1 Compilation"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#9-build-libraries","text":"","title":"9 Build Libraries"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#91-compilation","text":"na51090_linux_sdk provides some proprietary libraries and header files for the product customization (this part doesn\u2019t involve source code, we only provide you *.so), please according the following instruction to compile it. $ cd na51090_linux_sdk/ $ make library Libraries clean build: $ make library_clean Please execute \u201csource build/envsetup.sh\u201d firstly when you start to build it. Please reference to Application Note for the other details.","title":"9.1 Compilation"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#10-build-busybox","text":"","title":"10 Build busybox"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#101-compilation","text":"Busybox can provide rootfs necessary tools, using below instruction can compile it. And the tools will be installed to na51090_linux_sdk/BSP/root-fs. $ cd na51090_linux_sdk/ $ make busybox mybusybox clean build: $ make busybox_clean","title":"10.1 Compilation"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#102-menu-configuration","text":"SDK will provide two busybox configuration files, one is normal version (busybox_cfg_normal), and the other is minimized version (busybox_cfg_small). Edit Top Makefile can change the busybox configuration, the default is normal version. Edit Top Makefile to switch the configuration file: $ cd na51090_linux_sdk/ $ vi Makefile BUSYBOX_CFG:=busybox_cfg_full","title":"10.2 Menu configuration"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#busybox_cfgbusybox_cfg_small","text":"Below instruction can handle busybox features selection: $ make busybox_config Choose \u201cExit/Save\u201d after you finished function selection, it can generate new .config for the Busybox compilation usage.","title":"BUSYBOX_CFG:=busybox_cfg_small"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#11-build-sample-code","text":"","title":"11 Build sample code"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#111-compilation","text":"The device driver testing applications will be used to test NVT peripheral devices; the following instructions can compile it. And it will be installed to na51090_linux_sdk/BSP/root-fs. $ cd na51090_linux_sdk/ $ make sample Driver test clean build: ??????? $ make sample_clean","title":"11.1 Compilation"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#12-update-firmware","text":"We provide two OS version nvtpack image could be used, one is Linux version will be generate by Linux version nvtpack tool, the images will be generated under the output folder. Another is Windows vesion nvtpack tool, the following section can get more clearly description.","title":"12 Update Firmware"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#121-linux-version-nvtpack-for-all-in-one-image","text":"The nvt-nvtpack.dtsi is used to control what kinds of images want to be involved, and which files will be packed by all-in-one tool. If source_file = \u201c\u201d, it means we don\u2019t want to pack this image into all-in-one image. If id1 \u2026 source_file = \u201cnvt-evb.bin\u201d, it means nvt-evb.bin file will pack into all-in-one image partition 1, partition setting we can reference nvt-storage-partition.dtsi file. nvtpack { ???? ver = \u201cNVTPACK_FW_INI_16072017\u201d; / Fixed / ???? method = <1>; / Fixed / ???? index { ????????????? id0 { partition_name = \u201cloader\u201d;????? source_file = \u201c\u201d; }; / Fixed / ????????????? id1 { partition_name = \u201cfdt\u201d;???????? source_file = \u201cnvt-all.bin\u201d; }; / Fixed / ????????????? id2 { partition_name = \u201cfdt.restore\u201d; source_file = \u201c\u201d;???? }; / Fixed / ????????????? id3 { partition_name = \u201catf\u201d;???????? source_file = \u201catf.bin\u201d; }; ????????????? id4 { partition_name = \u201cuboot\u201d;??? ????? source_file = \u201cu-boot.bin\u201d; }; ????????????? id5 { partition_name = \u201cuenv\u201d;???? ????? source_file = \u201c\u201d; }; ????????????? id6 { partition_name = \u201ckernel\u201d;????? source_file = \u201cImage.bin\u201d; }; ????????????? id7 { partition_name = \u201crootfs\u201d;????? source_file = \u201crootfs.ramdisk.bin\u201d; }; ????????????? id8 { partition_name = \u201crootfs1\u201d;???? source_file = \u201crootfs_1.rw.ubifs.bin\u201d; }; ???? }; }; ??????? Using \u201cmake all\u201d or \u201cmake pack\u201d can generate the packed image is under output/packed/FW(SOC).bin.","title":"12.1 Linux version nvtpack for all-in-one image"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#122-update-firmware","text":"Insert SD card including All-in-One bin to the target board and power on can update firmware.","title":"12.2 Update Firmware"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#123-update-loader","text":"For a blank Nand flash, you need to burn loader (LD98336A.bin), by first SD card format (be sure to format), and then immediately put LD98336A.bin, then placed all in one bin (FW98336A.bin).","title":"12.3 Update Loader"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#13-power-on","text":"","title":"13 Power on"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#131-how-to-power-on","text":"To follow update steps to burn the desired Image, remove SD card can boot up directly.","title":"13.1 How to power on"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#14-debug","text":"The following list provides comparison and classification of the debugging tools. Name Classification Description Coredump AP debug Generated file for the further analysis when the program has terminated abnormally Messages AP/Kernel debug To record Linux kernel and AP booting log GDB AP debug To debug target board application from remote server printk Kernel debug Basic kernel/module debug usage kmemleak Kernel debug To analyze if Linux kernel has memory leak issue. OPENOCD Kernel debug To debug/ trace kernel or uboot","title":"14 Debug"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#141-coredump","text":"Provide analytical application error log, the application does not properly terminated, it generates a file in /var/log. It can record the program name, PID and time, can be loaded for analysis through a cross compiler. You should build it with debug mode when you start application analysis. The following is related setting: $ cd na51090_linux_sdk/root-fs/rootfs/ $ vi etc/profile # coredump setting echo 1 > /proc/sys/kernel/core_uses_pid ulimit -c unlimited echo \u201c/var/log/core-%e-%p-%t\u201d > /proc/sys/kernel/core_pattern","title":"14.1 Coredump"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#142-messages","text":"The boot log of the Linux will be stored in /var/log/messages, this file can involve Kernel and user space app. If the kernel crash occurred, please provide this file for the further analysis.","title":"14.2 Messages"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#143-gdb","text":"GDB (GNU Project Debugger) can support Remote and Target mode to debug AP. Target mode gdb/gdbserver can be generated by the following command: $ cd na51090_linux_sdk/tools $ make gdb The connection diagram as shown below, Figure 13-1: Figure 14-1 Target debug connection Remote mode can debug user space application through GDB server, and the connection architecture as below. Linux server is x86_64 compile server, target board is the EVB, they can be connected by serial or TCP/IP. Linux server will use cross compiler toolchain GDB to debug target board AP, this AP must be enabled debug symbol, and target board also needs to execute gdbserver which can be find in toolchain. The serial connection can connect USB-to-Serial cable to target board USB port, and check if there is /dev/ttyUSB0 existed. TCP/IP connection can use Wi-Fi or Ethernet, install necessary drivers and confirm whether it can ping to server. Figure 14-2 Remote debug connection GDB server needs to be executed on EVB. $ cp tools/__install/bin/gdbserver root-fs/rootfs/bin/ $ cp tools/__install/bin/gdb root-fs/rootfs/bin/ And then, running below procedures can debug your AP. Target Board target > gdbserver comm prog [args\u2026] The gdbserver doesn\u2019t loading debug symbol, all of the symbols will be loaded by the Linux server cross compiler gdb. It can reduce memory space in this way. Serial: target > gdbserver /dev/ttyUSB0 hello_world Net: target > gdbserver Host _IP:1234 hello_world Linux Server Serial: Server > {CROSS_COMPILE}-gdb hello_world Server > set remotebaud 115200 Server > target remote /dev/ttyUSB0 Net: Server > {CROSS_COMPILE}-gdb hello_world Server > target remote localhost:1234 Reference to below link can show you how to use command debug your AP: http://sourceware.org/gdb/current/onlinedocs/gdb/index.html In addition to command mode debug you also can use DDD, it is a framework on top of GDB debug visualization software, you can install and use by below command: $ sudo apt-get install ddd $ sudo ddd \u2013debugger aarch64-ca53-linux-uclibc-gdb","title":"14.3 GDB"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#144-printk","text":"Linux provides seven levels of Log printk available in the following table: Level Description Usage (0) KERN_EMERG system is unusable pr_emerg (1) KERN_ALERT action must be taken immediately pr_alert (2) KERN_CRIT critical conditions pr_crit (3) KERN_ERR error conditions pr_err (4) KERN_WARNING warning conditions pr_warning (5) KERN_NOTICE normal but significant condition pr_notice (6) KERN_INFO Informational pr_info (7) KERN_DEBUG debug-level messages pr_debug Above the printk level is used to decide whether or not to print the message console, the below instruction can show you the printk level, current representative of the level of the boot to be printed, default is the default level, minimum is the lowest possible print level, boot-time-default is boot stage log: root@NVTEVM:~$ cat /proc/sys/kernel/printk ??????????????????????????????????????? 7?????? 4?????? 1?????? 7 current??? default??? minimum??????? boot-time-default Kernel will compare the printed message log level, if the value is less than the current will be printed out. Therefore, to change the output level so that all messages are printed out can use this command:Kernel hui qu b?jiao yin ch? xunxi de log level, rugu? xi?oyu current de zhi jiu hui yin ch?lai. Y?nc?, yao g?ibian sh?ch? jibie rang su?y?u xunxi d?u k?y? yin ch?lai k?y? yong d?xia f?ngshi:\u60a8\u662f\u4e0d\u662f\u8981\u67e5\uff1a Linux\u9664\u4e86_Built_-in\u7684Driver\u4e4b\u5916,\u9084\u6709\u63d0\u4f9b\u5916\u90e8\u8f09\u5165\u7684\u65b9\u5f0f\u7a31\u4e4b\u70baKernel module,\u53ef\u900f\u904einsmod\u6216\u662fmodprobe\u505a\u8f09\u5165,\u5e95\u4e0b\u5206\u70babuild-in module\u8207out-of-tree module\u505a\u7de8\u8b6f\u4ecb\u7d39\u3002 root@NVTEVM:~$ echo 8 > /proc/sys/kernel/printk","title":"14.4 Printk"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#145-kmemleak","text":"Linux Kmemleak is provided for detecting a memory leak tool, it will record detect report in /sys/kernel/debug/kmemleak, to use this function as long as enable the \u201cKernel Hacking\u201d, \u201cKernel Memory Leak Detector\u201d (CONFIG_DEBUG_KMEMLEAK) in the kernel option, and configure the \u201cMaximum kmemleak early log entires\u201d with 1200. Clear current record: root@NVTEVM:~$ echo clear > /sys/kernel/debug/kmemleak Testing your driver: root@NVTEVM:~$ insert YourModule.ko Scan: root@NVTEVM:~$ echo scan > /sys/kernel/debug/kmemleak Check the resules: root@NVTEVM:~$ cat /sys/kernel/debug/kmemleak","title":"14.5 Kmemleak"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#15-faq","text":"This section will list frequently problems.","title":"15 FAQ"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#151-toolchain-cant-be-found","text":"We have two toolchains to build overall SDK, one is for itron, another is for Linux. First, please use below command to check your environment setting. $ get_stuff_for_environment","title":"15.1 Toolchain can\u2019t be found"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#152-operation-not-permitted","text":"The SDK installation path should be under your home folder, you should use the same owner to decompressing and building, otherwise you will get \u201c operation not permitted \u201d related message. Please use below command to check permission and owner. $ ls -al YOUR_FOLDER","title":"15.2  Operation not permitted"},{"location":"NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#153-linux-kernel-uimage-cant-be-generated","text":"This is because our default setting is lz4 compression format, you should follow section 1.2 to check lz4 tool is installed. Try to use lz4 command to check your compiling environment. $ lz4","title":"15.3  Linux kernel uImage can\u2019t be generated"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html","text":"VPE IQ Tuning Guide 1 Overview \u00b6 Figure 1?1 NT9833x Video Flow VPE is an independent image processing engine in YUV domain, and it performs some pre-processing process before LCD display or encoder to improve the image quality. The related modules are as follows: l Spatial Noise Reduction Module(SPNR, using MRNR method) l Tempoarl Noise Reduction Module(TMNR) l Sharpen Module(SHP) l Scaling Module(SCA) \u203b The 9833x series has removed DCE and DCTG. \u203b In the following description, the area shown in blue is the same module as the 9831x series but the parameters are different. Please pay special attention) Figure 1?2 VPE Image Processing Flow 2 System Control \u00b6 The processing sequence of Sharpen, SPNR(using MRNR method) and TMNR is changeable, and user can change the processing sequence depends on different camera charateristic to achieve the best image quality. 2.1 Parameter Description \u00b6 Parameter Range Def Description ch_fd Video graph use ch_fd to represent the connected video engine of each channel. User can fine tune parameter of each video engine by setting ch_fd. pipe_mode 0~5 0 Set module processing sequence. 0 : MRNR -> TMNR -> Sharpen 1 : MRNR-> Sharpen -> TMNR 2 : Sharpen -> MRNR -> TMNR 3 : SHP->TMNR->MRNR 4 :?TMNR->MRNR->SHP 5 : TMNR->SHP->MRNR 2.2 Setting Interface \u00b6 2.2.1 Proc \u00b6 l /proc/videograph/vpe/ch_fd \u00b6 [Description] Read or write the current camera channel, and it only needs to set once, the following SHP, MRNR, TMNR parameters will work on this channel. The following proc command will list all ch_fd of the current video engine: [Command] Write : proc command Target Parameter echo [fd ] > /proc/videograph/vpe/ch_fd Fw Internal Pointer Read : cat /proc/videograph/vpe/ch_fd l /proc/videograph/vpe/pipe_mode \u00b6 [Description] Read or write the executing sequence of SHP, MRNR and TMNR. [Command] Write : proc command Target Parameter echo [pipe_mode ] > /proc/videograph/vpe/pipe_mode src_ppo_idx???????? mrnr_ppi_idx???? mrnr_ppo_idx??? tmnr_ppi_idx????? tmnr_ppo_idx???? shp_ppi_idx???????? shp_ppo_idx??????? sca_ppi_idx Read : cat /proc/videograph/vpe/pipe_mode 3 Spatial Noise Reduction \u00b6 This is spatial noise reduction module(abbreviation is \u201cSPNR\u201d). It will divide the image into high frequency part and middle frequency part, performing noise reduction process respectively, then combine together to achieve the purpose of noise reduction and retain detail.? 3.1 Overview \u00b6 Major processing flow is as follows : Figure 3?1 The SPNR processing flow. Major processing flow : Divide the input image into high frequency image and middle frequency image. Determine and label whether the processing pixel is on the edge. Perform edge smooth process on high frequency image and middle frequency image, respectively. Perform flat region noise reduction process on middle frequency image. Use high/middle frequency image which had performed noise reduction process to reconstruct image. 3.2 Parameter Description \u00b6 (The blue text is the part of the parameter difference between this module and the 9831x series, please pay special attention) Table 3?1 SPNR Parameter List Parameter Range Def Description t_y_edge_detection [2][8] 0~1023 161,322,483,447, 419,320,195,130, 108,215,308,272, 246,185,125,100 Y threshold for determining whether the current processing pixel is on the edge. It has eight thresholds mapping to pixel brightness from dark to bright, respectively. [0][0~7] is the threshold from dark to bright for high frequency image. [1][0~7] is the threshold from dark to bright for middle frequency image. t_cb_edge_detection 0~1023 0,249 Cb threshold for determining whether the current processing pixel is on the edge. Only works in middle frequency image. t_cr_edge_detection [2] 0~1023 0,249 Cr threshold for determining whether the current processing pixel is on the edge. Only works in middle frequency image. t_y_edge_smoothing[2][8] 0~255 66,132,161,149, 140,107,80,53, 44,88,103,91, 82,62,51,41 Y threshold for determining whether it will perform smooth process. It has eight thresholds mapping to pixel brightness from dark to bright, respectively. [0][0~7] is the threshold from dark to bright for high frequency image. [1][0~7] is the threshold from dark to bright for middle frequency image. t_cb_edge_smoothing [2] 0~255 0,153 Cb threshold for determining whether it will perform smooth process. Only works in middle frequency image. t_cr_edge_smoothing [2] 0~255 0,153 Cr threshold for determining whether it will perform smooth process. Only works in middle frequency image. nr_strength_y[2] 0~15 {0, 0} The denoise strength of spatial domain on Y channel. [0] is denoise strength for high frequency image. [1] is denoise strength for middle frequency image. nr_strength_c 0~15 {0, 10} The denoise strength of spatial domain on Cb/Cr channel. Only works in middle frequency image. Advance description : l edge_smoothing?: When SPNR performs smooth process, it will calculate weighting sum of neighbor pixels along the edge direction, if the difference between the neighbor pixel and center pixel is larger than threshold, this neighbor pixel will not be used in the smooth process. The smooth process of Y/Cb/Cr are the same. 3.3 Setting Interface \u00b6 3.3.1 Proc \u00b6 l /proc/videograph/vpe/mrnr/dump_info \u00b6 [Description] Read all SPNR(using MRNR method) parameters of the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/mrnr/dump_info Output: l /proc/videograph/vpe/mrnr/mrnr_en \u00b6 [Description] Read or write the MRNR enable status of the current camera channel. [Command] Write : proc command Target Parameter echo [mrnr_en (0~1)] > /proc/videograph/vpe/mrnr/mrnr_en mrnr_en Read : cat /proc/videograph/vpe/mrnr/mrnr_en Output: l /proc/videograph/vpe/mrnr/t_xx_edge_det \u00b6 [Description] Read or write edge_detection parameters. [Command] Write : proc command Target Parameter echo [t_y_edge_det[0][0] \u2026..[0][7]] > /proc/videograph/vpe/mrnr/ t_y_edge_det_1 t_y_edge_detection[0~7] echo [t_y_edge_det[1][0] \u2026..[1][7]] > /proc/videograph/vpe/mrnr/ t_y_edge_det_2 t_y_edge_detection[8~15] echo [t_cb_edge_det] > /proc/videograph/vpe/mrnr/ t_cb_edge_det t_cb_edge_detection[0~1] echo [t_cr_edge_det] > /proc/videograph/vpe/mrnr/ t_cr_edge_det t_cr_edge_detection[0~1] Read : cat /proc/videograph/vpe/mrnr/ t_y_edge_det_1 cat /proc/videograph/vpe/mrnr/ t_y_edge_det_2 cat /proc/videograph/vpe/mrnr/ t_cb_edge_det_1 cat /proc/videograph/vpe/mrnr/ t_cr_edge_det_1 Output : l /proc/videograph/vpe/mrnr/t_xx_edge_smooth \u00b6 [Description] Read or write edge_smoothing parameters. [Command] Write : proc command Target Parameter echo [t_y_edge_smooth[0][0]] \u2026\u2026..[t_y_edge_smooth [0][7]] > /proc/videograph/vpe/mrnr/ t_y_edge_smooth_1 t_y_edge_ smoothing[0~7] echo [t_y_edge_smooth[1][0] \u2026\u2026.. [t_y_edge_smooth[1] [7]] > /proc/videograph/vpe/mrnr/t_y_edge_smooth_2 t_y_edge_ smoothing[8~16] echo [t_cb_edge_smooth] > /proc/videograph/vpe/mrnr/ t_cb_edge_smooth t_cb_edge_smoothing[0~1] echo [t_cr_edge_smooth] > /proc/videograph/vpe/mrnr/ t_cr_edge_smooth t_cr_edge_ smoothing[0~1] Read : cat /proc/videograph/vpe/mrnr/t_y_edge_smooth_1 cat /proc/videograph/vpe/mrnr/t_y_edge_smooth_2 cat /proc/videograph/vpe/mrnr/t_cb_edge_smooth cat /proc/videograph/vpe/mrnr/t_cr_edge_smooth Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [t_y_edge_smooth[0]] \u2026\u2026.. [t_y_edge_smooth [7]] > /proc/videograph/vpe/mrnr/t_y_edge_smooth_1 \u2026 =============================================================== t_y_edge_smooth1 = t_y_edge_smoothing[0][0] \u2026\u2026\u2026\u2026\u2026. [0][7] t_y_edge_smooth1 = t_y_edge_smoothing [1][0]\u2026\u2026\u2026\u2026\u2026.. [0][7] t_cb_edge_smooth = t_cb_edge_smoothing t_cr_edge_smooth = t_cr_edge_smoothing ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image012.png)** l /proc/videograph/vpe/mrnr/nr_strength \u00b6 [Description] Read or write nr_strength parameters on Y/C channel. [Command] Write : proc command Target Parameter echo [strength_y[0]] [strength_y [1]] [strength_c] > /proc/videograph/vpe/mrnr/nr_strength nr_strength_y[0~1], nr_strength_c Read : cat /proc/videograph/vpe/mrnr/ nr_strength Output : 3.3.2 Vendor API \u00b6 [Description] Get and set the 2DNR parameters corresponding to current path_id. [Command] ??????? Get \uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_DN_2D, VENDOR_VIDEO_PARAM_MRNR *p_param); ??????? Set \uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_DN_2D, VENDOR_VIDEO_PARAM_MRNR *p_param); [Definition] 4 Temporal Noise Reduction (TMNR) \u00b6 This is temporal noise reduction module(abbreviation is \u201cTMNR\u201d). The major function is to eliminate temporal noise in the image. 4.1 Overview \u00b6 The concept of TMNR algorithm is to determine whether the pixel status is static(MotionLevel=0) or motion(MotionLevel=2) by Motion Detect module. The static region perform 3DNR to reduce the temporal noise, and the motion region will not perform 3DNR to prevent from having ghost, instead, it will perform 2DNR to reduce noise. The transition region between static region and motion region will combine the result of 2DNR and 3DNR by weighting. 4.2 Parameter description \u00b6 (The blue text is the part of the parameter difference between this module and the 9831x series, please pay special attention) Table 4?1 TMNR Parameter List Parameter Range Default Description tmnr_en 0~1 1 TMNR ON/OFF luma_dn_en 0~1 1 Y channel TMNR ON/OFF chroma_dn_en 0~1 1 Cb/Cr channel TMNR ON/OFF tmnr_fcs_en 0~1 0 Temporal de-false color function ON/OFF It only works when \u201cchroma_dn_en\u201d is set to 1. Please refer to advance description. nr_str_y_3d 0~32 8 Y channel temporal NR strength nr_str_y_2d 0~32 16 Y channel spatial NR strength of motion object nr_str _c_3d 0~32 16 Cb/Cr channel temporal NR strength nr_str _c_2d 0~32 16 Cb/Cr channel spatial NR strength of motion object blur_str_y 0~2 1 Y image blurred strength 0: No blur 1: low-strength blur 2: high-strength blur \u203bIt is recommend to set enable, if the executing sequence of 3DNR is after Sharpness; otherwise, it is recommend to set disable. For DVR/NVR application, due to in most case the front-end camera had perfomed sharpen process, it is recommend to set 1. center_wzero_y_2d_en 0~1 1 Set to enable represents when performing the 2DNR, the weighting of center point is 0. It will increase NR strength, but might lose detail. Due to 2DNR only works on motion region, the detail loss is not obvious, it is recommend to fix enable. center_wzero_y_3d_en 0~1 1 Set to enable represents when performing 3DNR, the weighting of center point is 0. It is recommend to fix enable. small_vibrat_supp_y_en 0~1 0 Y channel small vibration suppresiioon ON/OFF. This function will enhance suppression on small vibration noise to make the image more stable. However, it also causes slower ghost removal. It is recommend to enable at normal luminance, and disable at dark luminance. avoid_residue_th_y 1~4 2 Upper threshold for Y channel small noise putting back. If err_compen sate = 0, bigger this value will cause smaller temporal noise. On the other hand, if err_compensate = 1, bigger this value will cause bigger temporal noise. avoid_residue_th_c 1~4 1 Upper threshold for Vb/Cr channel small noise putting back. If err_compensate = 0, bigger this value will cause smaller temporal noise. On the other hand, if err_compensate = 1, bigger this value will cause bigger temporal noise. display_motion_map_en 0~1 0 Debug mode. Show motion detection result on the image to assist to judge the correctness of motion detect parameters. Please refer to advance description. motion_map_channel 0~4 0 Select debug signal channel. 0: Y channel 1: Cb channel 2: Cr channel 3: temporal de-false color Cb channel 4: temporal de-false color Cr channel y_base[8] 0~16320 {146,147,107,110,102,104,104,104} y_base[0]-[7] are NoiseSAD mapping to pixel brightness from dark to bright. When performing 2DNR, the internal algorithm will automatically fine tune strength based on y_base. The larger the y_base, the stronger strength of 2DNR of motion object. It is recommend to increase y_base as sensor gain increases. motion_level_th_y_k1 0~32 8 Threshold (motion_level_th_y_k1*Y_NOISE) for determining transition region on Y channel. Y_NOISE please refer to advance description. motion_level_th_y_k2 0~32 8 Threshold (motion_level_th_y_k2*Y_NOISE) for determining motion region on Y channel. K2 must larger or equal to K1. y_coefa[8] 0~48 {0,0,0,0,0,0,0,0} The slope of NoiseSAD from flat region to detail region on Y channel. y_coefa[0]-[7] mapping to pixel brightness from dark to bright. y_coefb[8] 0~16320 {27,27,20,12,7,10,10,10} NoiseSAD of flat region on Y channel. y_coefb[0]-[7] mapping to pixel brightness from dark to bright. y_std[8] 0~16320 {20,70,70,70,70,50,28,18} The standard deviation of NoiseSAD on Y channel. y_std[0]-[7] mapping to pixel brightness from dark to bright. motion_level_th_c_k1 0~32 8 Threshold for determining transition region on Cb/Cr channel. motion_level_th_c_k2 0~32 8 Threshold for determining motion region on Cb/Cr channel, K2 must larger or equal to K1. cb_mean[8] 0~6375 {33,33,34,32,29,28,28,28} The NoiseSAD mean value on Cb channel. cb_mean[0]-[7] mapping to pixel brightness from dark to bright. cb_std[8] 0~6375 {10,9,10,10,9,9,9,9} The standard deviation of NoiseSAD on Cb channel. cb_std[0]-[7] mapping to pixel brightness from dark to bright. cr_mean[8] 0~6375 {23,23,25,23,20,20,21,21} The NoiseSAD mean value on Cr channel. cr_mean[0]-[7] mapping to pixel brightness from dark to bright. cr_std[8] 0~6375 {7,7,8,7,7,77,7} The standard deviation of NoiseSAD on Cr channel. cr_std[0]-[7] mapping to pixel brightness from dark to bright. lut_y_3d_1_Th[4] 0~127 {11,33,55,77} Lut of Y channel 3D_1 filter Please refer to advance description. lut_y _3d_2_Th[4] 0~127 {40,14,7,3} Lut of Y channel 3D_2 filter Please refer to advance description. lut_y_2d_Th[4] 0~127 {11,33,55,77} Lut of Y channel 2D filter Please refer to advance description. lut_c_3d_Th[4] 0~127 {37,19,11,7} Lut of Cb/Cr channel 3D filter Please refer to advance description. lut_c_2d_Th[4] 0~127 {11,33,55,77} Lut of Cb/Cr channel 2D filter Please refer to advance description. tmnr_fcs_str 0~15 4 The strength of temporal de-false color function. tmnr_fcs_th 0~255 32 Threshold for the difference between the previous frame and the current frame to determine whether it is false color. dithering_en 0~1 1 Dithering enable. This function can be used to eliminate slight power noise or flicker phenomenon. dithering_bit_y 0~3 2 Y channel random bit number. The higher the value, the stronger the ability to eliminate the power noiser and filcker phenomenon, but the picture may appear larger fine noise. dithering_bit_u 0~3 1 U channel random bit number. The higher the value, the stronger the ability to eliminate the power noiser and filcker phenomenon, but the picture may appear larger fine noise. dithering_bit_v 0~3 1 V channel random bit number. The higher the value, the stronger the ability to eliminate the power noiser and filcker phenomenon, but the picture may appear larger fine noise. err_compensate 0~1 1 YC Compression error compensation. 0: Antiflicker mode. (Larger anti-flicker effect) 1: Compensation mode. (Data Compression Error Compensation) Advance Description: l tmnr_fcs_en: Temporal de-false color ON/OFF. This function will eliminate color-flash phenomenon in high frequency region. FCS off FCS on l display_motion_map_en: \u3002 Motion region will label with red color, static region will label with black color, and transition region will label with white color. Original image Motion Map l Y_NOISE : Block SAD is the summation of pixel difference between the previous frame and current frame at the same location. If the Block SAD is larger than K2 NoiseSAD_STD(NoiseSAD_STD is the input parameter), it determines as motion region. If the Block SAD is smaller than K1 NoiseSAD_STD, it determines as static region. If the Block SAD is larger than K1*NoiseSAD_STD and smaller than K2*NoiseSAD_STD, it determines as transition region. As follows : l Cb_NOISE, Cr_NOISE: Different from Y channel, the NoiseSAD of Cb/Cr channel has no relationship with detail. Therefore, it has no slope parameter. l lut_Y_3d_1_Th: Weighting Lut for stage 1 3DNR on Y channel, the x-axis is delta difference of neighbor pixel, the y-axis is weighting. As the following figure, the larger the difference, the smaller the weighting. The smaller the difference, the larger the weighting. Then, based on each weighting to perform weighting sum. l lut_Y_3d_2_Th: Weighting Lut for Stage 2 3DNR on Y channel, the x-axis is difference of the reference point between the previous frame and current frame, the y-axis is weighting. As the following figure, those with smaller difference might be static region, and set smaller weighting, the output will close to the reference frame. On the contrast, those with larger difference might be motion region, and set larger weighting, the output will close to the current frame. l lut_Y_2d_Th: Weighting Lut of neighbor pixel for 2DNR on Y channel, the x-axis is difference, the y-axis is weighting. As the following figure, the larger the difference, the smaller the weighting. The smaller the difference, the larger the weighting. Then, based on each weighting to perform weighting sum. l lut_c_3d_Th: Suppression Level Lut for 3DNR on Cb/Cr channel, the x-axis is the difference of the reference point between the previous frame and current frame, the y-axis is the suppression level. The concept is the same with \u201c LUT_Y_3d_2_Th \u201d. l lut_c_2d_Th: Weighting Lut of neighbor pixel for 2DNR on Cb/Cr channel, the x-axis is difference, the y-axis is weighting. The concept is the same with \u201c lut_Y_2d_Th \u201d. 4.3 Setting Interface \u00b6 4.3.1 Proc \u00b6 l /proc/videograph/vpe/tmnr/dump_info \u00b6 [Description] Read all parameters of the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/tmnr/dump_info Output : l /proc/videograph/vpe/tmnr/ch_en_status \u00b6 [Description] Read or write the enable status of the current channel. [Command] Write : proc command Target Parameter echo [luma_en] [chroma_en] [fcs_en] > /proc/videograph/vpe/tmnr/ch_en_status luma_dn_en chroma_dn_en tmnr_fcs_en Read : cat /proc/videograph/vpe/tmnr/ch_en_status Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [luma_en] [chroma_en] [fcs_en] > /proc/videograph/vpe/tmnr/ch_en_status =============================================================== luma_en = luma_dn_en chroma_en = chroma_dn_en fcs_en = tmnr_fcs_en ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image027.png)** l /proc/videograph/vpe/tmnr/nr_strength \u00b6 [Description] Read or write the TMNR strength of the current channel. [Command] Write : proc command Target Parameter echo [y_3d_str] [y_2d_str] [c_3d_str] [c_2d_str] > /proc/videograph/vpe/tmnr/nr_strength nr_str_y_3d, nr_str_y_2d nr_str_c_3d, nr_str_c_2d Read : cat /proc/videograph/vpe/tmnr/nr_strength Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [y_3d_str] [y_2d_str] [c_3d_str] [c_2d_str] > /proc/videograph/vpe/tmnr//proc/videograph/vpe/tmnr/nr_strength =============================================================== nr_str_y_3d = nr_str_y_3d nr_str_y_2d = nr_str_y_2d nr_str_c_3d = nr_str_c_3d nr_str_c_2d = nr_str_c_2d ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image028.png)** l /proc/videograph/vpe/tmnr/y_base \u00b6 [Description] Read or write the base noise level of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_base0] [y_base1]\u2026\u2026\u2026[y_base7] > /proc/videograph/vpe/tmnr/y_base y_base[0]~[7] Read : cat /proc/videograph/vpe/tmnr/y_base Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [y_base0] [y_base1]\u2026\u2026\u2026[y_base7] > /proc/videograph/vpe/tmnr/y_base =============================================================== TMNR Noise Y_base = y_base[0]\u2026\u2026\u2026\u2026y_base[7] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image029.png)** l /proc/videograph/vpe/tmnr/motion_level_th \u00b6 [Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_k1] [y_k2] [c_k1] [c_k2] > /proc/videograph/vpe/tmnr/motion_level_th motion_level_th_y_k1 motion_level_th_y_k2 motion_level_th_c_k1 motion_level_th_c_k2 Read : cat /proc/videograph/vpe/tmnr/motion_level_th Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [y_k1] [y_k2] [c_k1] [c_k2] > /proc/videograph/vpe/tmnr/motion_level_th =============================================================== TMNR motion level th = motion_level_th_y_k1, motion_level_th_y_k2, motion_level_th_c_k1, motion_level_th_c_k2, ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image030.png)** l /proc/videograph/vpe/tmnr/y_coeffa \u00b6 [Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_coeffa0] [y_coeffa1]\u2026\u2026\u2026[y_coeffa7] > /proc/videograph/vpe/tmnr/y_coeffa y_coeffa[0]~[7] Read : cat /proc/videograph/vpe/tmnr/y_coeffa Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [y_coeffa0] [y_coeffa1]\u2026\u2026\u2026[y_coeffa7] > /proc/videograph/vpe/tmnr/y_coeffa =============================================================== TMNR Noise model y_coeffa = y_coeffa[0]\u2026\u2026\u2026\u2026y_coeffa[7] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image031.png)** l /proc/videograph/vpe/tmnr/y_coeffb \u00b6 [Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_coeffb0] [y_coeffb1]\u2026\u2026\u2026[y_coeffb7] > /proc/videograph/vpe/tmnr/y_coeffb y_coeffb[0]~[7] Read : cat /proc/videograph/vpe/tmnr/y_coeffb Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [y_coeffb0] [y_coeffb1]\u2026\u2026\u2026[y_coeffb7] > /proc/videograph/vpe/tmnr/y_coeffb =============================================================== TMNR Noise model y_coeffb = y_coeffb[0]\u2026\u2026\u2026\u2026y_coeffb[7] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image032.png)** l /proc/videograph/vpe/tmnr/y_std \u00b6 [Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_std0] [y_std1]\u2026\u2026\u2026[y_std7] > /proc/videograph/vpe/tmnr/y_std y_std[0]~[7] Read : cat /proc/videograph/vpe/tmnr/y_std Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [y_std0] [y_std1]\u2026\u2026\u2026[y_std7] > /proc/videograph/vpe/tmnr/y_std =============================================================== TMNR Noise model y_std = y_std[0]\u2026\u2026\u2026\u2026y_std[7] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image033.png)** l /proc/videograph/vpe/tmnr/cb_mean \u00b6 [Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [cb_mean0] [cb_mean1]\u2026\u2026\u2026[cb_mean 7] > /proc/videograph/vpe/tmnr/cb_mean cb_mean[0]~[7] Read : cat /proc/videograph/vpe/tmnr/cb_mean Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [cb_mean0] [cb_mean1]\u2026\u2026\u2026[cb_mean 7] > /proc/videograph/vpe/tmnr/cb_mean =============================================================== TMNR Noise model cb_mean = cb_mean[0]\u2026\u2026\u2026\u2026cb_mean[7] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image034.png)** l /proc/videograph/vpe/tmnr/cb_std \u00b6 [Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [cb_std0] [cb_std1]\u2026\u2026\u2026[cb_std7] > /proc/videograph/vpe/tmnr/cb_std cb_std[0]~[7] Read : cat /proc/videograph/vpe/tmnr/cb_std Output : l /proc/videograph/vpe/tmnr/cr_mean \u00b6 [Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [cr_mean0] [cr_mean1]\u2026\u2026\u2026[cr_std7] > /proc/videograph/vpe/tmnr/cr_mean cr_std[0]~[7] Read : cat /proc/videograph/vpe/tmnr/cr_mean Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [cr_mean0] [cr_mean1]\u2026\u2026\u2026[cr_std7] > /proc/videograph/vpe/tmnr/cr_mean =============================================================== TMNR Noise model cr_mean = cr_mean[0]\u2026\u2026\u2026\u2026cr_mean[7] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image036.png)** l /proc/videograph/vpe/tmnr/cr_std \u00b6 [Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [cr_std0] [cr_std1]\u2026\u2026\u2026[cr_std7] ] > /proc/videograph/vpe/tmnr/cr_std cr_std[0]~[7] Read : cat /proc/videograph/vpe/tmnr/cr_std Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [cr_std0] [cr_std1]\u2026\u2026\u2026[cr_std7] > /proc/videograph/vpe/tmnr/cr_std =============================================================== TMNR Noise model cr_std = cr_std[0]\u2026\u2026\u2026\u2026cr_std[7] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image037.png)** l /proc/videograph/vpe/tmnr/lut_y_3d_1_th \u00b6 [Description] Read or write the 3D noise reduction parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_y_3d_1_th lut_y_3d_1_th[0]~[3] Read : cat /proc/videograph/vpe/tmnr/lut_y_3d_1_th Output : l /proc/videograph/vpe/tmnr/lut_y_3d_2_th \u00b6 [Description] Read or write the 3D noise reduction parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_y_3d_2_th lut_y_3d_2_th[0]~[3] Read : cat /proc/videograph/vpe/tmnr/lut_y_3d_2_th Output : l /proc/videograph/vpe/tmnr/lut_y_2d_th \u00b6 [Description] Read or write the 2D noise reduction parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_y_2d_th lut_y_2d_th[0]~[3] Read : cat /proc/videograph/vpe/tmnr/lut_y_2d_th Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_y_2d_th =============================================================== TMNR lut_y_2d_th = lut_y_2d_th[0]\u2026th[3] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image040.png)** l /proc/videograph/vpe/tmnr/lut_c_3d_th \u00b6 [Description] Read or write the 3D noise reduction parameters of 3DNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_c_3d_th lut_c_3d_th[0]~[3] Read : cat /proc/videograph/vpe/tmnr/lut_c_3d_th Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_c_3d_th =============================================================== TMNR lut_c_3d_th = lut_c_3d_th[0]\u2026th[3] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image041.png)** l /proc/videograph/vpe/tmnr/lut_c_2d_th \u00b6 [Description] Read or write the 2D noise reduction parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_c_2d_th lut_c_2d_th[0]~[3] Read : cat /proc/videograph/vpe/tmnr/lut_c_2d_th Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_c_2d_th =============================================================== TMNR lut_c_3d_th = lut_c_2d_th[0]\u2026th[3] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image042.png)** l /proc/videograph/vpe/tmnr/fcs_str \u00b6 [Description] Read or write the false color suppression strength of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [fcs_str (0~15) ] > /proc/videograph/vpe/tmnr/fcs_str tmnr_fcs_str Read : cat /proc/videograph/vpe/tmnr/fcs_str Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [fcs_str (0~15) ] > /proc/videograph/vpe/tmnr/fcs_str =============================================================== TMNR FCS strength = tmnr_fcs_str ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image043.png)** l /proc/videograph/vpe/tmnr/fcs_th \u00b6 [Description] Read or write the threshold for determining whether it is false color of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [fcs_th (0~255) ] > /proc/videograph/vpe/tmnr/fcs_th tmnr_fcs_th Read : cat /proc/videograph/vpe/tmnr/fcs_th Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [fcs_th (0~255) ] > /proc/videograph/vpe/tmnr/fcs_th =============================================================== TMNR FCS th = tmnr_fcs_th ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image044.png)** l /proc/videograph/vpe/tmnr/motion_map \u00b6 [Description] Read or write the motion map of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [map_en (0~1)] > [map_idx] > /proc/videograph/vpe/tmnr/motion_map map_en: 0: display_motion_map_en = 0 1: display_motion_map_en = 1 map_idx : ?0: motion_map_channel=Y ?1: motion_map_channel=Cb 2: motion_map_channel=Cr 3: motion_map_channel=FCS_Cb 4: motion_map_channel=FCS_Cr display_motion_map_en, motion_map_channel Read : cat /proc/videograph/vpe/tmnr/motion_map Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [map_en (0~1)] [map_idx (0~4)] > /proc/videograph/vpe/tmnr/motion_map =============================================================== TMNR motion_map : map_en = display_motion_map_en map_channel = motion_map_channel ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image045.png)** l /proc/videograph/vpe/tmnr/diff_blur_str \u00b6 [Description] Read or write the Diff. image blur strength of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [str (0~2)] > /proc/videograph/vpe/tmnr/diff_blur_str str: blur strength 0 ~2 blur_str_y Read : cat /proc/videograph/vpe/tmnr/diff_blur_str Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [str (0~2)] > /proc/videograph/vpe/tmnr/diff_blur_str =============================================================== diff_blur_str = blur_str_y ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image046.png)** l /proc/videograph/vpe/tmnr/avoid_residue_th \u00b6 [Description] Read or write the Diff. image blur strength of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [avoid_residue_th_y (1~4)] [avoid_residue_th_c (1~4)] > /proc/videograph/vpe/tmnr/avoid_residue_th avoid_residue_th_y, avoid_residue_th_c Read : cat /proc/videograph/vpe/tmnr/avoid_residue_th Output : l /proc/videograph/vpe/tmnr/dithering \u00b6 [Description] Read or write the dithering relative parameters of the current channel. [Command] Write : proc command Target Parameter echo [dithering_en (0~1)] [dithering_bit_y (0~7)] [dithering_bit_u (0~7)] [dithering_bit_v (0~7)] > /proc/videograph/vpe/tmnr/dithering dithering_en dithering_bit_y dithering_bit_u dithering_bit_v Read : cat /proc/videograph/vpe/tmnr/ dithering Output : l /proc/videograph/vpe/tmnr/err_compensate \u00b6 [Description] Read or write the err_compensate parameter of the current channel. [Command] Write : proc command Target Parameter echo [err_compensate (0~1)] > /proc/videograph/vpe/tmnr/err_compensate err_compensate Read : cat /proc/videograph/vpe/tmnr/err_compensate Output : 4.3.2 Vendor API \u00b6 [Description] Get and set the TMNR parameters corresponding to current path_id. [Command] ??????? Get \uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_TMNR_CTRL, VENDOR_VIDEO_PARAM_TMNR_EXT *p_param); ??????? Set \uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_DN_2D, VENDOR_VIDEO_PARAM_TMNR_EXT *p_param); [Definition] 5 Sharpen (SHP) \u00b6 This is texture enhancement module. 5.1 Overview \u00b6 This algorithm adopts inverse gamma information and after gamma information to perform texture enhancement, respectively, to improve the enhancement strength not smooth problem of the bright/dark region. Besides, it adopts 3x3 and 5x5 filter to enhance thin edge and thick edge, repectively, to take care of the detail and contrast of image. Calculating \u201cEdge Weight\u201d to determine this is detail region or flat region(thinner edge) and automatically adjusting weighting of detail enhancement result and flat region enhancement result to take care of texture enhancement and avoid noise enhancement. The \u201cHalo clip\u201d is used to control the overshootong phenomenon caused by edge enhancement. The major flow please refer to the following figure: Parameter Description Table 5?1 SHP Parameter List Parameter Range Def Description sharpen_en 0~1 0 Edge enhance ON/OFF edge_weight_src_sel 0~1 0 Select the image source to calculate \u201cEdge Weight \u201d. 0: after gamma, 1: inverse gamma. Please refer to description. edge_weight_th 0~255 2 Threshold for calculating \u201cEdge Weight\u201d, those smaller than threshold will be considered as flat region, and the output all adopt flat region enhancement result. edge_weight_gain 0~255 175 Adjust the weighting of detail enhancement result and flat region(thin edge) enhancement result. Based on the setting of \u201cnoise_level+noise_curve\u201d to adjust EdgeWeight for different pixel brightness. The larger the Edge Weight, the larger weighting of detail enhancement result, repersenting the edge enhance is more stronger(more noise). In the contrast, the smaller the edge weight, the larger weighting of flat region enhancement result, representing the edge enhancement is less stronger. noise_level 0~255 25 Please refer to advance description. noise_curve[17] 0~255 {50, 50, 50, 48, 47, 44, 39, 38, 37, 36, 35, 35, 35, 35, 35, 35, 35} Please refer to advance description. blend_inv_gamma 0~128 64 The blending weight of inverse gamma edge enhancement result and after gamma edge enhancement result. This parameter is equal to adjust the ratio of edge enhancement between bright region and dark region, let the edge enhancement level of bright region and dark region is more even. The larger the value, the stronger strength of bright region enhancement, but the weaker strength of dark region enhancement. edge_sharp_str1 0~255 25 Adjust the strength of thin edge enhancement edge_sharp_str2 0~255 10 Adjust the strength of thick edge enhancement flat_sharp_str 0~255 0 Adjust the strength of flat region(thin detail) enhancement. coring_th 0~255 0 Threshold for determing whether to perform enhancement. For those edge value smaller than threshold, they will not perform edge enhancement to avoid enhancing noise. bright_halo_clip 0~128 32 Remove bright halo edge caused by edge enhancement. The smaller the \u201cbright_halo_clip\u201d, the less bright halo edge, but the sharpness might be decreased. dark_halo_clip 0~128 96 Remove dark halo edge caused by edge enhancement. The smaller the \u201cdark_halo_clip\u201d, the less dark halo edge, but the sharpness might be decreased. Advance description l noise_level, noise_curve[17]: noise_level = noise_level + NoiseofPixel, wherein the NoiseofPixel is the y-axis of noise_curve. The noise_curve may depend on the pixel brightness to set the noise size, respectively. Normally, human eyes are less sensitive to the noise in high bright region; thus, it can set small value to increase the edge enhancement strength to enhance detail. It is recommend to use the following default value. If user want to adjust the noise size at all Y range(0-255), it just needs to adjust noise_level. Noise ? Default value: edge_weight_src_sel =0 noise_curve[17] ={50,50,50,48,47,44,39,38,37,36,35,35,35,35,35,35,35} e More strengthen on detail in bright region to avoid enhancing noise. edge_weight_src_sel =1 noise_curve[17] = {0, 38, 46, 51, 54, 57, 59, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62} e More strengthen on detail in dark region to enhance thin detail, but the noise in dark region will be enhanced, either. 5.2 Setting Interface \u00b6 5.2.1 Proc \u00b6 l /proc/videograph/vpe/sharpen/dump_info \u00b6 [Description] Read all Sharpen parameters of the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/sharpen/dump_info l /proc/videograph/vpe/sharpen/sharp_en \u00b6 [Description] Read or write the enable status of the cuurent channel. [Command] Write : proc command Target Parameter echo [ sharp_en (0~1) ] > /proc/videograph/vpe/sharpen/sharp_en sharpen_en Read : cat /proc/videograph/vpe/sharpen/shp_en Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [ sharp_en (0~1) ] > /proc/videograph/vpe/sharpen/sharp_en =============================================================== sharpen_en = sharpen_en ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)** l /proc/videograph/vpe/sharpen/edge_weight_src_sel \u00b6 [Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [src_sel (0 ~ 1) ] > /proc/videograph/vpe/sharpen/edge_weight_src_sel edge_weight_src_sel Read : cat /proc/videograph/vpe/sharpen/edge_weight_src_sel Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [src_sel (0 ~ 1)] > /proc/videograph/vpe/sharpen/edge_weight_src_sel =============================================================== edge_weight_src_sel = edge_weight_src_sel 0: after gamma 1: before gamma ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)** l /proc/videograph/vpe/sharpen/edge_weigt_gain \u00b6 [Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [gain (0~255) ] > /proc/videograph/vpe/sharpen/edge_weight_gain edge_weight_gain Read : cat /proc/videograph/vpe/sharpen/edge_weight_gain Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [gain (0~255)] > /proc/videograph/vpe/sharpen/edge_weight_gain =============================================================== edge_weight_gain = edge_weight_gain ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)** l /proc/videograph/vpe/sharpen/edge_weight_th \u00b6 [Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [th (0~255) ] > /proc/videograph/vpe/sharpen/edge_weight_th edge_weight_th Read : cat /proc/videograph/vpe/sharpen/edge_weight_th Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [th (0~255)] > /proc/videograph/vpe/sharpen/edge_weight_th =============================================================== edge_weight_th = edge_weight_th ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)** l /proc/videograph/vpe/sharpen/blend_inv_gamma \u00b6 [Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [th (0~128) ] > /proc/videograph/vpe/sharpen/blend_inv_gamma blend_inv_gamma Read : cat /proc/videograph/vpe/sharpen/blend_inv_gamma Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [th (0~128) > /proc/videograph/vpe/sharpen/blend_inv_gamma =============================================================== blend_inv_gamma = blend_inv_gamma ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)** l /proc/videograph/vpe/sharpen/edge_sharp_str \u00b6 [Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [str1 (0~255)] [str2 (0~255)] > /proc/videograph/vpe/sharpen/edge_sharp_str edge_sharp_str1 edge_sharp_str2 Read : cat /proc/videograph/vpe/sharpen/edge_sharp_str Output : l /proc/videograph/vpe/sharpen/flat_sharp_str \u00b6 [Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [str (0~255)] > /proc/videograph/vpe/sharpen/flat_sharp_str flat_sharp_str Read : cat /proc/videograph/vpe/sharpen/flat_sharp_str Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [str (0~255)] > /proc/videograph/vpe/sharpen/flat_sharp_str =============================================================== flat_sharp_str = flat_sharp_str ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)** l /proc/videograph/vpe/sharpen/coring_th \u00b6 [Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [coring_th (0~255)] > /proc/videograph/vpe/sharpen/coring_th coring_th Read : cat /proc/videograph/vpe/sharpen/coring_th Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [coring_th (0~255)] > /proc/videograph/vpe/sharpen/coring_th =============================================================== coring_th = coring_th ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)** l /proc/videograph/vpe/sharpen/halo_clip \u00b6 [Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [bright_clip (0~128)] [dark_clip(0~128)] > /proc/videograph/vpe/sharpen/halo_clip bright_halo_clip drak_halo_clip Read : cat /proc/videograph/vpe/sharpen/halo_clip Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [bright_clip (0~128)] [dark_clip(0~128)] > /proc/videograph/vpe/sharpen/halo_clip =============================================================== Bright_halo_clip = bright_halo_clip Dark_halo_clip = dark_halo_clip ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)** l /proc/videograph/vpe/sharpen/noise_curve \u00b6 [Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [noise_curve[0] (0~255)]\u2026. [noise_curve [16] (0~255)] > /proc/videograph/vpe/sharpen/noise_curve noise_curve[17] Read : cat /proc/videograph/vpe/sharpen/noise_curve Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [noise_curve[0] (0~255)]\u2026. [noise_curve [16] (0~255)] > /proc/videograph/vpe/sharpen/noise_curve =============================================================== noise_curve = noise_curve[0] \u2026\u2026\u2026.noise_curve[16] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)** 5.2.2 Vendor API \u00b6 [Description] Get and set the sharpen parameters corresponding to current path_id. [Command] ??????? Get \uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_SHARP, VENDOR_VIDEO_PARAM_SHARP *p_param); ??????? Set \uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_SHARP, VENDOR_VIDEO_PARAM_SHARP *p_param); [ \u5b9a\u7fa9 ] 6 Edge Smoothing (ES) \u00b6 This module is edge smoothing. The main function is to eliminate aliasing in the picture to improve the smoothness of the picture. 6.1 Overview \u00b6 The characteristics of this algorithm are to effectively smooth the edges of the input image, correct the jaggedness in the edge area of the input image, and avoid the Sharpen module to enhance the degree of jaggedness in the image edge again. The algorithm divides the input image into edge area and detail area, calculates the direction of the edge on the edge area, and then performs LPF convolution adaptively along the edge direction to smooth the edge of the image. The Edge Mask can be adjusted to avoid high-frequency areas being blurred due to smoothing. Please refer to the following figure for the main process: 6.2 Parameter Description \u00b6 Table 6?1 ES Parameter List Parameter Range Def Description edge_smooth_en 0~1 0 Edge smooth enable edge_smooth_y_edeng_th_lo 0~255 10 Adjust the strength threshold of detail areas in the picture Please refer to the advanced instructions edge_smooth_y_edeng_th_hi 0~255 70 Adjust the strength threshold of the edge area in the picture Please refer to the advanced instructions edge_smooth_y_ew_lo 0~255 2 Adjust the smoothing strength weight of detail areas in the picture Please refer to the advanced instructions edge_smooth_y_ew_hi 0~255 32 Adjust the suppression threshold for the smoothing of high-frequency areas in the picture. The larger the value, the easier it is to determine and smooth the high-frequency area. Therefore, the larger the value, the smoother the high-frequency area, and the smaller the value, the clearer the high-frequency area edge_smooth_y_edi_th 0~63 31 Suppresses the strength of smoothing in the high-frequency region. The larger the value, the stronger the smoothing in the high-frequency region. edge_smooth_y_ds_str 0~7 5 Adjust the strength of the smoothing filter in the picture. The larger the value, the stronger the smoothing degree. Advance description: l edge_smooth_y_edeng_th_lo , edge_smooth_y_edeng_th_hi, edge_smooth_y_ew_lo, edge_smooth_y_ew_hi : The strength of edge smooth is controlled by the edge energy intensity of the input image, where edge_smooth_y_edeng_th_hi and edge_smooth_y_edeng_th_lo are the ranges that set the edge area and the detail area, and edge_smooth_y_ew_hi and edge_smooth_y_ew_lo set the smoothness strength of the edge area and detail area. The larger the number, the stronger of the smoothness. The relationship between the edge area and the detail area is a continuous linear change, and the corresponding relationship is shown in the following figure: 6.3 Setting Interface \u00b6 6.3.1 Proc \u00b6 l /proc/videograph/vpe/es/param \u00b6 [Description] Read all edge smoothing parameters of the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/es/param l /proc/videograph/vpe/es/edge_smooth_en \u00b6 [Description] Set the edge smooth switch of the current camera channel. [Command] Write : proc command Target Parameter echo [edge_smooth_en (0~1)] > /proc/videograph/vpe/es/edge_smooth_en edge_smooth_en l /proc/videograph/vpe/es/edge_smooth_out_sel \u00b6 [Description] Set the edge smooth debugging switch of the current camera channel. [Command] Write : proc command Target Parameter echo [edge_smooth_out_sel (0~1)] > /proc/videograph/vpe/es/edge_smooth_out_sel edge_smooth_out_sel Read : cat /proc/videograph/vpe/es/edge_smooth_out_sel Output : l /proc/videograph/vpe/es/edge_smooth_th \u00b6 [Description] Set the edge smooth related threshold of the current camera channel. [Command] Write : proc command Target Parameter echo [y_edeng_th_lo (0~255)] [y_edeng_th_hi (0~255)] [y_ew_lo (0~255)] [y_ew_hi (0~255)] > /proc/videograph/vpe/es/edge_smooth_th edge_smooth_y_edeng_th_l edge_smooth_y_edeng_th_hi edge_smooth_y_ew_lo edge_smooth_y_ew_hi Read : cat /proc/videograph/vpe/es/edge_smooth_th Output : l /proc/videograph/vpe/es/edge_smooth_y_edi_th \u00b6 [Description] Set the edge smooth mask related parameters of the current camera channel. [Command] Write : proc command Target Parameter echo [edge_smooth_y_edi_th (0~63)] > /proc/videograph/vpe/es/edge_smooth_y_edi_th edge_smooth_y_edi_th Read : cat /proc/videograph/vpe/es/edge_smooth_y_edi_th Output : l /proc/videograph/vpe/es/edge_smooth_y_ds_str \u00b6 [Description] Sets the filter strength of the edge smooth of the current camera channel. [Command] Write : proc command Target Parameter echo [edge_smooth_y_ds_str (0~7)] > /proc/videograph/vpe/es/edge_smooth_y_ds_str edge_smooth_y_ds_str Read : cat /proc/videograph/vpe/es/edge_smooth_y_ds_str Output : 6.3.2 Vendor API \u00b6 [Description] Get and set the edge smooth parameters corresponding to current path_id. [Command] Get \uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_EDGE_SMOOTH, VENDOR_VIDEO_PARAM_SHARP *p_param); ??????? Set \uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_EDGE_SMOOTH, VENDOR_VIDEO_PARAM_SHARP *p_param); [Definition] 7 Scaling (SCA) \u00b6 Inupt/Output low pass filter process with different resolution. The recommend maximum scaling down ratio is 8, and the recommend maximum scaling up ratio is 8. 7.1 Overview \u00b6 This is image scaling module, the major concept is interpolation and smooth process. 7.2 Parameter Description \u00b6 Table 7?1 SCA Parameter List Parameter Range Def Description sca_y_luma_algo_en 0~3 0 Algorithm select for vertical luma scaler. 0: judge by HW algorithm 1: select the nearest point on the left side 2: select the left side point and perform low pass filter process 3: the same as option 0 It is recommend to set 0. sca_x_luma_algo_en 0~3 0 Algorithm select for horizontal luma scaler. 0: judge by HW algorithm 1: select the nearest point on the left side 2: select the left side point and perform low pass filter process 3: the same as option 0 It is recommend to set 0. sca_y_chroma_algo_en 0~3 0 Algorithm select for vertical chroma scaler. 0: judge by HW algorithm 1: select the nearest point on the left side 2: bilinear interpolation 3: average It is recommend to set 0. sca_x_chroma_algo_en 0~3 0 Algorithm select for horizontal chroma scaler. 0: judge by HW algorithm 1: select the nearest point on the left side 2: bilinear interpolation 3: average It is recommend to set 0. sca_map_sel 0~1 0 Select scaler source mapping format. 0: without 0.5 pixel distance shift(start from the 0th pixel of image image) 1: with 0.5 pixel distance shift(start from the 0.5th pixel of image image) If set to 1, when the size of input image and output image is the same or the size is multiple of 2, the scaling performance of output image will similar to perform low pass filter. It is recommend to set 0. sca_ceffH_0~3 -128~127 [0, 0, 0, 64] LPF coefficient in horizontal direction. Please refer to advance description. \u203bThe software limit range is between -128~127, to reduce memory usage. sca_ceffv_0~3 -128~127 [0, 0, 0, 64] LPF coefficient in vertical direction. Please refer to advance description. \u203bThe software limit range is between -128~127, to reduce memory usage. des_drt 0, 2,3 0 YUV domain transform 0: bypass 2: PC level to TV level (Y: 16~235 / C:16~240) 3: TV level to PC level? (Y: 0~235 C:0~255) 255: decide by job parameter of AP rather than driver (default value is 255, other settings are used for debug) Advance description: l sca_ceffH_0~3, sca_ceffV_0~3: LPF coefficients in horizontal direction and vertical direction. User can adjust LPF coefficients to fine tune sawtooth phenomenon in oblique line caused by scaling. ?Table 7?2 Scaler Low pass filter default parameter list Scaling Ratio (R) HCoef0 HCoef1 HCoef2 HCoef3 VCoef0 VCoef1 VCoef2 VCoef3 \u2267 1x 0 0 0 64 0 0 0 64 1 < R \u2266 1.25x 0 0 3 58 0 0 3 58 1.25 < R \u2266 1.5x 0 0 7 50 0 0 7 50 1.5 < R \u2266 1.75x 0 0 11 42 0 0 11 42 1.75 < R \u2266 2x 0 1 13 36 0 1 13 36 2 < R \u2266 2.25x 0 1 15 32 0 1 15 32 2.25 < R \u2266 2.5x 0 2 15 30 0 2 15 30 2.5 < R \u2266 2.75x 0 3 15 28 0 3 15 28 2.75 < R \u2266 3x 0 4 15 26 0 4 15 26 3 < R \u2266 3.25x 1 4 15 24 1 4 15 24 3.25 < R \u2266 3.5x 1 5 15 22 1 5 15 22 3.5 < R \u2266 3.75x 2 7 14 18 2 7 14 18 3.75 < R \u2266 4x 3 8 13 16 3 8 13 16 4 < R \u2266 5x 4 8 13 14 4 8 13 14 5 < R \u2266 6x 4 9 12 14 4 9 12 14 6x < R \u2266 7x 6 9 11 12 6 9 11 12 7x < R 6 9 11 12 6 9 11 12 7.3 Setting Interface \u00b6 7.3.1 Proc \u00b6 l /proc/videograph/vpe/sca/param \u00b6 [Description] Read all SCA parameters of the cuurent scaling ratio [Command] Write : Not support. Read : cat /proc/videograph/vpe/sca/param **![\u6587\u5b57\u65b9\u584a: fd(0x00000000) sca_y_luma_algo_en = 0 sca_x_luma_algo_en = 0 sca_y_chroma_algo_en = 0 sca_x_chroma_algo_en = 0 sca_map_sel = 0 sca_1x_param = { 0, 0, 0, 64, 0, 0, 0, 64 } sca_1.25x_param = { 0, 0, 0, 64, 0, 0, 0, 64 } \u2026 ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image057.png)** l /proc/videograph/vpe/sca/ctrl_param \u00b6 [Description] Set SCA controlling parameter for specific ratio. [Command] Write : proc command Target Parameter echo [sca_luma_algo (0~3)] [sca_chroma_algo (0~3)] [sca_map_sel (0~1)] > /proc/videograph/vpe/sca/ctrl_param index: Target ratio The command \u201csca_luma_algo\u201d set parameters \u201csca_y_luma_algo_en\u201d and \u201csca_x_luma_algo_en\u201d at the same time. The command \u201csca_chroma_algo\u201d set parameters \u201csca_y_chroma_algo_en\u201d and \u201csca_x_chroma_algo_en\u201d at the same time. The command \u201csca_map_sel\u201d set \u201csca_map_sel\u201d parameter. Read : Not support l /proc/videograph/vpe/sca/lpf_param \u00b6 [Description] Set SCA low pass filter parameter for specific ratio. [Command] Write : proc command Target Parameter echo [index (0~16)] [coeffH[0]] [coeffH[1]] [coeffH[2]] ]coeffH[3]] [coeffV[0]] [coeffV[1]] [coeffV[2]] [coeffV[3]] (-128 ~ 127) >? /proc/videograph/vpe/sca/lpf_param index: Target ratio coeffH : sca_ceffH[4] coeffV: sca_ceffV[4] \u203bThe software limit range is between -128~127, to reduce memory usage. Read : Not support l /proc/videograph/vpe/sca/yuv_range \u00b6 [Description] Read or write YUV range of SCA at each one of the channel. \u203b Parameter can be set by put job of AP depends on channel requests, it is not recommend to be set by this proc command or ioctl to avoid conflicts. This command is used for debugging. [Command] Write : proc command Target Parameter echo [fd range] > /proc/videograph/vpe/sca /yuv_range yuv_range: 0, 2, 3, 255 (disable) \u203bdisable represent AP directly control parameters des_drt Read : cat /proc/videograph/vpe/sca/yuv_range Output : **![\u6587\u5b57\u65b9\u584a: Command : echo < fd range >(0:bypass, 2:TV, 3:PC, 255:diable) =============================================================== fd(0x40000000) yuv range = 0 fd(0x40000001) yuv range = 0 fd(0x40000002) yuv range = 0 fd(0x40000003) yuv range = 0 ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)** 7.3.2 Vendor API \u00b6 [Description] Get and set the scaling parameters corresponding to current path_id. [Command] ??????? Get \uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_SCA, VENDOR_VIDEO_PARAM_SCA_SET *p_param); ??????? Set \uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_SCA, VENDOR_VIDEO_PARAM_SCA_SET *p_param); [Definition] **![\u6587\u5b57\u65b9\u584a: typedef struct _VENDOR_VIDEO_PARMA_SCA_CTRL { INT32 sca_ceffH[4]; ///< LPF coefficient in horizontal direction INT32 sca_ceffV[4]; ///< LPF coefficient in vertical direction } VENDOR_VIDEO_PARMA_SCA_CTRL; typedef struct _VENDOR_VIDEO_PARAM_SCA_SET { UINT8 sca_y_luma_algo_en; ///< Algorithm select for vertical luma scaler UINT8 sca_x_luma_algo_en; ///< Algorithm select for horizontal luma scaler UINT8 sca_y_chroma_algo_en; ///< Algorithm select for vertical chroma scaler UINT8 sca_x_chroma_algo_en; ///< Algorithm select for horizontal chroma scaler UINT8 sca_map_sel; ///< Scaler source mapping format select VENDOR_VIDEO_PARMA_SCA_CTRL sca_1000x_param; ///< scaling parameter for scaling ratio 1.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_1250x_param; ///< scaling parameter for scaling ratio 1.25x VENDOR_VIDEO_PARMA_SCA_CTRL sca_1500x_param; ///< scaling parameter for scaling ratio 1.50x VENDOR_VIDEO_PARMA_SCA_CTRL sca_1750x_param; ///< scaling parameter for scaling ratio 1.75x VENDOR_VIDEO_PARMA_SCA_CTRL sca_2000x_param; ///< scaling parameter for scaling ratio 2.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_2250x_param; ///< scaling parameter for scaling ratio 2.25x VENDOR_VIDEO_PARMA_SCA_CTRL sca_2500x_param; ///< scaling parameter for scaling ratio 2.50x VENDOR_VIDEO_PARMA_SCA_CTRL sca_2750x_param; ///< scaling parameter for scaling ratio 2.75x VENDOR_VIDEO_PARMA_SCA_CTRL sca_3000x_param; ///< scaling parameter for scaling ratio 3.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_3250x_param; ///< scaling parameter for scaling ratio 3.25x VENDOR_VIDEO_PARMA_SCA_CTRL sca_3500x_param; ///< scaling parameter for scaling ratio 3.50x VENDOR_VIDEO_PARMA_SCA_CTRL sca_3750x_param; ///< scaling parameter for scaling ratio 3.75x VENDOR_VIDEO_PARMA_SCA_CTRL sca_4000x_param; ///< scaling parameter for scaling ratio 4.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_5000x_param; ///< scaling parameter for scaling ratio 5.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_6000x_param; ///< scaling parameter for scaling ratio 6.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_7000x_param; ///< scaling parameter for scaling ratio 7.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_8000x_param; ///< scaling parameter for scaling ratio 8.00x } VENDOR_VIDEO_PARAM_SCA_SET; ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image058.png)** 8 Distortion Correction Engine (DCE) \u00b6 8.1 Overview \u00b6 This is lens distortion calibration module, it can perform calibration on wide-angle lens and fish-eye lens. 8.2 DCE Parameter Description \u00b6 Table 8?1 DCE Parameter List Parameter Range Def Description dce_mode 0~1 0 Select distortion function 0: GDC lens calibration 1: 2DLUT self-define XY coordinate distortion lut2d_sz 0~5 0 Size selection of 2D look-up table. The larger the size, the more precision to describe distortion. 0: 9x9 3: 65x65 4: 129x129 5: 257x257 lsb_rand 0~1 0 LSB 2 bit random generation for internal 10 bit->8 bit image. 0: fixed fill 0 1: random generate 0~3 fovbound 0~1 0 FOV boundary process method selection. When the distortion result can not fill the total output image, select different way to proceed the exceed range. 0: Replace out of boundary pixels with duplicate nearest pixel 1: Replace out of boundary pixels with bound pixels boundy 0~1023 0 Bound value for Y component(u8.2) boundu 0~1023 0 Bound value for U component(u8.2) boundv 0~1023 0 Bound value for V component(u8.2) cent_x_s 213-1 0 Define lens center of x-axis. It is recommend to set width/2. cent_y_s 213-1 0 Define lens center of y-axis. It is recommend to set height/2. xdist 0~4095 0 X input distance factor, for oval shape modeling. It is recommend to set 4095, which is suitable for most situation. ydist 0~4095 0 Y input distance factor, for oval shape modeling. It is recommend to set 4095, which is suitable for most situation. geo_lut 0~65535 0 The GEO deformation gain table, a total of 65 points, indicates the magnification of each pixel in the image at a different distance from the deformation center (magnification = 65535 * input radius / output radius), the gainbase is 65535, please refer to Note 2 for the gain table example. Value range\uff1a[0, 65535]\u3002 normfact 0~255 128 Radius normalization factor. Normfact = 1 << (normbit + 7) / R2 normbit 0~31 31 Radius normalization shift bit. R2 = (width/2)2+(height/2)2 The total bit number of R2 is normbit. Example: 9602+5402 = 1213200 (21 bits) fovgain 0~4095 0 Adjust the scaling ratio of the final distortion coordinate to preserve FOV. Scale down factor for FOV preservation. Due to it will effect the calibration performance, it is recommend to set 1024. hfact 0 ~ 224 -1 0 Horizontal scaling factor for 2DLut scaling up(u0.24). ((2DLUT horizontal pixel number \u2013 1) << 24) / (width \u2013 1) vfact 0 ~ 224 -1 0 Vertical scaling factor for 2DLut scaling up(u0.24). ((2DLUT vertical pixel number \u2013 1) << 24) / (height \u2013 1) xofs_i 0~127 0 2DLut x offset, integer part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. xofs_f 0~224-1 0 2DLut x offset, fraction part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. yofs_i 0~127 0 2DLut y offset, integer part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. yofs_f 0~224-1 0 2DLut y offset, fraction part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. [Note 1] Adjust geo_fov_gain, the left side is 1024, the right side is 1320, you can observe the increase in the field of view on the right side. ? [Note 2] The example of the GEO deformation gain table, from left to right, corresponds to the deformation amount from the center of the image to the edge. This parameter group indicates that the larger the deformation amount toward the edge is. This example is a barrel deformation correction. R is the distance from the center of the image to each point. This distance can be understood as the radius of the circle. Ri represents the radius of each point of the input (before correction) image. Ro represents the radius of each point of the output (corrected) image. RoMax represents the longest distance from the center of the output image to the four corners. If the center of the image falls at 1/2 of the width and height, the four corners are all equal, and they are the longest distances. 8.3 Setting Interface \u00b6 8.3.1 Proc \u00b6 l /proc/videograph/vpe/dce/dump_info \u00b6 [Description] Read all DCE parameters at the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/dce/dump_info **![\u6587\u5b57\u65b9\u584a: dce_en = 0 dce_mode = 1 lut2d_sz = 3 lut2d_vaddr = 0x0000000000000000 lut2d_paddr = 0x0 lsb_rand = 0 fovbound = 1 boundy = 512 boundu = 512 boundv = 512 cent_x_s = 720 cent_y_s = 720 xdist = 4095 ydist = 4095 normfact = 0 normbit = 0 fovgain = 1024 hfact = 745654 vfact = 745654 xofs_i = 0 xofs_f = 0 yofs_i = 0 yofs_f = 0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)** l /proc/videograph/vpe/dce/ch_en \u00b6 [Description] Read or write the enable status of the current channel. [Command] Write : proc command Target Parameter echo [ dc_en 0~1 ] > /proc/videograph/vpe/dce/ch_en dc_en Read : cat /proc/videograph/vpe/dce/ch_en Output : 8.3.2 Vendor API \u00b6 [Description] Get and set the dce parameters corresponding to current path_id. [Command] ??????? Get\uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEOPROC_DEWARP_INFO, VENDOR_DEWARP_INFO *p_param); ??????? Set\uff1a HD_RESULT c(HD_PATH_ID path_id, VENDOR_ VENDOR_VIDEOPROC_DEWARP_INFO, VENDOR_DEWARP_INFO *p_param); [Define] **![\u6587\u5b57\u65b9\u584a: typedef struct _VENDOR_DEWARP_CTRL { BOOL dc_enable; BOOL dctg_enable; } VENDOR_DEWARP_CTRL; typedef enum _VENDOR_DEWARP_MODE { VENDOR_DEWARP_DEWARP_MODE_GDC = 0, VENDOR_DEWARP_DEWARP_MODE_2DLUT = 1, ENUM_DUMMY4WORD(VENDOR_DEWARP_DEWARP_MODE) } VENDOR_DEWARP_MODE; typedef struct _VENDOR_DEWARP_DGC_PARM { INT32 cent_x_s; ///< Lens center of x axis (signed) INT32 cent_y_s; ///< Lens center of y axis (signed) UINT32 lens_r; ///< Radius of Lens UINT32 xdist; ///< X input distance factor, for oval shape modeling UINT32 ydist; ///< Y input distance factor, for oval shape modeling UINT8 normfact; ///< Radius normalization factor (u1.7) UINT8 normbit; ///< Radius normalization shift bit UINT16 geo_lut[VENDOR_GEO_LUT_X]; ///< GDC look-up table } VENDOR_DEWARP_DGC_PARM; typedef struct _VENDOR_DEWARP_2DLUT_PARM { UINT8 lut2d_sz; ///< Size selection of 2D look-up table, 0:9x9, 3:65x65 UINT32 hfact; ///< Horizontal scaling factor for 2DLut scaling up (u0.24) UINT32 vfact; ///< Vertical scaling factor for 2DLut scaling up (u0.24) UINT8 xofs_i; ///< 2DLUT x offset, integer part UINT32 xofs_f; ///< 2DLUT x offset, fraction part UINT8 yofs_i; ///< 2DLUT y offset, integer part UINT32 yofs_f; ///< 2DLUT xy offset, fraction part } VENDOR_DEWARP_2DLUT_PARM; typedef struct _VENDOR_DEWARP_FOV_PARM { UINT8 fovbound; ///< FOV boundary process method selection UINT16 boundy; ///< Bound value for Y component (u8.2) UINT16 boundu; ///< Bound value for U component (u8.2) UINT16 boundv; ///< Bound value for V component (u8.2) UINT16 fovgain; ///< Scale down factor for FOV preservation (u2.10) } VENDOR_DEWARP_FOV_PARM; ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image064.png)** **![\u6587\u5b57\u65b9\u584a: typedef struct _VENDOR_DEWARP_INFO { VENDOR_DEWARP_MODE mode; VENDOR_DEWARP_DGC_PARM dgc; VENDOR_DEWARP_2DLUT_PARM lut2d; VENDOR_DEWARP_FOV_PARM fov; } VENDOR_DEWARP_INFO; typedef struct _VENDOR_DEWARP_2DLUT_TABLE { UINT32 tbl[VENDOR_GEO_LUT]; } VENDOR_DEWARP_2DLUT_TABLE; ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image058.png)** 9 DC Table Generator(DCTG) \u00b6 9.1 Overview \u00b6 For perspective projection application, in order to increase the convenience of usage, DCTG module let user to set the desired angle and size with an instinct way to generate DCTG parameters automatically. Whenever this function is enabled, manual set DCE 2D-LUT function will be invalid. [Note] ??When using DCTG function, user needs to set two parameters enable, one is dc_enable, the other is dctg_en. Please refer to the following description: The \u201ctheta\u201d is the top/bottom angle. The \u201cphi\u201d is the rotate angle. The \u201crot_y\u201d is the rotate offset of (x, z) plane towards Y-axis. The \u201crot_z\u201d is the rotate offset of (x, y) plane towards Z-axis. Generate LUT: Define the rotate angle of FOV by phi_st/phi_ed, and then rotate to FOV location by rot_y. Define the top/bottom angle of FOV by theta_st/theta_ed, and then rotate to FOV location by rot_z. 9.2 Parameter Description \u00b6 Table 9?1 DCTG parameter list Parameter Range Def Description dctg_en 0-1 0 DCTG ON/OFF mount_type 0~1 0 Camera mount type. 0: Ceiling mount 1: Floor mount lut2d_sz 0, 3 3 Select size of 2D look-up table, this parameter must the same with DCE parameter. 0: 9x9 3: 65x65 lens_r 0~215-1 0 Valid radius of fish-eye lens, the unit is pixel. Please refer to advance description. lens_x_st 0~214-1 0 The start x position of fish-eye lens at the source image, the unit is pixel. lens_y_st 0~214-1 0 The start y position of fish-eye lens at the source image, the unit is pixel. theta_st -180 ~ 180 (-*pi ~ *pi) 0 FOV theta start radian. theta_ed -180 ~ 180 (-*pi ~ *pi) 0 FOV theta end radian. theta_end > theta_st: normal image theta_end < theta_st: flip image phi_st -360 ~ 360 (-2*pi ~ 2*pi) 0 OV phi start radian. phi_ed -360 ~ 360 (-2*pi ~ 2*pi) 0 FOV phi end radian. (-2*pi ~ 2*pi) phi_end > theta_st: normal image phi_end < theta_st: flip image rot_z -360 ~ 360 (-2*pi ~ 2*pi) 0 Z-axis rotate radian rot_y -360 ~ 360 (-2*pi ~ 2*pi) 0 Y-zxis rotate radian. Advance description: l lens_r: The valid radius of fish-eye device. l lens_x_st : The start x position of fish-eye lens at the source image, the unit is pixel. l lens_y_st : The start y position of fish-eye lens at the source image, the unit is pixel. 9.3 Setting Interface \u00b6 9.3.1 Proc \u00b6 l /proc/videograph/vpe/dctg/dump_info \u00b6 [Description] Read all dctg parameters of the current channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/dctg/dump_info l /proc/videograph/vpe/dctg/ch_en \u00b6 [Description] ??????? Set dctg enable. [Command] Write : proc command Target Parameter echo [dctg_en] > /proc/videograph/vpe/dctg/ch_en dctg_en: dctg enable Read : cat /proc/videograph/vpe/dctg/ch_en Output : l /proc/videograph/vpe/dctg/phi \u00b6 [Description] Set FOV phi start radian [Command] Write : proc command Target Parameter echo [st] [ed] > /proc/videograph/vpe/dctg/phi st: FOV phi start radian ed : FOV phi end radian \u203bangle range: -360 ~ 360 Read : cat /proc/videograph/vpe/dctg/phi Output : l /proc/videograph/vpe/dctg/rot \u00b6 [Description] Set Z-axis and Y-zxis rotate radian. [Command] Write : proc command Target Parameter echo [z] [y] > /prc/videograph/vpe/dctg/rot z: Z-axis rotate radian. y: Y-zxis rotate radian \u203bangle range: -360 ~ 360 Read : cat /proc/videograph/vpe/dctg/rot Output : l /proc/videograph/vpe/dctg/theta \u00b6 [Description] Set FOV theta start radian. [Command] Write : proc command \u76ee\u6a19\u53c3\u6578 echo [st] [ed] > /prc/videograph/vpe/dctg/theta st: FOV theta start radian. ed : FOV theta end radian \u203bangle range: -180 ~ 180 Read : cat /proc/videograph/vpe/dctg/theta Output : 9.3.2 Vendor API \u00b6 [Description] Get and set the dctg parameters corresponding to current path_id. [Command] ??????? Get\uff1a HD_RESULT vendor_videoproc_get(HD_PATH_ID path_id, VENDOR_VIDEOPROC_DEWARP_DCTG_INFO, VENDOR_DEWARP_DCTG_INFO *p_param); ??????? Set\uff1a HD_RESULT vendor_videoproc_set(HD_PATH_ID path_id, VENDOR_VIDEOPROC_DEWARP_DCTG_INFO, VENDOR_DEWARP_DCTG_INFO *p_param); [Define] **![\u6587\u5b57\u65b9\u584a: typedef struct _VENDOR_DEWARP_CTRL { BOOL dc_enable; BOOL dctg_enable; } VENDOR_DEWARP_CTRL; typedef struct _VENDOR_DEWARP_DCTG_INFO { VENDOR_DEWARP_DCTG_MODE mode; VENDOR_DEWARP_DCTG_LENS_PARM lens; VENDOR_DEWARP_DCTG_FOV_PARM fov; } VENDOR_DEWARP_DCTG_INFO; typedef enum _VENDOR_DEWARP_DCTG_MODE { VENDOR_DEWARP_DCTG_MODE_90 = 0, VENDOR_DEWARP_DCTG_MODE_360 = 1, ENUM_DUMMY4WORD(VENDOR_DEWARP_DCTG_MODE) } VENDOR_DEWARP_DCTG_MODE; typedef struct _VENDOR_DEWARP_DCTG_LENS_PARM { UINT8 mount_type; ///< Camera mount type. 0:Ceiling mount, 1:Floor mount UINT8 lut2d_sz; ///< Size selection of 2D look-up table, 0:9x9, 3:65x65, should the same with DCE setting. UINT32 lens_r; ///< Radius of Lens UINT32 lens_x_st; ///< Lens start x position at a source image UINT32 lens_y_st; ///< Lens start y position at a source image } VENDOR_DEWARP_DCTG_LENS_PARM; typedef struct _VENDOR_DEWARP_DCTG_FOV_PARM { INT32 theta_st; ///< FOV theta start radian (s4.16) Range: - pi ~ pi INT32 theta_ed; ///< FOV theta end radian (s4.16) Range: - pi ~ pi INT32 phi_st; ///< FOV phi start radian (s4.16) Range: -2 pi ~ 2 pi INT32 phi_ed; ///< FOV phi end radian (s4.16) Range: -2 pi ~ 2 pi INT32 rot_z; ///< Z-axis rotate radian (s4.16) Range: -2 pi ~ 2 pi INT32 rot_y; ///< Y-axis rotate radian (s4.16) Range: -2 pi ~ 2 pi } VENDOR_DEWARP_DCTG_FOV_PARM; ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image070.png)** 10 Revise History \u00b6 Version Date Advisor Description 0.1.00 2021/01/20 Allen Hsu First version. 0.2.00 2021/3/26 Allen Hsu Add description of Vendor command. 0.3.00 2022/4/11 Mina Wang Add description for dce and dctg","title":"VPE IQ Tuning Guide"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#1-overview","text":"Figure 1?1 NT9833x Video Flow VPE is an independent image processing engine in YUV domain, and it performs some pre-processing process before LCD display or encoder to improve the image quality. The related modules are as follows: l Spatial Noise Reduction Module(SPNR, using MRNR method) l Tempoarl Noise Reduction Module(TMNR) l Sharpen Module(SHP) l Scaling Module(SCA) \u203b The 9833x series has removed DCE and DCTG. \u203b In the following description, the area shown in blue is the same module as the 9831x series but the parameters are different. Please pay special attention) Figure 1?2 VPE Image Processing Flow","title":"1 Overview"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#2-system-control","text":"The processing sequence of Sharpen, SPNR(using MRNR method) and TMNR is changeable, and user can change the processing sequence depends on different camera charateristic to achieve the best image quality.","title":"2 System Control"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#21-parameter-description","text":"Parameter Range Def Description ch_fd Video graph use ch_fd to represent the connected video engine of each channel. User can fine tune parameter of each video engine by setting ch_fd. pipe_mode 0~5 0 Set module processing sequence. 0 : MRNR -> TMNR -> Sharpen 1 : MRNR-> Sharpen -> TMNR 2 : Sharpen -> MRNR -> TMNR 3 : SHP->TMNR->MRNR 4 :?TMNR->MRNR->SHP 5 : TMNR->SHP->MRNR","title":"2.1 Parameter Description"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#22-setting-interface","text":"","title":"2.2 Setting Interface"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#221-proc","text":"","title":"2.2.1 Proc"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpech_fd","text":"[Description] Read or write the current camera channel, and it only needs to set once, the following SHP, MRNR, TMNR parameters will work on this channel. The following proc command will list all ch_fd of the current video engine: [Command] Write : proc command Target Parameter echo [fd ] > /proc/videograph/vpe/ch_fd Fw Internal Pointer Read : cat /proc/videograph/vpe/ch_fd","title":"l /proc/videograph/vpe/ch_fd"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpepipe_mode","text":"[Description] Read or write the executing sequence of SHP, MRNR and TMNR. [Command] Write : proc command Target Parameter echo [pipe_mode ] > /proc/videograph/vpe/pipe_mode src_ppo_idx???????? mrnr_ppi_idx???? mrnr_ppo_idx??? tmnr_ppi_idx????? tmnr_ppo_idx???? shp_ppi_idx???????? shp_ppo_idx??????? sca_ppi_idx Read : cat /proc/videograph/vpe/pipe_mode","title":"l /proc/videograph/vpe/pipe_mode"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#3-spatial-noise-reduction","text":"This is spatial noise reduction module(abbreviation is \u201cSPNR\u201d). It will divide the image into high frequency part and middle frequency part, performing noise reduction process respectively, then combine together to achieve the purpose of noise reduction and retain detail.?","title":"3 Spatial Noise Reduction"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#31-overview","text":"Major processing flow is as follows : Figure 3?1 The SPNR processing flow. Major processing flow : Divide the input image into high frequency image and middle frequency image. Determine and label whether the processing pixel is on the edge. Perform edge smooth process on high frequency image and middle frequency image, respectively. Perform flat region noise reduction process on middle frequency image. Use high/middle frequency image which had performed noise reduction process to reconstruct image.","title":"3.1 Overview"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#32-parameter-description","text":"(The blue text is the part of the parameter difference between this module and the 9831x series, please pay special attention) Table 3?1 SPNR Parameter List Parameter Range Def Description t_y_edge_detection [2][8] 0~1023 161,322,483,447, 419,320,195,130, 108,215,308,272, 246,185,125,100 Y threshold for determining whether the current processing pixel is on the edge. It has eight thresholds mapping to pixel brightness from dark to bright, respectively. [0][0~7] is the threshold from dark to bright for high frequency image. [1][0~7] is the threshold from dark to bright for middle frequency image. t_cb_edge_detection 0~1023 0,249 Cb threshold for determining whether the current processing pixel is on the edge. Only works in middle frequency image. t_cr_edge_detection [2] 0~1023 0,249 Cr threshold for determining whether the current processing pixel is on the edge. Only works in middle frequency image. t_y_edge_smoothing[2][8] 0~255 66,132,161,149, 140,107,80,53, 44,88,103,91, 82,62,51,41 Y threshold for determining whether it will perform smooth process. It has eight thresholds mapping to pixel brightness from dark to bright, respectively. [0][0~7] is the threshold from dark to bright for high frequency image. [1][0~7] is the threshold from dark to bright for middle frequency image. t_cb_edge_smoothing [2] 0~255 0,153 Cb threshold for determining whether it will perform smooth process. Only works in middle frequency image. t_cr_edge_smoothing [2] 0~255 0,153 Cr threshold for determining whether it will perform smooth process. Only works in middle frequency image. nr_strength_y[2] 0~15 {0, 0} The denoise strength of spatial domain on Y channel. [0] is denoise strength for high frequency image. [1] is denoise strength for middle frequency image. nr_strength_c 0~15 {0, 10} The denoise strength of spatial domain on Cb/Cr channel. Only works in middle frequency image. Advance description : l edge_smoothing?: When SPNR performs smooth process, it will calculate weighting sum of neighbor pixels along the edge direction, if the difference between the neighbor pixel and center pixel is larger than threshold, this neighbor pixel will not be used in the smooth process. The smooth process of Y/Cb/Cr are the same.","title":"3.2 Parameter Description"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#33-setting-interface","text":"","title":"3.3 Setting Interface"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#331-proc","text":"","title":"3.3.1 Proc"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpemrnrdump_info","text":"[Description] Read all SPNR(using MRNR method) parameters of the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/mrnr/dump_info Output:","title":"l /proc/videograph/vpe/mrnr/dump_info"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpemrnrmrnr_en","text":"[Description] Read or write the MRNR enable status of the current camera channel. [Command] Write : proc command Target Parameter echo [mrnr_en (0~1)] > /proc/videograph/vpe/mrnr/mrnr_en mrnr_en Read : cat /proc/videograph/vpe/mrnr/mrnr_en Output:","title":"l /proc/videograph/vpe/mrnr/mrnr_en"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpemrnrt_xx_edge_det","text":"[Description] Read or write edge_detection parameters. [Command] Write : proc command Target Parameter echo [t_y_edge_det[0][0] \u2026..[0][7]] > /proc/videograph/vpe/mrnr/ t_y_edge_det_1 t_y_edge_detection[0~7] echo [t_y_edge_det[1][0] \u2026..[1][7]] > /proc/videograph/vpe/mrnr/ t_y_edge_det_2 t_y_edge_detection[8~15] echo [t_cb_edge_det] > /proc/videograph/vpe/mrnr/ t_cb_edge_det t_cb_edge_detection[0~1] echo [t_cr_edge_det] > /proc/videograph/vpe/mrnr/ t_cr_edge_det t_cr_edge_detection[0~1] Read : cat /proc/videograph/vpe/mrnr/ t_y_edge_det_1 cat /proc/videograph/vpe/mrnr/ t_y_edge_det_2 cat /proc/videograph/vpe/mrnr/ t_cb_edge_det_1 cat /proc/videograph/vpe/mrnr/ t_cr_edge_det_1 Output :","title":"l /proc/videograph/vpe/mrnr/t_xx_edge_det"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpemrnrt_xx_edge_smooth","text":"[Description] Read or write edge_smoothing parameters. [Command] Write : proc command Target Parameter echo [t_y_edge_smooth[0][0]] \u2026\u2026..[t_y_edge_smooth [0][7]] > /proc/videograph/vpe/mrnr/ t_y_edge_smooth_1 t_y_edge_ smoothing[0~7] echo [t_y_edge_smooth[1][0] \u2026\u2026.. [t_y_edge_smooth[1] [7]] > /proc/videograph/vpe/mrnr/t_y_edge_smooth_2 t_y_edge_ smoothing[8~16] echo [t_cb_edge_smooth] > /proc/videograph/vpe/mrnr/ t_cb_edge_smooth t_cb_edge_smoothing[0~1] echo [t_cr_edge_smooth] > /proc/videograph/vpe/mrnr/ t_cr_edge_smooth t_cr_edge_ smoothing[0~1] Read : cat /proc/videograph/vpe/mrnr/t_y_edge_smooth_1 cat /proc/videograph/vpe/mrnr/t_y_edge_smooth_2 cat /proc/videograph/vpe/mrnr/t_cb_edge_smooth cat /proc/videograph/vpe/mrnr/t_cr_edge_smooth Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [t_y_edge_smooth[0]] \u2026\u2026.. [t_y_edge_smooth [7]] > /proc/videograph/vpe/mrnr/t_y_edge_smooth_1 \u2026 =============================================================== t_y_edge_smooth1 = t_y_edge_smoothing[0][0] \u2026\u2026\u2026\u2026\u2026. [0][7] t_y_edge_smooth1 = t_y_edge_smoothing [1][0]\u2026\u2026\u2026\u2026\u2026.. [0][7] t_cb_edge_smooth = t_cb_edge_smoothing t_cr_edge_smooth = t_cr_edge_smoothing ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image012.png)**","title":"l /proc/videograph/vpe/mrnr/t_xx_edge_smooth"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpemrnrnr_strength","text":"[Description] Read or write nr_strength parameters on Y/C channel. [Command] Write : proc command Target Parameter echo [strength_y[0]] [strength_y [1]] [strength_c] > /proc/videograph/vpe/mrnr/nr_strength nr_strength_y[0~1], nr_strength_c Read : cat /proc/videograph/vpe/mrnr/ nr_strength Output :","title":"l /proc/videograph/vpe/mrnr/nr_strength"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#332-vendor-api","text":"[Description] Get and set the 2DNR parameters corresponding to current path_id. [Command] ??????? Get \uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_DN_2D, VENDOR_VIDEO_PARAM_MRNR *p_param); ??????? Set \uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_DN_2D, VENDOR_VIDEO_PARAM_MRNR *p_param); [Definition]","title":"3.3.2 Vendor API"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#4-temporal-noise-reduction-tmnr","text":"This is temporal noise reduction module(abbreviation is \u201cTMNR\u201d). The major function is to eliminate temporal noise in the image.","title":"4 Temporal Noise Reduction (TMNR)"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#41-overview","text":"The concept of TMNR algorithm is to determine whether the pixel status is static(MotionLevel=0) or motion(MotionLevel=2) by Motion Detect module. The static region perform 3DNR to reduce the temporal noise, and the motion region will not perform 3DNR to prevent from having ghost, instead, it will perform 2DNR to reduce noise. The transition region between static region and motion region will combine the result of 2DNR and 3DNR by weighting.","title":"4.1 Overview"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#42-parameter-description","text":"(The blue text is the part of the parameter difference between this module and the 9831x series, please pay special attention) Table 4?1 TMNR Parameter List Parameter Range Default Description tmnr_en 0~1 1 TMNR ON/OFF luma_dn_en 0~1 1 Y channel TMNR ON/OFF chroma_dn_en 0~1 1 Cb/Cr channel TMNR ON/OFF tmnr_fcs_en 0~1 0 Temporal de-false color function ON/OFF It only works when \u201cchroma_dn_en\u201d is set to 1. Please refer to advance description. nr_str_y_3d 0~32 8 Y channel temporal NR strength nr_str_y_2d 0~32 16 Y channel spatial NR strength of motion object nr_str _c_3d 0~32 16 Cb/Cr channel temporal NR strength nr_str _c_2d 0~32 16 Cb/Cr channel spatial NR strength of motion object blur_str_y 0~2 1 Y image blurred strength 0: No blur 1: low-strength blur 2: high-strength blur \u203bIt is recommend to set enable, if the executing sequence of 3DNR is after Sharpness; otherwise, it is recommend to set disable. For DVR/NVR application, due to in most case the front-end camera had perfomed sharpen process, it is recommend to set 1. center_wzero_y_2d_en 0~1 1 Set to enable represents when performing the 2DNR, the weighting of center point is 0. It will increase NR strength, but might lose detail. Due to 2DNR only works on motion region, the detail loss is not obvious, it is recommend to fix enable. center_wzero_y_3d_en 0~1 1 Set to enable represents when performing 3DNR, the weighting of center point is 0. It is recommend to fix enable. small_vibrat_supp_y_en 0~1 0 Y channel small vibration suppresiioon ON/OFF. This function will enhance suppression on small vibration noise to make the image more stable. However, it also causes slower ghost removal. It is recommend to enable at normal luminance, and disable at dark luminance. avoid_residue_th_y 1~4 2 Upper threshold for Y channel small noise putting back. If err_compen sate = 0, bigger this value will cause smaller temporal noise. On the other hand, if err_compensate = 1, bigger this value will cause bigger temporal noise. avoid_residue_th_c 1~4 1 Upper threshold for Vb/Cr channel small noise putting back. If err_compensate = 0, bigger this value will cause smaller temporal noise. On the other hand, if err_compensate = 1, bigger this value will cause bigger temporal noise. display_motion_map_en 0~1 0 Debug mode. Show motion detection result on the image to assist to judge the correctness of motion detect parameters. Please refer to advance description. motion_map_channel 0~4 0 Select debug signal channel. 0: Y channel 1: Cb channel 2: Cr channel 3: temporal de-false color Cb channel 4: temporal de-false color Cr channel y_base[8] 0~16320 {146,147,107,110,102,104,104,104} y_base[0]-[7] are NoiseSAD mapping to pixel brightness from dark to bright. When performing 2DNR, the internal algorithm will automatically fine tune strength based on y_base. The larger the y_base, the stronger strength of 2DNR of motion object. It is recommend to increase y_base as sensor gain increases. motion_level_th_y_k1 0~32 8 Threshold (motion_level_th_y_k1*Y_NOISE) for determining transition region on Y channel. Y_NOISE please refer to advance description. motion_level_th_y_k2 0~32 8 Threshold (motion_level_th_y_k2*Y_NOISE) for determining motion region on Y channel. K2 must larger or equal to K1. y_coefa[8] 0~48 {0,0,0,0,0,0,0,0} The slope of NoiseSAD from flat region to detail region on Y channel. y_coefa[0]-[7] mapping to pixel brightness from dark to bright. y_coefb[8] 0~16320 {27,27,20,12,7,10,10,10} NoiseSAD of flat region on Y channel. y_coefb[0]-[7] mapping to pixel brightness from dark to bright. y_std[8] 0~16320 {20,70,70,70,70,50,28,18} The standard deviation of NoiseSAD on Y channel. y_std[0]-[7] mapping to pixel brightness from dark to bright. motion_level_th_c_k1 0~32 8 Threshold for determining transition region on Cb/Cr channel. motion_level_th_c_k2 0~32 8 Threshold for determining motion region on Cb/Cr channel, K2 must larger or equal to K1. cb_mean[8] 0~6375 {33,33,34,32,29,28,28,28} The NoiseSAD mean value on Cb channel. cb_mean[0]-[7] mapping to pixel brightness from dark to bright. cb_std[8] 0~6375 {10,9,10,10,9,9,9,9} The standard deviation of NoiseSAD on Cb channel. cb_std[0]-[7] mapping to pixel brightness from dark to bright. cr_mean[8] 0~6375 {23,23,25,23,20,20,21,21} The NoiseSAD mean value on Cr channel. cr_mean[0]-[7] mapping to pixel brightness from dark to bright. cr_std[8] 0~6375 {7,7,8,7,7,77,7} The standard deviation of NoiseSAD on Cr channel. cr_std[0]-[7] mapping to pixel brightness from dark to bright. lut_y_3d_1_Th[4] 0~127 {11,33,55,77} Lut of Y channel 3D_1 filter Please refer to advance description. lut_y _3d_2_Th[4] 0~127 {40,14,7,3} Lut of Y channel 3D_2 filter Please refer to advance description. lut_y_2d_Th[4] 0~127 {11,33,55,77} Lut of Y channel 2D filter Please refer to advance description. lut_c_3d_Th[4] 0~127 {37,19,11,7} Lut of Cb/Cr channel 3D filter Please refer to advance description. lut_c_2d_Th[4] 0~127 {11,33,55,77} Lut of Cb/Cr channel 2D filter Please refer to advance description. tmnr_fcs_str 0~15 4 The strength of temporal de-false color function. tmnr_fcs_th 0~255 32 Threshold for the difference between the previous frame and the current frame to determine whether it is false color. dithering_en 0~1 1 Dithering enable. This function can be used to eliminate slight power noise or flicker phenomenon. dithering_bit_y 0~3 2 Y channel random bit number. The higher the value, the stronger the ability to eliminate the power noiser and filcker phenomenon, but the picture may appear larger fine noise. dithering_bit_u 0~3 1 U channel random bit number. The higher the value, the stronger the ability to eliminate the power noiser and filcker phenomenon, but the picture may appear larger fine noise. dithering_bit_v 0~3 1 V channel random bit number. The higher the value, the stronger the ability to eliminate the power noiser and filcker phenomenon, but the picture may appear larger fine noise. err_compensate 0~1 1 YC Compression error compensation. 0: Antiflicker mode. (Larger anti-flicker effect) 1: Compensation mode. (Data Compression Error Compensation) Advance Description: l tmnr_fcs_en: Temporal de-false color ON/OFF. This function will eliminate color-flash phenomenon in high frequency region. FCS off FCS on l display_motion_map_en: \u3002 Motion region will label with red color, static region will label with black color, and transition region will label with white color. Original image Motion Map l Y_NOISE : Block SAD is the summation of pixel difference between the previous frame and current frame at the same location. If the Block SAD is larger than K2 NoiseSAD_STD(NoiseSAD_STD is the input parameter), it determines as motion region. If the Block SAD is smaller than K1 NoiseSAD_STD, it determines as static region. If the Block SAD is larger than K1*NoiseSAD_STD and smaller than K2*NoiseSAD_STD, it determines as transition region. As follows : l Cb_NOISE, Cr_NOISE: Different from Y channel, the NoiseSAD of Cb/Cr channel has no relationship with detail. Therefore, it has no slope parameter. l lut_Y_3d_1_Th: Weighting Lut for stage 1 3DNR on Y channel, the x-axis is delta difference of neighbor pixel, the y-axis is weighting. As the following figure, the larger the difference, the smaller the weighting. The smaller the difference, the larger the weighting. Then, based on each weighting to perform weighting sum. l lut_Y_3d_2_Th: Weighting Lut for Stage 2 3DNR on Y channel, the x-axis is difference of the reference point between the previous frame and current frame, the y-axis is weighting. As the following figure, those with smaller difference might be static region, and set smaller weighting, the output will close to the reference frame. On the contrast, those with larger difference might be motion region, and set larger weighting, the output will close to the current frame. l lut_Y_2d_Th: Weighting Lut of neighbor pixel for 2DNR on Y channel, the x-axis is difference, the y-axis is weighting. As the following figure, the larger the difference, the smaller the weighting. The smaller the difference, the larger the weighting. Then, based on each weighting to perform weighting sum. l lut_c_3d_Th: Suppression Level Lut for 3DNR on Cb/Cr channel, the x-axis is the difference of the reference point between the previous frame and current frame, the y-axis is the suppression level. The concept is the same with \u201c LUT_Y_3d_2_Th \u201d. l lut_c_2d_Th: Weighting Lut of neighbor pixel for 2DNR on Cb/Cr channel, the x-axis is difference, the y-axis is weighting. The concept is the same with \u201c lut_Y_2d_Th \u201d.","title":"4.2 Parameter description"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#43-setting-interface","text":"","title":"4.3 Setting Interface"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#431-proc","text":"","title":"4.3.1 Proc"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrdump_info","text":"[Description] Read all parameters of the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/tmnr/dump_info Output :","title":"l /proc/videograph/vpe/tmnr/dump_info"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrch_en_status","text":"[Description] Read or write the enable status of the current channel. [Command] Write : proc command Target Parameter echo [luma_en] [chroma_en] [fcs_en] > /proc/videograph/vpe/tmnr/ch_en_status luma_dn_en chroma_dn_en tmnr_fcs_en Read : cat /proc/videograph/vpe/tmnr/ch_en_status Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [luma_en] [chroma_en] [fcs_en] > /proc/videograph/vpe/tmnr/ch_en_status =============================================================== luma_en = luma_dn_en chroma_en = chroma_dn_en fcs_en = tmnr_fcs_en ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image027.png)**","title":"l /proc/videograph/vpe/tmnr/ch_en_status"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrnr_strength","text":"[Description] Read or write the TMNR strength of the current channel. [Command] Write : proc command Target Parameter echo [y_3d_str] [y_2d_str] [c_3d_str] [c_2d_str] > /proc/videograph/vpe/tmnr/nr_strength nr_str_y_3d, nr_str_y_2d nr_str_c_3d, nr_str_c_2d Read : cat /proc/videograph/vpe/tmnr/nr_strength Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [y_3d_str] [y_2d_str] [c_3d_str] [c_2d_str] > /proc/videograph/vpe/tmnr//proc/videograph/vpe/tmnr/nr_strength =============================================================== nr_str_y_3d = nr_str_y_3d nr_str_y_2d = nr_str_y_2d nr_str_c_3d = nr_str_c_3d nr_str_c_2d = nr_str_c_2d ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image028.png)**","title":"l /proc/videograph/vpe/tmnr/nr_strength"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnry_base","text":"[Description] Read or write the base noise level of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_base0] [y_base1]\u2026\u2026\u2026[y_base7] > /proc/videograph/vpe/tmnr/y_base y_base[0]~[7] Read : cat /proc/videograph/vpe/tmnr/y_base Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [y_base0] [y_base1]\u2026\u2026\u2026[y_base7] > /proc/videograph/vpe/tmnr/y_base =============================================================== TMNR Noise Y_base = y_base[0]\u2026\u2026\u2026\u2026y_base[7] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image029.png)**","title":"l /proc/videograph/vpe/tmnr/y_base"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrmotion_level_th","text":"[Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_k1] [y_k2] [c_k1] [c_k2] > /proc/videograph/vpe/tmnr/motion_level_th motion_level_th_y_k1 motion_level_th_y_k2 motion_level_th_c_k1 motion_level_th_c_k2 Read : cat /proc/videograph/vpe/tmnr/motion_level_th Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [y_k1] [y_k2] [c_k1] [c_k2] > /proc/videograph/vpe/tmnr/motion_level_th =============================================================== TMNR motion level th = motion_level_th_y_k1, motion_level_th_y_k2, motion_level_th_c_k1, motion_level_th_c_k2, ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image030.png)**","title":"l /proc/videograph/vpe/tmnr/motion_level_th"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnry_coeffa","text":"[Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_coeffa0] [y_coeffa1]\u2026\u2026\u2026[y_coeffa7] > /proc/videograph/vpe/tmnr/y_coeffa y_coeffa[0]~[7] Read : cat /proc/videograph/vpe/tmnr/y_coeffa Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [y_coeffa0] [y_coeffa1]\u2026\u2026\u2026[y_coeffa7] > /proc/videograph/vpe/tmnr/y_coeffa =============================================================== TMNR Noise model y_coeffa = y_coeffa[0]\u2026\u2026\u2026\u2026y_coeffa[7] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image031.png)**","title":"l /proc/videograph/vpe/tmnr/y_coeffa"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnry_coeffb","text":"[Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_coeffb0] [y_coeffb1]\u2026\u2026\u2026[y_coeffb7] > /proc/videograph/vpe/tmnr/y_coeffb y_coeffb[0]~[7] Read : cat /proc/videograph/vpe/tmnr/y_coeffb Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [y_coeffb0] [y_coeffb1]\u2026\u2026\u2026[y_coeffb7] > /proc/videograph/vpe/tmnr/y_coeffb =============================================================== TMNR Noise model y_coeffb = y_coeffb[0]\u2026\u2026\u2026\u2026y_coeffb[7] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image032.png)**","title":"l /proc/videograph/vpe/tmnr/y_coeffb"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnry_std","text":"[Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_std0] [y_std1]\u2026\u2026\u2026[y_std7] > /proc/videograph/vpe/tmnr/y_std y_std[0]~[7] Read : cat /proc/videograph/vpe/tmnr/y_std Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [y_std0] [y_std1]\u2026\u2026\u2026[y_std7] > /proc/videograph/vpe/tmnr/y_std =============================================================== TMNR Noise model y_std = y_std[0]\u2026\u2026\u2026\u2026y_std[7] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image033.png)**","title":"l /proc/videograph/vpe/tmnr/y_std"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrcb_mean","text":"[Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [cb_mean0] [cb_mean1]\u2026\u2026\u2026[cb_mean 7] > /proc/videograph/vpe/tmnr/cb_mean cb_mean[0]~[7] Read : cat /proc/videograph/vpe/tmnr/cb_mean Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [cb_mean0] [cb_mean1]\u2026\u2026\u2026[cb_mean 7] > /proc/videograph/vpe/tmnr/cb_mean =============================================================== TMNR Noise model cb_mean = cb_mean[0]\u2026\u2026\u2026\u2026cb_mean[7] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image034.png)**","title":"l /proc/videograph/vpe/tmnr/cb_mean"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrcb_std","text":"[Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [cb_std0] [cb_std1]\u2026\u2026\u2026[cb_std7] > /proc/videograph/vpe/tmnr/cb_std cb_std[0]~[7] Read : cat /proc/videograph/vpe/tmnr/cb_std Output :","title":"l /proc/videograph/vpe/tmnr/cb_std"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrcr_mean","text":"[Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [cr_mean0] [cr_mean1]\u2026\u2026\u2026[cr_std7] > /proc/videograph/vpe/tmnr/cr_mean cr_std[0]~[7] Read : cat /proc/videograph/vpe/tmnr/cr_mean Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [cr_mean0] [cr_mean1]\u2026\u2026\u2026[cr_std7] > /proc/videograph/vpe/tmnr/cr_mean =============================================================== TMNR Noise model cr_mean = cr_mean[0]\u2026\u2026\u2026\u2026cr_mean[7] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image036.png)**","title":"l /proc/videograph/vpe/tmnr/cr_mean"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrcr_std","text":"[Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [cr_std0] [cr_std1]\u2026\u2026\u2026[cr_std7] ] > /proc/videograph/vpe/tmnr/cr_std cr_std[0]~[7] Read : cat /proc/videograph/vpe/tmnr/cr_std Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [cr_std0] [cr_std1]\u2026\u2026\u2026[cr_std7] > /proc/videograph/vpe/tmnr/cr_std =============================================================== TMNR Noise model cr_std = cr_std[0]\u2026\u2026\u2026\u2026cr_std[7] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image037.png)**","title":"l /proc/videograph/vpe/tmnr/cr_std"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrlut_y_3d_1_th","text":"[Description] Read or write the 3D noise reduction parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_y_3d_1_th lut_y_3d_1_th[0]~[3] Read : cat /proc/videograph/vpe/tmnr/lut_y_3d_1_th Output :","title":"l /proc/videograph/vpe/tmnr/lut_y_3d_1_th"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrlut_y_3d_2_th","text":"[Description] Read or write the 3D noise reduction parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_y_3d_2_th lut_y_3d_2_th[0]~[3] Read : cat /proc/videograph/vpe/tmnr/lut_y_3d_2_th Output :","title":"l /proc/videograph/vpe/tmnr/lut_y_3d_2_th"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrlut_y_2d_th","text":"[Description] Read or write the 2D noise reduction parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_y_2d_th lut_y_2d_th[0]~[3] Read : cat /proc/videograph/vpe/tmnr/lut_y_2d_th Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_y_2d_th =============================================================== TMNR lut_y_2d_th = lut_y_2d_th[0]\u2026th[3] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image040.png)**","title":"l /proc/videograph/vpe/tmnr/lut_y_2d_th"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrlut_c_3d_th","text":"[Description] Read or write the 3D noise reduction parameters of 3DNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_c_3d_th lut_c_3d_th[0]~[3] Read : cat /proc/videograph/vpe/tmnr/lut_c_3d_th Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_c_3d_th =============================================================== TMNR lut_c_3d_th = lut_c_3d_th[0]\u2026th[3] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image041.png)**","title":"l /proc/videograph/vpe/tmnr/lut_c_3d_th"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrlut_c_2d_th","text":"[Description] Read or write the 2D noise reduction parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_c_2d_th lut_c_2d_th[0]~[3] Read : cat /proc/videograph/vpe/tmnr/lut_c_2d_th Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_c_2d_th =============================================================== TMNR lut_c_3d_th = lut_c_2d_th[0]\u2026th[3] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image042.png)**","title":"l /proc/videograph/vpe/tmnr/lut_c_2d_th"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrfcs_str","text":"[Description] Read or write the false color suppression strength of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [fcs_str (0~15) ] > /proc/videograph/vpe/tmnr/fcs_str tmnr_fcs_str Read : cat /proc/videograph/vpe/tmnr/fcs_str Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [fcs_str (0~15) ] > /proc/videograph/vpe/tmnr/fcs_str =============================================================== TMNR FCS strength = tmnr_fcs_str ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image043.png)**","title":"l /proc/videograph/vpe/tmnr/fcs_str"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrfcs_th","text":"[Description] Read or write the threshold for determining whether it is false color of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [fcs_th (0~255) ] > /proc/videograph/vpe/tmnr/fcs_th tmnr_fcs_th Read : cat /proc/videograph/vpe/tmnr/fcs_th Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [fcs_th (0~255) ] > /proc/videograph/vpe/tmnr/fcs_th =============================================================== TMNR FCS th = tmnr_fcs_th ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image044.png)**","title":"l /proc/videograph/vpe/tmnr/fcs_th"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrmotion_map","text":"[Description] Read or write the motion map of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [map_en (0~1)] > [map_idx] > /proc/videograph/vpe/tmnr/motion_map map_en: 0: display_motion_map_en = 0 1: display_motion_map_en = 1 map_idx : ?0: motion_map_channel=Y ?1: motion_map_channel=Cb 2: motion_map_channel=Cr 3: motion_map_channel=FCS_Cb 4: motion_map_channel=FCS_Cr display_motion_map_en, motion_map_channel Read : cat /proc/videograph/vpe/tmnr/motion_map Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [map_en (0~1)] [map_idx (0~4)] > /proc/videograph/vpe/tmnr/motion_map =============================================================== TMNR motion_map : map_en = display_motion_map_en map_channel = motion_map_channel ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image045.png)**","title":"l /proc/videograph/vpe/tmnr/motion_map"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrdiff_blur_str","text":"[Description] Read or write the Diff. image blur strength of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [str (0~2)] > /proc/videograph/vpe/tmnr/diff_blur_str str: blur strength 0 ~2 blur_str_y Read : cat /proc/videograph/vpe/tmnr/diff_blur_str Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [str (0~2)] > /proc/videograph/vpe/tmnr/diff_blur_str =============================================================== diff_blur_str = blur_str_y ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image046.png)**","title":"l /proc/videograph/vpe/tmnr/diff_blur_str"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnravoid_residue_th","text":"[Description] Read or write the Diff. image blur strength of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [avoid_residue_th_y (1~4)] [avoid_residue_th_c (1~4)] > /proc/videograph/vpe/tmnr/avoid_residue_th avoid_residue_th_y, avoid_residue_th_c Read : cat /proc/videograph/vpe/tmnr/avoid_residue_th Output :","title":"l /proc/videograph/vpe/tmnr/avoid_residue_th"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrdithering","text":"[Description] Read or write the dithering relative parameters of the current channel. [Command] Write : proc command Target Parameter echo [dithering_en (0~1)] [dithering_bit_y (0~7)] [dithering_bit_u (0~7)] [dithering_bit_v (0~7)] > /proc/videograph/vpe/tmnr/dithering dithering_en dithering_bit_y dithering_bit_u dithering_bit_v Read : cat /proc/videograph/vpe/tmnr/ dithering Output :","title":"l /proc/videograph/vpe/tmnr/dithering"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpetmnrerr_compensate","text":"[Description] Read or write the err_compensate parameter of the current channel. [Command] Write : proc command Target Parameter echo [err_compensate (0~1)] > /proc/videograph/vpe/tmnr/err_compensate err_compensate Read : cat /proc/videograph/vpe/tmnr/err_compensate Output :","title":"l /proc/videograph/vpe/tmnr/err_compensate"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#432-vendor-api","text":"[Description] Get and set the TMNR parameters corresponding to current path_id. [Command] ??????? Get \uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_TMNR_CTRL, VENDOR_VIDEO_PARAM_TMNR_EXT *p_param); ??????? Set \uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_DN_2D, VENDOR_VIDEO_PARAM_TMNR_EXT *p_param); [Definition]","title":"4.3.2 Vendor API"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#5-sharpen-shp","text":"This is texture enhancement module.","title":"5 Sharpen (SHP)"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#51-overview","text":"This algorithm adopts inverse gamma information and after gamma information to perform texture enhancement, respectively, to improve the enhancement strength not smooth problem of the bright/dark region. Besides, it adopts 3x3 and 5x5 filter to enhance thin edge and thick edge, repectively, to take care of the detail and contrast of image. Calculating \u201cEdge Weight\u201d to determine this is detail region or flat region(thinner edge) and automatically adjusting weighting of detail enhancement result and flat region enhancement result to take care of texture enhancement and avoid noise enhancement. The \u201cHalo clip\u201d is used to control the overshootong phenomenon caused by edge enhancement. The major flow please refer to the following figure: Parameter Description Table 5?1 SHP Parameter List Parameter Range Def Description sharpen_en 0~1 0 Edge enhance ON/OFF edge_weight_src_sel 0~1 0 Select the image source to calculate \u201cEdge Weight \u201d. 0: after gamma, 1: inverse gamma. Please refer to description. edge_weight_th 0~255 2 Threshold for calculating \u201cEdge Weight\u201d, those smaller than threshold will be considered as flat region, and the output all adopt flat region enhancement result. edge_weight_gain 0~255 175 Adjust the weighting of detail enhancement result and flat region(thin edge) enhancement result. Based on the setting of \u201cnoise_level+noise_curve\u201d to adjust EdgeWeight for different pixel brightness. The larger the Edge Weight, the larger weighting of detail enhancement result, repersenting the edge enhance is more stronger(more noise). In the contrast, the smaller the edge weight, the larger weighting of flat region enhancement result, representing the edge enhancement is less stronger. noise_level 0~255 25 Please refer to advance description. noise_curve[17] 0~255 {50, 50, 50, 48, 47, 44, 39, 38, 37, 36, 35, 35, 35, 35, 35, 35, 35} Please refer to advance description. blend_inv_gamma 0~128 64 The blending weight of inverse gamma edge enhancement result and after gamma edge enhancement result. This parameter is equal to adjust the ratio of edge enhancement between bright region and dark region, let the edge enhancement level of bright region and dark region is more even. The larger the value, the stronger strength of bright region enhancement, but the weaker strength of dark region enhancement. edge_sharp_str1 0~255 25 Adjust the strength of thin edge enhancement edge_sharp_str2 0~255 10 Adjust the strength of thick edge enhancement flat_sharp_str 0~255 0 Adjust the strength of flat region(thin detail) enhancement. coring_th 0~255 0 Threshold for determing whether to perform enhancement. For those edge value smaller than threshold, they will not perform edge enhancement to avoid enhancing noise. bright_halo_clip 0~128 32 Remove bright halo edge caused by edge enhancement. The smaller the \u201cbright_halo_clip\u201d, the less bright halo edge, but the sharpness might be decreased. dark_halo_clip 0~128 96 Remove dark halo edge caused by edge enhancement. The smaller the \u201cdark_halo_clip\u201d, the less dark halo edge, but the sharpness might be decreased. Advance description l noise_level, noise_curve[17]: noise_level = noise_level + NoiseofPixel, wherein the NoiseofPixel is the y-axis of noise_curve. The noise_curve may depend on the pixel brightness to set the noise size, respectively. Normally, human eyes are less sensitive to the noise in high bright region; thus, it can set small value to increase the edge enhancement strength to enhance detail. It is recommend to use the following default value. If user want to adjust the noise size at all Y range(0-255), it just needs to adjust noise_level. Noise ? Default value: edge_weight_src_sel =0 noise_curve[17] ={50,50,50,48,47,44,39,38,37,36,35,35,35,35,35,35,35} e More strengthen on detail in bright region to avoid enhancing noise. edge_weight_src_sel =1 noise_curve[17] = {0, 38, 46, 51, 54, 57, 59, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62} e More strengthen on detail in dark region to enhance thin detail, but the noise in dark region will be enhanced, either.","title":"5.1 Overview"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#52-setting-interface","text":"","title":"5.2 Setting Interface"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#521-proc","text":"","title":"5.2.1 Proc"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpesharpendump_info","text":"[Description] Read all Sharpen parameters of the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/sharpen/dump_info","title":"l /proc/videograph/vpe/sharpen/dump_info"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpesharpensharp_en","text":"[Description] Read or write the enable status of the cuurent channel. [Command] Write : proc command Target Parameter echo [ sharp_en (0~1) ] > /proc/videograph/vpe/sharpen/sharp_en sharpen_en Read : cat /proc/videograph/vpe/sharpen/shp_en Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [ sharp_en (0~1) ] > /proc/videograph/vpe/sharpen/sharp_en =============================================================== sharpen_en = sharpen_en ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)**","title":"l /proc/videograph/vpe/sharpen/sharp_en"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpesharpenedge_weight_src_sel","text":"[Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [src_sel (0 ~ 1) ] > /proc/videograph/vpe/sharpen/edge_weight_src_sel edge_weight_src_sel Read : cat /proc/videograph/vpe/sharpen/edge_weight_src_sel Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [src_sel (0 ~ 1)] > /proc/videograph/vpe/sharpen/edge_weight_src_sel =============================================================== edge_weight_src_sel = edge_weight_src_sel 0: after gamma 1: before gamma ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)**","title":"l /proc/videograph/vpe/sharpen/edge_weight_src_sel"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpesharpenedge_weigt_gain","text":"[Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [gain (0~255) ] > /proc/videograph/vpe/sharpen/edge_weight_gain edge_weight_gain Read : cat /proc/videograph/vpe/sharpen/edge_weight_gain Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [gain (0~255)] > /proc/videograph/vpe/sharpen/edge_weight_gain =============================================================== edge_weight_gain = edge_weight_gain ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)**","title":"l /proc/videograph/vpe/sharpen/edge_weigt_gain"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpesharpenedge_weight_th","text":"[Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [th (0~255) ] > /proc/videograph/vpe/sharpen/edge_weight_th edge_weight_th Read : cat /proc/videograph/vpe/sharpen/edge_weight_th Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [th (0~255)] > /proc/videograph/vpe/sharpen/edge_weight_th =============================================================== edge_weight_th = edge_weight_th ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)**","title":"l /proc/videograph/vpe/sharpen/edge_weight_th"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpesharpenblend_inv_gamma","text":"[Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [th (0~128) ] > /proc/videograph/vpe/sharpen/blend_inv_gamma blend_inv_gamma Read : cat /proc/videograph/vpe/sharpen/blend_inv_gamma Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [th (0~128) > /proc/videograph/vpe/sharpen/blend_inv_gamma =============================================================== blend_inv_gamma = blend_inv_gamma ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)**","title":"l /proc/videograph/vpe/sharpen/blend_inv_gamma"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpesharpenedge_sharp_str","text":"[Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [str1 (0~255)] [str2 (0~255)] > /proc/videograph/vpe/sharpen/edge_sharp_str edge_sharp_str1 edge_sharp_str2 Read : cat /proc/videograph/vpe/sharpen/edge_sharp_str Output :","title":"l /proc/videograph/vpe/sharpen/edge_sharp_str"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpesharpenflat_sharp_str","text":"[Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [str (0~255)] > /proc/videograph/vpe/sharpen/flat_sharp_str flat_sharp_str Read : cat /proc/videograph/vpe/sharpen/flat_sharp_str Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [str (0~255)] > /proc/videograph/vpe/sharpen/flat_sharp_str =============================================================== flat_sharp_str = flat_sharp_str ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)**","title":"l /proc/videograph/vpe/sharpen/flat_sharp_str"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpesharpencoring_th","text":"[Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [coring_th (0~255)] > /proc/videograph/vpe/sharpen/coring_th coring_th Read : cat /proc/videograph/vpe/sharpen/coring_th Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [coring_th (0~255)] > /proc/videograph/vpe/sharpen/coring_th =============================================================== coring_th = coring_th ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)**","title":"l /proc/videograph/vpe/sharpen/coring_th"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpesharpenhalo_clip","text":"[Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [bright_clip (0~128)] [dark_clip(0~128)] > /proc/videograph/vpe/sharpen/halo_clip bright_halo_clip drak_halo_clip Read : cat /proc/videograph/vpe/sharpen/halo_clip Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [bright_clip (0~128)] [dark_clip(0~128)] > /proc/videograph/vpe/sharpen/halo_clip =============================================================== Bright_halo_clip = bright_halo_clip Dark_halo_clip = dark_halo_clip ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)**","title":"l /proc/videograph/vpe/sharpen/halo_clip"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpesharpennoise_curve","text":"[Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [noise_curve[0] (0~255)]\u2026. [noise_curve [16] (0~255)] > /proc/videograph/vpe/sharpen/noise_curve noise_curve[17] Read : cat /proc/videograph/vpe/sharpen/noise_curve Output : **![\u6587\u5b57\u65b9\u584a: Command : echo [noise_curve[0] (0~255)]\u2026. [noise_curve [16] (0~255)] > /proc/videograph/vpe/sharpen/noise_curve =============================================================== noise_curve = noise_curve[0] \u2026\u2026\u2026.noise_curve[16] ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)**","title":"l /proc/videograph/vpe/sharpen/noise_curve"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#522-vendor-api","text":"[Description] Get and set the sharpen parameters corresponding to current path_id. [Command] ??????? Get \uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_SHARP, VENDOR_VIDEO_PARAM_SHARP *p_param); ??????? Set \uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_SHARP, VENDOR_VIDEO_PARAM_SHARP *p_param); [ \u5b9a\u7fa9 ]","title":"5.2.2 Vendor API"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#6-edge-smoothing-es","text":"This module is edge smoothing. The main function is to eliminate aliasing in the picture to improve the smoothness of the picture.","title":"6 Edge Smoothing (ES)"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#61-overview","text":"The characteristics of this algorithm are to effectively smooth the edges of the input image, correct the jaggedness in the edge area of the input image, and avoid the Sharpen module to enhance the degree of jaggedness in the image edge again. The algorithm divides the input image into edge area and detail area, calculates the direction of the edge on the edge area, and then performs LPF convolution adaptively along the edge direction to smooth the edge of the image. The Edge Mask can be adjusted to avoid high-frequency areas being blurred due to smoothing. Please refer to the following figure for the main process:","title":"6.1 Overview"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#62-parameter-description","text":"Table 6?1 ES Parameter List Parameter Range Def Description edge_smooth_en 0~1 0 Edge smooth enable edge_smooth_y_edeng_th_lo 0~255 10 Adjust the strength threshold of detail areas in the picture Please refer to the advanced instructions edge_smooth_y_edeng_th_hi 0~255 70 Adjust the strength threshold of the edge area in the picture Please refer to the advanced instructions edge_smooth_y_ew_lo 0~255 2 Adjust the smoothing strength weight of detail areas in the picture Please refer to the advanced instructions edge_smooth_y_ew_hi 0~255 32 Adjust the suppression threshold for the smoothing of high-frequency areas in the picture. The larger the value, the easier it is to determine and smooth the high-frequency area. Therefore, the larger the value, the smoother the high-frequency area, and the smaller the value, the clearer the high-frequency area edge_smooth_y_edi_th 0~63 31 Suppresses the strength of smoothing in the high-frequency region. The larger the value, the stronger the smoothing in the high-frequency region. edge_smooth_y_ds_str 0~7 5 Adjust the strength of the smoothing filter in the picture. The larger the value, the stronger the smoothing degree. Advance description: l edge_smooth_y_edeng_th_lo , edge_smooth_y_edeng_th_hi, edge_smooth_y_ew_lo, edge_smooth_y_ew_hi : The strength of edge smooth is controlled by the edge energy intensity of the input image, where edge_smooth_y_edeng_th_hi and edge_smooth_y_edeng_th_lo are the ranges that set the edge area and the detail area, and edge_smooth_y_ew_hi and edge_smooth_y_ew_lo set the smoothness strength of the edge area and detail area. The larger the number, the stronger of the smoothness. The relationship between the edge area and the detail area is a continuous linear change, and the corresponding relationship is shown in the following figure:","title":"6.2 Parameter Description"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#63-setting-interface","text":"","title":"6.3 Setting Interface"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#631-proc","text":"","title":"6.3.1 Proc"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpeesparam","text":"[Description] Read all edge smoothing parameters of the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/es/param","title":"l /proc/videograph/vpe/es/param"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpeesedge_smooth_en","text":"[Description] Set the edge smooth switch of the current camera channel. [Command] Write : proc command Target Parameter echo [edge_smooth_en (0~1)] > /proc/videograph/vpe/es/edge_smooth_en edge_smooth_en","title":"l /proc/videograph/vpe/es/edge_smooth_en"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpeesedge_smooth_out_sel","text":"[Description] Set the edge smooth debugging switch of the current camera channel. [Command] Write : proc command Target Parameter echo [edge_smooth_out_sel (0~1)] > /proc/videograph/vpe/es/edge_smooth_out_sel edge_smooth_out_sel Read : cat /proc/videograph/vpe/es/edge_smooth_out_sel Output :","title":"l /proc/videograph/vpe/es/edge_smooth_out_sel"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpeesedge_smooth_th","text":"[Description] Set the edge smooth related threshold of the current camera channel. [Command] Write : proc command Target Parameter echo [y_edeng_th_lo (0~255)] [y_edeng_th_hi (0~255)] [y_ew_lo (0~255)] [y_ew_hi (0~255)] > /proc/videograph/vpe/es/edge_smooth_th edge_smooth_y_edeng_th_l edge_smooth_y_edeng_th_hi edge_smooth_y_ew_lo edge_smooth_y_ew_hi Read : cat /proc/videograph/vpe/es/edge_smooth_th Output :","title":"l /proc/videograph/vpe/es/edge_smooth_th"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpeesedge_smooth_y_edi_th","text":"[Description] Set the edge smooth mask related parameters of the current camera channel. [Command] Write : proc command Target Parameter echo [edge_smooth_y_edi_th (0~63)] > /proc/videograph/vpe/es/edge_smooth_y_edi_th edge_smooth_y_edi_th Read : cat /proc/videograph/vpe/es/edge_smooth_y_edi_th Output :","title":"l /proc/videograph/vpe/es/edge_smooth_y_edi_th"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpeesedge_smooth_y_ds_str","text":"[Description] Sets the filter strength of the edge smooth of the current camera channel. [Command] Write : proc command Target Parameter echo [edge_smooth_y_ds_str (0~7)] > /proc/videograph/vpe/es/edge_smooth_y_ds_str edge_smooth_y_ds_str Read : cat /proc/videograph/vpe/es/edge_smooth_y_ds_str Output :","title":"l /proc/videograph/vpe/es/edge_smooth_y_ds_str"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#632-vendor-api","text":"[Description] Get and set the edge smooth parameters corresponding to current path_id. [Command] Get \uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_EDGE_SMOOTH, VENDOR_VIDEO_PARAM_SHARP *p_param); ??????? Set \uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_EDGE_SMOOTH, VENDOR_VIDEO_PARAM_SHARP *p_param); [Definition]","title":"6.3.2 Vendor API"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#7-scaling-sca","text":"Inupt/Output low pass filter process with different resolution. The recommend maximum scaling down ratio is 8, and the recommend maximum scaling up ratio is 8.","title":"7 Scaling (SCA)"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#71-overview","text":"This is image scaling module, the major concept is interpolation and smooth process.","title":"7.1 Overview"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#72-parameter-description","text":"Table 7?1 SCA Parameter List Parameter Range Def Description sca_y_luma_algo_en 0~3 0 Algorithm select for vertical luma scaler. 0: judge by HW algorithm 1: select the nearest point on the left side 2: select the left side point and perform low pass filter process 3: the same as option 0 It is recommend to set 0. sca_x_luma_algo_en 0~3 0 Algorithm select for horizontal luma scaler. 0: judge by HW algorithm 1: select the nearest point on the left side 2: select the left side point and perform low pass filter process 3: the same as option 0 It is recommend to set 0. sca_y_chroma_algo_en 0~3 0 Algorithm select for vertical chroma scaler. 0: judge by HW algorithm 1: select the nearest point on the left side 2: bilinear interpolation 3: average It is recommend to set 0. sca_x_chroma_algo_en 0~3 0 Algorithm select for horizontal chroma scaler. 0: judge by HW algorithm 1: select the nearest point on the left side 2: bilinear interpolation 3: average It is recommend to set 0. sca_map_sel 0~1 0 Select scaler source mapping format. 0: without 0.5 pixel distance shift(start from the 0th pixel of image image) 1: with 0.5 pixel distance shift(start from the 0.5th pixel of image image) If set to 1, when the size of input image and output image is the same or the size is multiple of 2, the scaling performance of output image will similar to perform low pass filter. It is recommend to set 0. sca_ceffH_0~3 -128~127 [0, 0, 0, 64] LPF coefficient in horizontal direction. Please refer to advance description. \u203bThe software limit range is between -128~127, to reduce memory usage. sca_ceffv_0~3 -128~127 [0, 0, 0, 64] LPF coefficient in vertical direction. Please refer to advance description. \u203bThe software limit range is between -128~127, to reduce memory usage. des_drt 0, 2,3 0 YUV domain transform 0: bypass 2: PC level to TV level (Y: 16~235 / C:16~240) 3: TV level to PC level? (Y: 0~235 C:0~255) 255: decide by job parameter of AP rather than driver (default value is 255, other settings are used for debug) Advance description: l sca_ceffH_0~3, sca_ceffV_0~3: LPF coefficients in horizontal direction and vertical direction. User can adjust LPF coefficients to fine tune sawtooth phenomenon in oblique line caused by scaling. ?Table 7?2 Scaler Low pass filter default parameter list Scaling Ratio (R) HCoef0 HCoef1 HCoef2 HCoef3 VCoef0 VCoef1 VCoef2 VCoef3 \u2267 1x 0 0 0 64 0 0 0 64 1 < R \u2266 1.25x 0 0 3 58 0 0 3 58 1.25 < R \u2266 1.5x 0 0 7 50 0 0 7 50 1.5 < R \u2266 1.75x 0 0 11 42 0 0 11 42 1.75 < R \u2266 2x 0 1 13 36 0 1 13 36 2 < R \u2266 2.25x 0 1 15 32 0 1 15 32 2.25 < R \u2266 2.5x 0 2 15 30 0 2 15 30 2.5 < R \u2266 2.75x 0 3 15 28 0 3 15 28 2.75 < R \u2266 3x 0 4 15 26 0 4 15 26 3 < R \u2266 3.25x 1 4 15 24 1 4 15 24 3.25 < R \u2266 3.5x 1 5 15 22 1 5 15 22 3.5 < R \u2266 3.75x 2 7 14 18 2 7 14 18 3.75 < R \u2266 4x 3 8 13 16 3 8 13 16 4 < R \u2266 5x 4 8 13 14 4 8 13 14 5 < R \u2266 6x 4 9 12 14 4 9 12 14 6x < R \u2266 7x 6 9 11 12 6 9 11 12 7x < R 6 9 11 12 6 9 11 12","title":"7.2 Parameter Description"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#73-setting-interface","text":"","title":"7.3 Setting Interface"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#731-proc","text":"","title":"7.3.1 Proc"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpescaparam","text":"[Description] Read all SCA parameters of the cuurent scaling ratio [Command] Write : Not support. Read : cat /proc/videograph/vpe/sca/param **![\u6587\u5b57\u65b9\u584a: fd(0x00000000) sca_y_luma_algo_en = 0 sca_x_luma_algo_en = 0 sca_y_chroma_algo_en = 0 sca_x_chroma_algo_en = 0 sca_map_sel = 0 sca_1x_param = { 0, 0, 0, 64, 0, 0, 0, 64 } sca_1.25x_param = { 0, 0, 0, 64, 0, 0, 0, 64 } \u2026 ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image057.png)**","title":"l /proc/videograph/vpe/sca/param"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpescactrl_param","text":"[Description] Set SCA controlling parameter for specific ratio. [Command] Write : proc command Target Parameter echo [sca_luma_algo (0~3)] [sca_chroma_algo (0~3)] [sca_map_sel (0~1)] > /proc/videograph/vpe/sca/ctrl_param index: Target ratio The command \u201csca_luma_algo\u201d set parameters \u201csca_y_luma_algo_en\u201d and \u201csca_x_luma_algo_en\u201d at the same time. The command \u201csca_chroma_algo\u201d set parameters \u201csca_y_chroma_algo_en\u201d and \u201csca_x_chroma_algo_en\u201d at the same time. The command \u201csca_map_sel\u201d set \u201csca_map_sel\u201d parameter. Read : Not support","title":"l /proc/videograph/vpe/sca/ctrl_param"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpescalpf_param","text":"[Description] Set SCA low pass filter parameter for specific ratio. [Command] Write : proc command Target Parameter echo [index (0~16)] [coeffH[0]] [coeffH[1]] [coeffH[2]] ]coeffH[3]] [coeffV[0]] [coeffV[1]] [coeffV[2]] [coeffV[3]] (-128 ~ 127) >? /proc/videograph/vpe/sca/lpf_param index: Target ratio coeffH : sca_ceffH[4] coeffV: sca_ceffV[4] \u203bThe software limit range is between -128~127, to reduce memory usage. Read : Not support","title":"l /proc/videograph/vpe/sca/lpf_param"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpescayuv_range","text":"[Description] Read or write YUV range of SCA at each one of the channel. \u203b Parameter can be set by put job of AP depends on channel requests, it is not recommend to be set by this proc command or ioctl to avoid conflicts. This command is used for debugging. [Command] Write : proc command Target Parameter echo [fd range] > /proc/videograph/vpe/sca /yuv_range yuv_range: 0, 2, 3, 255 (disable) \u203bdisable represent AP directly control parameters des_drt Read : cat /proc/videograph/vpe/sca/yuv_range Output : **![\u6587\u5b57\u65b9\u584a: Command : echo < fd range >(0:bypass, 2:TV, 3:PC, 255:diable) =============================================================== fd(0x40000000) yuv range = 0 fd(0x40000001) yuv range = 0 fd(0x40000002) yuv range = 0 fd(0x40000003) yuv range = 0 ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)**","title":"l /proc/videograph/vpe/sca/yuv_range"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#732-vendor-api","text":"[Description] Get and set the scaling parameters corresponding to current path_id. [Command] ??????? Get \uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_SCA, VENDOR_VIDEO_PARAM_SCA_SET *p_param); ??????? Set \uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_SCA, VENDOR_VIDEO_PARAM_SCA_SET *p_param); [Definition] **![\u6587\u5b57\u65b9\u584a: typedef struct _VENDOR_VIDEO_PARMA_SCA_CTRL { INT32 sca_ceffH[4]; ///< LPF coefficient in horizontal direction INT32 sca_ceffV[4]; ///< LPF coefficient in vertical direction } VENDOR_VIDEO_PARMA_SCA_CTRL; typedef struct _VENDOR_VIDEO_PARAM_SCA_SET { UINT8 sca_y_luma_algo_en; ///< Algorithm select for vertical luma scaler UINT8 sca_x_luma_algo_en; ///< Algorithm select for horizontal luma scaler UINT8 sca_y_chroma_algo_en; ///< Algorithm select for vertical chroma scaler UINT8 sca_x_chroma_algo_en; ///< Algorithm select for horizontal chroma scaler UINT8 sca_map_sel; ///< Scaler source mapping format select VENDOR_VIDEO_PARMA_SCA_CTRL sca_1000x_param; ///< scaling parameter for scaling ratio 1.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_1250x_param; ///< scaling parameter for scaling ratio 1.25x VENDOR_VIDEO_PARMA_SCA_CTRL sca_1500x_param; ///< scaling parameter for scaling ratio 1.50x VENDOR_VIDEO_PARMA_SCA_CTRL sca_1750x_param; ///< scaling parameter for scaling ratio 1.75x VENDOR_VIDEO_PARMA_SCA_CTRL sca_2000x_param; ///< scaling parameter for scaling ratio 2.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_2250x_param; ///< scaling parameter for scaling ratio 2.25x VENDOR_VIDEO_PARMA_SCA_CTRL sca_2500x_param; ///< scaling parameter for scaling ratio 2.50x VENDOR_VIDEO_PARMA_SCA_CTRL sca_2750x_param; ///< scaling parameter for scaling ratio 2.75x VENDOR_VIDEO_PARMA_SCA_CTRL sca_3000x_param; ///< scaling parameter for scaling ratio 3.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_3250x_param; ///< scaling parameter for scaling ratio 3.25x VENDOR_VIDEO_PARMA_SCA_CTRL sca_3500x_param; ///< scaling parameter for scaling ratio 3.50x VENDOR_VIDEO_PARMA_SCA_CTRL sca_3750x_param; ///< scaling parameter for scaling ratio 3.75x VENDOR_VIDEO_PARMA_SCA_CTRL sca_4000x_param; ///< scaling parameter for scaling ratio 4.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_5000x_param; ///< scaling parameter for scaling ratio 5.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_6000x_param; ///< scaling parameter for scaling ratio 6.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_7000x_param; ///< scaling parameter for scaling ratio 7.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_8000x_param; ///< scaling parameter for scaling ratio 8.00x } VENDOR_VIDEO_PARAM_SCA_SET; ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image058.png)**","title":"7.3.2 Vendor API"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#8-distortion-correction-engine-dce","text":"","title":"8 Distortion Correction Engine (DCE)"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#81-overview","text":"This is lens distortion calibration module, it can perform calibration on wide-angle lens and fish-eye lens.","title":"8.1 Overview"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#82-dce-parameter-description","text":"Table 8?1 DCE Parameter List Parameter Range Def Description dce_mode 0~1 0 Select distortion function 0: GDC lens calibration 1: 2DLUT self-define XY coordinate distortion lut2d_sz 0~5 0 Size selection of 2D look-up table. The larger the size, the more precision to describe distortion. 0: 9x9 3: 65x65 4: 129x129 5: 257x257 lsb_rand 0~1 0 LSB 2 bit random generation for internal 10 bit->8 bit image. 0: fixed fill 0 1: random generate 0~3 fovbound 0~1 0 FOV boundary process method selection. When the distortion result can not fill the total output image, select different way to proceed the exceed range. 0: Replace out of boundary pixels with duplicate nearest pixel 1: Replace out of boundary pixels with bound pixels boundy 0~1023 0 Bound value for Y component(u8.2) boundu 0~1023 0 Bound value for U component(u8.2) boundv 0~1023 0 Bound value for V component(u8.2) cent_x_s 213-1 0 Define lens center of x-axis. It is recommend to set width/2. cent_y_s 213-1 0 Define lens center of y-axis. It is recommend to set height/2. xdist 0~4095 0 X input distance factor, for oval shape modeling. It is recommend to set 4095, which is suitable for most situation. ydist 0~4095 0 Y input distance factor, for oval shape modeling. It is recommend to set 4095, which is suitable for most situation. geo_lut 0~65535 0 The GEO deformation gain table, a total of 65 points, indicates the magnification of each pixel in the image at a different distance from the deformation center (magnification = 65535 * input radius / output radius), the gainbase is 65535, please refer to Note 2 for the gain table example. Value range\uff1a[0, 65535]\u3002 normfact 0~255 128 Radius normalization factor. Normfact = 1 << (normbit + 7) / R2 normbit 0~31 31 Radius normalization shift bit. R2 = (width/2)2+(height/2)2 The total bit number of R2 is normbit. Example: 9602+5402 = 1213200 (21 bits) fovgain 0~4095 0 Adjust the scaling ratio of the final distortion coordinate to preserve FOV. Scale down factor for FOV preservation. Due to it will effect the calibration performance, it is recommend to set 1024. hfact 0 ~ 224 -1 0 Horizontal scaling factor for 2DLut scaling up(u0.24). ((2DLUT horizontal pixel number \u2013 1) << 24) / (width \u2013 1) vfact 0 ~ 224 -1 0 Vertical scaling factor for 2DLut scaling up(u0.24). ((2DLUT vertical pixel number \u2013 1) << 24) / (height \u2013 1) xofs_i 0~127 0 2DLut x offset, integer part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. xofs_f 0~224-1 0 2DLut x offset, fraction part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. yofs_i 0~127 0 2DLut y offset, integer part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. yofs_f 0~224-1 0 2DLut y offset, fraction part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. [Note 1] Adjust geo_fov_gain, the left side is 1024, the right side is 1320, you can observe the increase in the field of view on the right side. ? [Note 2] The example of the GEO deformation gain table, from left to right, corresponds to the deformation amount from the center of the image to the edge. This parameter group indicates that the larger the deformation amount toward the edge is. This example is a barrel deformation correction. R is the distance from the center of the image to each point. This distance can be understood as the radius of the circle. Ri represents the radius of each point of the input (before correction) image. Ro represents the radius of each point of the output (corrected) image. RoMax represents the longest distance from the center of the output image to the four corners. If the center of the image falls at 1/2 of the width and height, the four corners are all equal, and they are the longest distances.","title":"8.2 DCE Parameter Description"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#83-setting-interface","text":"","title":"8.3 Setting Interface"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#831-proc","text":"","title":"8.3.1 Proc"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpedcedump_info","text":"[Description] Read all DCE parameters at the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/dce/dump_info **![\u6587\u5b57\u65b9\u584a: dce_en = 0 dce_mode = 1 lut2d_sz = 3 lut2d_vaddr = 0x0000000000000000 lut2d_paddr = 0x0 lsb_rand = 0 fovbound = 1 boundy = 512 boundu = 512 boundv = 512 cent_x_s = 720 cent_y_s = 720 xdist = 4095 ydist = 4095 normfact = 0 normbit = 0 fovgain = 1024 hfact = 745654 vfact = 745654 xofs_i = 0 xofs_f = 0 yofs_i = 0 yofs_f = 0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image053.png)**","title":"l /proc/videograph/vpe/dce/dump_info"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpedcech_en","text":"[Description] Read or write the enable status of the current channel. [Command] Write : proc command Target Parameter echo [ dc_en 0~1 ] > /proc/videograph/vpe/dce/ch_en dc_en Read : cat /proc/videograph/vpe/dce/ch_en Output :","title":"l /proc/videograph/vpe/dce/ch_en"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#832-vendor-api","text":"[Description] Get and set the dce parameters corresponding to current path_id. [Command] ??????? Get\uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEOPROC_DEWARP_INFO, VENDOR_DEWARP_INFO *p_param); ??????? Set\uff1a HD_RESULT c(HD_PATH_ID path_id, VENDOR_ VENDOR_VIDEOPROC_DEWARP_INFO, VENDOR_DEWARP_INFO *p_param); [Define] **![\u6587\u5b57\u65b9\u584a: typedef struct _VENDOR_DEWARP_CTRL { BOOL dc_enable; BOOL dctg_enable; } VENDOR_DEWARP_CTRL; typedef enum _VENDOR_DEWARP_MODE { VENDOR_DEWARP_DEWARP_MODE_GDC = 0, VENDOR_DEWARP_DEWARP_MODE_2DLUT = 1, ENUM_DUMMY4WORD(VENDOR_DEWARP_DEWARP_MODE) } VENDOR_DEWARP_MODE; typedef struct _VENDOR_DEWARP_DGC_PARM { INT32 cent_x_s; ///< Lens center of x axis (signed) INT32 cent_y_s; ///< Lens center of y axis (signed) UINT32 lens_r; ///< Radius of Lens UINT32 xdist; ///< X input distance factor, for oval shape modeling UINT32 ydist; ///< Y input distance factor, for oval shape modeling UINT8 normfact; ///< Radius normalization factor (u1.7) UINT8 normbit; ///< Radius normalization shift bit UINT16 geo_lut[VENDOR_GEO_LUT_X]; ///< GDC look-up table } VENDOR_DEWARP_DGC_PARM; typedef struct _VENDOR_DEWARP_2DLUT_PARM { UINT8 lut2d_sz; ///< Size selection of 2D look-up table, 0:9x9, 3:65x65 UINT32 hfact; ///< Horizontal scaling factor for 2DLut scaling up (u0.24) UINT32 vfact; ///< Vertical scaling factor for 2DLut scaling up (u0.24) UINT8 xofs_i; ///< 2DLUT x offset, integer part UINT32 xofs_f; ///< 2DLUT x offset, fraction part UINT8 yofs_i; ///< 2DLUT y offset, integer part UINT32 yofs_f; ///< 2DLUT xy offset, fraction part } VENDOR_DEWARP_2DLUT_PARM; typedef struct _VENDOR_DEWARP_FOV_PARM { UINT8 fovbound; ///< FOV boundary process method selection UINT16 boundy; ///< Bound value for Y component (u8.2) UINT16 boundu; ///< Bound value for U component (u8.2) UINT16 boundv; ///< Bound value for V component (u8.2) UINT16 fovgain; ///< Scale down factor for FOV preservation (u2.10) } VENDOR_DEWARP_FOV_PARM; ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image064.png)** **![\u6587\u5b57\u65b9\u584a: typedef struct _VENDOR_DEWARP_INFO { VENDOR_DEWARP_MODE mode; VENDOR_DEWARP_DGC_PARM dgc; VENDOR_DEWARP_2DLUT_PARM lut2d; VENDOR_DEWARP_FOV_PARM fov; } VENDOR_DEWARP_INFO; typedef struct _VENDOR_DEWARP_2DLUT_TABLE { UINT32 tbl[VENDOR_GEO_LUT]; } VENDOR_DEWARP_2DLUT_TABLE; ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image058.png)**","title":"8.3.2 Vendor API"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#9-dc-table-generatordctg","text":"","title":"9 DC Table Generator(DCTG)"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#91-overview","text":"For perspective projection application, in order to increase the convenience of usage, DCTG module let user to set the desired angle and size with an instinct way to generate DCTG parameters automatically. Whenever this function is enabled, manual set DCE 2D-LUT function will be invalid. [Note] ??When using DCTG function, user needs to set two parameters enable, one is dc_enable, the other is dctg_en. Please refer to the following description: The \u201ctheta\u201d is the top/bottom angle. The \u201cphi\u201d is the rotate angle. The \u201crot_y\u201d is the rotate offset of (x, z) plane towards Y-axis. The \u201crot_z\u201d is the rotate offset of (x, y) plane towards Z-axis. Generate LUT: Define the rotate angle of FOV by phi_st/phi_ed, and then rotate to FOV location by rot_y. Define the top/bottom angle of FOV by theta_st/theta_ed, and then rotate to FOV location by rot_z.","title":"9.1 Overview"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#92-parameter-description","text":"Table 9?1 DCTG parameter list Parameter Range Def Description dctg_en 0-1 0 DCTG ON/OFF mount_type 0~1 0 Camera mount type. 0: Ceiling mount 1: Floor mount lut2d_sz 0, 3 3 Select size of 2D look-up table, this parameter must the same with DCE parameter. 0: 9x9 3: 65x65 lens_r 0~215-1 0 Valid radius of fish-eye lens, the unit is pixel. Please refer to advance description. lens_x_st 0~214-1 0 The start x position of fish-eye lens at the source image, the unit is pixel. lens_y_st 0~214-1 0 The start y position of fish-eye lens at the source image, the unit is pixel. theta_st -180 ~ 180 (-*pi ~ *pi) 0 FOV theta start radian. theta_ed -180 ~ 180 (-*pi ~ *pi) 0 FOV theta end radian. theta_end > theta_st: normal image theta_end < theta_st: flip image phi_st -360 ~ 360 (-2*pi ~ 2*pi) 0 OV phi start radian. phi_ed -360 ~ 360 (-2*pi ~ 2*pi) 0 FOV phi end radian. (-2*pi ~ 2*pi) phi_end > theta_st: normal image phi_end < theta_st: flip image rot_z -360 ~ 360 (-2*pi ~ 2*pi) 0 Z-axis rotate radian rot_y -360 ~ 360 (-2*pi ~ 2*pi) 0 Y-zxis rotate radian. Advance description: l lens_r: The valid radius of fish-eye device. l lens_x_st : The start x position of fish-eye lens at the source image, the unit is pixel. l lens_y_st : The start y position of fish-eye lens at the source image, the unit is pixel.","title":"9.2 Parameter Description"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#93-setting-interface","text":"","title":"9.3 Setting Interface"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#931-proc","text":"","title":"9.3.1 Proc"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpedctgdump_info","text":"[Description] Read all dctg parameters of the current channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/dctg/dump_info","title":"l /proc/videograph/vpe/dctg/dump_info"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpedctgch_en","text":"[Description] ??????? Set dctg enable. [Command] Write : proc command Target Parameter echo [dctg_en] > /proc/videograph/vpe/dctg/ch_en dctg_en: dctg enable Read : cat /proc/videograph/vpe/dctg/ch_en Output :","title":"l /proc/videograph/vpe/dctg/ch_en"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpedctgphi","text":"[Description] Set FOV phi start radian [Command] Write : proc command Target Parameter echo [st] [ed] > /proc/videograph/vpe/dctg/phi st: FOV phi start radian ed : FOV phi end radian \u203bangle range: -360 ~ 360 Read : cat /proc/videograph/vpe/dctg/phi Output :","title":"l /proc/videograph/vpe/dctg/phi"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpedctgrot","text":"[Description] Set Z-axis and Y-zxis rotate radian. [Command] Write : proc command Target Parameter echo [z] [y] > /prc/videograph/vpe/dctg/rot z: Z-axis rotate radian. y: Y-zxis rotate radian \u203bangle range: -360 ~ 360 Read : cat /proc/videograph/vpe/dctg/rot Output :","title":"l /proc/videograph/vpe/dctg/rot"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#l-procvideographvpedctgtheta","text":"[Description] Set FOV theta start radian. [Command] Write : proc command \u76ee\u6a19\u53c3\u6578 echo [st] [ed] > /prc/videograph/vpe/dctg/theta st: FOV theta start radian. ed : FOV theta end radian \u203bangle range: -180 ~ 180 Read : cat /proc/videograph/vpe/dctg/theta Output :","title":"l /proc/videograph/vpe/dctg/theta"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#932-vendor-api","text":"[Description] Get and set the dctg parameters corresponding to current path_id. [Command] ??????? Get\uff1a HD_RESULT vendor_videoproc_get(HD_PATH_ID path_id, VENDOR_VIDEOPROC_DEWARP_DCTG_INFO, VENDOR_DEWARP_DCTG_INFO *p_param); ??????? Set\uff1a HD_RESULT vendor_videoproc_set(HD_PATH_ID path_id, VENDOR_VIDEOPROC_DEWARP_DCTG_INFO, VENDOR_DEWARP_DCTG_INFO *p_param); [Define] **![\u6587\u5b57\u65b9\u584a: typedef struct _VENDOR_DEWARP_CTRL { BOOL dc_enable; BOOL dctg_enable; } VENDOR_DEWARP_CTRL; typedef struct _VENDOR_DEWARP_DCTG_INFO { VENDOR_DEWARP_DCTG_MODE mode; VENDOR_DEWARP_DCTG_LENS_PARM lens; VENDOR_DEWARP_DCTG_FOV_PARM fov; } VENDOR_DEWARP_DCTG_INFO; typedef enum _VENDOR_DEWARP_DCTG_MODE { VENDOR_DEWARP_DCTG_MODE_90 = 0, VENDOR_DEWARP_DCTG_MODE_360 = 1, ENUM_DUMMY4WORD(VENDOR_DEWARP_DCTG_MODE) } VENDOR_DEWARP_DCTG_MODE; typedef struct _VENDOR_DEWARP_DCTG_LENS_PARM { UINT8 mount_type; ///< Camera mount type. 0:Ceiling mount, 1:Floor mount UINT8 lut2d_sz; ///< Size selection of 2D look-up table, 0:9x9, 3:65x65, should the same with DCE setting. UINT32 lens_r; ///< Radius of Lens UINT32 lens_x_st; ///< Lens start x position at a source image UINT32 lens_y_st; ///< Lens start y position at a source image } VENDOR_DEWARP_DCTG_LENS_PARM; typedef struct _VENDOR_DEWARP_DCTG_FOV_PARM { INT32 theta_st; ///< FOV theta start radian (s4.16) Range: - pi ~ pi INT32 theta_ed; ///< FOV theta end radian (s4.16) Range: - pi ~ pi INT32 phi_st; ///< FOV phi start radian (s4.16) Range: -2 pi ~ 2 pi INT32 phi_ed; ///< FOV phi end radian (s4.16) Range: -2 pi ~ 2 pi INT32 rot_z; ///< Z-axis rotate radian (s4.16) Range: -2 pi ~ 2 pi INT32 rot_y; ///< Y-axis rotate radian (s4.16) Range: -2 pi ~ 2 pi } VENDOR_DEWARP_DCTG_FOV_PARM; ](NT9833x_VPE_IQ_Tuning_Guide_en.files/image070.png)**","title":"9.3.2 Vendor API"},{"location":"NT9833x_VPE_IQ_Tuning_Guide_en.html#10-revise-history","text":"Version Date Advisor Description 0.1.00 2021/01/20 Allen Hsu First version. 0.2.00 2021/3/26 Allen Hsu Add description of Vendor command. 0.3.00 2022/4/11 Mina Wang Add description for dce and dctg","title":"10 Revise History"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html","text":"1 Introduction \u00b6 The major purpose of hd_videodec is to get bitstream data from upper unit, and controls the video decoder to decode the bitstream data then return the YUV frame data which can be used for displaying. This document will talk about the red block in the following diagram. The device driver is not the main point in this document. Module diagram is shown as below: 1.1 Block Diagram \u00b6 1.1.1 Block Diagram (NT9668X / NT9852X / NT9856X / NT98530) \u00b6 The block diagram of H264/H265 codec is shown as below: 1.1.2 Block Diagram (NT9831X / NT9832X / NT9833X / NT98331) \u00b6 The block diagram of H264 codec is shown as below: The block diagram of H265 codec is shown as below: 1.2 Basic Flow \u00b6 The call sequence is needed to be done correctly for the unit. The standard starting flows of most modules are init, open, get, set and start. The standard closing flows of most modules are stop, unbind, close and uninit. The basic flow is shown as below. Now, below section in this chapter is mainly about what things to do in those functions above. 1.3 Single Trigger Operation \u00b6 Single trigger operation is used to trigger the unit to do one job, such as to grab one YUV frame from video capture; or encode one frame to bitstream by using video encoder. There are two types of functions for the input port and output port. The sequence for input port is new, push and release; the sequence for output port is pull and release. The flow is shown as below. 1.4 Multi List Operation \u00b6 Multi list operation is used to send mulit bitstream simultaneously, it is very efficiency in the multi channels case. The flow is shown as below: 2 Functions Definition \u00b6 2.1 hd_videodec_init \u00b6 [Description] Initialize the unit [Syntax] HD_RESULT hd_videodec_init(VOID); [Parameter] Value Description VOID Not available [Return Value] Value Description HD_OK Success HD_ERR_NG Failure 2.2 hd_videodec_open \u00b6 [Description] Open the unit [Syntax] HD_RESULT hd_videodec_open(HD_IN_ID in_id, HD_OUT_ID out_id, HD_PATH_ID* p_path_id) [Parameter] Value Description in_id Id of input port. out_id Id of output port. p_path_id Pointer of the path id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure 2.3 hd_videodec_get \u00b6 [Description] Get parameters from unit by path id [Syntax] HD_RESULT hd_videodec_get(HD_PATH_ID path_id, HD_VIDEODEC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id The path id id Id of parameters p_param Pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter 2.4 hd_videodec_set \u00b6 [Description] Set parameters to unit by path id [Syntax] HD_RESULT hd_videodec_set(HD_PATH_ID path_id, HD_VIDEODEC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id The path id id Id of parameters p_param Pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter 2.5 hd_videodec_bind \u00b6 [Description] Bind this unit with destination unit [Syntax] HD_RESULT hd_videodec_bind(HD_OUT_ID out_id, HD_IN_ID dest_in_id) [Parameter] Value Description out_id Id of output port. dest_in_id Id of the destination input port. [Return Value] Value Description HD_OK Success HD_ERR_NG Failure 2.6 hd_videodec_start \u00b6 [Description] Start the unit [Syntax] HD_RESULT hd_videodec_start(HD_PATH_ID path_id) [Parameter] Value Description path_id Pointer of the path id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure 2.7 hd_videodec_stop \u00b6 [Description] Stop the unit [Syntax] HD_RESULT hd_videodec_stop(HD_PATH_ID path_id) [Parameter] Value Description path_id Pointer of the path id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure 2.8 hd_videodec_unbind \u00b6 [Description] Unbind the unit [Syntax] HD_RESULT hd_videodec_unbind (HD_OUT_ID out_id) [Parameter] Value Description out_id Id of output port. [Return Value] Value Description HD_OK Success HD_ERR_NG Failure 2.9 hd_videodec_close \u00b6 [Description] Close the unit [Syntax] HD_RESULT hd_videodec_close(HD_PATH_ID path_id) [Parameter] Value Description path_id Pointer of the path id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure 2.10 hd_videodec_uninit \u00b6 [Description] Uninitialize the unit [Syntax] HD_RESULT hd_videodec_uninit(VOID); [Parameter] Value Description VOID Not available [Return Value] Value Description HD_OK Success HD_ERR_NG Failure 2.11 hd_videodec_push_in_buf \u00b6 [Description] Push the video bitstream buffer to unit [Syntax] HD_RESULT hd_videodec_push_in_buf(HD_PATH_ID path_id, HD_VIDEO_BS p_in_videodec_bs, HD_VIDEO_FRAME p_user_out_video_frame, INT32 wait_ms); [Parameter] Value Description path_id The path id p_in_videodec_bs Pointer of the input bitstream buffer p_user_out_video_frame Pointer of the output frame buffer wait_ms Timeout value in microsecond [Return Value] Value Description HD_OK Success HD_ERR_NG Failure 2.12 hd_videodec_pull_out_buf \u00b6 [Description] Pull the video frame buffer from unit [Syntax] HD_RESULT hd_videodec_pull_out_buf(HD_PATH_ID path_id, HD_VIDEO_FRAME* p_video_frame, INT32 wait_ms); [Parameter] Value Description path_id The path id p_video_frame Pointer of the output frame buffer [Supplement] Only for [NT9832X][NT9833X][NT98331] HD_VIDEO_FRAME* p_video_frame :: reserved[] 0: width of background dimension 1: height of background dimension wait_ms Timeout value in microsecond [Return Value] Value Description HD_OK Success HD_ERR_NG General failure HD_ERR_TIMEDOUT Timeout occurred (There is no decoded data in pull_out queue.) HD_ERR_SYS Operating system call failure HD_ERR_FAIL Decoding error occurred 2.13 hd_videodec_release_out_buf \u00b6 [Description] Release the video frame buffer which is get from unit [Syntax] HD_RESULT hd_videodec_release_out_buf(HD_PATH_ID path_id, HD_VIDEO_FRAME* p_video_frame) [Parameter] Value Description path_id The path id p_video_frame Pointer of the output frame buffer [Return Value] Value Description HD_OK Success HD_ERR_NG Failure 2.14 hd_videodec_send_list \u00b6 [Description] Send(Push) multiple video bitstream buffers to each corresponding unit [Syntax] HD_RESULT hd_videodec_send_list(HD_VIDEODEC_SEND_LIST *p_videodec_list, UINT32 num, INT32 wait_ms); [Parameter] Value Description p_videodec_list Pointer of multiple bitstream buffers num Number of multiple bitstream buffers wait_ms Timeout value in microsecond [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_PATH Invalid path id HD_ERR_TIMEDOUT Timeout occured [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Not supported. NT9831X NT9832X NT9833X NT98331 All functions are supported. 2.15 hd_videodec_start_list \u00b6 [Description] Start multiple units to run [Syntax] HD_RESULT hd_videodec_start_list(HD_PATH_ID *path_id, UINT num); [Parameter] Value Description path_id The path id num Number of multiple units [Return Value] Value Description HD_OK Success HD_ERR_NG Failure [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Not supported. NT9831X NT9832X NT9833X NT98331 All functions are supported. 2.16 hd_videodec_stop_list \u00b6 [Description] Stop multiple units running [Syntax] HD_RESULT hd_videodec_stop_list(HD_PATH_ID *path_id, UINT num); [Parameter] Value Description path_id The path id num Number of multiple units [Return Value] Value Description HD_OK Success HD_ERR_NG Failure [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Not supported. NT9831X NT9832X NT9833X NT98331 All functions are supported. 3 Parameter IDs and Data Structures \u00b6 3.1 Parameter IDs \u00b6 The videodec provides the following parameter IDs: l HD_VIDEODEC_PARAM_DEVCOUNT o support get with ctrl path o using HD_DEVCOUNT struct (device id max count) l HD_VIDEODEC_PARAM_SYSCAPS o support get with ctrl path o using HD_VIDEODEC_SYSCAPS l HD_VIDEODEC_PARAM_PATH_CONFIG o support get/set with i/o path o using HD_VIDEODEC_PATH_CONFIG l HD_VIDEODEC_PARAM_STATUS o support get/set with i/o path o Using HD_VIDEODEC_STATUS 3.2 Data structure definition \u00b6 3.2.1 HD_VIDEODEC_SYSCAPS \u00b6 [Description] Device capability. [Parameter] Value Description dev_id device id chip_id chip id of this device max_in_count max count of input of this device max_out_count max count of output of this device dev_caps capability of device, combine caps of HD_DEVICE_CAPS and HD_VIDEODEC_DEVCAPS in_caps capability of input, combine caps of HD_VIDEO_CAPS and HD_VIDEODEC_INCAPS out_caps capability of output, combine caps of HD_VIDEO_CAPS and HD_VIDEODEC_OUTCAPS max_dim max dimension of video decoder max_bitrate max bitrate of video decoder [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 max_in_count = 16; max_out_count = 16; dev_caps = ??????????????? HD_CAPS_PATHCONFIG; in_caps[0~16] = ??????????????? ?HD_VIDEODEC_CAPS_JPEG ??????????????? ?| HD_VIDEODEC_CAPS_H264 ??????????????? ?| HD_VIDEODEC_CAPS_H265; out_caps[0~16] = ??????????????? ?HD_VIDEO_CAPS_YUV420 ??????????????? ?| HD_VIDEO_CAPS_YUV422; NT9831X NT9832X NT9833X NT98331 max_in_count = 128; max_out_count = 128; dev_caps = ??????????????? HD_CAPS_LISTFUNC; in_caps[0~127] = ??????????????? ?HD_VIDEODEC_CAPS_JPEG ??????????????? ?| HD_VIDEODEC_CAPS_H264 ??????????????? ?| HD_VIDEODEC_CAPS_H265; out_caps[0~127] = ??????????????? ?HD_VIDEO_CAPS_YUV420 ??????????????? ?| HD_VIDEO_CAPS_YUV422; 3.2.2 HD_VIDEODEC_PATH_CONFIG \u00b6 [Description] Device configurations. [Parameter] Value Description max_mem maximum memory information, see HD_VIDEODEC_MAXMEM data_pool pool memory information, see HD_VIDEODEC_POOL [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 data_pool is not supported. NT9831X NT9832X NT9833X NT98331 All parameters are supported. [Apply Require] stop -> close -> open -> set -> start 3.2.3 HD_VIDEODEC_MAXMEM \u00b6 [Description] Maximum memory allocation informations. [Parameter] Value Description codec_type Video codec type dim Video image dimension frame_rate Video frame rate max_bitrate Maximum bitrate support bs_counts Bitstream buffer counts max_ref_num Maximum reference number of video frame ddr_id The ddr id max_bs_size Maximum bitstream size (window size), 0 means AUTO calculating by system. max_multi_slice_num Maximum multiple slice number reserved Reserved for future using [Difference] Chip Description NT9668X NT9852X NT9856X Only support codec_type and dim. NT98530 Only support codec_type, dim and max_ref_num. NT9831X NT9832X NT9833X NT98331 All parameters are supported. [Apply Require] stop -> close -> open -> set -> start 3.2.4 HD_VIDEODEC_POOL \u00b6 [Description] Memory pool informations. [Parameter] Value Description ddr_id The ddr id counts Counts of buffer, use HD_VIDEODEC_SET_COUNT to set. (Take 30 fps as an example, a bit-stream is 1/30 of the playback time. The larger the setting, the longer the playback time that datain can cache.) max_counts Maximum counts of buffer, use HD_VIDEODEC_SET_COUNT to set. min_counts Minimum counts of buffer, use HD_VIDEODEC_SET_COUNT to set. mode Pool mode, 0: auto, 1: enable, 2: disable [Apply Require] stop -> close -> open -> set -> start [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Not supported. NT9831X NT9832X NT9833X NT98331 All parameters are supported. 3.2.5 HD_VIDEODEC_USER_BS \u00b6 [Description] User video bitstream information [Parameter] Value Description sign Data signature, use MAKEFOURCC(\u2018V\u2019,\u2019S\u2019,\u2019T\u2019,\u2019M\u2019) p_next Pointer to next meta p_bs_buf Pointer of bitstream buffer address pointer bs_buf_size Bitstream buffer size retval Reserved for future using time_align Playback timestamp alignment mode, see HD_VIDEODEC_ALIGN time_diff Playback interval time (unit: microsecond) timestamp Decode bitstream timestamp to encode for transcode (unit: microsecond) user_flag User specific control flag, use HD_VIDEODEC_FLAG_XXX definitions reserved Reserved for future using [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Not supported. NT9831X NT9832X NT9833X NT98331 All parameters are supported. 3.2.6 HD_VIDEODEC_ALIGN \u00b6 [Description] Playback timestamp alignment information [State] Value Description HD_VIDEODEC_TIME_ALIGN_ENABLE (default) playback time align by LCD period (e.g. 60HZ should be 33333 us) HD_VIDEODEC_TIME_ALIGN_DISABLE Play timestamp by hd_videodec_send_list called HD_VIDEODEC_TIME_ALIGN_USER Start to play at previous play point + time_diff(us) [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Not supported. NT9831X NT9832X NT9833X NT98331 All states are supported. 3.2.7 HD_VIDEODEC_STATUS \u00b6 [Description] Video decoder current status. [Parameter] Value Description left_frames Number of frames to be decoded. reserved_ref_frame Reserved reference frame when unbind unit. NOTE: Cannot be set when swtiching codec type. done_frames Number of decoded frames reserved[0] Decode input available buffer counts. Please refer to sample for usage, playback_with_sync.c (code\\hdal\\samples\\media_flow) reserved[1~7] Reserved for future using. [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Not supported. NT9831X NT9832X NT9833X NT98331 All states are supported. 4 Trouble shooting \u00b6 The videodec module supports two kinds of debug mechanism for user. User can use proc command or debug menu to debug. 4.1 Debug Menu (NT9668X / NT9852X / NT9856X / NT98530) \u00b6 In application, call hd_debug_run_menu() to open the debug menu. ============================== ?HDAL ------------------------------ ?01 : AUDIOCAPTURE ?02 : AUDIOOUT ?03 : AUDIOENC ?04 : AUDIODEC ?05 : VIDEOCAPTURE ?06 : VIDEOOUT ?07 : VIDEOPROCESS ?08 : VIDEOENC ?09 : VIDEODEC ?10 : OSG ?11 : COMMON ?12 : UTIL ?13 : DEBUG ------------------------------ ?254 : Quit ?255 : Return ------------------------------ Enter \u201c9\u201d to open VIDEODEC debug menu ============================== VIDEODEC ------------------------------ ?01 : dump status ------------------------------ ?254 : Quit ?255 : Return ------------------------------ Note: The items in the menu may vary for each chip. 4.1.1 dump status \u00b6 Enter \u201c1\u201d to show the status of videodec Run: 01 : dump status HDAL_VERSION: 00010001:00010001 ------------------------- VIDEODEC 0? PATH & BIND ------------------------------ in??? out?? state bind_src????????????? bind_dest 0???? 0???? START (null)??????????????? VIDEOPROC_0_IN_0 ------------------------- VIDEODEC 0? PATH CONFIG ------------------------------ in??? out?? max_w max_h? codec 0???? 0???? 640?? 480??? JPEG ------------------------- VIDEODEC 0? IN FRAME --------------------------------- in??? codec 0???? JPEG As above, the debug menu shows the path & bind information, path_config , input frame / output bitstream information, more detail can see the table as below. [PATH & BIND] Status Description Value In input id of path 0 ~ [max_in_count] out output id of path 0 ~ [max_out_count] state state of path OFF/OPEN/START (default OFF) bind_src current binding source of input bind: [module] [device_id]_OUT [output_id] not-bind: (null) bind_dest current binding source of output bind: [module] [device_id]_IN [input_id] not-bind: (null) [PATH CONFIG] Value Description Value in input id of path 0 ~ [max_in_count] out output id of path 0 ~ [max_out_count] max_w maximum dimension width 16 ~ 65532: user assign width default 0 (n/a) max_h maximum dimension height 16 ~ 65532: user assign height default 0 (n/a) [IN FRAME] Value Description Value in input id 0 ~ [max_in_count] codec current input video codec type enum: user assign codec type see HD_VIDEO_CODEC default 0 (n/a) 4.2 proc command (NT9668X / NT9852X / NT9856X / NT98530) \u00b6 User can obtained debugging information from the proc file system of Linux. 4.2.1 dump status \u00b6 [dump info] cat /proc/hdal/vdec/info the result is exactly the same as 4.1.1 Dump status Run: 01 : dump status HDAL_VERSION: 00010001:00010001 ------------------------- VIDEODEC 0? PATH & BIND ------------------------------ in??? out?? state bind_src????????????? bind_dest 0???? 0???? START (null)??????????????? VIDEOPROC_0_IN_0 ------------------------- VIDEODEC 0? PATH CONFIG ------------------------------ in??? out?? max_w max_h? codec 0???? 0???? 640?? 480??? JPEG ------------------------- VIDEODEC 0? IN FRAME --------------------------------- in??? codec 0???? JPEG 4.2.2 debug command \u00b6 [debug port] echo debug [dev] [i/o] [mask] > /proc/hdal/adec/cmd where [dev] = d0 , [i/o] = i0, i1, i2, \u2026, o0, o1, o2, \u2026 , [mask] = show info mask [ Sample ] echo debug d0 o0 mffff > /proc/hdal/vdec/cmd this debug command can show more debug log on console root@NVTEVM:/mnt/sd$ hd_video_playback 2 [ 4183.595988] hd_reset - begin [ 4183.601853] hd_reset - end HDAL_VERSION: 00010001:00010002 [ 4183.657738] [ 4183.657738] hd: \u201cvdodec\u201d.out[0]: open begin, state=0 [ 4183.665326] hd: \u201cvdodec\u201d.out[0]: cmd OPEN [ 4183.678796] hd: \u201cvdodec\u201d.out[0]: open end, state=1 [ 4183.685213] hd: \u201cvdodec\u201d.out[0]: set param(08000a05)=1 [ 4183.708678] hd: \u201cvdodec\u201d.out[0]: set param(08000a00)=1 [ 4183.716255] hd: \u201cvdodec\u201d.out[0]: set param(08000a00)=1 [ 4183.722596] [ 4183.722596] hd: \u201cvdodec\u201d.out[0]: bind begin, (\u201cvdoprc0\u201d.in[0]) [ 4183.732387] hd: \u201cvdodec\u201d.out[0]: cmd CONNECT [ 4183.737854] hd: \u201cvdodec\u201d.out[0]: cmd RDYSYNC [ 4183.748315] hd: \u201cvdodec\u201d.out[0]: bind end [ 4183.753391] [ 4183.753391] hd: \u201cvdodec\u201d.out[0]: start begin, state=1 [ 4183.761045] hd: \u201cvdodec\u201d.out[0]: cmd RDYSYNC [ 4183.771498] hd: \u201cvdodec\u201d.out[0]: cmd START [ 4183.782689] hd: \u201cvdodec\u201d.out[0]: start end, state=2 Enter q to exit bs file: [/mnt/sd/video_bs_640_480_jpeg.dat] bslen file: [/mnt/sd/video_bs_640_480_jpeg.len] q [ 4188.409136] [ 4188.409136] hd: \u201cvdodec\u201d.out[0]: stop begin, state=2 [ 4188.416733] hd: \u201cvdodec\u201d.out[0]: cmd STOP [ 4188.429400] hd: \u201cvdodec\u201d.out[0]: stop end, state=1 [ 4188.443260] [ 4188.443260] hd: \u201cvdodec\u201d.out[0]: unbind begin, (\u201cvdoprc0\u201d.in[0]) [ 4188.451877] hd: \u201cvdodec\u201d.out[0]: cmd DISCONNECT [ 4188.457451] hd: \u201cvdodec\u201d.out[0]: unbind end [ 4188.462694] hd: \u201cvdodec\u201d.out[0]: set param(08000a05)=0 [ 4188.468879] [ 4188.468879] hd: \u201cvdodec\u201d.out[0]: close begin, state=1 [ 4188.476533] hd: \u201cvdodec\u201d.out[0]: cmd CLOSE [ 4188.484832] hd: \u201cvdodec\u201d.out[0]: close end, state=0 4.2.3 trace command \u00b6 [trace port] echo trace [dev] [i/o] [mask] > /proc/hdal/adec/cmd where [dev] = d0 , [i/o] = i0, i1, i2, \u2026, o0, o1, o2, \u2026 , [mask] = show info mask [ Sample ] echo trace d0 o0 mffff > /proc/hdal/vdec/cmd this trace command could enable module internal debug message to know what\u2019s going on for the VIDEODEC module. 4.2.4 probe command \u00b6 [probe port] echo probe [dev] [i/o] [mask] > /proc/hdal/adec/cmd where [dev] = d0 , [i/o] = i0, i1, i2, \u2026, o0, o1, o2, \u2026 , [mask] = show info mask [ Sample ] echo probe d0 o0 mffff > /proc/hdal/vdec/cmd this probe command could print per-data status [ 5310.074418] hd: \u201cvdodec\u201d.out[0] - NEW - new \u2013 h=94001fc0 size=00070800 addr=94002000 OK [ 5310.085787] hd: \u201cvdodec\u201d.out[0] - PUSH - data \u2013 h=94001fc0 t=000000013dd1c406 (YUV: 640x480.520c0420 94002000 9404d000 640 640) [ 5310.113972] hd: \u201cvdodec\u201d.out[0] - NEW - new \u2013 h=9407afc0 size=00070800 addr=9407b000 OK [ 5310.125334] hd: \u201cvdodec\u201d.out[0] - PUSH - data \u2013 h=9407afc0 t=000000013dd25e8e (YUV: 640x480.520c0420 9407b000 940c6000 640 640) [ 5310.153493] hd: \u201cvdodec\u201d.out[0] - NEW - new \u2013 h=940f3fc0 size=00070800 addr=940f4000 OK [ 5310.164831] hd: \u201cvdodec\u201d.out[0] - PUSH - data \u2013 h=940f3fc0 t=000000013dd2f8ef (YUV: 640x480.520c0420 940f4000 9413f000 640 640) [ 5310.192974] hd: \u201cvdodec\u201d.out[0] - NEW - new \u2013 h=940f3fc0 size=00070800 addr=940f4000 OK [ 5310.204320] hd: \u201cvdodec\u201d.out[0] - PUSH - data \u2013 h=940f3fc0 t=000000013dd39329 (YUV: 640x480.520c0420 940f4000 9413f000 640 640) [ 5310.232463] hd: \u201cvdodec\u201d.out[0] - NEW - new \u2013 h=9407afc0 size=00070800 addr=9407b000 OK [ 5310.243803] hd: \u201cvdodec\u201d.out[0] - PUSH - data \u2013 h=9407afc0 t=000000013dd42d6b (YUV: 640x480.520c0420 9407b000 940c6000 640 640) [ 5310.271956] hd: \u201cvdodec\u201d.out[0] - NEW - new \u2013 h=94001fc0 size=00070800 addr=94002000 OK [ 5310.283296] hd: \u201cvdodec\u201d.out[0] - PUSH - data \u2013 h=94001fc0 t=000000013dd4c7ac (YUV: 640x480.520c0420 94002000 9404d000 640 640) 4.2.5 perf command \u00b6 [perf port] echo perf [dev] [i/o] > /proc/hdal/adec/cmd [ Sample ] echo perf d0 i0 > /proc/hdal/vdec/cmd this perf command could print data count per second [ 5390.325791] hd: \u201cvdodec\u201d.in[0] - perf \u2013 (VideoBs) 825 KByte/sec [ 5391.330332] hd: \u201cvdodec\u201d.in[0] - perf \u2013 (VideoBs) 825 KByte/sec [ 5392.336753] hd: \u201cvdodec\u201d.in[0] - perf \u2013 (VideoBs) 819 KByte/sec [ 5393.345119] hd: \u201cvdodec\u201d.in[0] - perf \u2013 (VideoBs) 820 KByte/sec 4.2.6 save command \u00b6 [save port] echo save [dev] [i/o] [count] > /proc/hdal/adec/cmd where [count] means how many i/o datas to save [ Sample ] echo save d0 i0 > /proc/hdal/vdec/cmd this save command could save i/o data to SDCard for debug purpose. [ 5471.047725] save i/o begin: \u201cvdodec\u201d.in[0] count=1 [ 5473.414755] hd: \u201cvdodec\u201d.in[0] - save \u2013 h=9416dfc0 t=00000001478e2434 (VSTM: 1296e000 25874) [ 5473.443425] hd: \u201cvdodec\u201d.in[0] - save \u2013 //mnt//sd//isf_? vdodec_in[0]_c0.bsv ok [ 5473.451859] save port end 4.3 Proc Command (NT9631X / NT9832X / NT9833X / NT98331) \u00b6 4.3.1 dump setting \u00b6 User can cat info file to dump module\u2019s status. ------------------------- VIDEODEC 0? PATH & BIND ----------------------------- in????? out???? state?? bind_src??????????????? bind_dest 0?????? 0?????? START?? -?????????????????????? VIDEOPROC_4_IN_0 0?????? 1?????? START?? -?????????????????????? VIDEOPROC_5_IN_0 0?????? 2?????? START?? -?????????????????????? VIDEOPROC_6_IN_0 0?????? 3?????? START?? -????????? ?????????????VIDEOPROC_7_IN_0 ------------------------- VIDEODEC 0? PATH POOL ----------------------------- out???? pool??? ddr_id? count?? max_count 0?????? 0?????? 0?????? 3.5???? 3.0 0?????? 1?????? 0?????? 3.5???? 3.0 1?????? 0?????? 0?????? 3.5???? 3.0 1?????? 1?????? 0?????? 3.5???? 3.0 2?????? 0?????? 0?????? 3.5???? 3.0 2?????? 1?????? 0?????? 3.5???? 3.0 3?????? 0?????? 0?????? 3.5???? 3.0 3?????? 1?????? 0?????? 3.5???? 3.0 [PATH & BIND] Status Description Value in input id of path 0 out output id of path 0 ~ [max_out_count] state state of path OFF/OPEN/START (default OFF) bind_src current binding source of input bind: [module] [device_id]_OUT [output_id] not-bind: (null) bind_dest current binding source of output bind: [module] [device_id]_IN [input_id] not-bind: (null) 4.4 Debug Menu (NT9631X / NT9832X / NT9833X / NT98331) \u00b6 4.4.1 dump info \u00b6 After enter debug menu, select 09 to enter this module\u2019s sub-menu. User can select 01 to dump module\u2019s status shown as below. ------------------------- VIDEODEC 0? PATH & BIND ----------------------------- in????? out???? state?? bind_src??????????????? bind_dest 0?????? 0?????? START?? -?????????????????????? VIDEOPROC_4_IN_0 0?????? 1?????? START?? -?????????????????????? VIDEOPROC_5_IN_0 0?????? 2?????? START?? -?????????????????????? VIDEOPROC_6_IN_0 0?????? 3?????? START?? -?????????????????????? VIDEOPROC_7_IN_0 ------------------------- VIDEODEC 0? PATH POOL ----------------------------- out???? pool??? ddr_id? count?? max_count 0?????? 0?????? 0?????? 3.5???? 3.0 0?????? 1?????? 0?????? 3.5???? 3.0 1?????? 0?????? 0?????? 3.5???? 3.0 1?????? 1?????? 0?????? 3.5???? 3.0 2?????? 0?????? 0?????? 3.5???? 3.0 2?????? 1?????? 0?????? 3.5???? 3.0 3?????? 0?????? 0?????? 3.5???? 3.0 3?????? 1?????? 0?????? 3.5?? ??3.0 5 Sample Codes \u00b6 5.1 Video_playback \u00b6 This sample code is used in NT9668X / NT9852X / NT9856X / NT98530. The hd_video_playback demonstrates how to use the single trigger operation to process the input image. /* Allocate common buffer*/ // config common pool (main) mem_cfg.pool_info[0].type = HD_COMMON_MEM_COMMON_POOL; mem_cfg.pool_info[0].blk_size = DBGINFO_BUFSIZE()+VDO_YUV_BUFSIZE(ALIGN_CEIL_64(VDO_SIZE_W), ALIGN_CEIL_64(VDO_SIZE_H), HD_VIDEO_PXLFMT_YUV420);? // align to 16 for rotate buffer mem_cfg.pool_info[0].blk_cnt = 3; mem_cfg.pool_info[0].ddr_id = DDR_ID0; // config common pool for bs pushing in mem_cfg.pool_info[1].type = HD_COMMON_MEM_USER_POOL_BEGIN; mem_cfg.pool_info[1].blk_size = BS_BLK_SIZE; mem_cfg.pool_info[1].blk_cnt = 1; mem_cfg.pool_info[1].ddr_id = DDR_ID0; ret = hd_common_mem_init(&mem_cfg); /* Set dec path configuration */ video_path_cfg.max_mem.codec_type = dec_type; video_path_cfg.max_mem.dim.w = p_max_dim->w; video_path_cfg.max_mem.dim.h = p_max_dim->h; ret = hd_videodec_set(video_dec_path, HD_VIDEODEC_PARAM_PATH_CONFIG, &video_path_cfg); if (ret != HD_OK) { return ret; } /* Set dec parameter */ video_in_param.codec_type = dec_type; video_in_param.dim.w = p_dim->w; video_in_param.dim.h = p_dim->h; ret = hd_videodec_set(video_dec_path, HD_VIDEODEC_PARAM_IN, &video_in_param); if (ret != HD_OK) { return ret; } /* Set proc configuration */ ret = hd_videoproc_open(0, HD_VIDEOPROC_0_CTRL, &video_proc_ctrl); //open this for device control if (p_max_dim != NULL) { video_cfg_param.pipe = HD_VIDEOPROC_PIPE_SCALE; video_cfg_param.isp_id = 0; video_cfg_param.ctrl_max.func = 0; video_cfg_param.in_max.func = 0; video_cfg_param.in_max.dim.w = p_max_dim->w; video_cfg_param.in_max.dim.h = p_max_dim->h; video_cfg_param.in_max.pxlfmt = HD_VIDEO_PXLFMT_YUV420; video_cfg_param.in_max.frc = HD_VIDEO_FRC_RATIO(1,1); ret = hd_videoproc_set(video_proc_ctrl, HD_VIDEOPROC_PARAM_DEV_CONFIG, &video_cfg_param); ???? if (ret != HD_OK) { ???????? return HD_ERR_NG; ???? } } video_ctrl_param.func = 0; ret = hd_videoproc_set(video_proc_ctrl, HD_VIDEOPROC_PARAM_CTRL, &video_ctrl_param); if (ret != HD_OK) { return ret;} /* Set proc parameter */ video_out_param.func = 0; video_out_param.dim.w = p_dim->w; video_out_param.dim.h = p_dim->h; video_out_param.pxlfmt = HD_VIDEO_PXLFMT_YUV420; video_out_param.dir = HD_VIDEO_DIR_NONE; video_out_param.frc = HD_VIDEO_FRC_RATIO(1,1); ret = hd_videoproc_set(video_proc_path, HD_VIDEOPROC_PARAM_OUT, &video_out_param); if (ret != HD_OK) { return ret;} /* Set out configuration */ ret = hd_videoout_open(0, HD_VIDEOOUT_0_CTRL, &video_out_ctrl); //open this for device control switch(out_type){ case 0: ???? videoout_mode.output_type = HD_COMMON_VIDEO_OUT_CVBS; ???? videoout_mode.input_dim = HD_VIDEOOUT_IN_AUTO; ???? videoout_mode.output_mode.cvbs= HD_VIDEOOUT_CVBS_NTSC; break; case 1: ???? videoout_mode.output_type = HD_COMMON_VIDEO_OUT_LCD; ???? videoout_mode.input_dim = HD_VIDEOOUT_IN_AUTO; ???? videoout_mode.output_mode.lcd = HD_VIDEOOUT_LCD_0; break; case 2: ???? videoout_mode.output_type = HD_COMMON_VIDEO_OUT_HDMI; ???? videoout_mode.input_dim = HD_VIDEOOUT_IN_AUTO; ???? videoout_mode.output_mode.hdmi= hdmi_id; break; default: ???? printf(\u201cnot support out_type\\r\\n\u201d); break; } ret = hd_videoout_set(video_out_ctrl, HD_VIDEOOUT_PARAM_MODE, &videoout_mode); if (ret != HD_OK) { return ret;} /* Set out parameter */ video_out_param.dim.w = p_dim->w; video_out_param.dim.h = p_dim->h; video_out_param.pxlfmt = HD_VIDEO_PXLFMT_YUV420; video_out_param.dir = HD_VIDEO_DIR_NONE; ret = hd_videoout_set(video_out_path, HD_VIDEOOUT_PARAM_IN, &video_out_param); if (ret != HD_OK) { return ret;} memset((void *)&video_out_param,0,sizeof(HD_VIDEOOUT_IN)); ret = hd_videoout_get(video_out_path, HD_VIDEOOUT_PARAM_IN, &video_out_param); if (ret != HD_OK) { return ret;} /* Bind modules */ hd_videodec_bind(HD_VIDEODEC_0_OUT_0, HD_VIDEOPROC_0_IN_0); hd_videoproc_bind(HD_VIDEOPROC_0_OUT_0, HD_VIDEOOUT_0_IN_0); /* start modules */ hd_videodec_start(stream[0].dec_path); hd_videoproc_start(stream[0].proc_path); hd_videoout_start(stream[0].out_path); /* Push in buffer */ blk = hd_common_mem_get_block(HD_COMMON_MEM_COMMON_POOL, blk_size, ddr_id); pa = hd_common_mem_blk2pa(blk); va= hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_CACHE, pa, blk_size); fread((void *)va, 1, length, bs_fd); video_bs.phy_addr[0] = pa; video_bs.size = length; ret = hd_videodec_push_in_buf(p_stream0->dec_path, &video_bs, NULL, 0); if (ret != HD_OK) { return ret; } /* Release in buffer */ hd_common_mem_munmap((void *)va, blk_size) hd_common_mem_release_block(blk); 5.2 video_decode_only \u00b6 This sample code is used in NT9668X / NT9852X / NT9856X / NT98530. The hd_videodec_only demonstrates how to use the single trigger operation to process the input image. /* Allocate common buffer*/ // config common pool (main) mem_cfg.pool_info[0].type = HD_COMMON_MEM_COMMON_POOL; mem_cfg.pool_info[0].blk_size = DBGINFO_BUFSIZE()+VDO_YUV_BUFSIZE(ALIGN_CEIL_64(VDO_SIZE_W), ALIGN_CEIL_64(VDO_SIZE_H), HD_VIDEO_PXLFMT_YUV420);? // align to 16 for rotate buffer mem_cfg.pool_info[0].blk_cnt = 3; mem_cfg.pool_info[0].ddr_id = DDR_ID0; // config common pool for bs pushing in mem_cfg.pool_info[1].type = HD_COMMON_MEM_USER_POOL_BEGIN; mem_cfg.pool_info[1].blk_size = BS_BLK_SIZE; mem_cfg.pool_info[1].blk_cnt = 1; mem_cfg.pool_info[1].ddr_id = DDR_ID0; ret = hd_common_mem_init(&mem_cfg); /* Set dec path configuration */ video_path_cfg.max_mem.codec_type = dec_type; video_path_cfg.max_mem.dim.w = p_max_dim->w; video_path_cfg.max_mem.dim.h = p_max_dim->h; ret = hd_videodec_set(video_dec_path, HD_VIDEODEC_PARAM_PATH_CONFIG, &video_path_cfg); if (ret != HD_OK) { return ret; } /* Set dec parameter */ video_in_param.codec_type = dec_type; video_in_param.dim.w = p_dim->w; video_in_param.dim.h = p_dim->h; ret = hd_videodec_set(video_dec_path, HD_VIDEODEC_PARAM_IN, &video_in_param); if (ret != HD_OK) { return ret; } /* start modules */ hd_videodec_start(stream[0].dec_path); /* Push in buffer */ blk = hd_common_mem_get_block(HD_COMMON_MEM_COMMON_POOL, blk_size, ddr_id); pa = hd_common_mem_blk2pa(blk); va= hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_CACHE, pa, blk_size); fread((void *)va, 1, length, bs_fd); video_bs.phy_addr[0] = pa; video_bs.size = length; ret = hd_videodec_push_in_buf(p_stream0->dec_path, &video_bs, NULL, 0); if (ret != HD_OK) { return ret; } /* Release in buffer */ hd_common_mem_munmap((void *)va, blk_size) hd_common_mem_release_block(blk); /* Pull out buffer */ ret = hd_videodec_pull_out_buf(p_stream0->dec_path, &data_pull, -1); if (ret == HD_OK) { ???? hd_videodec_get(p_stream0->dec_path, HD_VIDEODEC_PARAM_BUFINFO, &phy_buf_main); vir_addr_main = (UINT32)hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_CACHE, phy_buf_main.buf_info.phy_addr, phy_buf_main.buf_info.buf_size); define PHY2VIRT_MAIN(pa) (vir_addr_main + (pa - phy_buf_main.buf_info.phy_addr)) \u00b6 ???? va = PHY2VIRT_MAIN(data_pull.phy_addr); ???? size = data_pull.size; ???? sprintf(filename, \u201cdump_frm_main.dat\u201d); ???? save_output(filename, va, size); } /* Release out buffer */ hd_common_mem_munmap(vir_addr_main, phy_buf_main.buf_info.buf_size); hd_videodec_release_out_buf(p_stream0->dec_path, &data_pull); 5.3 user_videodec \u00b6 This sample code is used in NT9831X / NT9832X / NT9833X / NT98331. The user_videodec demonstrates how to use the single trigger operation to process the input image. /* Set parameters */ config.max_mem.dim.w = max_frame_width; config.max_mem.dim.h = max_frame_height; config.max_mem.frame_rate = 30; ret = hd_videodec_set(path_id, HD_VIDEODEC_PARAM_PATH_CONFIG, &config); if (ret != HD_OK) { ???? printf(\u201chd_videodec_set fail\\n\u201d); ???? goto exit; } /* Allocate in buffer */ bs_in_buffer.ddr_id = ddr_id; bs_in_buffer.size = BS_BUF_SIZE; blk = hd_common_mem_get_block(pool, bs_in_buffer.size, ddr_id); if (HD_COMMON_MEM_VB_INVALID_BLK == blk) { ???? printf(\u201chd_common_mem_get_block fail\\r\\n\u201d); ???? ret =? HD_ERR_NG; ???? goto exit; } bs_in_buffer.phy_addr = hd_common_mem_blk2pa(blk); if (bs_in_buffer.phy_addr == 0) { ???? printf(\u201chd_common_mem_blk2pa fail, blk = %#lx\\r\\n\u201d, blk); ???? hd_common_mem_release_block(blk); ???? return HD_ERR_NG; } bs_in_buffer_va = hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_NONCACHE, ??????????????????????????????? bs_in_buffer.phy_addr, ??????????????????????????????? bs_in_buffer.size); /* Allocate out buffer */ blk = hd_common_mem_get_block(pool, frame_buf_size, ddr_id); if (HD_COMMON_MEM_VB_INVALID_BLK == blk) { ???? printf(\u201chd_common_mem_get_block fail\\r\\n\u201d); ???? ret =? HD_ERR_NG; ???? goto exit; } dec_out_buffer.phy_addr[0] = hd_common_mem_blk2pa(blk); if (dec_out_buffer.phy_addr[0] == 0) { ???? printf(\u201chd_common_mem_blk2pa fail, blk = %#lx\\r\\n\u201d, blk); ???? hd_common_mem_release_block(blk); ???? return HD_ERR_NG; } dec_out_buffer_va = hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_NONCACHE, ???????????????????????????????????????? dec_out_buffer.phy_addr[0], ???????????????????????????????????????? frame_buf_size); /* Push in buffer */ fscanf(bs_len_fd, \u201c%d\\n\u201d, &length); if (length > BS_BUF_SIZE) { ???? printf(\u201cUser bitstream is too large. bs_size(%d) > max(%d)\\n\u201d, length, BS_BUF_SIZE); ???? goto exit; } fseek(bs_fd, 0, SEEK_SET); fread((void *)bs_in_buffer_va, 1, length, bs_fd); bs_in_buffer.size = length; ret = hd_videodec_push_in_buf(path_id, &bs_in_buffer, &dec_out_buffer, 500); if (ret != HD_OK) { ???? printf(\u201chd_videodec_push_in_buf fail\\n\u201d); ???? goto exit; } /* Pull out buffer */ ret = hd_videodec_pull_out_buf(path_id, &dec_out_buffer, 500); if (ret != HD_OK) { ???? printf(\u201chd_videodec_pull_out_buf fail\\n\u201d); ???? goto exit; } else { ???? dec_out_buffer_va = hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_NONCACHE, ???????????????????????????????????????? dec_out_buffer.phy_addr[0], ???????????????????????????????????????? frame_buf_size); ???? sprintf(filename, \u201cuser_dec_%ldx%ld_YUV420_16x2.yuv\u201d, dec_out_buffer.dim.w, dec_out_buffer.dim.h); ???? save_output(filename, dec_out_buffer_va, frame_buf_size); } /* Release in buffer */ hd_common_mem_munmap(bs_in_buffer_va, frame_buf_size); hd_common_mem_release_block((HD_COMMON_MEM_VB_BLK)bs_in_buffer.phy_addr); /* Release out buffer */ hd_common_mem_munmap(dec_out_buffer_va, frame_buf_size); hd_common_mem_release_block((HD_COMMON_MEM_VB_BLK)dec_out_buffer.phy_addr[0]); 6 FAQ \u00b6 Why using hd_videodec_push_in_buf() but return error -19? Answer: o Check hd_videodec_start() is already called. o If hd_videodec_start() is called, please check the order of hd_videodec_set (HD_VIDEODEC_PARAM_IN_DESC) and hd_videodec_start(). Call hd_videodec_set(HD_VIDEODEC_PARAM_IN_DESC) first, and then call hd_videodec_start(). Why using hd_videoproc_pull_out_buf() to pull the yuv data from videodec, but return time out error -15? Answer: o Check the bitstream first. If the continuous incorrect frames exist in the bitstream, video decode error happened and decoder not send the error YUV to vproc in binding mode. It caused time out error -15 if timeout value is set. What values of width and height should I set for each codecs? Answer: o H264: width is aligned to 64, height is aligned to 16. o H265: width is aligned to 64, height is aligned to 64. o JPEG: width is aligned to 16, height is aligned to 16. Is it possible to push yuv data from vdodec to vdoout directly? Answer: o For Achieving video playback function, vdec, vproc and vout are necessary. The binding order is vdec, vproc, and then vout. Vproc scaled the resolution if the resolution of YUV is differ to display device. Is it possible to change the resolution when video decode is processing? Answer: o No, please call hd_videodec_stop() to stop decoder, set the new width/height, and ?? call hd_videodec_start() to start decoder again. Remember that config the maximum width/height at beginning. I set vdodec_maxpath = 17 in dtsi, why show warning message \u201cdts max_path=17 is larger than built-in max_path=16\u201d? Answer: o VDODEC_MAX_PATH_NUM is defined as 16 in isf_vdodec, which means video decode path maximum is 16. Please set vdodec_maxpath <= 16 in dtsi.","title":"HDAL hd_videodec"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#1-introduction","text":"The major purpose of hd_videodec is to get bitstream data from upper unit, and controls the video decoder to decode the bitstream data then return the YUV frame data which can be used for displaying. This document will talk about the red block in the following diagram. The device driver is not the main point in this document. Module diagram is shown as below:","title":"1 Introduction"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#11-block-diagram","text":"","title":"1.1 Block Diagram"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#111-block-diagram-nt9668x-nt9852x-nt9856x-nt98530","text":"The block diagram of H264/H265 codec is shown as below:","title":"1.1.1 Block Diagram (NT9668X / NT9852X / NT9856X / NT98530)"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#112-block-diagram-nt9831x-nt9832x-nt9833x-nt98331","text":"The block diagram of H264 codec is shown as below: The block diagram of H265 codec is shown as below:","title":"1.1.2 Block Diagram (NT9831X / NT9832X / NT9833X / NT98331)"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#12-basic-flow","text":"The call sequence is needed to be done correctly for the unit. The standard starting flows of most modules are init, open, get, set and start. The standard closing flows of most modules are stop, unbind, close and uninit. The basic flow is shown as below. Now, below section in this chapter is mainly about what things to do in those functions above.","title":"1.2 Basic Flow"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#13-single-trigger-operation","text":"Single trigger operation is used to trigger the unit to do one job, such as to grab one YUV frame from video capture; or encode one frame to bitstream by using video encoder. There are two types of functions for the input port and output port. The sequence for input port is new, push and release; the sequence for output port is pull and release. The flow is shown as below.","title":"1.3 Single Trigger Operation"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#14-multi-list-operation","text":"Multi list operation is used to send mulit bitstream simultaneously, it is very efficiency in the multi channels case. The flow is shown as below:","title":"1.4 Multi List Operation"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#2-functions-definition","text":"","title":"2 Functions Definition"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#21-hd_videodec_init","text":"[Description] Initialize the unit [Syntax] HD_RESULT hd_videodec_init(VOID); [Parameter] Value Description VOID Not available [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"2.1 hd_videodec_init"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#22-hd_videodec_open","text":"[Description] Open the unit [Syntax] HD_RESULT hd_videodec_open(HD_IN_ID in_id, HD_OUT_ID out_id, HD_PATH_ID* p_path_id) [Parameter] Value Description in_id Id of input port. out_id Id of output port. p_path_id Pointer of the path id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"2.2 hd_videodec_open"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#23-hd_videodec_get","text":"[Description] Get parameters from unit by path id [Syntax] HD_RESULT hd_videodec_get(HD_PATH_ID path_id, HD_VIDEODEC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id The path id id Id of parameters p_param Pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter","title":"2.3 hd_videodec_get"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#24-hd_videodec_set","text":"[Description] Set parameters to unit by path id [Syntax] HD_RESULT hd_videodec_set(HD_PATH_ID path_id, HD_VIDEODEC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id The path id id Id of parameters p_param Pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter","title":"2.4 hd_videodec_set"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#25-hd_videodec_bind","text":"[Description] Bind this unit with destination unit [Syntax] HD_RESULT hd_videodec_bind(HD_OUT_ID out_id, HD_IN_ID dest_in_id) [Parameter] Value Description out_id Id of output port. dest_in_id Id of the destination input port. [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"2.5 hd_videodec_bind"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#26-hd_videodec_start","text":"[Description] Start the unit [Syntax] HD_RESULT hd_videodec_start(HD_PATH_ID path_id) [Parameter] Value Description path_id Pointer of the path id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"2.6 hd_videodec_start"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#27-hd_videodec_stop","text":"[Description] Stop the unit [Syntax] HD_RESULT hd_videodec_stop(HD_PATH_ID path_id) [Parameter] Value Description path_id Pointer of the path id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"2.7 hd_videodec_stop"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#28-hd_videodec_unbind","text":"[Description] Unbind the unit [Syntax] HD_RESULT hd_videodec_unbind (HD_OUT_ID out_id) [Parameter] Value Description out_id Id of output port. [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"2.8 hd_videodec_unbind"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#29-hd_videodec_close","text":"[Description] Close the unit [Syntax] HD_RESULT hd_videodec_close(HD_PATH_ID path_id) [Parameter] Value Description path_id Pointer of the path id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"2.9 hd_videodec_close"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#210-hd_videodec_uninit","text":"[Description] Uninitialize the unit [Syntax] HD_RESULT hd_videodec_uninit(VOID); [Parameter] Value Description VOID Not available [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"2.10 hd_videodec_uninit"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#211-hd_videodec_push_in_buf","text":"[Description] Push the video bitstream buffer to unit [Syntax] HD_RESULT hd_videodec_push_in_buf(HD_PATH_ID path_id, HD_VIDEO_BS p_in_videodec_bs, HD_VIDEO_FRAME p_user_out_video_frame, INT32 wait_ms); [Parameter] Value Description path_id The path id p_in_videodec_bs Pointer of the input bitstream buffer p_user_out_video_frame Pointer of the output frame buffer wait_ms Timeout value in microsecond [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"2.11 hd_videodec_push_in_buf"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#212-hd_videodec_pull_out_buf","text":"[Description] Pull the video frame buffer from unit [Syntax] HD_RESULT hd_videodec_pull_out_buf(HD_PATH_ID path_id, HD_VIDEO_FRAME* p_video_frame, INT32 wait_ms); [Parameter] Value Description path_id The path id p_video_frame Pointer of the output frame buffer [Supplement] Only for [NT9832X][NT9833X][NT98331] HD_VIDEO_FRAME* p_video_frame :: reserved[] 0: width of background dimension 1: height of background dimension wait_ms Timeout value in microsecond [Return Value] Value Description HD_OK Success HD_ERR_NG General failure HD_ERR_TIMEDOUT Timeout occurred (There is no decoded data in pull_out queue.) HD_ERR_SYS Operating system call failure HD_ERR_FAIL Decoding error occurred","title":"2.12 hd_videodec_pull_out_buf"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#213-hd_videodec_release_out_buf","text":"[Description] Release the video frame buffer which is get from unit [Syntax] HD_RESULT hd_videodec_release_out_buf(HD_PATH_ID path_id, HD_VIDEO_FRAME* p_video_frame) [Parameter] Value Description path_id The path id p_video_frame Pointer of the output frame buffer [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"2.13 hd_videodec_release_out_buf"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#214-hd_videodec_send_list","text":"[Description] Send(Push) multiple video bitstream buffers to each corresponding unit [Syntax] HD_RESULT hd_videodec_send_list(HD_VIDEODEC_SEND_LIST *p_videodec_list, UINT32 num, INT32 wait_ms); [Parameter] Value Description p_videodec_list Pointer of multiple bitstream buffers num Number of multiple bitstream buffers wait_ms Timeout value in microsecond [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_PATH Invalid path id HD_ERR_TIMEDOUT Timeout occured [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Not supported. NT9831X NT9832X NT9833X NT98331 All functions are supported.","title":"2.14 hd_videodec_send_list"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#215-hd_videodec_start_list","text":"[Description] Start multiple units to run [Syntax] HD_RESULT hd_videodec_start_list(HD_PATH_ID *path_id, UINT num); [Parameter] Value Description path_id The path id num Number of multiple units [Return Value] Value Description HD_OK Success HD_ERR_NG Failure [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Not supported. NT9831X NT9832X NT9833X NT98331 All functions are supported.","title":"2.15 hd_videodec_start_list"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#216-hd_videodec_stop_list","text":"[Description] Stop multiple units running [Syntax] HD_RESULT hd_videodec_stop_list(HD_PATH_ID *path_id, UINT num); [Parameter] Value Description path_id The path id num Number of multiple units [Return Value] Value Description HD_OK Success HD_ERR_NG Failure [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Not supported. NT9831X NT9832X NT9833X NT98331 All functions are supported.","title":"2.16 hd_videodec_stop_list"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#3-parameter-ids-and-data-structures","text":"","title":"3 Parameter IDs and Data Structures"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#31-parameter-ids","text":"The videodec provides the following parameter IDs: l HD_VIDEODEC_PARAM_DEVCOUNT o support get with ctrl path o using HD_DEVCOUNT struct (device id max count) l HD_VIDEODEC_PARAM_SYSCAPS o support get with ctrl path o using HD_VIDEODEC_SYSCAPS l HD_VIDEODEC_PARAM_PATH_CONFIG o support get/set with i/o path o using HD_VIDEODEC_PATH_CONFIG l HD_VIDEODEC_PARAM_STATUS o support get/set with i/o path o Using HD_VIDEODEC_STATUS","title":"3.1 Parameter IDs"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#32-data-structure-definition","text":"","title":"3.2 Data structure  definition"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#321-hd_videodec_syscaps","text":"[Description] Device capability. [Parameter] Value Description dev_id device id chip_id chip id of this device max_in_count max count of input of this device max_out_count max count of output of this device dev_caps capability of device, combine caps of HD_DEVICE_CAPS and HD_VIDEODEC_DEVCAPS in_caps capability of input, combine caps of HD_VIDEO_CAPS and HD_VIDEODEC_INCAPS out_caps capability of output, combine caps of HD_VIDEO_CAPS and HD_VIDEODEC_OUTCAPS max_dim max dimension of video decoder max_bitrate max bitrate of video decoder [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 max_in_count = 16; max_out_count = 16; dev_caps = ??????????????? HD_CAPS_PATHCONFIG; in_caps[0~16] = ??????????????? ?HD_VIDEODEC_CAPS_JPEG ??????????????? ?| HD_VIDEODEC_CAPS_H264 ??????????????? ?| HD_VIDEODEC_CAPS_H265; out_caps[0~16] = ??????????????? ?HD_VIDEO_CAPS_YUV420 ??????????????? ?| HD_VIDEO_CAPS_YUV422; NT9831X NT9832X NT9833X NT98331 max_in_count = 128; max_out_count = 128; dev_caps = ??????????????? HD_CAPS_LISTFUNC; in_caps[0~127] = ??????????????? ?HD_VIDEODEC_CAPS_JPEG ??????????????? ?| HD_VIDEODEC_CAPS_H264 ??????????????? ?| HD_VIDEODEC_CAPS_H265; out_caps[0~127] = ??????????????? ?HD_VIDEO_CAPS_YUV420 ??????????????? ?| HD_VIDEO_CAPS_YUV422;","title":"3.2.1 HD_VIDEODEC_SYSCAPS"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#322-hd_videodec_path_config","text":"[Description] Device configurations. [Parameter] Value Description max_mem maximum memory information, see HD_VIDEODEC_MAXMEM data_pool pool memory information, see HD_VIDEODEC_POOL [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 data_pool is not supported. NT9831X NT9832X NT9833X NT98331 All parameters are supported. [Apply Require] stop -> close -> open -> set -> start","title":"3.2.2 HD_VIDEODEC_PATH_CONFIG"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#323-hd_videodec_maxmem","text":"[Description] Maximum memory allocation informations. [Parameter] Value Description codec_type Video codec type dim Video image dimension frame_rate Video frame rate max_bitrate Maximum bitrate support bs_counts Bitstream buffer counts max_ref_num Maximum reference number of video frame ddr_id The ddr id max_bs_size Maximum bitstream size (window size), 0 means AUTO calculating by system. max_multi_slice_num Maximum multiple slice number reserved Reserved for future using [Difference] Chip Description NT9668X NT9852X NT9856X Only support codec_type and dim. NT98530 Only support codec_type, dim and max_ref_num. NT9831X NT9832X NT9833X NT98331 All parameters are supported. [Apply Require] stop -> close -> open -> set -> start","title":"3.2.3 HD_VIDEODEC_MAXMEM"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#324-hd_videodec_pool","text":"[Description] Memory pool informations. [Parameter] Value Description ddr_id The ddr id counts Counts of buffer, use HD_VIDEODEC_SET_COUNT to set. (Take 30 fps as an example, a bit-stream is 1/30 of the playback time. The larger the setting, the longer the playback time that datain can cache.) max_counts Maximum counts of buffer, use HD_VIDEODEC_SET_COUNT to set. min_counts Minimum counts of buffer, use HD_VIDEODEC_SET_COUNT to set. mode Pool mode, 0: auto, 1: enable, 2: disable [Apply Require] stop -> close -> open -> set -> start [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Not supported. NT9831X NT9832X NT9833X NT98331 All parameters are supported.","title":"3.2.4 HD_VIDEODEC_POOL"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#325-hd_videodec_user_bs","text":"[Description] User video bitstream information [Parameter] Value Description sign Data signature, use MAKEFOURCC(\u2018V\u2019,\u2019S\u2019,\u2019T\u2019,\u2019M\u2019) p_next Pointer to next meta p_bs_buf Pointer of bitstream buffer address pointer bs_buf_size Bitstream buffer size retval Reserved for future using time_align Playback timestamp alignment mode, see HD_VIDEODEC_ALIGN time_diff Playback interval time (unit: microsecond) timestamp Decode bitstream timestamp to encode for transcode (unit: microsecond) user_flag User specific control flag, use HD_VIDEODEC_FLAG_XXX definitions reserved Reserved for future using [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Not supported. NT9831X NT9832X NT9833X NT98331 All parameters are supported.","title":"3.2.5 HD_VIDEODEC_USER_BS"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#326-hd_videodec_align","text":"[Description] Playback timestamp alignment information [State] Value Description HD_VIDEODEC_TIME_ALIGN_ENABLE (default) playback time align by LCD period (e.g. 60HZ should be 33333 us) HD_VIDEODEC_TIME_ALIGN_DISABLE Play timestamp by hd_videodec_send_list called HD_VIDEODEC_TIME_ALIGN_USER Start to play at previous play point + time_diff(us) [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Not supported. NT9831X NT9832X NT9833X NT98331 All states are supported.","title":"3.2.6 HD_VIDEODEC_ALIGN"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#327-hd_videodec_status","text":"[Description] Video decoder current status. [Parameter] Value Description left_frames Number of frames to be decoded. reserved_ref_frame Reserved reference frame when unbind unit. NOTE: Cannot be set when swtiching codec type. done_frames Number of decoded frames reserved[0] Decode input available buffer counts. Please refer to sample for usage, playback_with_sync.c (code\\hdal\\samples\\media_flow) reserved[1~7] Reserved for future using. [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Not supported. NT9831X NT9832X NT9833X NT98331 All states are supported.","title":"3.2.7 HD_VIDEODEC_STATUS"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#4-trouble-shooting","text":"The videodec module supports two kinds of debug mechanism for user. User can use proc command or debug menu to debug.","title":"4 Trouble shooting"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#41-debug-menu-nt9668x-nt9852x-nt9856x-nt98530","text":"In application, call hd_debug_run_menu() to open the debug menu. ============================== ?HDAL ------------------------------ ?01 : AUDIOCAPTURE ?02 : AUDIOOUT ?03 : AUDIOENC ?04 : AUDIODEC ?05 : VIDEOCAPTURE ?06 : VIDEOOUT ?07 : VIDEOPROCESS ?08 : VIDEOENC ?09 : VIDEODEC ?10 : OSG ?11 : COMMON ?12 : UTIL ?13 : DEBUG ------------------------------ ?254 : Quit ?255 : Return ------------------------------ Enter \u201c9\u201d to open VIDEODEC debug menu ============================== VIDEODEC ------------------------------ ?01 : dump status ------------------------------ ?254 : Quit ?255 : Return ------------------------------ Note: The items in the menu may vary for each chip.","title":"4.1 Debug Menu (NT9668X / NT9852X / NT9856X / NT98530)"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#411-dump-status","text":"Enter \u201c1\u201d to show the status of videodec Run: 01 : dump status HDAL_VERSION: 00010001:00010001 ------------------------- VIDEODEC 0? PATH & BIND ------------------------------ in??? out?? state bind_src????????????? bind_dest 0???? 0???? START (null)??????????????? VIDEOPROC_0_IN_0 ------------------------- VIDEODEC 0? PATH CONFIG ------------------------------ in??? out?? max_w max_h? codec 0???? 0???? 640?? 480??? JPEG ------------------------- VIDEODEC 0? IN FRAME --------------------------------- in??? codec 0???? JPEG As above, the debug menu shows the path & bind information, path_config , input frame / output bitstream information, more detail can see the table as below. [PATH & BIND] Status Description Value In input id of path 0 ~ [max_in_count] out output id of path 0 ~ [max_out_count] state state of path OFF/OPEN/START (default OFF) bind_src current binding source of input bind: [module] [device_id]_OUT [output_id] not-bind: (null) bind_dest current binding source of output bind: [module] [device_id]_IN [input_id] not-bind: (null) [PATH CONFIG] Value Description Value in input id of path 0 ~ [max_in_count] out output id of path 0 ~ [max_out_count] max_w maximum dimension width 16 ~ 65532: user assign width default 0 (n/a) max_h maximum dimension height 16 ~ 65532: user assign height default 0 (n/a) [IN FRAME] Value Description Value in input id 0 ~ [max_in_count] codec current input video codec type enum: user assign codec type see HD_VIDEO_CODEC default 0 (n/a)","title":"4.1.1 dump status"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#42-proc-command-nt9668x-nt9852x-nt9856x-nt98530","text":"User can obtained debugging information from the proc file system of Linux.","title":"4.2 proc command (NT9668X / NT9852X / NT9856X / NT98530)"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#421-dump-status","text":"[dump info] cat /proc/hdal/vdec/info the result is exactly the same as 4.1.1 Dump status Run: 01 : dump status HDAL_VERSION: 00010001:00010001 ------------------------- VIDEODEC 0? PATH & BIND ------------------------------ in??? out?? state bind_src????????????? bind_dest 0???? 0???? START (null)??????????????? VIDEOPROC_0_IN_0 ------------------------- VIDEODEC 0? PATH CONFIG ------------------------------ in??? out?? max_w max_h? codec 0???? 0???? 640?? 480??? JPEG ------------------------- VIDEODEC 0? IN FRAME --------------------------------- in??? codec 0???? JPEG","title":"4.2.1 dump status"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#422-debug-command","text":"[debug port] echo debug [dev] [i/o] [mask] > /proc/hdal/adec/cmd where [dev] = d0 , [i/o] = i0, i1, i2, \u2026, o0, o1, o2, \u2026 , [mask] = show info mask [ Sample ] echo debug d0 o0 mffff > /proc/hdal/vdec/cmd this debug command can show more debug log on console root@NVTEVM:/mnt/sd$ hd_video_playback 2 [ 4183.595988] hd_reset - begin [ 4183.601853] hd_reset - end HDAL_VERSION: 00010001:00010002 [ 4183.657738] [ 4183.657738] hd: \u201cvdodec\u201d.out[0]: open begin, state=0 [ 4183.665326] hd: \u201cvdodec\u201d.out[0]: cmd OPEN [ 4183.678796] hd: \u201cvdodec\u201d.out[0]: open end, state=1 [ 4183.685213] hd: \u201cvdodec\u201d.out[0]: set param(08000a05)=1 [ 4183.708678] hd: \u201cvdodec\u201d.out[0]: set param(08000a00)=1 [ 4183.716255] hd: \u201cvdodec\u201d.out[0]: set param(08000a00)=1 [ 4183.722596] [ 4183.722596] hd: \u201cvdodec\u201d.out[0]: bind begin, (\u201cvdoprc0\u201d.in[0]) [ 4183.732387] hd: \u201cvdodec\u201d.out[0]: cmd CONNECT [ 4183.737854] hd: \u201cvdodec\u201d.out[0]: cmd RDYSYNC [ 4183.748315] hd: \u201cvdodec\u201d.out[0]: bind end [ 4183.753391] [ 4183.753391] hd: \u201cvdodec\u201d.out[0]: start begin, state=1 [ 4183.761045] hd: \u201cvdodec\u201d.out[0]: cmd RDYSYNC [ 4183.771498] hd: \u201cvdodec\u201d.out[0]: cmd START [ 4183.782689] hd: \u201cvdodec\u201d.out[0]: start end, state=2 Enter q to exit bs file: [/mnt/sd/video_bs_640_480_jpeg.dat] bslen file: [/mnt/sd/video_bs_640_480_jpeg.len] q [ 4188.409136] [ 4188.409136] hd: \u201cvdodec\u201d.out[0]: stop begin, state=2 [ 4188.416733] hd: \u201cvdodec\u201d.out[0]: cmd STOP [ 4188.429400] hd: \u201cvdodec\u201d.out[0]: stop end, state=1 [ 4188.443260] [ 4188.443260] hd: \u201cvdodec\u201d.out[0]: unbind begin, (\u201cvdoprc0\u201d.in[0]) [ 4188.451877] hd: \u201cvdodec\u201d.out[0]: cmd DISCONNECT [ 4188.457451] hd: \u201cvdodec\u201d.out[0]: unbind end [ 4188.462694] hd: \u201cvdodec\u201d.out[0]: set param(08000a05)=0 [ 4188.468879] [ 4188.468879] hd: \u201cvdodec\u201d.out[0]: close begin, state=1 [ 4188.476533] hd: \u201cvdodec\u201d.out[0]: cmd CLOSE [ 4188.484832] hd: \u201cvdodec\u201d.out[0]: close end, state=0","title":"4.2.2 debug command"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#423-trace-command","text":"[trace port] echo trace [dev] [i/o] [mask] > /proc/hdal/adec/cmd where [dev] = d0 , [i/o] = i0, i1, i2, \u2026, o0, o1, o2, \u2026 , [mask] = show info mask [ Sample ] echo trace d0 o0 mffff > /proc/hdal/vdec/cmd this trace command could enable module internal debug message to know what\u2019s going on for the VIDEODEC module.","title":"4.2.3 trace command"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#424-probe-command","text":"[probe port] echo probe [dev] [i/o] [mask] > /proc/hdal/adec/cmd where [dev] = d0 , [i/o] = i0, i1, i2, \u2026, o0, o1, o2, \u2026 , [mask] = show info mask [ Sample ] echo probe d0 o0 mffff > /proc/hdal/vdec/cmd this probe command could print per-data status [ 5310.074418] hd: \u201cvdodec\u201d.out[0] - NEW - new \u2013 h=94001fc0 size=00070800 addr=94002000 OK [ 5310.085787] hd: \u201cvdodec\u201d.out[0] - PUSH - data \u2013 h=94001fc0 t=000000013dd1c406 (YUV: 640x480.520c0420 94002000 9404d000 640 640) [ 5310.113972] hd: \u201cvdodec\u201d.out[0] - NEW - new \u2013 h=9407afc0 size=00070800 addr=9407b000 OK [ 5310.125334] hd: \u201cvdodec\u201d.out[0] - PUSH - data \u2013 h=9407afc0 t=000000013dd25e8e (YUV: 640x480.520c0420 9407b000 940c6000 640 640) [ 5310.153493] hd: \u201cvdodec\u201d.out[0] - NEW - new \u2013 h=940f3fc0 size=00070800 addr=940f4000 OK [ 5310.164831] hd: \u201cvdodec\u201d.out[0] - PUSH - data \u2013 h=940f3fc0 t=000000013dd2f8ef (YUV: 640x480.520c0420 940f4000 9413f000 640 640) [ 5310.192974] hd: \u201cvdodec\u201d.out[0] - NEW - new \u2013 h=940f3fc0 size=00070800 addr=940f4000 OK [ 5310.204320] hd: \u201cvdodec\u201d.out[0] - PUSH - data \u2013 h=940f3fc0 t=000000013dd39329 (YUV: 640x480.520c0420 940f4000 9413f000 640 640) [ 5310.232463] hd: \u201cvdodec\u201d.out[0] - NEW - new \u2013 h=9407afc0 size=00070800 addr=9407b000 OK [ 5310.243803] hd: \u201cvdodec\u201d.out[0] - PUSH - data \u2013 h=9407afc0 t=000000013dd42d6b (YUV: 640x480.520c0420 9407b000 940c6000 640 640) [ 5310.271956] hd: \u201cvdodec\u201d.out[0] - NEW - new \u2013 h=94001fc0 size=00070800 addr=94002000 OK [ 5310.283296] hd: \u201cvdodec\u201d.out[0] - PUSH - data \u2013 h=94001fc0 t=000000013dd4c7ac (YUV: 640x480.520c0420 94002000 9404d000 640 640)","title":"4.2.4 probe command"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#425-perf-command","text":"[perf port] echo perf [dev] [i/o] > /proc/hdal/adec/cmd [ Sample ] echo perf d0 i0 > /proc/hdal/vdec/cmd this perf command could print data count per second [ 5390.325791] hd: \u201cvdodec\u201d.in[0] - perf \u2013 (VideoBs) 825 KByte/sec [ 5391.330332] hd: \u201cvdodec\u201d.in[0] - perf \u2013 (VideoBs) 825 KByte/sec [ 5392.336753] hd: \u201cvdodec\u201d.in[0] - perf \u2013 (VideoBs) 819 KByte/sec [ 5393.345119] hd: \u201cvdodec\u201d.in[0] - perf \u2013 (VideoBs) 820 KByte/sec","title":"4.2.5 perf command"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#426-save-command","text":"[save port] echo save [dev] [i/o] [count] > /proc/hdal/adec/cmd where [count] means how many i/o datas to save [ Sample ] echo save d0 i0 > /proc/hdal/vdec/cmd this save command could save i/o data to SDCard for debug purpose. [ 5471.047725] save i/o begin: \u201cvdodec\u201d.in[0] count=1 [ 5473.414755] hd: \u201cvdodec\u201d.in[0] - save \u2013 h=9416dfc0 t=00000001478e2434 (VSTM: 1296e000 25874) [ 5473.443425] hd: \u201cvdodec\u201d.in[0] - save \u2013 //mnt//sd//isf_? vdodec_in[0]_c0.bsv ok [ 5473.451859] save port end","title":"4.2.6 save command"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#43-proc-command-nt9631x-nt9832x-nt9833x-nt98331","text":"","title":"4.3 Proc Command (NT9631X / NT9832X / NT9833X / NT98331)"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#431-dump-setting","text":"User can cat info file to dump module\u2019s status. ------------------------- VIDEODEC 0? PATH & BIND ----------------------------- in????? out???? state?? bind_src??????????????? bind_dest 0?????? 0?????? START?? -?????????????????????? VIDEOPROC_4_IN_0 0?????? 1?????? START?? -?????????????????????? VIDEOPROC_5_IN_0 0?????? 2?????? START?? -?????????????????????? VIDEOPROC_6_IN_0 0?????? 3?????? START?? -????????? ?????????????VIDEOPROC_7_IN_0 ------------------------- VIDEODEC 0? PATH POOL ----------------------------- out???? pool??? ddr_id? count?? max_count 0?????? 0?????? 0?????? 3.5???? 3.0 0?????? 1?????? 0?????? 3.5???? 3.0 1?????? 0?????? 0?????? 3.5???? 3.0 1?????? 1?????? 0?????? 3.5???? 3.0 2?????? 0?????? 0?????? 3.5???? 3.0 2?????? 1?????? 0?????? 3.5???? 3.0 3?????? 0?????? 0?????? 3.5???? 3.0 3?????? 1?????? 0?????? 3.5???? 3.0 [PATH & BIND] Status Description Value in input id of path 0 out output id of path 0 ~ [max_out_count] state state of path OFF/OPEN/START (default OFF) bind_src current binding source of input bind: [module] [device_id]_OUT [output_id] not-bind: (null) bind_dest current binding source of output bind: [module] [device_id]_IN [input_id] not-bind: (null)","title":"4.3.1 dump setting"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#44-debug-menu-nt9631x-nt9832x-nt9833x-nt98331","text":"","title":"4.4 Debug Menu  (NT9631X / NT9832X / NT9833X / NT98331)"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#441-dump-info","text":"After enter debug menu, select 09 to enter this module\u2019s sub-menu. User can select 01 to dump module\u2019s status shown as below. ------------------------- VIDEODEC 0? PATH & BIND ----------------------------- in????? out???? state?? bind_src??????????????? bind_dest 0?????? 0?????? START?? -?????????????????????? VIDEOPROC_4_IN_0 0?????? 1?????? START?? -?????????????????????? VIDEOPROC_5_IN_0 0?????? 2?????? START?? -?????????????????????? VIDEOPROC_6_IN_0 0?????? 3?????? START?? -?????????????????????? VIDEOPROC_7_IN_0 ------------------------- VIDEODEC 0? PATH POOL ----------------------------- out???? pool??? ddr_id? count?? max_count 0?????? 0?????? 0?????? 3.5???? 3.0 0?????? 1?????? 0?????? 3.5???? 3.0 1?????? 0?????? 0?????? 3.5???? 3.0 1?????? 1?????? 0?????? 3.5???? 3.0 2?????? 0?????? 0?????? 3.5???? 3.0 2?????? 1?????? 0?????? 3.5???? 3.0 3?????? 0?????? 0?????? 3.5???? 3.0 3?????? 1?????? 0?????? 3.5?? ??3.0","title":"4.4.1 dump info"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#5-sample-codes","text":"","title":"5 Sample Codes"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#51-video_playback","text":"This sample code is used in NT9668X / NT9852X / NT9856X / NT98530. The hd_video_playback demonstrates how to use the single trigger operation to process the input image. /* Allocate common buffer*/ // config common pool (main) mem_cfg.pool_info[0].type = HD_COMMON_MEM_COMMON_POOL; mem_cfg.pool_info[0].blk_size = DBGINFO_BUFSIZE()+VDO_YUV_BUFSIZE(ALIGN_CEIL_64(VDO_SIZE_W), ALIGN_CEIL_64(VDO_SIZE_H), HD_VIDEO_PXLFMT_YUV420);? // align to 16 for rotate buffer mem_cfg.pool_info[0].blk_cnt = 3; mem_cfg.pool_info[0].ddr_id = DDR_ID0; // config common pool for bs pushing in mem_cfg.pool_info[1].type = HD_COMMON_MEM_USER_POOL_BEGIN; mem_cfg.pool_info[1].blk_size = BS_BLK_SIZE; mem_cfg.pool_info[1].blk_cnt = 1; mem_cfg.pool_info[1].ddr_id = DDR_ID0; ret = hd_common_mem_init(&mem_cfg); /* Set dec path configuration */ video_path_cfg.max_mem.codec_type = dec_type; video_path_cfg.max_mem.dim.w = p_max_dim->w; video_path_cfg.max_mem.dim.h = p_max_dim->h; ret = hd_videodec_set(video_dec_path, HD_VIDEODEC_PARAM_PATH_CONFIG, &video_path_cfg); if (ret != HD_OK) { return ret; } /* Set dec parameter */ video_in_param.codec_type = dec_type; video_in_param.dim.w = p_dim->w; video_in_param.dim.h = p_dim->h; ret = hd_videodec_set(video_dec_path, HD_VIDEODEC_PARAM_IN, &video_in_param); if (ret != HD_OK) { return ret; } /* Set proc configuration */ ret = hd_videoproc_open(0, HD_VIDEOPROC_0_CTRL, &video_proc_ctrl); //open this for device control if (p_max_dim != NULL) { video_cfg_param.pipe = HD_VIDEOPROC_PIPE_SCALE; video_cfg_param.isp_id = 0; video_cfg_param.ctrl_max.func = 0; video_cfg_param.in_max.func = 0; video_cfg_param.in_max.dim.w = p_max_dim->w; video_cfg_param.in_max.dim.h = p_max_dim->h; video_cfg_param.in_max.pxlfmt = HD_VIDEO_PXLFMT_YUV420; video_cfg_param.in_max.frc = HD_VIDEO_FRC_RATIO(1,1); ret = hd_videoproc_set(video_proc_ctrl, HD_VIDEOPROC_PARAM_DEV_CONFIG, &video_cfg_param); ???? if (ret != HD_OK) { ???????? return HD_ERR_NG; ???? } } video_ctrl_param.func = 0; ret = hd_videoproc_set(video_proc_ctrl, HD_VIDEOPROC_PARAM_CTRL, &video_ctrl_param); if (ret != HD_OK) { return ret;} /* Set proc parameter */ video_out_param.func = 0; video_out_param.dim.w = p_dim->w; video_out_param.dim.h = p_dim->h; video_out_param.pxlfmt = HD_VIDEO_PXLFMT_YUV420; video_out_param.dir = HD_VIDEO_DIR_NONE; video_out_param.frc = HD_VIDEO_FRC_RATIO(1,1); ret = hd_videoproc_set(video_proc_path, HD_VIDEOPROC_PARAM_OUT, &video_out_param); if (ret != HD_OK) { return ret;} /* Set out configuration */ ret = hd_videoout_open(0, HD_VIDEOOUT_0_CTRL, &video_out_ctrl); //open this for device control switch(out_type){ case 0: ???? videoout_mode.output_type = HD_COMMON_VIDEO_OUT_CVBS; ???? videoout_mode.input_dim = HD_VIDEOOUT_IN_AUTO; ???? videoout_mode.output_mode.cvbs= HD_VIDEOOUT_CVBS_NTSC; break; case 1: ???? videoout_mode.output_type = HD_COMMON_VIDEO_OUT_LCD; ???? videoout_mode.input_dim = HD_VIDEOOUT_IN_AUTO; ???? videoout_mode.output_mode.lcd = HD_VIDEOOUT_LCD_0; break; case 2: ???? videoout_mode.output_type = HD_COMMON_VIDEO_OUT_HDMI; ???? videoout_mode.input_dim = HD_VIDEOOUT_IN_AUTO; ???? videoout_mode.output_mode.hdmi= hdmi_id; break; default: ???? printf(\u201cnot support out_type\\r\\n\u201d); break; } ret = hd_videoout_set(video_out_ctrl, HD_VIDEOOUT_PARAM_MODE, &videoout_mode); if (ret != HD_OK) { return ret;} /* Set out parameter */ video_out_param.dim.w = p_dim->w; video_out_param.dim.h = p_dim->h; video_out_param.pxlfmt = HD_VIDEO_PXLFMT_YUV420; video_out_param.dir = HD_VIDEO_DIR_NONE; ret = hd_videoout_set(video_out_path, HD_VIDEOOUT_PARAM_IN, &video_out_param); if (ret != HD_OK) { return ret;} memset((void *)&video_out_param,0,sizeof(HD_VIDEOOUT_IN)); ret = hd_videoout_get(video_out_path, HD_VIDEOOUT_PARAM_IN, &video_out_param); if (ret != HD_OK) { return ret;} /* Bind modules */ hd_videodec_bind(HD_VIDEODEC_0_OUT_0, HD_VIDEOPROC_0_IN_0); hd_videoproc_bind(HD_VIDEOPROC_0_OUT_0, HD_VIDEOOUT_0_IN_0); /* start modules */ hd_videodec_start(stream[0].dec_path); hd_videoproc_start(stream[0].proc_path); hd_videoout_start(stream[0].out_path); /* Push in buffer */ blk = hd_common_mem_get_block(HD_COMMON_MEM_COMMON_POOL, blk_size, ddr_id); pa = hd_common_mem_blk2pa(blk); va= hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_CACHE, pa, blk_size); fread((void *)va, 1, length, bs_fd); video_bs.phy_addr[0] = pa; video_bs.size = length; ret = hd_videodec_push_in_buf(p_stream0->dec_path, &video_bs, NULL, 0); if (ret != HD_OK) { return ret; } /* Release in buffer */ hd_common_mem_munmap((void *)va, blk_size) hd_common_mem_release_block(blk);","title":"5.1 Video_playback"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#52-video_decode_only","text":"This sample code is used in NT9668X / NT9852X / NT9856X / NT98530. The hd_videodec_only demonstrates how to use the single trigger operation to process the input image. /* Allocate common buffer*/ // config common pool (main) mem_cfg.pool_info[0].type = HD_COMMON_MEM_COMMON_POOL; mem_cfg.pool_info[0].blk_size = DBGINFO_BUFSIZE()+VDO_YUV_BUFSIZE(ALIGN_CEIL_64(VDO_SIZE_W), ALIGN_CEIL_64(VDO_SIZE_H), HD_VIDEO_PXLFMT_YUV420);? // align to 16 for rotate buffer mem_cfg.pool_info[0].blk_cnt = 3; mem_cfg.pool_info[0].ddr_id = DDR_ID0; // config common pool for bs pushing in mem_cfg.pool_info[1].type = HD_COMMON_MEM_USER_POOL_BEGIN; mem_cfg.pool_info[1].blk_size = BS_BLK_SIZE; mem_cfg.pool_info[1].blk_cnt = 1; mem_cfg.pool_info[1].ddr_id = DDR_ID0; ret = hd_common_mem_init(&mem_cfg); /* Set dec path configuration */ video_path_cfg.max_mem.codec_type = dec_type; video_path_cfg.max_mem.dim.w = p_max_dim->w; video_path_cfg.max_mem.dim.h = p_max_dim->h; ret = hd_videodec_set(video_dec_path, HD_VIDEODEC_PARAM_PATH_CONFIG, &video_path_cfg); if (ret != HD_OK) { return ret; } /* Set dec parameter */ video_in_param.codec_type = dec_type; video_in_param.dim.w = p_dim->w; video_in_param.dim.h = p_dim->h; ret = hd_videodec_set(video_dec_path, HD_VIDEODEC_PARAM_IN, &video_in_param); if (ret != HD_OK) { return ret; } /* start modules */ hd_videodec_start(stream[0].dec_path); /* Push in buffer */ blk = hd_common_mem_get_block(HD_COMMON_MEM_COMMON_POOL, blk_size, ddr_id); pa = hd_common_mem_blk2pa(blk); va= hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_CACHE, pa, blk_size); fread((void *)va, 1, length, bs_fd); video_bs.phy_addr[0] = pa; video_bs.size = length; ret = hd_videodec_push_in_buf(p_stream0->dec_path, &video_bs, NULL, 0); if (ret != HD_OK) { return ret; } /* Release in buffer */ hd_common_mem_munmap((void *)va, blk_size) hd_common_mem_release_block(blk); /* Pull out buffer */ ret = hd_videodec_pull_out_buf(p_stream0->dec_path, &data_pull, -1); if (ret == HD_OK) { ???? hd_videodec_get(p_stream0->dec_path, HD_VIDEODEC_PARAM_BUFINFO, &phy_buf_main); vir_addr_main = (UINT32)hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_CACHE, phy_buf_main.buf_info.phy_addr, phy_buf_main.buf_info.buf_size);","title":"5.2 video_decode_only"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#define-phy2virt_mainpa-vir_addr_main-pa-phy_buf_mainbuf_infophy_addr","text":"???? va = PHY2VIRT_MAIN(data_pull.phy_addr); ???? size = data_pull.size; ???? sprintf(filename, \u201cdump_frm_main.dat\u201d); ???? save_output(filename, va, size); } /* Release out buffer */ hd_common_mem_munmap(vir_addr_main, phy_buf_main.buf_info.buf_size); hd_videodec_release_out_buf(p_stream0->dec_path, &data_pull);","title":"define PHY2VIRT_MAIN(pa) (vir_addr_main + (pa - phy_buf_main.buf_info.phy_addr))"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#53-user_videodec","text":"This sample code is used in NT9831X / NT9832X / NT9833X / NT98331. The user_videodec demonstrates how to use the single trigger operation to process the input image. /* Set parameters */ config.max_mem.dim.w = max_frame_width; config.max_mem.dim.h = max_frame_height; config.max_mem.frame_rate = 30; ret = hd_videodec_set(path_id, HD_VIDEODEC_PARAM_PATH_CONFIG, &config); if (ret != HD_OK) { ???? printf(\u201chd_videodec_set fail\\n\u201d); ???? goto exit; } /* Allocate in buffer */ bs_in_buffer.ddr_id = ddr_id; bs_in_buffer.size = BS_BUF_SIZE; blk = hd_common_mem_get_block(pool, bs_in_buffer.size, ddr_id); if (HD_COMMON_MEM_VB_INVALID_BLK == blk) { ???? printf(\u201chd_common_mem_get_block fail\\r\\n\u201d); ???? ret =? HD_ERR_NG; ???? goto exit; } bs_in_buffer.phy_addr = hd_common_mem_blk2pa(blk); if (bs_in_buffer.phy_addr == 0) { ???? printf(\u201chd_common_mem_blk2pa fail, blk = %#lx\\r\\n\u201d, blk); ???? hd_common_mem_release_block(blk); ???? return HD_ERR_NG; } bs_in_buffer_va = hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_NONCACHE, ??????????????????????????????? bs_in_buffer.phy_addr, ??????????????????????????????? bs_in_buffer.size); /* Allocate out buffer */ blk = hd_common_mem_get_block(pool, frame_buf_size, ddr_id); if (HD_COMMON_MEM_VB_INVALID_BLK == blk) { ???? printf(\u201chd_common_mem_get_block fail\\r\\n\u201d); ???? ret =? HD_ERR_NG; ???? goto exit; } dec_out_buffer.phy_addr[0] = hd_common_mem_blk2pa(blk); if (dec_out_buffer.phy_addr[0] == 0) { ???? printf(\u201chd_common_mem_blk2pa fail, blk = %#lx\\r\\n\u201d, blk); ???? hd_common_mem_release_block(blk); ???? return HD_ERR_NG; } dec_out_buffer_va = hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_NONCACHE, ???????????????????????????????????????? dec_out_buffer.phy_addr[0], ???????????????????????????????????????? frame_buf_size); /* Push in buffer */ fscanf(bs_len_fd, \u201c%d\\n\u201d, &length); if (length > BS_BUF_SIZE) { ???? printf(\u201cUser bitstream is too large. bs_size(%d) > max(%d)\\n\u201d, length, BS_BUF_SIZE); ???? goto exit; } fseek(bs_fd, 0, SEEK_SET); fread((void *)bs_in_buffer_va, 1, length, bs_fd); bs_in_buffer.size = length; ret = hd_videodec_push_in_buf(path_id, &bs_in_buffer, &dec_out_buffer, 500); if (ret != HD_OK) { ???? printf(\u201chd_videodec_push_in_buf fail\\n\u201d); ???? goto exit; } /* Pull out buffer */ ret = hd_videodec_pull_out_buf(path_id, &dec_out_buffer, 500); if (ret != HD_OK) { ???? printf(\u201chd_videodec_pull_out_buf fail\\n\u201d); ???? goto exit; } else { ???? dec_out_buffer_va = hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_NONCACHE, ???????????????????????????????????????? dec_out_buffer.phy_addr[0], ???????????????????????????????????????? frame_buf_size); ???? sprintf(filename, \u201cuser_dec_%ldx%ld_YUV420_16x2.yuv\u201d, dec_out_buffer.dim.w, dec_out_buffer.dim.h); ???? save_output(filename, dec_out_buffer_va, frame_buf_size); } /* Release in buffer */ hd_common_mem_munmap(bs_in_buffer_va, frame_buf_size); hd_common_mem_release_block((HD_COMMON_MEM_VB_BLK)bs_in_buffer.phy_addr); /* Release out buffer */ hd_common_mem_munmap(dec_out_buffer_va, frame_buf_size); hd_common_mem_release_block((HD_COMMON_MEM_VB_BLK)dec_out_buffer.phy_addr[0]);","title":"5.3 user_videodec"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videodec.html#6-faq","text":"Why using hd_videodec_push_in_buf() but return error -19? Answer: o Check hd_videodec_start() is already called. o If hd_videodec_start() is called, please check the order of hd_videodec_set (HD_VIDEODEC_PARAM_IN_DESC) and hd_videodec_start(). Call hd_videodec_set(HD_VIDEODEC_PARAM_IN_DESC) first, and then call hd_videodec_start(). Why using hd_videoproc_pull_out_buf() to pull the yuv data from videodec, but return time out error -15? Answer: o Check the bitstream first. If the continuous incorrect frames exist in the bitstream, video decode error happened and decoder not send the error YUV to vproc in binding mode. It caused time out error -15 if timeout value is set. What values of width and height should I set for each codecs? Answer: o H264: width is aligned to 64, height is aligned to 16. o H265: width is aligned to 64, height is aligned to 64. o JPEG: width is aligned to 16, height is aligned to 16. Is it possible to push yuv data from vdodec to vdoout directly? Answer: o For Achieving video playback function, vdec, vproc and vout are necessary. The binding order is vdec, vproc, and then vout. Vproc scaled the resolution if the resolution of YUV is differ to display device. Is it possible to change the resolution when video decode is processing? Answer: o No, please call hd_videodec_stop() to stop decoder, set the new width/height, and ?? call hd_videodec_start() to start decoder again. Remember that config the maximum width/height at beginning. I set vdodec_maxpath = 17 in dtsi, why show warning message \u201cdts max_path=17 is larger than built-in max_path=16\u201d? Answer: o VDODEC_MAX_PATH_NUM is defined as 16 in isf_vdodec, which means video decode path maximum is 16. Please set vdodec_maxpath <= 16 in dtsi.","title":"6 FAQ"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html","text":"1 Introduction \u00b6 The major purpose of hd_videoenc is to get YUV raw data from upper unit, and controls the video encoder to encode the YUV data then return the bitstream data which can be used for saving video files / online streaming. This document will talk about the red block in the following diagram. The device driver is not the main point in this document. Module diagram is shown as below: 1.1 Basic Flow \u00b6 The call sequence is needed to be done correctly for the unit. The standard starting flows of most modules are init, open, get, set, bind and start. The standard closing flows of most modules are stop, unbind, close and uninit. The basic flow is shown as below. Now, below section in this chapter is mainly about what things to do in those functions above. 1.2 Single Trigger Operation \u00b6 Single trigger operation is used to trigger the unit to do one job, such as to grab one YUV frame from video capture; then, encode one frame to bitstream by using video encoder. There are two types of functions for the input port and output port. The sequence for input port is push; the sequence for output port is pull and release. The flow is shown as below. 1.3 Multi Channel Operation \u00b6 Multi channel operation is used to send multi bitstream simultaneously, it is very efficiency in the multi channels case. The flow is shown as below: 2 Parameter IDs and data structure definition \u00b6 The videoenc provides the following parameter IDs: l HD_VIDEOENC_PARAM_DEVCOUNT o support get with ctrl path o using HD_DEVCOUNT struct (device id max count) l HD_VIDEOENC_PARAM_SYSCAPS o support get with ctrl path o using HD_VIDEOENC_SYSCAPS struct (system capabilitiy) l HD_VIDEOENC_PARAM_PATH_CONFIG o support get/set with i/o path o using HD_VIDEOENC_PATH_CONFIG struct l HD_VIDEOENC_PARAM_BUFINFO o support get with i/o path o using HD_VIDEOENC_BUFINFO struct l HD_VIDEOENC_PARAM_IN o support get/set with i/o path o using HD_VIDEOENC_IN struct l HD_VIDEOENC_PARAM_OUT_ENC_PARAM o support get/set with i/o path o using HD_VIDEOENC_OUT struct l HD_VIDEOENC_PARAM_OUT_VUI o support get/set with i/o path o using HD_H26XENC_VUI struct l HD_VIDEOENC_PARAM_OUT_DEBLOCK o support get/set with i/o path o using HD_H26XENC_DEBLOCK struct l HD_VIDEOENC_PARAM_OUT_RATE_CONTROL o support get/set with i/o path o using HD_H26XENC_RATE_CONTROL struct l HD_VIDEOENC_PARAM_OUT_USR_QP o support get/set with i/o path o using HD_H26XENC_USR_QP struct l HD_VIDEOENC_PARAM_OUT_SLICE_SPLIT o support get/set with i/o path o using HD_H26XENC_SLICE_SPLIT struct l HD_VIDEOENC_PARAM_OUT_ENC_GDR o support get/set with i/o path o using HD_H26XENC_GDR struct l HD_VIDEOENC_PARAM_OUT_ROI o support get/set with i/o path o using HD_H26XENC_ROI struct l HD_VIDEOENC_PARAM_OUT_ROW_RC o support get/set with i/o path o using HD_H26XENC_ROW_RC struct l HD_VIDEOENC_PARAM_OUT_AQ o support get/set with i/o path o using HD_H26XENC_AQ struct l HD_VIDEOENC_PARAM_OUT_REQUEST_IFRAME o support set with i/o path o using HD_H26XENC_REQUEST_IFRAME struct l HD_VIDEOENC_PARAM_OUT_TRIG_SNAPSHOT o support set with i/o path o using HD_H26XENC_TRIG_SNAPSHOT struct l HD_VIDEOENC_PARAM_IN_STAMP_BUF o support set with i/stamp path o using HD_OSG_STAMP_BUF struct (stamp buffer parameter) l HD_VIDEOENC_PARAM_IN_STAMP_IMG o support set with i/stamp path o using HD_OSG_STAMP_IMG struct (stamp image parameter) l HD_VIDEOENC_PARAM_IN_STAMP_ATTR o support get/set with i/stamp path o using HD_OSG_STAMP_ATTR struct (stamp display attribute) l HD_VIDEOENC_PARAM_IN_MASK_ATTR o support get/set with i/mask path o using HD_OSG_MASK_ATTR struct (mask display attribute) l HD_VIDEOENC_PARAM_IN_MOSAIC_ATTR o support get/set with i/mask path o using HD_OSG_MOSAIC_ATTR struct (mosaic display attribute) l HD_VIDEOENC_PARAM_IN_PALETTE_TABLE o support get/set with i path o using HD_OSG_PALETTE_TBL struct 2.1 General function \u00b6 2.1.1 hd_videoenc_init \u00b6 [Description] Initialize the unit [Syntax] HD_RESULT hd_videoenc_init(VOID); [Parameter] Value Description VOID Not available [Return Value] Value Description HD_OK Success HD_ERR_NG Failure 2.1.2 hd_videoenc_open \u00b6 [Description] Open the unit [Syntax] HD_RESULT hd_videoenc_open(HD_IN_ID in_id, HD_OUT_ID out_id, HD_PATH_ID* p_path_id) [Parameter] Value Description in_id id of input port out_id id of output port p_path_id pointer of the path id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure [Note] For OSG: There are two kinds of OSG : ext and non-ext. ext poses less position limitation but consumes more CPU/DMA. ext is ideal for OSG with small resolution and high position flexibility. Ext modifies input yuv buffer. If an input yuv buffer is feed to multiple streamings and each streaming should have its own OSG, don\u2019t use ext. One buffer mode can\u2019t work with ext. It\u2019s possible videoprocess and ext are updating the same yuv buffer and leads to broken streamings. Compressed yuv can\u2019t work with ext. Currently, OSG on jpeg is implemented as ext. This means performance deterioration and input buffer pollution automatically apply to jpeg. Built-in mask should be regarded as built-in stamp. This means all restrictions imposed to stamp also impose to mask. For example, a macro block can\u2019t render a mask and a stamp in a layer. Opening HD_MASK_X after opening HD_STAMP_X would render HD_STAMP_X invalid unless opening HD_MASK_Y instead. NT9853X has full built-in mask. Above note doesn\u2019t hold for NT9853X. Built-in mask is rendered atop stamp. If encoder rotation is supported and enabled, ext will be rotated. OSG should be opened with HD_MASK_X, HD_MASK_EX_X, HD_STAMP_X and HD_STAMP_EX_X. Don\u2019t use HD_MASK(), HD_MASK_EX(), HD_STAMP() or HD_STAMP_EX(). Ext OSG are rendered beneath non-ext OSG. 2.1.3 hd_videoenc_get \u00b6 [Description] Get parameters from unit by path id [Syntax] HD_RESULT hd_videoenc_get(HD_PATH_ID path_id, HD_VIDEOENC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter 2.1.4 hd_videoenc_set \u00b6 [Description] Set parameters to unit by path id [Syntax] HD_RESULT hd_videoenc_set(HD_PATH_ID path_id, HD_VIDEOENC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter 2.1.5 hd_videoenc_bind \u00b6 [Description] Bind this unit with destination unit [Syntax] HD_RESULT hd_videoenc_bind(HD_OUT_ID out_id, HD_IN_ID dest_in_id) [Parameter] Value Description out_id id of output port. dest_in_id id of input port. [Return Value] Value Description HD_OK Success HD_ERR_NG Failure 2.1.6 hd_videoenc_start \u00b6 [Description] Start the unit [Syntax] HD_RESULT hd_videoenc_start(HD_PATH_ID path_id) [Parameter] Value Description path_id pointer of the path id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure 2.1.7 hd_videoenc_stop \u00b6 [Description] Stop the unit [Syntax] HD_RESULT hd_videoenc_stop(HD_PATH_ID path_id) [Parameter] Value Description path_id pointer of the path id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure 2.1.8 hd_videoenc_unbind \u00b6 [Description] Unbind the unit [Syntax] HD_RESULT hd_videoenc_unbind(HD_OUT_ID out_id); [Parameter] Value Description out_id id of output port. [Return Value] Value Description HD_OK Success HD_ERR_NG Failure 2.1.9 hd_videoenc_close \u00b6 [Description] Close the unit [Syntax] HD_RESULT hd_videoenc_close(HD_PATH_ID path_id) [Parameter] Value Description path_id pointer of the path id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure [Note] For OSG: OSGs will keep registered buffer until they are closed. Only after this API returns can application safely access/reclaim the buffer. 2.1.10 hd_videoenc_uninit \u00b6 [Description] Uninitialize the unit [Syntax] HD_RESULT hd_videoenc_uninit(VOID); [Parameter] Value Description VOID Not available [Return Value] Value Description HD_OK Success HD_ERR_NG Failure 2.1.11 hd_videoenc_push_in_buf \u00b6 [Description] Push the video frame buffer to unit [Syntax] HD_RESULT hd_videoenc_push_in_buf(HD_PATH_ID path_id, HD_VIDEO_FRAME p_in_video_frame, HD_VIDEOENC_BS p_user_out_videoenc_bs, INT32 wait_ms); [Parameter] Value Description path_id the path id p_in_video_frame pointer of the input video frame buffer p_user_out_videoenc_bs pointer of the output video bitstream buffer wait_ms timeout value in ms [Return Value] Value Description HD_OK Success HD_ERR_NG Failure [Note] p_user_out_videoenc_bs is optional. If this value is set, videoenc module uses it as the output buffer for bitstream, and the buffer should be released by user after using it; otherwise, if the value is NULL, videoenc will allocate the buffer internally, and user need to call hd_videoenc_release_out_buf API to release the buffer finally. [Note] If videoproc is NOT binding to videoenc, that is, SDK user call pull_out YUV from videoproc and push_in to videoenc to encode. Be sure to check YUV weight/height is equal to encoder weight/height. If videoproc is binding to videoenc, the SDK will automatically check YUV & encoder setting. If the YUV weight/height is not correctly for encoding, SDK will automatically drop YUV. But if videoproc is NOT binding to videoenc, the SDK will NOT automatically check YUV & encoder setting, SDK user should take responsibility for checking YUV weight/height and encoder setting. This is essential to check YUV & encoder settings while changing resolution, because the two module will NOT change to new setting at the same time. If YUV from videoproc is NOT match videoenc setting, the YUV should be dropped instead of pushing to videoenc. 2.1.12 hd_videoenc_pull_out_buf \u00b6 [Description] Pull the video bitstream buffer from unit [Syntax] HD_RESULT hd_videoenc_pull_out_buf (HD_PATH_ID path_id, HD_VIDEOENC_BS* p_videoenc_bs, INT32 wait_ms); [Parameter] Value Description path_id the path id p_videoenc_bs pointer of the output video bitstream buffer wait_ms timeout value in ms [Return Value] Value Description HD_OK Success HD_ERR_NG Failure 2.1.13 hd_videoenc_release_out_buf \u00b6 [Description] Release the video bitstream buffer which is get from unit [Syntax] HD_RESULT hd_videoenc_release_out_buf (HD_PATH_ID path_id, HD_VIDEOENC_BS* p_videoenc_bs) [Parameter] Value Description path_id the path id p_videoenc_bs pointer of the output video bitstream buffer [Return Value] Value Description HD_OK Success HD_ERR_NG Failure 2.2 Multi List Operation \u00b6 Multi channel operation is used to send multi bitstream simultaneously, it is very efficiency in the multi channels case. The flow is shown as below: 2.2.1 hd_videoenc_start_list \u00b6 [Description] Start to send multi bitstream data to the unit [Syntax] HD_RESULT hd_videoenc_start_list(HD_PATH_ID *path_id, UINT num); [Parameter] Value Description path_id the path id num number of bitstream data [Return Value] Value Description HD_OK Success HD_ERR_NG Failure [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 NOT supported. NT9831X NT9832X NT9833X NT98331 All functions are supported. 2.2.2 hd_videoenc_stop_list \u00b6 [Description] Stop sending multi bitstream data to the unit [Syntax] HD_RESULT hd_videoenc_stop_list(HD_PATH_ID *path_id, UINT num); [Parameter] Value Description path_id the path id num number of bitstream data [Return Value] Value Description HD_OK Success HD_ERR_NG Failure [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 NOT supported. NT9831X NT9832X NT9833X NT98331 All functions are supported. 2.2.3 hd_videoenc_poll_list \u00b6 [Description]???????????????????????????????????? Query the bitstream status of all specifying channels [Syntax] HD_RESULT hd_videoenc_poll_list(HD_VIDEOENC_POLL_LIST *p_poll, UINT32 num, INT32 wait_ms); [Parameter] Value Description p_poll The path information of multi channels num Number of bitstream paths wait_ms The timeout value in millisecond while polling. 0: not wait >0: wait time (in millisecond) <0: wait forever or not supported [Return Value] Value Description HD_OK Success HD_ERR_NG Failure [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Only revent.event is supported. wait_ms < 0: wait forever NT9831X NT9832X NT9833X NT98331 All functions are supported. wait_ms < 0: not supported 2.2.4 hd_videoenc_recv_list \u00b6 [Description] Receive bitstream data for all channels [Syntax] HD_RESULT hd_videoenc_recv_list(HD_VIDEOENC_RECV_LIST *p_videoenc_list, UINT32 num); [Parameter] Value Description p_videoenc_list An array of bitstream structure to be filled for multi channels num The number of channels to retrieve bitstream [Return Value] Value Description HD_OK Success HD_ERR_NG Failure [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 NOT supported. NT9831X NT9832X NT9833X NT98331 All functions are supported. 2.3 Data structure definition \u00b6 2.3.1 HD_VIDEOENC_PARAM_SYSCAPS \u00b6 [Description] System capability [Parameter] Value Description dev_id device id chip_id chip id of this device max_in_count max count of input of this device max_out_count max count of output of this device dev_caps capability of device, using HD_DEVICE_CAPS in_caps capability of input, using HD_VIDEO_CAPS out_caps capability of output, using HD_VIDEOENC_CAPS max_in_stamp max input stamp max_in_stamp_ex max input stamp_ex max_in_mask max input mask max_in_mask_ex max input mask_ex [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 max_in_count? = 16; max_out_count = 16; dev_caps = ??????????????? HD_CAPS_PATHCONFIG; in_caps[0~15] = ??????????????? HD_VIDEO_CAPS_YUV420 ??????????????? | HD_VIDEO_CAPS_YUV422 ??????????????? | HD_VIDEO_CAPS_COMPRESS ??????????????? | HD_VIDEO_CAPS_DIR_ROTATER ??????????????? | HD_VIDEO_CAPS_DIR_ROTATEL ??????????????? | HD_VIDEO_CAPS_STAMP ??????????????? | HD_VIDEO_CAPS_MASK; out_caps[0~15] = ??????????????? HD_VIDEOENC_CAPS_JPEG ??????????????? | HD_VIDEOENC_CAPS_H264 ??????????????? | HD_VIDEOENC_CAPS_H265; max_in_stamp = 32; max_in_stamp_ex = 64; max_in_mask = 8; max_in_mask_ex = 16; NT9831X NT9832X NT9833X NT98331 max_in_count = 64; max_out_count = 64; dev_caps = ??????????????? HD_CAPS_PATHCONFIG ??????????????? | HD_CAPS_LISTFUNC; in_caps[0~63] = ??????????????? HD_VIDEO_CAPS_YUV420 ??????????????? | HD_VIDEO_CAPS_YUV422 ??????????????? | HD_VIDEO_CAPS_DIR_ROTATER ??????????????? | HD_VIDEO_CAPS_DIR_ROTATE180 ??????????????? | HD_VIDEO_CAPS_DIR_ROTATEL ??????????????? | HD_VIDEO_CAPS_MASK; out_caps[0~63] = ??????????????? HD_VIDEOENC_CAPS_JPEG ??????????????? | HD_VIDEOENC_CAPS_H264 ??????????????? | HD_VIDEOENC_CAPS_H265; max_in_stamp = 0; max_in_stamp_ex = 0; max_in_mask = 0; max_in_mask_ex = 0; 2.3.2 HD_VIDEOENC_PARAM_PATH_CONFIG \u00b6 [Description] Path configure [Parameter] Value Description max_mem maximum memory information. Using HD_VIDEOENC_MAXMEM struct isp_id ISP id. range: 0~7 or 0xffffffff = ignore data_pool pool memory information. User can specify the size/count of buffers for encoder\u2019s out-buffer. [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 data_pool is not supported NT9831X NT9832X NT9833X NT98331 max_mem and isp_id are not supported. [Apply Require] stop -> close -> open -> set -> start 2.3.3 HD_VIDEOENC_PARAM_BUFINFO \u00b6 [Description] Buffer information [Parameter] Value Description buf_info physical addr/size of bitstream buffer, for user space to mmap [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Function is supported. NT9831X NT9832X NT9833X NT98331 Function is not supported. 2.3.4 HD_VIDEOENC_PARAM_IN \u00b6 [Description] Input parameters [Parameter] Value Description dim encode width/height, using HD_DIM struct pxl_fmt source format, using HD_VIDEO_PXLFMT struct dir input direction, using HD_VIDEO_DIR struct frc frame rate control [Difference] Chip Description NT9668X the valid pxl_fmt values in H26X with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV420_NVX1_H264(for H264 encode) HD_VIDEO_PXLFMT_YUV420_NVX1_H265(for H265 encode) and JPEG with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV422 NT9852X the valid pxl_fmt values in H26X with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV420_NVX2 and JPEG with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV422 NT9856X the valid pxl_fmt values in H26X with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV420_NVX2 and JPEG with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV420_NVX2 HD_VIDEO_PXLFMT_YUV422 NT98530 the valid pxl_fmt values in H26X with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV420_MB4 HD_VIDEO_PXLFMT_YUV420_NVX2 HD_VIDEO_PXLFMT_YUV420_NVX5 and JPEG with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV420_NVX2 HD_VIDEO_PXLFMT_YUV422 NT9831X NT9832X frc is not supported. the valid pxl_fmt values in H26X with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV420_NVX3 And JPEG with HD_VIDEO_PXLFMT_YUV420_MB NT9833X NT98331 the valid pxl_fmt values in H26X and jpeg with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV420_NVX3 [Apply Require] stop -> set -> start [Note] If videoproc is binding to videoenc, and HD_VIDEOPROC_OUT is set to default=0 (auto-sync parameters from videoenc), then remember to call start for videoproc [videoenc] stop -> set -> start [videoproc] start 2.3.5 HD_VIDEOENC_PARAM_IN_FRC \u00b6 [Description] Input parameters [Parameter] Value Description frc frame rate control [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Function is supported. NT9831X NT9832X NT9833X NT98331 Function is not supported. [Apply Require] If change between (dst <= src) and (dst <= src) set -> start If change between (dst <= src) and (dst > src)? (both direction) If change between (dst > src) and (dst > src) stop -> set -> start 2.3.6 HD_VIDEOENC_PARAM_OUT_ENC_PARAM \u00b6 [Description] Input frame [Parameter] Value Description codec_type codec type, using HD_VIDEO_CODEC struct h26x H26x config, using HD_H26X_CONFIG struct jpeg Jpeg config, using HD_JPEG_CONFIG struct [Apply Require] stop -> set -> start 2.3.7 HD_VIDEOENC_PARAM_OUT_VUI \u00b6 [Description] H26x vui settings [Parameter] Value Description vui_en enable vui. default: 0, range: 0~1 (0: disable, 1: enable) sar_width Horizontal size of the sample aspect ratio. default: 0, range: 0~65535 sar_height Vertical size of the sample aspect rat. default: 0, range: 0~65535 matrix_coef Matrix coefficients are used to derive the luma and Chroma signals from green, blue, and red primaries. default: 2, range: 0~255 transfer_characteristics The opto-electronic transfers characteristic of the source pictures. default: 2, range: 0~255 colour_primaries Chromaticity coordinates the source primaries. default: 2, range: 0~255 video_format Indicate the representation of pictures. default: 5, range: 0~7 color_range Indicate the black level and range of the luma and Chroma signals. default: 0, range: 0~1 (0: Not full range, 1: Full range) timing_present_flag timing info present flag. default: 0, range: 0~1 (0: disable, 1: enable) [Apply Require] stop -> set -> start 2.3.8 HD_VIDEOENC_PARAM_OUT_DEBLOCK \u00b6 [Description] H26x deblock settings [Parameter] Value Description dis_ilf_idc Disable loop filter in slice header. default: 0, range: 0~2 (0: Filter, 1: No Filter, 2: Slice Mode) db_alpha Alpha & C0 offset. default: 0, range: -12~12 db_beta Beta offset.?????? default: 0, range: -12~12 [Difference] Chip Description NT9668X dis_ilf_idc-> across_tile_en is not supported NT9852X NT9856X NT98530 NT9831X NT9832X NT9833X NT98331 All functions are supported. [Apply Require] stop -> set -> start 2.3.9 HD_VIDEOENC_PARAM_OUT_RATE_CONTROL \u00b6 [Description] H26x rate control settings [Parameter] Value Description rc_mode rate control mode. default: 1, range: 1~4 (1: CBR, 2: VBR, 3: FixQP, 4: EVBR), using HD_VIDEOENC_RC_MODE struct cbr parameter of rate control mode CBR, using HD_H26XENC_CBR struct vbr parameter of rate control mode VBR, using HD_H26XENC_VBR struct fixqp parameter of rate control mode FixQP, using HD_H26XENC_FIXQP struct evbr parameter of rate control mode EVBR, using HD_H26XENC_EVBR struct [Apply Require] set -> start 2.3.10 HD_VIDEOENC_PARAM_OUT_USR_QP \u00b6 [Description] H26x user qp settings [Parameter] Value Description Enable enable user qp. default: 0, range: 0~1 (0: disable, 1: enable) qp_map_addr buffer address of user qp map. one byte per cu16 (bit[0:7] qp value. default: 26, range: 0~51) two byte per cu16. (bit[0:5] qp value (default: 0; if qp mode is 3 then qp value means fixed qp [range: 0~51], otherwise qp value means delta qp [range: -32~31])) (bit[6:7] qp? mode (default: 0; 0: delta qp, 1: reserved, 2: delta qp [disable AQ], 3: fixed qp) [Difference] Chip Description NT9668X qp_map_addr is one byte per cu16 NT9852X NT9856X NT98530 qp_map_addr is two bytes per cu16 NT9831X NT9832X NT9833X NT98331 All functions are supported. [Apply Require] set -> start 2.3.11 HD_VIDEOENC_PARAM_OUT_SLICE_SPLIT \u00b6 [Description] H26x slice split [Parameter] Value Description enable enable multiple slice. default: 0, range: 0~1 (0: disable, 1: enable) slice_row_num number of macroblock/ctu rows occupied by a slice, range: 1 ~ number of macroblock/ctu row [Apply Require] set -> start 2.3.12 HD_VIDEOENC_PARAM_OUT_ENC_GDR \u00b6 [Description] H26x GDR settins [Parameter] Value Description enable enable gdr. default: 0, range: 0~1 (0: disable, 1: enable) period intra refresh period. default: 0, range: 0~0xFFFFFFFF (0: always refresh, others: intra refresh frame period) number intra refresh row number. default: 1, range: 1 ~ number of macroblock/ctu row [Apply Require] set -> start 2.3.13 HD_VIDEOENC_PARAM_OUT_ROI \u00b6 [Description] H26x ROI settings [Parameter] Value Description roi_qp_mode roi qp mode for all windows.? available value: HD_VIDEOENC_QPMODE_FIXED_QP(default) / HD_VIDEOENC_QPMODE_DELTA, using HD_VIDEOENC_QPMODE struct st_roi roi window settings. ROIs can be overlaid, and the priority of the ROIs is based on index number, index 0 is highest priority and index 9 is lowest. Using HD_H26XENC_ROI_WIN struct [Difference] Chip Description NT9668X st_roi is not supported. NT9852X NT9856X NT98530 All functions are supported. NT9831X NT9832X NT9833X NT98331 roi_qp_mode is not supported. [Apply Require] set -> start 2.3.14 HD_VIDEOENC_PARAM_OUT_ROW_RC \u00b6 [Description] H26x row rc settings [Parameter] Value Description enable enable row rc. default: 1, range: 0~1 (0: disable, 1: enable) i_qp_range row-level rata control. default: 2, range: 0~15 i_qp_step row-level rata control. default: 1, range: 0~15 p_qp_range qp range of P frame for row-level rata control. default: 4, range: 0~15 p_qp_step qp step? of P frame for row-level rata control. default: 1, range: 0~15 min_i_qp min qp of I frame for row-level rata control. default:? 1, range: 0~51 max_i_qp max qp of I frame for row-level rata control. default: 51, range: 0~51 min_p_qp min qp of P frame for row-level rata control. default:? 1, range: 0~51 max_p_qp max qp of P frame for row-level rata control. default: 51, range: 0~51 [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 i_qp_range: qp range of I&P frame. i_qp_step: qp step of I&P frame. p_qp_range, p_qp_step, min_i_qp, max_i_qp, min_i_qp and max_i_qp are not supported. NT9831X NT9832X NT9833X NT98331 i_qp_range: qp range of I frame. i_qp_step: qp step of I frame. [Apply Require] set -> start 2.3.15 HD_VIDEOENC_PARAM_OUT_AQ \u00b6 [Description] H26x aq settings [Parameter] Value Description enable AQ enable. default: 0, range: 0~1 (0: disable, 1: enable) i_str aq strength of I frame. default: 3, range: 1~8 p_str aq strength of P frame. default: 1, range: 1~8 max_delta_qp max delta qp of aq. min_delta_qp min delta qp of aq. depth AQ depth. default: 2, range(H.264): 2, range(H.265): 0~2 (0: cu64, 1: cu32, 2: cu16) thd_table non-linear AQ mapping table. range: -512~511, default: {-120,-112,-104, -96, -88, -80, -72, -64, -56, -48, -40, -32, -24, -16, -8, 7, 15, 23, 31, 39,47, 55, 63, 71, 79, 87, 95, 103, 111, 119} for ( dqp = -15; dqp < 15; dqp++ ) if ( Cu.RelativeTextureComplexity(x_str) <= thd_table[dqp+15] ) break; Cu.DeltaQP_AQ = MIN ( MAX (min_delta_qp, dqp), max_delta_qp ); [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 max_delta_qp range 0~8 (default: 6). min_delta_qp range -8~0 (default: -6). depth and thd_table are not supported. NT9831X NT9832X NT9833X NT98331 max_delta_qp range 0~15 (default: 6). min_delta_qp range -15~0 (default: -6). [Apply Require] set -> start 2.3.16 HD_VIDEOENC_PARAM_OUT_REQUEST_IFRAME \u00b6 [Description] H26x request I-frame [Parameter] Value Description enable request i-frame enable. default: 0, range: 0~1 (0: disable, 1: enable) [Apply Require] set -> start 2.3.17 HD_VIDEOENC_PARAM_OUT_TRIG_SNAPSHOT \u00b6 [Description] H26x trigger snapshot [Parameter] Value Description phy_addr [w]physical address of encoded data (user provide memory space to put JPEG result) size [w]user buffer size provided [r]real size of encoded data [Apply Require] set 2.3.18 HD_VIDEOENC_PARAM_IN_STAMP_BUF \u00b6 [Description] Stamp buffer settings [Parameter] Value Description type ping pong buffer or single buffer, using HD_OSG_BUF_TYPE size buffer\u2019s size in byte p_addr buffer\u2019s physical address ddr_id p_addr\u2019s ddr id [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 ddr_id is not supported. NT9831X NT9832X NT9833X NT98331 All functions are not supported. [Apply Require] stop -> set -> start [Note] For NT9668X / NT9852X / NT9856X / NT98530: Different OSGs can share the same buffer to save memory Double buffer requires \u201c2 * max OSG resolution * sizeof(short)\u201d while single buffer requires only \u201cmax OSG resolution* sizeof(short)\u201d. But single buffer suffers from blinking when image is updated. The starting address and length should be (2 x cpu cache line) aligned for ping pong buffer (128 or 64 bytes) and cpu cache line aligned for single buffer(64 or 32 bytes). If stamp will be rendered on mjpg or jpeg, width must be extended to multiple of 4 to calculate buffer size. 2.3.19 HD_VIDEOENC_PARAM_IN_STAMP_IMG \u00b6 [Description] Stamp image settings [Parameter] Value Description fmt RGB565/ARGB1555/ARGB4444/ARGB8888/ Using HD_VIDEO_PXLFMT struct dim image\u2019s width and height, using HD_DIM struct p_addr image\u2019s bitmap content ddr_id p_addr\u2019s ddr id [Difference] Chip Description NT9668X Palette and ddr_id are not supported. NT9852X NT9856X NT98530 ddr_id Is not supported. NT9831X NT9832X NT9833X NT98331 All functions are supported [Apply Require] set [Note] For NT9668X / NT9852X / NT9856X / NT98530: Only RGB565/ARGB1555/ARGB4444 are supported Image width is best to be multiple of 4 bytes for best compatibility. For example, image width of an argb1555 is multiple of 2 and image width of a palette2 (a pixels takes 2 bits) is multiple of 16. Image height is best to be multiple of 2 for best compatibility. In addition to the whole image width and height, every color area(e.g. timestamp and border)\u2019s width and height should be multiple of 2. hd_videoenc_get retrieves free buffer(not accessed by hardware) for OSG of ping pong buffer For NT9831X / NT9832X / NT98331 1. User needs to use external OSG for JPEG codec. Please refer to hd_videoout.doc. 2.3.20 HD_VIDEOENC_PARAM_IN_STAMP_ATTR \u00b6 [Description] Stamp attr settings [Parameter] Value Description align_type to which corner is stamp aligned Using HD_OSG_ALIGN_TYPE struct alpha (DISP)alpha value position (DISP)stamp\u2019s x,y position, using HD_IPOINT struct colorkey_en colorkey used to filter background colorkey_val filtered background color qp_en does stamp have its own qp qp_fix qp_val is fixed or relative to streaming qp qp_val qp value layer set layer attribute for videoenc region set region attribute for videoenc gcac_enable (GCAC)gcac enable gcac_blk_width unit width of GCAC gcac_blk_height unit height of GCAC. Note: OSG dim / (gcac_blk_width* gcac_blk_height) must less than 64 [Difference] Chip Description NT9668X alpha only for rgb565. align_type, gcac_enable, gcac_blk_width and gcac_blk_width are not supported. NT9852X NT9856X NT98530 alpha for argb4444, argb1555, rgb565. align_type, gcac_enable, gcac_blk_width and gcac_blk_width are not supported. NT9831X NT9832X NT9833X NT98331 colorkey_en, colorkey_val, qp_en, qp_fix, qp_val, layer and region are not supported. [Apply Require] set [Note] For NT9668X / NT9852X / NT9856X / NT98530: align_type, gcac_* are not supported For ARGB4444, alpha field is not applicable. For ARGB1555. alpha[3..0] is for pixels of A = 0 and alpha[7..4] is for pixels of A = 1. For best compatibility, set alpha to 0xf0. Other values may lead to missing stamp or opaque background. X y are best to be multiple of 2 for best compatibility. For h264, any 16*16 macro block can have only one OSG. For h265, any 64*64 macro block can have only one OSG. If two OSGs are inside a macro block or even overlapped, they must be in different layer(currently, there are only two layers : 0 and 1. Layer 1 will be rendered above layer 0.) region is a serial number(each layer has 16 regions : 0 ~ 15) qp_* are used to resolve conflicting qp value between streaming and OSG. Ext stamp doesn\u2019t support colorkey_en, colorkey_val, qp_en, qp_fix, qp_val, layer, region, gcac_enable, gcac_blk_width, gcac_blk_height Ext stamp opened with higher HD_STAMP_EX value will override ext stamps with lower value For NT9831X / NT9832X / NT9833X / NT98331: 1.x/y need to be multiple of 2 for best compatibility. 2. For NT9831X / NT9832X / NT98331, user needs to use external OSG for JPEG codec. Please refer to hd_videoout.doc. 2.3.21 HD_VIDEOENC_PARAM_IN_MASK_ATTR \u00b6 [Description] Mask attribute settings [Parameter] Value Description type mask is solid or hollow. Using HD_OSG_MASK_TYPE color mask color in rgb, mask palette index alpha mask transparency position 4 vertices\u2019 position, using HD_UPOINT struct thickness border width for hollow mask [Difference] Chip Description NT9668X only support ext mask. NT9852X support builtin mask and builtin mask should be set through vendor_videoenc_set NT9853X support builtin mask and builtin mask should be set through hd_videoenc_set. Irregular rectangle is supported. NT9831X NT9832X NT9833X NT98331 color and thickness are not supported. [Apply Require] set [Note] For NT9668X / NT9852X / NT9856X / NT98530: position[0] should be the top left. Others should be in clockwise order. thickness should be multiple of 2 Hollow mask takes more time to complete than solid mask. Don\u2019t set over 4 hollow masks in a path. mask opened with higher HD_MASK_EX value will override ext masks with lower value DDR consumption is proportional to ext mask\u2019s area. This is true even for hollow ext masks with thin border. For NT9831X / NT9832X / NT9833X / NT98331 1. JPEG doesn\u2019t have relative engine, so user needs to use external OSG for JPEG mask. Please refer to hd_videoout.doc. 2.3.22 HD_VIDEOENC_PARAM_IN_MOSAIC_ATTR \u00b6 [Description] Mosaic attribute settings [Parameter] Value Description Type mask is solid or inversion. Using HD_OSG_MASK_TYPE struct Alpha mask alpha blending. range: 0 ~ 256 (0: foreground, 256: background) mosaic_blk_w witdh of internal block mosaic_blk_h height of internal block position 4 vertices\u2019 position, using HD_UPOINT struct [Difference] Chip Description NT9853X type and alpha are not supported. NT9831X NT9832X NT9833X NT98331 All functions are supported. [Apply Require] set [Note] For NT9668X / NT9852X / NT9856X / NT98530: Mosaic is not supported For NT9831X / NT9832X / NT9833X / NT98331 1. JPEG doesn\u2019t have relative engine, so user needs to use external OSG for JPEG mosaic. Please refer to hd_videoout.doc. 2.3.23 HD_VIDEOENC_PARAM_IN_PALETTE_TABLE \u00b6 [Description] Palette table settings [Parameter] Value Description pal_y palette colors y. range: 0 ~ 255 pal_cb palette colors cb. range: 0 ~ 255 pal_cr palette colors cr. range: 0 ~ 255 [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 All functions are not supported. NT9831X NT9832X NT9833X NT98331 All functions are supported. [Apply Require] set For NT9831X / NT9832X / NT9833X / NT98331 1. JPEG doesn\u2019t have relative engine, so user needs to use external OSG for JPEG palette table. Please refer to hd_videoout.doc. 2.3.24 HD_VIDEOENC_PARAM_FUNC_CONFIG \u00b6 [Description] Function configure [Parameter] Value Description ddr_id Configure which ddr to work & output bitstream in_func additional function of in (bit-wise mask). enable ONEBUFF/ LOWLATENCY mode. [Difference] Chip Description NT9668X ddr_id and in_func are not supported. NT9852X NT9856X NT98530 All functions are supported. NT9831X NT9832X NT9833X NT98331 ddr_id and in_func are not supported. 2.3.25 HD_VIDEOENC_POLL_LIST \u00b6 [Description] The polling item including path information Use this type to form an array in hd_videoenc_poll_list() to get the results for all paths. [Parameter] Value Description path_id path ID revent The returned event value [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 NOT supported. NT9831X NT9832X NT9833X NT98331 Supported. 2.3.26 HD_VIDEOENC_USER_BS \u00b6 [Description] Video bitstream data and relative information [Parameter] Value Description sign signature = MAKEFOURCC(\u2018V\u2019,\u2019S\u2019,\u2019T\u2019,\u2019M\u2019) p_next pointer to next meta vcodec_format Encoded format of video frame pack_num Pack number in video frame timestamp Encode bs timestamp frame_type The frame type svc_layer_type svc layer type video_pack Pack array of encoded data psnr_info The PSNR information blk_info The block partition information newbs_flag Flag notification of new seting qp The qp value slice_offset multi-slice offset 0~VENC_USER_SLICE_MAX p_user_buf Bitstream buffer pointer user_buf_size AP provide bs_buf max size [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 NOT supported. NT9831X NT9832X NT9833X NT98331 Supported. 2.3.27 HD_VIDEOENC_RECV_LIST \u00b6 [Description] The video bitstream item including path information Use this type to form an array in hd_videoenc_recv_list() to get the video bitstreams for all paths. [Parameter] Value Description path_id path ID user_bs video encode user bitstream retval less than 0: recv bistream fail. [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 NOT supported. NT9831X NT9832X NT9833X NT98331 Supported. 2.3.28 HD_H26X_CONFIG \u00b6 [Description] The basic parameters for H264/H265. [Parameter] Value Description gop_num I-frame period chrm_qp_idx chroma qp offset sec_chrm_qp_idx Second chroma QP offset ltr_interval Long-term reference frame interval 0: all long-term reference to IDR frame, 1: reference latest long-term reference frame ltr_pre_ref Long-term reference setting gray_en Encode color to gray source_output Source output profile Profile IDC level_idc Level IDC svc_layer SVC Layer entropy_mode Entropy coding method 2.3.29 HD_JPEG_CONFIG \u00b6 [Description] The basic parameters for JPEG. [Parameter] Value Description retstart_interval Specifies the interval between RSTn markers, in Minimum Coded Units (MCUs). This marker is followed by two bytes indicating the fixed size so it can be treated like any other variable size segment. Restart interval default setting is zero. The user can setting interval value from 0 to image size/256. image_quality Specify the picture quality 3 Trouble shooting \u00b6 The hd_videoenc provides a useful feature to debug, it is called debug menu. 3.1 debug menu (NT9668X / NT9852X / NT9856X / NT98530) \u00b6 In application, call hd_debug_run_menu() to open the debug menu. ============================== ?HDAL ------------------------------ ?01 : AUDIOCAPTURE ?02 : AUDIOOUT ?03 : AUDIOENC ?04 : AUDIODEC ?05 : VIDEOCAPTURE ?06 : VIDEOOUT ?07 : VIDEOPROCESS ?08 : VIDEOENC ?09 : VIDEODEC ?10 : OSG ?11 : COMMON ?12 : UTIL ?13 : DEBUG ------------------------------ ?254 : Quit ?255 : Return ------------------------------ Enter \u201c8\u201d to open VIDEOENC debug menu ============================== ?VIDEOENC ------------------------------ ?01 : dump status ?02 : enc info ?03 : rc info ON ?04 : rc info OFF ------------------------------ ?254 : Quit ?255 : Return ------------------------------ Note: The items in the menu may vary for each chip. 3.1.1 dump status \u00b6 Enter \u201c1\u201d to show the status of videoenc Run: 01 : dump status HDAL_VERSION: 00010001:00010001 ------------------------- VIDEOENC 0? PATH & BIND ------------------------------ in??? out?? state bind_src????????????? bind_dest 0???? 0???? START VIDEOPROC_0_OUT_0???? (null) ------------------------- VIDEOENC 0? PATH CONFIG ------------------------------ in??? out?? max_w max_h? svc? ltr? rotate? bitrate?? enc_ms 0???? 0???? 1920? 1080??? 2??? 1????? 0??? 2097152?? 3000 ------------------------- VIDEOENC 0? IN FRAME --------------------------------- in??? w???? h???? pxlfmt? frc?? dir 0???? 1920? 1080? YUV420? 1/1?? .... ------------------------- VIDEOENC 0? OUT BS ----------------------------------- --- [H26x] \u2014 out?? codec? gop? ltr_int? ltr_ref? gray? src_out? profile? level? svc? entropy 0???? H265?? 15?? 0??????? 0??????? 0???? 0??????? MAIN???? 150? ??0??? CABAC ------------------------- VIDEOENC 0? VUI -------------------------------------- out?? vui_en? sar_w? sar_h? mat_c? tran_c? col_prim? vid_fmt? col_rng? time_pre 0???? 0?????? .....? .....? .....? ......? ........? .......? .......? ........ ------------------------- VIDEOENC 0? DEBLOCK ---------------------------------- out?? dis_ilf_idc? alpha? beta 0???? 0??????????? 0????? 0 ------------------------- VIDEOENC 0? RC --------------------------------------- out?? mode? bitrate? fr? I(int/min/max)? P(int/min/max)? sta? ip_w 0???? CBR?? 2097152? 30?? ( 26/ 10/ 45)?? ( 26/ 10/ 45)? 4??? 0 ------------------------- VIDEOENC 0? USER QP ---------------------------------- out?? en? map_addr 0???? 0?? ........ ------------------------- VIDEOENC 0? SLICE SPLIT ------------------------------ out?? en? row_num 0???? 0?? ....... ------------------------- VIDEOENC 0? GDR -------------------------------------- out?? en? period? row_num 0???? 0?? ......? ....... ------------------------- VIDEOENC 0? ROI -------------------------------------- out?? qp_mode? win? qp? rect(x,y,w,h) ------------------------- VIDEOENC 0? ROW RC ----------------------------------- out?? en? qp_rng? qp_step 0???? 1?? 2?????? 1 ------------------------- VIDEOENC 0? AQ --------------------------------------- out?? en? i_str? p_str? max_delta? min_delta 0???? 0?? .....? .....? .........? ......... ------------------------- VIDEOENC 0? IN WORK STATUS -------------------------- in??? PUSH? drop? wrn?? err?? PROC? drop? wrn?? err?? REL 0???? 30?? ??0??? ??0???? 0???? 30??? ?0???? 0???? ?0???? 30 ------------------------- VIDEOENC 0? OUT WORK STATUS ------------------------- out?? NEW?? drop? wrn?? err?? PROC? drop? wrn?? err?? PUSH? drop? wrn?? err 0???? ?30??? 0???? ?0???? 0???? 30?? ??0???? 0?? ???0???? 30?? ?0??? ??0???? 0 ------------------------- VIDEOENC 0? USER WORK STATUS ------------------------- out?? PULL?? drop? wrn?? err?? REL 0??? ?30???? ?0??? ??0???? 0???? 30 As above, the debug menu shows the path & bind information, path_config , input frame / output bitstream information. The detail for each count value is as following, [IN] IN PUSH => get YUV from previous unit / user push_in err (1) module is NOT start ??? (2) for auto-bind mod, check YUV lineoffset is wrong wrn (1) YUV ping-pong buffer if full ??? (2) bitstream buffer is full, drop this YUV drop (1) module is stop, drop any YUV that is not processed PROC => prepare to encode err (1) encode fail wrn (1) N/A drop (1) N/A REL => release YUV [OUT] OUT NEW => search for bitstream buffer to put encode result err (1) N/A wrn (1) bitstream buffer is full, could not encode this YUV drop (1) N/A PROC => prepare to encode err (1) encode fail wrn (1) N/A drop (1) N/A PUSH => push encoded bitstream to pull queue (for user pull later) err (1) N/A wrn (1) pull queue is full drop (1) N/A [USER] USER PULL => user call hd_videoenc_pull_out_buf() to get bitstream err (1) N/A wrn (1) pull fail due to timeout drop (1) N/A REL => user call hd_videoenc_release_out_buf() to release bitstream 3.1.2 enc info \u00b6 Enter \u201c2\u201d and then enter which path to show encoder information Run: 02 : enc info Please enter which path (0~15)? => : 0 [ 2855.827904] [VDOENC][0] Codec = H265, RC Mode = CBR, W = 1920, H = 1080, BitRate = 2097152, Fps = 30, Gop = 15, SVC = 0, IQP = (26, 10, 45), PQP = (26, 10, 45), Static = 4, Weight = 0, RowRc = (1, 2, 1), SmartRoi = 0, LTR = (0, 0), DB = (0, 0, 0), VUI = (0, 1, 1, 2, 2, 2, 5, 0, 0), 3DNR Callback = 0x7ed68f20, AQ = (0, 3, 1, 36, 6, -6, 0), Rotate = 0, GDR = (0, 0, 1), SLICE = (0, 1), QPMap = (0, 80000000), Enc(Drop, In, Out, Re-Enc, Err) = (0, 8444, 8444, 0, 0) As above, the debug menu shows the encoder settings for certain path. 3.1.3 rc info on \u00b6 Enter \u201c3\u201d and then enter which path to START dump rate control information Run: 03 : rc info ON Please enter which path (0~15)? => : 0 [ 3034.766550] h265Enc_DumpRcInfo:mode CBR, frame rate 30/1, gop 15, GOP bitrate 1048576, QP (I 10/45, P 10/45), cur qp 23 (23) [ 3035.795426] dal_h265enc_encodeone:[H265ENC][0] [ 3035.799832] h265Enc_DumpRcInfo:mode CBR, frame rate 30/1, gop 15, GOP bitrate 1048576, QP (I 10/45, P 10/45), cur qp 24 (24) [ 3036.828812] dal_h265enc_encodeone:[H265ENC][0] [ 3036.833193] h265Enc_DumpRcInfo:mode CBR, frame rate 30/1, gop 15, GOP bitrate 1048576, QP (I 10/45, P 10/45), cur qp 26 (26) [ 3037.862142] dal_h265enc_encodeone:[H265ENC][0] [ 3037.866552] h265Enc_DumpRcInfo:mode CBR, frame rate 30/1, gop 15, GOP bitrate 1048576, QP (I 10/45, P 10/45), cur qp 24 (24) As above, the debug menu START dump rate control information. 3.1.4 rc info off \u00b6 Enter \u201c4\u201d and then enter which path to STOP dump rate control information Run: 04 : rc info OFF Please enter which path (0~15)? => : 0 As above, the debug menu STOP dump rate control information. 3.2 proc command (NT9668X / NT9852X / NT9856X / NT98530) \u00b6 3.2.1 dump status \u00b6 [dump info] Cat /proc/hdal/venc/info the result is exactly the same as 3.1.1 Dump status root@NVTEVM:~$ cat /proc/hdal/venc/info HDAL_VERSION: 00010001:00010001 ------------------------- VIDEOENC 0? PATH & BIND ------------------------------ in??? out?? state bind_src????????????? bind_dest 0???? 0???? START VIDEOPROC_0_OUT_0???? (null) ------------------------- VIDEOENC 0? PATH CONFIG ------------------------------ in??? out?? max_w max_h? svc? ltr? rotate? bitrate?? enc_ms 0???? 0???? 1920? 1080??? 2??? 1????? 0??? 2097152?? 3000 ------------------------- VIDEOENC 0? IN FRAME --------------------------------- in??? w???? h???? pxlfmt? frc?? dir 0???? 1920? 1080? YUV420? 1/1?? .... ------------------------- VIDEOENC 0? OUT BS ----------------------------------- --- [H26x] \u2014 out?? codec? gop? ltr_int? ltr_ref? gray? src_out? profile? level? svc? entropy 0???? H265?? 15?? 0??????? 0??????? 0???? 0??????? MAIN???? 150??? 0??? CABAC ------------------------- VIDEOENC 0? VUI -------------------------------------- out?? vui_en? sar_w? sar_h? mat_c? tran_c? col_prim? vid_fmt? col_rng? time_pre 0???? 0?????? .....? .....? .....? ......? ........? .......? .......? ........ ------------------------- VIDEOENC 0? DEBLOCK ---------------------------------- out?? dis_ilf_idc? alpha? beta 0???? 0??????????? 0????? 0 ------------------------- VIDEOENC 0? RC --------------------------------------- out?? mode? bitrate? fr? I(int/min/max)? P(int/min/max)? sta? ip_w 0???? CBR?? 2097152? 30?? ( 26/ 10/ 45)?? ( 26/ 10/ 45)? 4??? 0 ------------------------- VIDEOENC 0? USER QP ---------------------------------- out?? en? map_addr 0???? 0?? ........ ------------------------- VIDEOENC 0? SLICE SPLIT ------------------------------ out?? en? row_num 0???? 0?? ....... ------------------------- VIDEOENC 0? GDR -------------------------------------- out?? en? period? row_num 0???? 0?? ......? ....... ------------------------- VIDEOENC 0? ROI -------------------------------------- out?? qp_mode? win? qp? rect(x,y,w,h) ------------------------- VIDEOENC 0? ROW RC ----------------------------------- out?? en? qp_rng? qp_step 0???? 1?? 2?????? 1 ------------------------- VIDEOENC 0? AQ --------------------------------------- out?? en? i_str? p_str? max_delta? min_delta 0???? 0?? .....? .....? .........? ......... ------------------------- VIDEOENC 0? IN WORK STATUS -------------------------- in??? PUSH? drop? wrn?? err?? PROC? drop? wrn?? err?? REL 0???? 30??? ?0???? 0??? ??0???? 30??? ?0???? 0??? ??0???? 30 ------------------------- VIDEOENC 0? OUT WORK STATUS ------------------------- out?? NEW ??drop? wrn?? err?? PROC? drop? wrn?? err?? PUSH? drop? wrn?? err 0???? ?30??? 0???? ?0???? 0???? 30?? ??0???? 0?? ???0???? 30?? ?0??? ??0???? 0 ------------------------- VIDEOENC 0? USER WORK STATUS ------------------------- out?? PULL?? drop? wrn?? err? ?REL 0???? 30?? ???0??? ??0???? 0???? 30 3.2.2 debug command \u00b6 [debug port] echo debug [dev] [i/o] [mask] > /proc/hdal/venc/cmd where [dev] = d0 , [i/o] = i0, i1, i2, \u2026, o0, o1, o2, \u2026 , [mask] = show info mask [ Sample ] echo debug d0 o0 mfff > /proc/hdal/venc/cmd this debug command can show more debug log on console root@NVTEVM:/mnt/sd$ hd_video_record [ 4376.440341] hd_reset - begin [ 4376.445192] hd_reset - end HDAL_VERSION: 00010001:00010001 [ 4376.467841] [ 4376.467841]? \u201cvdoenc\u201d.out[0]: open begin, state=0 [ 4376.475047]? \u201cvdoenc\u201d.out[0]: cmd OPEN [ 4376.479852] _ISF_VdoEnc_ImgCap_Open:bIs_NMI_ImgCap_ON = 0 [ 4376.485364]? \u201cvdoenc\u201d.out[0]: open end, state=1 [ 4376.490942] ?\u201dvdoenc\u201d.out[0]: set param(0000f000)=2 [ 4376.496720] ?\u201dvdoenc\u201d.out[0]: set param(0000f005)=3000 [ 4376.502745]? \u201cvdoenc\u201d.out[0]: set param(0000f039)=0 [ 4376.508512] ?\u201dvdoenc\u201d.out[0]: set param(0000f004)=2 [ 4376.514284] [VDOENC][0] Set max alloc size, codec = 2, w = 1920, h = 1080, byterate = 262144, recformat = 7, rotate = 0, svc = 2, ltr = 1, snapshot size = 0, codec size = 9581988, enc buf size = 786432 [ 4376.532280]? \u201cvdoenc\u201d.out[0]: set vdo-size(1920,1080) vdo-format(520C0420) vdo-dir(0) [ 4376.540977]? \u201cvdoenc\u201d.out[0]: set vdo-framerate(1,1) enc_type=0 [ 4377.711187]? \u201cvdoenc\u201d.out[0]: set param(0000f015)=0 [ 4377.717186]? \u201cvdoenc\u201d.out[0]: set param(0000f018)=1 [ 4377.722982]? \u201cvdoenc\u201d.out[0]: set param(0000f01c)=0 [ 4377.728742]? \u201cvdoenc\u201d.out[0]: set param(0000f023)=0 [ 4377.734515]? \u201cvdoenc\u201d.out[0]: set param(0000f03d)=0 [ 4377.740272]? \u201cvdoenc\u201d.out[0]: set param(0000f03e)=0 [ 4377.748686]? \u201cvdoenc\u201d.out[0]: set param(0000f03f)=0 [ 4377.754662]? \u201cvdoenc\u201d.out[0]: set param(0000f040)=0 [ 4377.760429]? \u201cvdoenc\u201d.out[0]: set param(0000f041)=0 [ 4377.767241]? \u201cvdoenc\u201d.out[0]: set param(0000f000)=3 [ 4377.773002]? \u201cvdoenc\u201d.out[0]: set param(0000f001)=1 [ 4377.779520] ?\u201dvdoenc\u201d.out[0]: set param(0000f005)=3000 [ 4377.785535]? \u201cvdoenc\u201d.out[0]: set param(0000f008)=0 [ 4377.791287] ?\u201dvdoenc\u201d.out[0]: set param(0000f009)=15 [ 4377.797124]? \u201cvdoenc\u201d.out[0]: set param(0000f00a)=7 [ 4377.802874]? \u201cvdoenc\u201d.out[0]: set param(0000f014)=0 [ 4377.808624] ?\u201dvdoenc\u201d.out[0]: set param(0000f030)=0 [ 4377.815039]? \u201cvdoenc\u201d.out[0]: set param(0000f035)=0 [ 4377.820793] ?\u201dvdoenc\u201d.out[0]: set param(0000f03a)=150 [ 4377.826717]? \u201cvdoenc\u201d.out[0]: set param(0000f03b)=1 [ 4377.832467]? \u201cvdoenc\u201d.out[0]: set param(0000f03c)=0 [ 4377.839343] [ 4377.839343]? \u201cvdoenc\u201d.out[0]: start begin, state=1 [ 4377.846625]? \u201cvdoenc\u201d.out[0]: cmd RDYSYNC [ 4377.851524] ?\u201dvdoenc\u201d.out[0]: cmd START [ 4377.856325] [VDOENC][0] Action = 0, Codec = 3, Mode = 7, Size = (1920, 1080), Fr = 30, Trig = 1, Alloc size = (0, 3239692, 786432), Enc Buf = (3000 ms, 0 ms, 0x95575f0c, 0x95635f08, 0x95635f08, 786428), Min Size(I, P) = (393216, 262144) [ 4377.877363] dal_h265enc_init:[H265ENC][0] Init Codec = (0x9525f000, 3239692), W = 1920, H = 1080, Prof = 1, Br = 2097152, Fps = 30, Gop = 15, SVC = 0, IQP = (26, 10, 45), PQP = (26, 10, 45), Sta = 4, Wei = 0, RowRc = (1, 2, 1), LTR = (0, 0), MultiT = 0, Rot = 0, FastSr = 0, ColorR = 0, Mode = 0, SEI = 0 [ 4377.904386] h26x_open:H26X Version = 0x20161211 [ 4377.909023] _h265enc_setratecontrol:[H265ENC][0] Set CBR [ 4377.914457]? \u201cvdoenc\u201d.out[0]: start end, state=2 [ 4377.920980]? \u201cvdoenc\u201d.out[0]: get param(0000f037)=329641984 [ 4377.927623]? \u201cvdoenc\u201d.out[0]: get param(0000f038)=10384808 Enter q to exit [ 4377.936965] dal_h265enc_encodeone:[H265ENC][0] Reset I OK, idx = 0, Frame Type = 3, Frame = (0x95575f0c, 258106), Buf = (0x95575f0c, 0x95635f08), t = 103465566 us dump main bitstream to file (/mnt/sd/dump_bs_main.dat) .... if you want to stop, enter \u201cq\u201d to exit !! 3.2.3 trace command \u00b6 [trace port] echo trace [dev] [i/o] [mask] > /proc/hdal/venc/cmd where [dev] = d0 , [i/o] = i0, i1, i2, \u2026, o0, o1, o2, \u2026 , [mask] = show info mask [ Sample ] echo trace d0 o0 mfff > /proc/hdal/venc/cmd this trace command could enable module internal debug message to know what\u2019s going on for the VIDEOENC module. 3.2.4 probe command \u00b6 [probe port] echo probe [dev] [i/o] [mask] > /proc/hdal/venc/cmd where [dev] = d0 , [i/o] = i0, i1, i2, \u2026, o0, o1, o2, \u2026 , [mask] = show info mask [ Sample ] echo probe d0 o0 mffff > /proc/hdal/venc/cmd this probe command could print per-data status [ 5692.621611] \u201cvdoenc\u201d.out[0] - NEW - new \u2013 h=9558697c size=00000000 addr=9558697c OK [ 5692.631780] \u201cvdoenc\u201d.out[0] - PUSH - rel \u2013 h=9558697c (result=0) OK [ 5692.652093] \u201cvdoenc\u201d.out[0] - NEW - new \u2013 h=9558779c size=00000000 addr=9558779c OK [ 5692.662281] \u201cvdoenc\u201d.out[0] - PUSH - rel \u2013 h=9558779c (result=0) OK [ 5692.682488] \u201cvdoenc\u201d.out[0] - NEW - new \u2013 h=95588474 size=00000000 addr=95588474 OK [ 5692.691369] \u201cvdoenc\u201d.out[0] - PUSH - rel \u2013 h=95588474 (result=0) OK [ 5692.718160] \u201cvdoenc\u201d.out[0] - NEW - new \u2013 h=95589084 size=00000000 addr=95589084 OK [ 5692.729104] \u201cvdoenc\u201d.out[0] - PUSH - rel \u2013 h=95589084 (result=0) OK [ 5692.749191] \u201cvdoenc\u201d.out[0] - NEW - new \u2013 h=95589e88 size=00000000 addr=95589e88 OK [ 5692.758027] \u201cvdoenc\u201d.out[0] - PUSH - rel \u2013 h=95589e88 (result=0) OK [ 5692.785621] \u201cvdoenc\u201d.out[0] - NEW - new \u2013 h=9558a9f0 size=00000000 addr=9558a9f0 OK [ 5692.796616] \u201cvdoenc\u201d.out[0] - PUSH - rel \u2013 h=9558a9f0 (result=0) OK 3.2.5 perf command \u00b6 [perf port] echo perf [dev] [i/o] > /proc/hdal/venc/cmd [ Sample ] echo perf d0 i0 > /proc/hdal/venc/cmd this perf command could print data count per second [?? 37.463860] \u201cvdoenc\u201d.in[0] Perf! \u2013 (Video) 30 Frame/sec [?? 38.495429] \u201cvdoenc\u201d.in[0] Perf! \u2013 (Video) 30 Frame/sec [?? 39.495233] \u201cvdoenc\u201d.in[0] Perf! \u2013 (Video) 30 Frame/sec 3.2.6 save command \u00b6 [save port] echo save [dev] [i/o] [count] > /proc/hdal/venc/cmd where [count] means how many i/o datas to save [ Sample ] echo perf d0 i0 1 > /proc/hdal/venc/cmd this save command could save i/o data to SDCard for debug purpose. [? 140.135994] save i/o begin: \u201cvdoenc\u201d.in[0] count=1 [? 140.153779] \u201cvdoenc\u201d.in[0] Save \u2013 h=94f5bfc0 t=00000000099334e3 (YUV: 1920x1080.520c0420 94f5c000 95156400 1920 1920) [? 141.330243] \u201cvdoenc\u201d.in[0] Save \u2013 //mnt//sd//isf_? vdoenc_in[0]_520c0420_1920_1080_1920_c208.vdo ok [? 141.340271] save port end 3.3 OSG proc command \u00b6 3.3.1 dump status \u00b6 cat /proc/hdal/osg/info to show the status of OSG and focus on VIDEOENC ------------------------- VIDEOENC 0 BUFFER ------------------------------------ pid???? type??? fmt???? w?????? h?????? addr??? ????size??????? draw 0?????? pp????? 4444??? 1000??? 200???? 13a55000??? 400000????? 1 0?????? pp????????????? ?0?????? ?0?????? 13ab6a80??? 400000????? 0 ------------------------- VIDEOENC 0 STAMP ------------------------------------- pid???? start?? x? ?????y?????? alpha?? cken??? ckval?? layer?? rgn 0?????? 1?????? ?0?????? 0?????? 255???? ?0?????? ?0?????? 0?????? ?0 ------------------------- VIDEOENC 0 MASK -------------------------------------- pid???? start?? x?????? y?????? w?????? h?????? solid?? thick?? color?????????? alpha 0?????? 1?????? ?500???? 0?????? 100???? 120???? 1?????? 0?????? ff0000????????? 255 As above, the debug menu shows buffer, stamp and mask configuration of all videoenc\u2019s OSGs. Most values are simply from hd_videoenc_set and self-explained. pid serves as an internal serial number and is mainly used to associate stamp and buffer information. start reflects if hd_videoenc_start/hd_videoenc_stop had been applied to that OSG. 3.3.2 change status \u00b6 OSG attr can be changed through debug menu while buffer and image can\u2019t because buffer and image typically require a buffer which can\u2019t be created by shell console. To change an OSG\u2019s attr, echo data > /proc/hdal/osg/cmd. Below are the format of data : For stamp: phase osg pid io start x y alpha cken ckval layer region example: to set the 5th stamp of output id 3 of videoenc to position[1024,512] and layer(1) region(8), run \u201cecho videoenc stamp 5 3 1 1024 512 255 0 0 1 8\u201d For mask : phase osg pid io start x y w h solid thick color alpha example: to set the 5th green mask of output id 3 of videoenc to position[1024,512] and size 256x128, run \u201cecho videoenc mask 5 3 1 1024 512 256 128 1 0 0x0FF00 255\u201d 3.4 Debug menu (NT9831X / NT9832X / NT9833X / NT98331) \u00b6 3.4.1 dump status \u00b6 In application, call hd_debug_run_menu() to open the debug menu. Run: 01 : dump status ------------------------- VIDEOENC 0? PATH & BIND ----------------------------- in????? out???? state?? bind_src??????????????? bind_dest 0?????? 0?????? START?? VIDEOCAP_0_OUT_1??????? - 0?????? 1?????? START?? VIDEOCAP_1_OUT_1??????? - 0?????? 2?????? START?? VIDEOCAP_2_OUT_1??????? - 0?????? 3?????? START?? VIDEOCAP_3_OUT_1??????? - 0?????? 4?????? START?? VIDEOCAP_0_OUT_2??????? - 0?????? 5?????? START?? VIDEOCAP_1_OUT_2??????? - 0?????? 6?????? START?? VIDEOCAP_2_OUT_2??????? - 0?????? 7?????? START?? VIDEOCAP_3_OUT_2??????? - ------------------------- VIDEOENC 0? IN FRAME ----------------------------- in????? w?????? h?????? pxlfmt 0?????? 1920??? 1080??? YUV420 1?????? 1920??? 1080??? YUV420 2?????? 1920??? 1080??? YUV420 3?????? 1920??? 1080??? YUV420 4?????? 960???? 480???? YUV420_NVX3 5?????? 960???? 480???? YUV420_NVX3 6?????? 960???? 480???? YUV420_NVX3 7?????? 960???? 480???? YUV420_NVX3 ------------------------- VIDEOENC 0? OUT FRAME ----------------------------- in????? codec?? gop???? profile svc???? level?? entropy 0?????? -?????? -?????? 0001??? -??????? - 1?????? -?????? -?????? 0001??? -??????? - 2?????? -?????? -?????? 0001??? -??????? - 3?????? -?????? -?????? 0001??? -??????? - 4?????? - ??????-?????? 0001??? -??????? - 5?????? -?????? -?????? 0001??? -??????? - 6?????? -?????? -?????? 0001??? -??????? - 7?????? -?????? -?????? 0001??? -??????? - ------------------------- VIDEOENC 0? RC ----------------------------- in????? mode??? base?? ?incr??? bitrate 0?????? CBR???? 0025??? 0001??? 4096Kbps 1?????? CBR???? 0025??? 0001??? 4096Kbps 2?????? CBR???? 0025??? 0001??? 4096Kbps 3?????? CBR???? 0025??? 0001??? 4096Kbps 4?????? CBR???? 0025??? 0001??? 1024Kbps 5?????? CBR???? 0025??? 0001??? 1024Kbps 6?????? CBR???? 0025??? 0001??? 1024Kbps 7?????? CBR???? 0025??? 0001??? 1024Kbps 3.5 proc command (NT9831X / NT9832X / NT9833X) \u00b6 3.5.1 dump status \u00b6 [dump info] Cat /proc/videograph/hdal_setting the result is similar to 3.1.1 Dump status root@NVTEVM:/$ cat /proc/videograph/hdal_setting ========================== VIDEOCAP 0? SYSCAP ========================== w?????? h?????? fps???? scaling 1920??? 1080??? 25????? 4088 ------------------------- VIDEOCAP 0? PATH & BIND ----------------------------- in????? out???? state?? bind_src??????????????? bind_dest 0?????? 0?????? START?? -?????????????????????? VIDEOENC_0_IN_0 ------------------------- VIDEOCAP 0? OUT FRAME ----------------------------- out???? w?????? h?????? pxlfmt 0???? ??1920??? 1080??? YUV420_NVX3 ------------------------- VIDEOCAP 0? PATH POOL ----------------------------- out???? pool??? ddr_id? count?? max_count 0?????? 0?????? 0?????? 4.0???? 4.0 ------------------------- VIDEOENC 0? PATH & BIND ----------------------------- in????? out???? state?? bind_src??????????????? bind_dest 0?????? 0?????? START?? VIDEOCAP_0_OUT_0??????? - ------------------------- VIDEOENC 0? IN FRAME ----------------------------- in????? w?????? h?????? pxlfmt 0?????? 1920??? 1080??? YUV420_NVX3 ------------------------- VIDEOENC 0? OUT FRAME ----------------------------- in????? codec?? gop???? profile svc???? level?? entropy 0?????? -?????? -?????? 1992728576??? -??????? CABAC ------------------------- VIDEOENC 0? RC ----------------------------- in????? mode??? base??? incr??? bitrate 0?????? CBR???? 0030??? 0001??? 2048Kbps 4 Sample Codes \u00b6 4.1 hd_videoenc_only \u00b6 This sample code is used in NT9668X / NT9852X / NT9856X / NT98530. The hd_videoenc_only demonstrates how to use the single trigger operation to process the input image. /* Allocate common buffer */ ? mem_cfg.pool_info[0].type???? = HD_COMMON_MEM_COMMON_POOL; ? mem_cfg.pool_info[0].blk_size = YUV_BLK_SIZE; ? mem_cfg.pool_info[0].blk_cnt? = MAX_YUV_BLK_CNT; ? mem_cfg.pool_info[0].ddr_id?? = DDR_ID0; ? ret = hd_common_mem_init(&mem_cfg); /* set enc path configuration */ ? video_path_config.max_mem.codec_type = HD_CODEC_TYPE_H265; ? video_path_config.max_mem.max_dim.w? = 1920; ? video_path_config.max_mem.max_dim.h? = 1080; ? video_path_config.max_mem.bitrate??? = 2 * 1024 * 1024; // 2 Mb/s = 512 MB/s ? video_path_config.max_mem.enc_buf_ms = 3000; ? video_path_config.max_mem.svc_layer? = HD_SVC_4X; ? video_path_config.max_mem.ltr??????? = TRUE; ? video_path_config.max_mem.rotate???? = FALSE; ? video_path_config.max_mem.source_output?? = FALSE; ? video_path_config.isp_id???????????? = 0; ? ret = hd_videoenc_set(video_enc_path0, HD_VIDEOENC_PARAM_PATH_CONFIG, &video_path_config); /* set enc parameters */ ? //--- HD_VIDEOENC_PARAM_IN \u2014 ? video_in_param.dir???? = HD_VIDEO_DIR_NONE; ? video_in_param.pxl_fmt = HD_VIDEO_PXLFMT_YUV420; ? video_in_param.dim.w?? = main_dim.w; ? video_in_param.dim.h?? = main_dim.h; ? ret = hd_videoenc_set(video_enc_path0, HD_VIDEOENC_PARAM_IN, &video_in_param); ? //--- HD_VIDEOENC_PARAM_OUT_ENC_PARAM \u2014 ? video_out_param.codec_type???????? = HD_CODEC_TYPE_H264; ? video_out_param.h26x.profile?????? = HD_H264E_HIGH_PROFILE; ? video_out_param.h26x.level_idc???? = HD_H264E_LEVEL_5_1; ? video_out_param.h26x.gop_num?????? = 15; ? video_out_param.h26x.ltr_interval? = 0; ? video_out_param.h26x.ltr_pre_ref?? = 0; ? video_out_param.h26x.gray_en?????? = 0; ? video_out_param.h26x.source_output = 0; ? video_out_param.h26x.svc_layer???? = HD_SVC_DISABLE; ? video_out_param.h26x.entropy_mode? = HD_H264E_CABAC_CODING; ? ret = hd_videoenc_set(video_enc_path0, HD_VIDEOENC_PARAM_OUT_ENC_PARAM, &video_out_param); ? //--- HD_VIDEOENC_PARAM_OUT_RATE_CONTROL \u2014 ? rc_param.rc_mode???????????? = HD_RC_MODE_CBR; ? rc_param.cbr.bitrate???????? = 2 * 1024 * 1024; ? rc_param.cbr.frame_rate_base = 30; ? rc_param.cbr.frame_rate_incr = 1; ? rc_param.cbr.init_i_qp?????? = 26; ? rc_param.cbr.min_i_qp??????? = 10; ? rc_param.cbr.max_i_qp??????? = 45; ? rc_param.cbr.init_p_qp?????? = 26; ? rc_param.cbr.min_p_qp??????? = 10; ? rc_param.cbr.max_p_qp?? ?????= 45; ? rc_param.cbr.static_time???? = 4; ? rc_param.cbr.ip_weight?????? = 0; ? ret = hd_videoenc_set(video_enc_path0, HD_VIDEOENC_PARAM_OUT_RATE_CONTROL, &rc_param); /* Push in buffer */ ? blk = hd_common_mem_get_block(HD_COMMON_MEM_COMMON_POOL, blk_size, ddr_id); ? pa = hd_common_mem_blk2pa(blk); ? va = (UINT32)hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_CACHE, pa, blk_size); ? fread((void *)va, 1, yuv_size, fd_yuv); ? video_frame.sign??????? = MAKEFOURCC(\u2018V\u2019,\u2019F\u2019,\u2019R\u2019,\u2019M\u2019); ? video_frame.p_next????? = NULL; ? video_frame.ddr_id????? = ddr_id; ? video_frame.pxlfmt????? = HD_VIDEO_PXLFMT_YUV420; ? video_frame.dim.w?????? = VDO_SIZE_W; ? video_frame.dim.h?????? = VDO_SIZE_H; ? video_frame.count?????? = 0; ? video_frame.timestamp?? = 0; ? video_frame.loff[0]???? = VDO_SIZE_W; // Y ? video_frame.loff[1]???? = VDO_SIZE_W; // UV ? video_frame.phy_addr[0] = pa;? ????????????????????????????// Y ? video_frame.phy_addr[1] = pa + VDO_SIZE_W*VDO_SIZE_H;? // UV pack ? video_frame.blk???????? = blk; ? ret = hd_videoenc_push_in_buf(video_enc_path0, &video_frame, NULL, 0); //--- release buffer \u2014 ? hd_common_mem_release_block(blk); ? hd_common_mem_munmap((void *)va, blk_size); /* pull out buffer */ ? ret = hd_videoenc_pull_out_buf(video_enc_path0, &data_pull, -1); ? if (ret == HD_OK) { ? ???? hd_videoenc_get(video_enc_path0, HD_VIDEOENC_PARAM_BUFINFO, &phy_buf_main); ?????? vir_addr_main = (UINT32)hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_CACHE, phy_buf_main.buf_info.phy_addr, phy_buf_main.buf_info.buf_size); define PHY2VIRT_MAIN(pa) (vir_addr_main + (pa - phy_buf_main.buf_info.phy_addr)) \u00b6 for (j=0; j< data_pull.pack_num; j++) { ?????????? va ??= PHY2VIRT_MAIN(data_pull.video_pack[j].phy_addr); ?????????? size = data_pull.video_pack[j].size; ?????????? fwrite(va, 1, size, fd_bs); ?????? } ???????? //--- release buffer \u2014 ret = hd_videoenc_release_out_buf(video_enc_path0, &data_pull); hd_common_mem_munmap((void *)vir_addr_main, phy_buf_main.buf_info.buf_size); } 4.2 user_videoenc \u00b6 This sample code is used in NT9831X / NT9832X / NT9833X. The user_videoenc demonstrates how to use the single trigger operation to process the input image. typedef struct { ? union { ?????? HD_VIDEO_FRAME frame; ?????? HD_VIDEOENC_BS bs; ? }; ? UINT64 pool; ? int size; ? HD_COMMON_MEM_DDR_ID ddr_id; ? HD_COMMON_MEM_VB_BLK blk; ? void *va; ? UINT32 pa; } app_buffer_t; typedef struct _USER_VIDEOENC { ? app_buffer_t enc_in_buffer[MAX_IN_FRAME_COUNT]; ? int mem_fd; ? HD_PATH_ID videoenc_path_id; } USER_VIDEOENC; void save_output(char *filename, void *data, int size) { ? FILE *pfile; ? if ((pfile = fopen(filename, \u201cwb\u201d)) == NULL) { ?????? printf(\u201c[ERROR] Open File %s failed!!\\n\u201d, filename); ?????? exit(1); ? } ? fwrite(data, 1, size, pfile); ? fclose(pfile); ? printf(\u201cWrite file: %s\\n\u201d, filename); } int read_input(char *filename, void *buffer, int max_buf_size, int read_size) { ? FILE *pfile; ? INT ret; ? if ((pfile = fopen(filename, \u201crb\u201d)) == NULL) { ?????? printf(\u201c[ERROR] Open File %s failed!!\\n\u201d, filename); ?????? exit(1); ? } ? //if read_size is zero, read whole file. ? if (read_size == 0) { ? ??? fseek(pfile, 0, SEEK_END); ? ??? read_size = ftell(pfile); ?????? fseek(pfile, 0, SEEK_SET); ? } ? if (read_size > max_buf_size) ?????? read_size = max_buf_size; ? if (read_size > 0) { ?????? ret = fread(buffer, 1, read_size, pfile); ? } ? fclose(pfile); ? return ret; } HD_RESULT allocate_buffer(UINT64 pool, int size, HD_COMMON_MEM_DDR_ID ddr_id, app_buffer_t *p_app_buf) { ? HD_RESULT ret = HD_OK; ? HD_COMMON_MEM_VB_BLK blk; ? UINT32 pa, sign; ? VOID *va; ? p_app_buf->pool = pool; ? p_app_buf->size = size; ? p_app_buf->ddr_id = ddr_id; ? blk = hd_common_mem_get_block(pool, size, ddr_id); ? if (HD_COMMON_MEM_VB_INVALID_BLK == blk) { ?????? printf(\u201chd_common_mem_get_block fail\\r\\n\u201d); ?????? ret = HD_ERR_NG; ?????? goto exit; ? } ? pa = hd_common_mem_blk2pa(blk); ? if (pa == 0) { ?????? printf(\u201chd_common_mem_blk2pa fail, blk = %#lx\\r\\n\u201d, blk); ?????? hd_common_mem_release_block(blk); ?????? ret = HD_ERR_NG; ?????? goto exit; ? } ? va = hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_NONCACHE, pa, size); ? p_app_buf->blk = blk; ? p_app_buf->va = va; ? p_app_buf->pa = pa; ? sign = p_app_buf->frame.sign; ? if (sign == MAKEFOURCC(\u2018V\u2019,\u2019F\u2019,\u2019R\u2019,\u2019M\u2019)) { ?????? p_app_buf->frame.phy_addr[0] = pa; ? } else { ?????? p_app_buf->bs.video_pack[0].phy_addr = pa; ? } exit: ? return ret; } HD_RESULT free_buffer(app_buffer_t *p_app_buf) { ? HD_RESULT hd_ret; ? hd_ret = hd_common_mem_munmap(p_app_buf->va, p_app_buf->size); ? if (hd_ret != HD_OK) { ?????? printf(\u201chd_common_mem_munmap fail\\r\\n\u201d); ?????? goto exit; ? } ? hd_ret = hd_common_mem_release_block((HD_COMMON_MEM_VB_BLK)p_app_buf->blk); ? if (hd_ret != HD_OK) { ?????? printf(\u201chd_common_mem_munmap fail\\r\\n\u201d); ?????? goto exit; ? } exit: ? return hd_ret; } HD_RESULT prepare_buffers(USER_VIDEOENC *p_usr_videoenc) { ? INT i, x, y, raw_frame_size; ? UINT16 *pixel; ? HD_VIDEO_FRAME *p_frame; ? HD_RESULT ret = HD_OK; ? for (i = 0; i < MAX_IN_FRAME_COUNT; i++) { ?????? p_frame = &p_usr_videoenc->enc_in_buffer[i].frame; ?????? p_frame->sign = MAKEFOURCC(\u2018V\u2019,\u2019F\u2019,\u2019R\u2019,\u2019M\u2019); ?????? p_frame->ddr_id = 0; ?????? p_frame->dim.w = RAW_FRAME_WIDTH; ?????? p_frame->dim.h = RAW_FRAME_HEIGHT; ?????? p_frame->pxlfmt = HD_VIDEO_PXLFMT_YUV420; ?????? raw_frame_size = p_frame->dim.w * p_frame->dim.h * 2; ?????? ret = allocate_buffer(HD_COMMON_MEM_ENC_CAP_OUT_POOL, raw_frame_size, p_frame->ddr_id, &p_usr_videoenc->enc_in_buffer[i]); ?????? if (ret != 0) { ?????????? goto exit; ?????? } ?????? read_input(RAW_FRAME_FILE, p_usr_videoenc->enc_in_buffer[i].va, FRAME_BUF_SIZE, 0); ????? // Set moving black block ?????? for (y = 300; y < 330; y ++) ?????? for (x = (i * 10 + 300); x < (i * 10 + 330); x ++) { ?????????? pixel = (unsigned short *) (p_usr_videoenc->enc_in_buffer[i].va + ((y * p_frame->dim.w) + x) * 2); ?????????? *pixel = 0x1080; ?????? } ? } exit: ? return ret; } HD_RESULT return_buffers(USER_VIDEOENC *p_usr_videoenc) { ? INT i; ? HD_RESULT ret = HD_OK; ? for (i = 0; i < MAX_IN_FRAME_COUNT; i++) { ?????? ret = free_buffer(&p_usr_videoenc->enc_in_buffer[i]); ?????? if (ret != HD_OK) { ?????????? printf(\u201cfree_buffer fail\\n\u201d); ?????????? break; ?????? } ? } ? return ret; } HD_RESULT set_param(USER_VIDEOENC *p_usr_videoenc) { ? HD_RESULT ret = HD_OK; ? HD_VIDEOENC_IN video_in_param; ? HD_VIDEOENC_OUT enc_param; ? HD_H26XENC_RATE_CONTROL rc_param; ? //set main stream param ? video_in_param.dim.w = RAW_FRAME_WIDTH; ? video_in_param.dim.h = RAW_FRAME_HEIGHT; ? ret = hd_videoenc_set(p_usr_videoenc->videoenc_path_id, HD_VIDEOENC_PARAM_IN, &video_in_param); ? if (ret != HD_OK) { ?????? printf(\u201chd_videoenc_set(HD_VIDEOENC_PARAM_IN) fail\\n\u201d); ?????? goto exit; ? } ? ret = hd_videoenc_get(p_usr_videoenc->videoenc_path_id, HD_VIDEOENC_PARAM_OUT_ENC_PARAM, &enc_param); ? if (ret != HD_OK) { ?????? printf(\u201chd_videoenc_get(HD_VIDEOENC_PARAM_OUT_ENC_PARAM) fail\\n\u201d); ?????? goto exit; ? } ? enc_param.codec_type = HD_CODEC_TYPE_H264; ? enc_param.h26x.gop_num = 60; ? ret = hd_videoenc_set(p_usr_videoenc->videoenc_path_id, HD_VIDEOENC_PARAM_OUT_ENC_PARAM, &enc_param); ? if (ret != HD_OK) { ?????? printf(\u201chd_videoenc_set(HD_VIDEOENC_PARAM_OUT_ENC_PARAM) fail\\n\u201d); ?????? goto exit; ? } ? ret = hd_videoenc_get(p_usr_videoenc->videoenc_path_id, HD_VIDEOENC_PARAM_OUT_RATE_CONTROL, &rc_param); ? if (ret != HD_OK) { ?????? printf(\u201chd_videoenc_get(HD_VIDEOENC_PARAM_OUT_RATE_CONTROL) fail\\n\u201d); ?????? goto exit; ? } ? rc_param.rc_mode = HD_RC_MODE_CBR; ? rc_param.cbr.frame_rate_base = 30;?? //fps = 30/1 = 30 ? rc_param.cbr.frame_rate_incr = 1; ? rc_param.cbr.bitrate = 2048 * 1024; ? ret = hd_videoenc_set(p_usr_videoenc->videoenc_path_id, HD_VIDEOENC_PARAM_OUT_RATE_CONTROL, &rc_param); ? if (ret != HD_OK) { ?????? printf(\u201chd_videoenc_set(HD_VIDEOENC_PARAM_OUT_RATE_CONTROL) fail\\n\u201d); ?????? goto exit; ? } exit: ? return ret; } int encode_the_buffer(USER_VIDEOENC *p_usr_videoenc) { ? INT i, pattern_idx, bs_max_size; ? FILE *bs_file; ? HD_VIDEOENC_BS video_bitstream; ? app_buffer_t bs_out_buffer; ? HD_RESULT ret = HD_OK; ? //open files for writing ? if ((bs_file = fopen(OUT_BS_FILE, \u201cwb\u201d)) == NULL) { ?????? printf(\u201c[ERROR] Open File %s failed!!\\n\u201d, OUT_BS_FILE); ?????? exit(1); ? } ? //prepare bitstream buffer ? bs_max_size = BS_BUF_SIZE; ? bs_out_buffer.bs.sign = MAKEFOURCC(\u2018V\u2019,\u2019S\u2019,\u2019T\u2019,\u2019M\u2019); ? bs_out_buffer.bs.video_pack[0].size = bs_max_size; ? bs_out_buffer.bs.ddr_id = 0; ? ret = allocate_buffer(HD_COMMON_MEM_ENC_CAP_OUT_POOL, bs_max_size, bs_out_buffer.bs.ddr_id, &bs_out_buffer); ? if (ret != 0) { ?????? printf(\u201callocate_buffer fail\\n\u201d); ?????? goto exit; ? } ? //encode frames for LOOP_COUNT times ? pattern_idx = 0; ? for (i = 0; i < LOOP_COUNT; i++) { ?????? bs_out_buffer.bs.video_pack[0].size = bs_max_size; ?????? //trigger it ?????? ret = hd_videoenc_push_in_buf(p_usr_videoenc->videoenc_path_id, &p_usr_videoenc->enc_in_buffer[pattern_idx++].frame, &(bs_out_buffer.bs), 500); ?????? if (ret != HD_OK) { ?????????? printf(\u201chd_videoenc_push_in_buf fail\\n\u201d); ?????????? goto exit; ?????? } ?????? //get the result ?????? ret = hd_videoenc_pull_out_buf(p_usr_videoenc->videoenc_path_id, &video_bitstream, 500); ?????? if (ret != HD_OK) { ?????????? printf(\u201chd_videoenc_pull_out_buf fail\\n\u201d); ?????? } else { ?????????? INT bs_size = 0, pack_num, pa_offset; ?????????? for (pack_num = 0; pack_num < video_bitstream.pack_num; pack_num++) { ??????????????? pa_offset = video_bitstream.video_pack[pack_num].phy_addr - bs_out_buffer.pa; ??????????????? bs_size += fwrite(bs_out_buffer.va+pa_offset, 1, video_bitstream.video_pack[pack_num].size, bs_file); ?????????? } ?????????? printf(\u201d Encode output size: %d\\n\u201d, bs_size); ?????? } ?????? if (pattern_idx >= MAX_IN_FRAME_COUNT) ?????????? pattern_idx = 0; ? } ? //free bitstream buffer ? ret = free_buffer(&bs_out_buffer); ? if (ret != HD_OK) { ?????? printf(\u201cfree_buffer fail\\n\u201d); ? } exit: ? if (bs_file) ?????? fclose(bs_file); ? return ret; } int main(int argc, char *argv[]) { ? HD_RESULT ret = HD_OK; ? USER_VIDEOENC usr_videoenc; ? memset(&usr_videoenc, 0, sizeof(usr_videoenc)); ? usr_videoenc.mem_fd = -1; ? if ((usr_videoenc.mem_fd = open(\u201c/dev/mem\u201d, O_RDWR | O_SYNC)) < 0) { ?????? printf(\u201copen /dev/mem failed.\\n\u201d); ?????? goto exit; ? } ? //init hdal and open modules ? ret = hd_common_init(1); ? if (ret != HD_OK) { ?????? printf(\u201chd_common_init fail\\n\u201d); ?????? goto exit; ? } ? ret = hd_videoenc_init(); ? if (ret != HD_OK) { ?????? printf(\u201chd_videoenc_init fail\\n\u201d); ?????? goto exit; ? } ? ret = hd_videoenc_open(HD_VIDEOENC_0_IN_0, HD_VIDEOENC_0_OUT_0, &usr_videoenc.videoenc_path_id); ? if (ret != HD_OK) { ?????? printf(\u201chd_videoenc_open fail\\n\u201d); ?????? goto exit; ? } ? //setup encoder parameters ? ret = set_param(&usr_videoenc); ? if (ret < 0) { ?????? printf(\u201cset_param fail\\n\u201d); ?????? goto exit; ? } ? //generate source frame for encoding ? ret = prepare_buffers(&usr_videoenc); ? if (ret < 0) { ?????? printf(\u201cprepare_buffers fail\\n\u201d); ?????? goto exit; ? } ? //encode the frames ? ret = encode_the_buffer(&usr_videoenc); ? if (ret < 0) { ?????? printf(\u201cencode_the_buffer fail\\n\u201d); ?????? goto exit; ? } ? //release source frames ? ret = return_buffers(&usr_videoenc); ? if (ret < 0) { ?????? printf(\u201creturn_buffers fail\\n\u201d); ?????? goto exit; ? } exit: ? //close modules, release resources and exit hdal ? ret = hd_videoenc_close(usr_videoenc.videoenc_path_id); ? if (ret != HD_OK) { ?????? printf(\u201chd_videoenc_close fail\\n\u201d); ?????? return -1; ? } ? ret = hd_videoenc_uninit(); ? if (ret != HD_OK) { ?????? printf(\u201chd_videoenc_uninit fail\\n\u201d); ?????? return -1; ? } ? ret = hd_common_uninit(); ? if (ret != HD_OK) { ?????? printf(\u201chd_common_uninit fail\\n\u201d); ?????? return -1; ? } ? if (usr_videoenc.mem_fd != -1) { ?????? close(usr_videoenc.mem_fd); ? } ? return 0; 5 FAQ (NT9668X / NT9852X / NT9856X / NT98530) \u00b6 What is the differnece from HD_VIDEOENC_PARAM_PATH_CONFIG.max_mem and HD_VIDEOENC_PARAM_OUT_ENC_PARAM? Answer: n HD_VIDEOENC_PARAM_PATH_CONFIG.max_mem sets \u201cMaximum requirement\u201d, while HD_VIDEOENC_PARAM_OUT_ENC_PARAM sets current encode settings. n For example, you may set PATH_CONFIG.max_mem.max_dim as 1920x1080. Then you can set HD_VIDEOENC_IN.dim as any resolution smaller than 1920x1080. n Another example, you may set PATH_CONFIG.max_mem.ltr as TRUE. Then you can set HD_VIDEOENC_PARAM_OUT_ENC_PARAM.h26x.ltr_interval > 0 to enable LTR, or, you can set ltr_interval = 0 to disable LTR. n But if you set PATH_CONFIG.max_mem.ltr as FALSE, then you can only set HD_VIDEOEC_PARAM_0UT_ENC_PARAM.h26x.ltr_interval = 0. n PATH_CONFIG set maximum requirement, if you don\u2019t need certain function, you should not set the function as TRUE because this will alloc extra memory. 2 svc_layer, ltr, source_output => each of those function will alloc extra YUV420 buffer to support function. What control flow should I apply for each param for hd_videoenc_set()? n stop -> close -> open -> set -> start 2 HD_VIDEOENC_PARAM_PATH_CONFIG O because this will involve memory re-alloc. n stop -> set -> start 2 HD_VIDEOENC_PARAM_IN O If videoproc is binding to videoenc, and videoproc.out setting=0 (auto sync videoenc settings), you have to call videoproc_start to sync videoenc new settings. 2 HD_VIDEOENC_PARAM_OUT_ENC_PARAM 2 HD_VIDEOENC_PARAM_OUT_VUI 2 HD_VIDEOENC_PARAM_OUT_DEBLOCK 2 HD_VIDEOENC_PARAM_IN_FRC O If change between (dst <= src) and (dst > src)? (both direction) O If change between (dst > src) and (dst > src) n set -> start 2 HD_VIDEOENC_PARAM_OUT_RATE_CONTROL 2 HD_VIDEOENC_PARAM_OUT_USR_QP 2 HD_VIDEOENC_PARAM_OUT_SLICE_SPLIT 2 HD_VIDEOENC_PARAM_OUT_ENC_GDR 2 HD_VIDEOENC_PARAM_OUT_ROI 2 HD_VIDEOENC_PARAM_OUT_ROW_RC 2 HD_VIDEOENC_PARAM_OUT_AQ 2 HD_VIDEOENC_PARAM_OUT_REQUEST_IFRAME 2 HD_VIDEOENC_PARAM_OUT_TRIG_SNAPSHOT 2 HD_VIDEOENC_PARAM_IN_FRC O If change between (dst <= src) and (dst <= src) Is there anything I should take care for codec JPG with HD_VIDEOENC_PARAM_IN.dir rotate90/270? n Yes : because JPG rotate depends on gximage library 2 You have to alloc extra YUV buffer. On the other word, hd_common_mem_init() for YUV buffer, set blk_cnt from 3 to 4 2 Also, the YUV buffer width/height MUST be ALIGN_CEIL_16. Calling hd_videoenc_open() failed with return value HD_ERR_IO, what does it mean? n It means that user is accessing invalid HD_IN_ID or HD_OUT_ID. It possibly occurs due to configuration for maxpath in dts file is smaller than needed path. n For example, in dts file, user set vdoenc_maxpath = 4, but calling hd_videoenc_open(HD_VIDEOENC_0_IN_4, \u2026 ) is invalid !! => because dts max_path = 4, but attempt to open path 5 => if user really need to open path 5, user have to modify dts file for vdoenc_maxpath = 5 Can an osd image shared between videoprocess, videoenc and videoout? n Yes : Just set the same p_addr value of HD_OSG_STAMP_BUF to videoprocess, videoenc and videoout pathid. n Subsequent upate through any pathid with automatically reflect on other pathid Why an osd/mask disappear without error or warning message? n In any macro block, only an osd will be rendered in a layer. n Since there are only two layers, this means at most two images can be rendered in a macro block n In h264, a macro block is 16x16 n In h265, a macro block is 64x64 n Osd on layer 0 will be rendered above layer 1 Any constrain on osd image and buffer? n Width of an image is best to be 4 aligned n Height of an image is best to be 2 aligned n Buffer address is best to be 128 aligned Ex stamp and mask consume much system resource. Any advice on the number? n It\u2019s hard to say. System with heavy loading has less margin for ex stamp and mask n For a 30fps system, 4 ex stamps or 4 ex masks are safe How to set alpha for an osd image n This is conditional to image formats n Alpha of argb4444 is completely determined by pixel\u2019s 4-bits alpha value n Alpha of argb1555 is determined by pixel\u2019s 1-bit alpha value and the alpha field of HD_OSG_STAMP_ATTR. If pixel\u2019s alpha value is 0, bits 3 ~ bits 0 of HD_OSG_STAMP_ATTR\u2019s alpha field determines transparency. If pixel\u2019s alpha value is 1, bits 7 ~ bits 4 of HD_OSG_STAMP_ATTR\u2019s alpha field determines transparency n Alpha of rgb565 is completely determined by the alpha field of HD_OSG_STAMP_ATTR. If an osd is configured with ping pong buffer. Is it possible to directly draw the free buffer? n Yes n Use HD_VIDEOENC_PARAM_IN_STAMP_IMG to get the physical address of the free buffer n Draw this free buffer n Apply the drawing by set HD_VIDEOENC_PARAM_IN_STAMP_IMG. The p_addr field of HD_OSG_STAMP_IMG should be the same physical address. I set vdoenc_maxpath = 17 in dtsi, why show warning message \u201cdts max_path=17 is larger than built-in max_path=16\u201d? n VDOENC_MAX_PATH_NUM is defined as 16 in isf_vdoenc, which means video encode path maximum is 16. Please set vdoenc_maxpath <= 16 in dtsi. OSG nvt-mem-tbl.dtsi n In nvt-mem-tbl.dtsi of cfg_model, stamp_maximg, vdoenc_maxstamp and vdoenc_maxmask determine osd numbers. ???? \\configs\\Linux\\cfg_xxx\\nvt-mem-tbl.dtsi ???? hdal-maxpath-cfg { stamp_maximg???? = <16>; ???????? vdoenc_maxstamp? = <32 16>; ???????? vdoenc_maxmask?? = <0? 64>; n stamp_maximg is the max number of stamps across videoprocess, videoencoder and videoout. 16 means vproc, venc and vout can create up to 16 stamps. There is no limit on this number. n vdoenc_maxstamp is the max number of stamps on videoenc. The left number is for built-in stamp and the right number is for ext stamp. Max left number is 32 and max right number is 16 n vdoenc_maxmask is the max number of masks on videoenc. The left number is for built-in mask and the right number is for ext mask. Since videoenc has no built-in osd, the left number is always 0. Max right number is 64 To update an existing OSG, simply set image. No need to start OSG, stop OGG or reset buffer. If a buffer is shared among many OSG, updating through any of OSG also refreshes other OSG. No need to update every OSG with the same share buffer. To setup a new buffer on OSG with shared buffer, all OSG with this shared buffer should be stopped and closed.","title":"HDAL hd_videoenc"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#1-introduction","text":"The major purpose of hd_videoenc is to get YUV raw data from upper unit, and controls the video encoder to encode the YUV data then return the bitstream data which can be used for saving video files / online streaming. This document will talk about the red block in the following diagram. The device driver is not the main point in this document. Module diagram is shown as below:","title":"1 Introduction"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#11-basic-flow","text":"The call sequence is needed to be done correctly for the unit. The standard starting flows of most modules are init, open, get, set, bind and start. The standard closing flows of most modules are stop, unbind, close and uninit. The basic flow is shown as below. Now, below section in this chapter is mainly about what things to do in those functions above.","title":"1.1 Basic Flow"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#12-single-trigger-operation","text":"Single trigger operation is used to trigger the unit to do one job, such as to grab one YUV frame from video capture; then, encode one frame to bitstream by using video encoder. There are two types of functions for the input port and output port. The sequence for input port is push; the sequence for output port is pull and release. The flow is shown as below.","title":"1.2 Single Trigger Operation"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#13-multi-channel-operation","text":"Multi channel operation is used to send multi bitstream simultaneously, it is very efficiency in the multi channels case. The flow is shown as below:","title":"1.3 Multi Channel Operation"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2-parameter-ids-and-data-structure-definition","text":"The videoenc provides the following parameter IDs: l HD_VIDEOENC_PARAM_DEVCOUNT o support get with ctrl path o using HD_DEVCOUNT struct (device id max count) l HD_VIDEOENC_PARAM_SYSCAPS o support get with ctrl path o using HD_VIDEOENC_SYSCAPS struct (system capabilitiy) l HD_VIDEOENC_PARAM_PATH_CONFIG o support get/set with i/o path o using HD_VIDEOENC_PATH_CONFIG struct l HD_VIDEOENC_PARAM_BUFINFO o support get with i/o path o using HD_VIDEOENC_BUFINFO struct l HD_VIDEOENC_PARAM_IN o support get/set with i/o path o using HD_VIDEOENC_IN struct l HD_VIDEOENC_PARAM_OUT_ENC_PARAM o support get/set with i/o path o using HD_VIDEOENC_OUT struct l HD_VIDEOENC_PARAM_OUT_VUI o support get/set with i/o path o using HD_H26XENC_VUI struct l HD_VIDEOENC_PARAM_OUT_DEBLOCK o support get/set with i/o path o using HD_H26XENC_DEBLOCK struct l HD_VIDEOENC_PARAM_OUT_RATE_CONTROL o support get/set with i/o path o using HD_H26XENC_RATE_CONTROL struct l HD_VIDEOENC_PARAM_OUT_USR_QP o support get/set with i/o path o using HD_H26XENC_USR_QP struct l HD_VIDEOENC_PARAM_OUT_SLICE_SPLIT o support get/set with i/o path o using HD_H26XENC_SLICE_SPLIT struct l HD_VIDEOENC_PARAM_OUT_ENC_GDR o support get/set with i/o path o using HD_H26XENC_GDR struct l HD_VIDEOENC_PARAM_OUT_ROI o support get/set with i/o path o using HD_H26XENC_ROI struct l HD_VIDEOENC_PARAM_OUT_ROW_RC o support get/set with i/o path o using HD_H26XENC_ROW_RC struct l HD_VIDEOENC_PARAM_OUT_AQ o support get/set with i/o path o using HD_H26XENC_AQ struct l HD_VIDEOENC_PARAM_OUT_REQUEST_IFRAME o support set with i/o path o using HD_H26XENC_REQUEST_IFRAME struct l HD_VIDEOENC_PARAM_OUT_TRIG_SNAPSHOT o support set with i/o path o using HD_H26XENC_TRIG_SNAPSHOT struct l HD_VIDEOENC_PARAM_IN_STAMP_BUF o support set with i/stamp path o using HD_OSG_STAMP_BUF struct (stamp buffer parameter) l HD_VIDEOENC_PARAM_IN_STAMP_IMG o support set with i/stamp path o using HD_OSG_STAMP_IMG struct (stamp image parameter) l HD_VIDEOENC_PARAM_IN_STAMP_ATTR o support get/set with i/stamp path o using HD_OSG_STAMP_ATTR struct (stamp display attribute) l HD_VIDEOENC_PARAM_IN_MASK_ATTR o support get/set with i/mask path o using HD_OSG_MASK_ATTR struct (mask display attribute) l HD_VIDEOENC_PARAM_IN_MOSAIC_ATTR o support get/set with i/mask path o using HD_OSG_MOSAIC_ATTR struct (mosaic display attribute) l HD_VIDEOENC_PARAM_IN_PALETTE_TABLE o support get/set with i path o using HD_OSG_PALETTE_TBL struct","title":"2 Parameter IDs and data structure definition"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#21-general-function","text":"","title":"2.1 General function"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#211-hd_videoenc_init","text":"[Description] Initialize the unit [Syntax] HD_RESULT hd_videoenc_init(VOID); [Parameter] Value Description VOID Not available [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"2.1.1 hd_videoenc_init"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#212-hd_videoenc_open","text":"[Description] Open the unit [Syntax] HD_RESULT hd_videoenc_open(HD_IN_ID in_id, HD_OUT_ID out_id, HD_PATH_ID* p_path_id) [Parameter] Value Description in_id id of input port out_id id of output port p_path_id pointer of the path id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure [Note] For OSG: There are two kinds of OSG : ext and non-ext. ext poses less position limitation but consumes more CPU/DMA. ext is ideal for OSG with small resolution and high position flexibility. Ext modifies input yuv buffer. If an input yuv buffer is feed to multiple streamings and each streaming should have its own OSG, don\u2019t use ext. One buffer mode can\u2019t work with ext. It\u2019s possible videoprocess and ext are updating the same yuv buffer and leads to broken streamings. Compressed yuv can\u2019t work with ext. Currently, OSG on jpeg is implemented as ext. This means performance deterioration and input buffer pollution automatically apply to jpeg. Built-in mask should be regarded as built-in stamp. This means all restrictions imposed to stamp also impose to mask. For example, a macro block can\u2019t render a mask and a stamp in a layer. Opening HD_MASK_X after opening HD_STAMP_X would render HD_STAMP_X invalid unless opening HD_MASK_Y instead. NT9853X has full built-in mask. Above note doesn\u2019t hold for NT9853X. Built-in mask is rendered atop stamp. If encoder rotation is supported and enabled, ext will be rotated. OSG should be opened with HD_MASK_X, HD_MASK_EX_X, HD_STAMP_X and HD_STAMP_EX_X. Don\u2019t use HD_MASK(), HD_MASK_EX(), HD_STAMP() or HD_STAMP_EX(). Ext OSG are rendered beneath non-ext OSG.","title":"2.1.2 hd_videoenc_open"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#213-hd_videoenc_get","text":"[Description] Get parameters from unit by path id [Syntax] HD_RESULT hd_videoenc_get(HD_PATH_ID path_id, HD_VIDEOENC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter","title":"2.1.3 hd_videoenc_get"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#214-hd_videoenc_set","text":"[Description] Set parameters to unit by path id [Syntax] HD_RESULT hd_videoenc_set(HD_PATH_ID path_id, HD_VIDEOENC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter","title":"2.1.4 hd_videoenc_set"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#215-hd_videoenc_bind","text":"[Description] Bind this unit with destination unit [Syntax] HD_RESULT hd_videoenc_bind(HD_OUT_ID out_id, HD_IN_ID dest_in_id) [Parameter] Value Description out_id id of output port. dest_in_id id of input port. [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"2.1.5 hd_videoenc_bind"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#216-hd_videoenc_start","text":"[Description] Start the unit [Syntax] HD_RESULT hd_videoenc_start(HD_PATH_ID path_id) [Parameter] Value Description path_id pointer of the path id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"2.1.6 hd_videoenc_start"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#217-hd_videoenc_stop","text":"[Description] Stop the unit [Syntax] HD_RESULT hd_videoenc_stop(HD_PATH_ID path_id) [Parameter] Value Description path_id pointer of the path id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"2.1.7 hd_videoenc_stop"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#218-hd_videoenc_unbind","text":"[Description] Unbind the unit [Syntax] HD_RESULT hd_videoenc_unbind(HD_OUT_ID out_id); [Parameter] Value Description out_id id of output port. [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"2.1.8 hd_videoenc_unbind"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#219-hd_videoenc_close","text":"[Description] Close the unit [Syntax] HD_RESULT hd_videoenc_close(HD_PATH_ID path_id) [Parameter] Value Description path_id pointer of the path id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure [Note] For OSG: OSGs will keep registered buffer until they are closed. Only after this API returns can application safely access/reclaim the buffer.","title":"2.1.9 hd_videoenc_close"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2110-hd_videoenc_uninit","text":"[Description] Uninitialize the unit [Syntax] HD_RESULT hd_videoenc_uninit(VOID); [Parameter] Value Description VOID Not available [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"2.1.10 hd_videoenc_uninit"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2111-hd_videoenc_push_in_buf","text":"[Description] Push the video frame buffer to unit [Syntax] HD_RESULT hd_videoenc_push_in_buf(HD_PATH_ID path_id, HD_VIDEO_FRAME p_in_video_frame, HD_VIDEOENC_BS p_user_out_videoenc_bs, INT32 wait_ms); [Parameter] Value Description path_id the path id p_in_video_frame pointer of the input video frame buffer p_user_out_videoenc_bs pointer of the output video bitstream buffer wait_ms timeout value in ms [Return Value] Value Description HD_OK Success HD_ERR_NG Failure [Note] p_user_out_videoenc_bs is optional. If this value is set, videoenc module uses it as the output buffer for bitstream, and the buffer should be released by user after using it; otherwise, if the value is NULL, videoenc will allocate the buffer internally, and user need to call hd_videoenc_release_out_buf API to release the buffer finally. [Note] If videoproc is NOT binding to videoenc, that is, SDK user call pull_out YUV from videoproc and push_in to videoenc to encode. Be sure to check YUV weight/height is equal to encoder weight/height. If videoproc is binding to videoenc, the SDK will automatically check YUV & encoder setting. If the YUV weight/height is not correctly for encoding, SDK will automatically drop YUV. But if videoproc is NOT binding to videoenc, the SDK will NOT automatically check YUV & encoder setting, SDK user should take responsibility for checking YUV weight/height and encoder setting. This is essential to check YUV & encoder settings while changing resolution, because the two module will NOT change to new setting at the same time. If YUV from videoproc is NOT match videoenc setting, the YUV should be dropped instead of pushing to videoenc.","title":"2.1.11 hd_videoenc_push_in_buf"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2112-hd_videoenc_pull_out_buf","text":"[Description] Pull the video bitstream buffer from unit [Syntax] HD_RESULT hd_videoenc_pull_out_buf (HD_PATH_ID path_id, HD_VIDEOENC_BS* p_videoenc_bs, INT32 wait_ms); [Parameter] Value Description path_id the path id p_videoenc_bs pointer of the output video bitstream buffer wait_ms timeout value in ms [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"2.1.12 hd_videoenc_pull_out_buf"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2113-hd_videoenc_release_out_buf","text":"[Description] Release the video bitstream buffer which is get from unit [Syntax] HD_RESULT hd_videoenc_release_out_buf (HD_PATH_ID path_id, HD_VIDEOENC_BS* p_videoenc_bs) [Parameter] Value Description path_id the path id p_videoenc_bs pointer of the output video bitstream buffer [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"2.1.13 hd_videoenc_release_out_buf"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#22-multi-list-operation","text":"Multi channel operation is used to send multi bitstream simultaneously, it is very efficiency in the multi channels case. The flow is shown as below:","title":"2.2 Multi List Operation"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#221-hd_videoenc_start_list","text":"[Description] Start to send multi bitstream data to the unit [Syntax] HD_RESULT hd_videoenc_start_list(HD_PATH_ID *path_id, UINT num); [Parameter] Value Description path_id the path id num number of bitstream data [Return Value] Value Description HD_OK Success HD_ERR_NG Failure [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 NOT supported. NT9831X NT9832X NT9833X NT98331 All functions are supported.","title":"2.2.1 hd_videoenc_start_list"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#222-hd_videoenc_stop_list","text":"[Description] Stop sending multi bitstream data to the unit [Syntax] HD_RESULT hd_videoenc_stop_list(HD_PATH_ID *path_id, UINT num); [Parameter] Value Description path_id the path id num number of bitstream data [Return Value] Value Description HD_OK Success HD_ERR_NG Failure [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 NOT supported. NT9831X NT9832X NT9833X NT98331 All functions are supported.","title":"2.2.2 hd_videoenc_stop_list"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#223-hd_videoenc_poll_list","text":"[Description]???????????????????????????????????? Query the bitstream status of all specifying channels [Syntax] HD_RESULT hd_videoenc_poll_list(HD_VIDEOENC_POLL_LIST *p_poll, UINT32 num, INT32 wait_ms); [Parameter] Value Description p_poll The path information of multi channels num Number of bitstream paths wait_ms The timeout value in millisecond while polling. 0: not wait >0: wait time (in millisecond) <0: wait forever or not supported [Return Value] Value Description HD_OK Success HD_ERR_NG Failure [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Only revent.event is supported. wait_ms < 0: wait forever NT9831X NT9832X NT9833X NT98331 All functions are supported. wait_ms < 0: not supported","title":"2.2.3 hd_videoenc_poll_list"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#224-hd_videoenc_recv_list","text":"[Description] Receive bitstream data for all channels [Syntax] HD_RESULT hd_videoenc_recv_list(HD_VIDEOENC_RECV_LIST *p_videoenc_list, UINT32 num); [Parameter] Value Description p_videoenc_list An array of bitstream structure to be filled for multi channels num The number of channels to retrieve bitstream [Return Value] Value Description HD_OK Success HD_ERR_NG Failure [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 NOT supported. NT9831X NT9832X NT9833X NT98331 All functions are supported.","title":"2.2.4 hd_videoenc_recv_list"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#23-data-structure-definition","text":"","title":"2.3 Data structure  definition"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#231-hd_videoenc_param_syscaps","text":"[Description] System capability [Parameter] Value Description dev_id device id chip_id chip id of this device max_in_count max count of input of this device max_out_count max count of output of this device dev_caps capability of device, using HD_DEVICE_CAPS in_caps capability of input, using HD_VIDEO_CAPS out_caps capability of output, using HD_VIDEOENC_CAPS max_in_stamp max input stamp max_in_stamp_ex max input stamp_ex max_in_mask max input mask max_in_mask_ex max input mask_ex [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 max_in_count? = 16; max_out_count = 16; dev_caps = ??????????????? HD_CAPS_PATHCONFIG; in_caps[0~15] = ??????????????? HD_VIDEO_CAPS_YUV420 ??????????????? | HD_VIDEO_CAPS_YUV422 ??????????????? | HD_VIDEO_CAPS_COMPRESS ??????????????? | HD_VIDEO_CAPS_DIR_ROTATER ??????????????? | HD_VIDEO_CAPS_DIR_ROTATEL ??????????????? | HD_VIDEO_CAPS_STAMP ??????????????? | HD_VIDEO_CAPS_MASK; out_caps[0~15] = ??????????????? HD_VIDEOENC_CAPS_JPEG ??????????????? | HD_VIDEOENC_CAPS_H264 ??????????????? | HD_VIDEOENC_CAPS_H265; max_in_stamp = 32; max_in_stamp_ex = 64; max_in_mask = 8; max_in_mask_ex = 16; NT9831X NT9832X NT9833X NT98331 max_in_count = 64; max_out_count = 64; dev_caps = ??????????????? HD_CAPS_PATHCONFIG ??????????????? | HD_CAPS_LISTFUNC; in_caps[0~63] = ??????????????? HD_VIDEO_CAPS_YUV420 ??????????????? | HD_VIDEO_CAPS_YUV422 ??????????????? | HD_VIDEO_CAPS_DIR_ROTATER ??????????????? | HD_VIDEO_CAPS_DIR_ROTATE180 ??????????????? | HD_VIDEO_CAPS_DIR_ROTATEL ??????????????? | HD_VIDEO_CAPS_MASK; out_caps[0~63] = ??????????????? HD_VIDEOENC_CAPS_JPEG ??????????????? | HD_VIDEOENC_CAPS_H264 ??????????????? | HD_VIDEOENC_CAPS_H265; max_in_stamp = 0; max_in_stamp_ex = 0; max_in_mask = 0; max_in_mask_ex = 0;","title":"2.3.1 HD_VIDEOENC_PARAM_SYSCAPS"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#232-hd_videoenc_param_path_config","text":"[Description] Path configure [Parameter] Value Description max_mem maximum memory information. Using HD_VIDEOENC_MAXMEM struct isp_id ISP id. range: 0~7 or 0xffffffff = ignore data_pool pool memory information. User can specify the size/count of buffers for encoder\u2019s out-buffer. [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 data_pool is not supported NT9831X NT9832X NT9833X NT98331 max_mem and isp_id are not supported. [Apply Require] stop -> close -> open -> set -> start","title":"2.3.2 HD_VIDEOENC_PARAM_PATH_CONFIG"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#233-hd_videoenc_param_bufinfo","text":"[Description] Buffer information [Parameter] Value Description buf_info physical addr/size of bitstream buffer, for user space to mmap [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Function is supported. NT9831X NT9832X NT9833X NT98331 Function is not supported.","title":"2.3.3 HD_VIDEOENC_PARAM_BUFINFO"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#234-hd_videoenc_param_in","text":"[Description] Input parameters [Parameter] Value Description dim encode width/height, using HD_DIM struct pxl_fmt source format, using HD_VIDEO_PXLFMT struct dir input direction, using HD_VIDEO_DIR struct frc frame rate control [Difference] Chip Description NT9668X the valid pxl_fmt values in H26X with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV420_NVX1_H264(for H264 encode) HD_VIDEO_PXLFMT_YUV420_NVX1_H265(for H265 encode) and JPEG with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV422 NT9852X the valid pxl_fmt values in H26X with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV420_NVX2 and JPEG with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV422 NT9856X the valid pxl_fmt values in H26X with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV420_NVX2 and JPEG with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV420_NVX2 HD_VIDEO_PXLFMT_YUV422 NT98530 the valid pxl_fmt values in H26X with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV420_MB4 HD_VIDEO_PXLFMT_YUV420_NVX2 HD_VIDEO_PXLFMT_YUV420_NVX5 and JPEG with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV420_NVX2 HD_VIDEO_PXLFMT_YUV422 NT9831X NT9832X frc is not supported. the valid pxl_fmt values in H26X with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV420_NVX3 And JPEG with HD_VIDEO_PXLFMT_YUV420_MB NT9833X NT98331 the valid pxl_fmt values in H26X and jpeg with HD_VIDEO_PXLFMT_YUV420 HD_VIDEO_PXLFMT_YUV420_NVX3 [Apply Require] stop -> set -> start [Note] If videoproc is binding to videoenc, and HD_VIDEOPROC_OUT is set to default=0 (auto-sync parameters from videoenc), then remember to call start for videoproc [videoenc] stop -> set -> start [videoproc] start","title":"2.3.4 HD_VIDEOENC_PARAM_IN"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#235-hd_videoenc_param_in_frc","text":"[Description] Input parameters [Parameter] Value Description frc frame rate control [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 Function is supported. NT9831X NT9832X NT9833X NT98331 Function is not supported. [Apply Require] If change between (dst <= src) and (dst <= src) set -> start If change between (dst <= src) and (dst > src)? (both direction) If change between (dst > src) and (dst > src) stop -> set -> start","title":"2.3.5 HD_VIDEOENC_PARAM_IN_FRC"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#236-hd_videoenc_param_out_enc_param","text":"[Description] Input frame [Parameter] Value Description codec_type codec type, using HD_VIDEO_CODEC struct h26x H26x config, using HD_H26X_CONFIG struct jpeg Jpeg config, using HD_JPEG_CONFIG struct [Apply Require] stop -> set -> start","title":"2.3.6 HD_VIDEOENC_PARAM_OUT_ENC_PARAM"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#237-hd_videoenc_param_out_vui","text":"[Description] H26x vui settings [Parameter] Value Description vui_en enable vui. default: 0, range: 0~1 (0: disable, 1: enable) sar_width Horizontal size of the sample aspect ratio. default: 0, range: 0~65535 sar_height Vertical size of the sample aspect rat. default: 0, range: 0~65535 matrix_coef Matrix coefficients are used to derive the luma and Chroma signals from green, blue, and red primaries. default: 2, range: 0~255 transfer_characteristics The opto-electronic transfers characteristic of the source pictures. default: 2, range: 0~255 colour_primaries Chromaticity coordinates the source primaries. default: 2, range: 0~255 video_format Indicate the representation of pictures. default: 5, range: 0~7 color_range Indicate the black level and range of the luma and Chroma signals. default: 0, range: 0~1 (0: Not full range, 1: Full range) timing_present_flag timing info present flag. default: 0, range: 0~1 (0: disable, 1: enable) [Apply Require] stop -> set -> start","title":"2.3.7 HD_VIDEOENC_PARAM_OUT_VUI"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#238-hd_videoenc_param_out_deblock","text":"[Description] H26x deblock settings [Parameter] Value Description dis_ilf_idc Disable loop filter in slice header. default: 0, range: 0~2 (0: Filter, 1: No Filter, 2: Slice Mode) db_alpha Alpha & C0 offset. default: 0, range: -12~12 db_beta Beta offset.?????? default: 0, range: -12~12 [Difference] Chip Description NT9668X dis_ilf_idc-> across_tile_en is not supported NT9852X NT9856X NT98530 NT9831X NT9832X NT9833X NT98331 All functions are supported. [Apply Require] stop -> set -> start","title":"2.3.8 HD_VIDEOENC_PARAM_OUT_DEBLOCK"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#239-hd_videoenc_param_out_rate_control","text":"[Description] H26x rate control settings [Parameter] Value Description rc_mode rate control mode. default: 1, range: 1~4 (1: CBR, 2: VBR, 3: FixQP, 4: EVBR), using HD_VIDEOENC_RC_MODE struct cbr parameter of rate control mode CBR, using HD_H26XENC_CBR struct vbr parameter of rate control mode VBR, using HD_H26XENC_VBR struct fixqp parameter of rate control mode FixQP, using HD_H26XENC_FIXQP struct evbr parameter of rate control mode EVBR, using HD_H26XENC_EVBR struct [Apply Require] set -> start","title":"2.3.9 HD_VIDEOENC_PARAM_OUT_RATE_CONTROL"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2310-hd_videoenc_param_out_usr_qp","text":"[Description] H26x user qp settings [Parameter] Value Description Enable enable user qp. default: 0, range: 0~1 (0: disable, 1: enable) qp_map_addr buffer address of user qp map. one byte per cu16 (bit[0:7] qp value. default: 26, range: 0~51) two byte per cu16. (bit[0:5] qp value (default: 0; if qp mode is 3 then qp value means fixed qp [range: 0~51], otherwise qp value means delta qp [range: -32~31])) (bit[6:7] qp? mode (default: 0; 0: delta qp, 1: reserved, 2: delta qp [disable AQ], 3: fixed qp) [Difference] Chip Description NT9668X qp_map_addr is one byte per cu16 NT9852X NT9856X NT98530 qp_map_addr is two bytes per cu16 NT9831X NT9832X NT9833X NT98331 All functions are supported. [Apply Require] set -> start","title":"2.3.10 HD_VIDEOENC_PARAM_OUT_USR_QP"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2311-hd_videoenc_param_out_slice_split","text":"[Description] H26x slice split [Parameter] Value Description enable enable multiple slice. default: 0, range: 0~1 (0: disable, 1: enable) slice_row_num number of macroblock/ctu rows occupied by a slice, range: 1 ~ number of macroblock/ctu row [Apply Require] set -> start","title":"2.3.11 HD_VIDEOENC_PARAM_OUT_SLICE_SPLIT"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2312-hd_videoenc_param_out_enc_gdr","text":"[Description] H26x GDR settins [Parameter] Value Description enable enable gdr. default: 0, range: 0~1 (0: disable, 1: enable) period intra refresh period. default: 0, range: 0~0xFFFFFFFF (0: always refresh, others: intra refresh frame period) number intra refresh row number. default: 1, range: 1 ~ number of macroblock/ctu row [Apply Require] set -> start","title":"2.3.12 HD_VIDEOENC_PARAM_OUT_ENC_GDR"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2313-hd_videoenc_param_out_roi","text":"[Description] H26x ROI settings [Parameter] Value Description roi_qp_mode roi qp mode for all windows.? available value: HD_VIDEOENC_QPMODE_FIXED_QP(default) / HD_VIDEOENC_QPMODE_DELTA, using HD_VIDEOENC_QPMODE struct st_roi roi window settings. ROIs can be overlaid, and the priority of the ROIs is based on index number, index 0 is highest priority and index 9 is lowest. Using HD_H26XENC_ROI_WIN struct [Difference] Chip Description NT9668X st_roi is not supported. NT9852X NT9856X NT98530 All functions are supported. NT9831X NT9832X NT9833X NT98331 roi_qp_mode is not supported. [Apply Require] set -> start","title":"2.3.13 HD_VIDEOENC_PARAM_OUT_ROI"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2314-hd_videoenc_param_out_row_rc","text":"[Description] H26x row rc settings [Parameter] Value Description enable enable row rc. default: 1, range: 0~1 (0: disable, 1: enable) i_qp_range row-level rata control. default: 2, range: 0~15 i_qp_step row-level rata control. default: 1, range: 0~15 p_qp_range qp range of P frame for row-level rata control. default: 4, range: 0~15 p_qp_step qp step? of P frame for row-level rata control. default: 1, range: 0~15 min_i_qp min qp of I frame for row-level rata control. default:? 1, range: 0~51 max_i_qp max qp of I frame for row-level rata control. default: 51, range: 0~51 min_p_qp min qp of P frame for row-level rata control. default:? 1, range: 0~51 max_p_qp max qp of P frame for row-level rata control. default: 51, range: 0~51 [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 i_qp_range: qp range of I&P frame. i_qp_step: qp step of I&P frame. p_qp_range, p_qp_step, min_i_qp, max_i_qp, min_i_qp and max_i_qp are not supported. NT9831X NT9832X NT9833X NT98331 i_qp_range: qp range of I frame. i_qp_step: qp step of I frame. [Apply Require] set -> start","title":"2.3.14 HD_VIDEOENC_PARAM_OUT_ROW_RC"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2315-hd_videoenc_param_out_aq","text":"[Description] H26x aq settings [Parameter] Value Description enable AQ enable. default: 0, range: 0~1 (0: disable, 1: enable) i_str aq strength of I frame. default: 3, range: 1~8 p_str aq strength of P frame. default: 1, range: 1~8 max_delta_qp max delta qp of aq. min_delta_qp min delta qp of aq. depth AQ depth. default: 2, range(H.264): 2, range(H.265): 0~2 (0: cu64, 1: cu32, 2: cu16) thd_table non-linear AQ mapping table. range: -512~511, default: {-120,-112,-104, -96, -88, -80, -72, -64, -56, -48, -40, -32, -24, -16, -8, 7, 15, 23, 31, 39,47, 55, 63, 71, 79, 87, 95, 103, 111, 119} for ( dqp = -15; dqp < 15; dqp++ ) if ( Cu.RelativeTextureComplexity(x_str) <= thd_table[dqp+15] ) break; Cu.DeltaQP_AQ = MIN ( MAX (min_delta_qp, dqp), max_delta_qp ); [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 max_delta_qp range 0~8 (default: 6). min_delta_qp range -8~0 (default: -6). depth and thd_table are not supported. NT9831X NT9832X NT9833X NT98331 max_delta_qp range 0~15 (default: 6). min_delta_qp range -15~0 (default: -6). [Apply Require] set -> start","title":"2.3.15 HD_VIDEOENC_PARAM_OUT_AQ"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2316-hd_videoenc_param_out_request_iframe","text":"[Description] H26x request I-frame [Parameter] Value Description enable request i-frame enable. default: 0, range: 0~1 (0: disable, 1: enable) [Apply Require] set -> start","title":"2.3.16 HD_VIDEOENC_PARAM_OUT_REQUEST_IFRAME"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2317-hd_videoenc_param_out_trig_snapshot","text":"[Description] H26x trigger snapshot [Parameter] Value Description phy_addr [w]physical address of encoded data (user provide memory space to put JPEG result) size [w]user buffer size provided [r]real size of encoded data [Apply Require] set","title":"2.3.17 HD_VIDEOENC_PARAM_OUT_TRIG_SNAPSHOT"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2318-hd_videoenc_param_in_stamp_buf","text":"[Description] Stamp buffer settings [Parameter] Value Description type ping pong buffer or single buffer, using HD_OSG_BUF_TYPE size buffer\u2019s size in byte p_addr buffer\u2019s physical address ddr_id p_addr\u2019s ddr id [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 ddr_id is not supported. NT9831X NT9832X NT9833X NT98331 All functions are not supported. [Apply Require] stop -> set -> start [Note] For NT9668X / NT9852X / NT9856X / NT98530: Different OSGs can share the same buffer to save memory Double buffer requires \u201c2 * max OSG resolution * sizeof(short)\u201d while single buffer requires only \u201cmax OSG resolution* sizeof(short)\u201d. But single buffer suffers from blinking when image is updated. The starting address and length should be (2 x cpu cache line) aligned for ping pong buffer (128 or 64 bytes) and cpu cache line aligned for single buffer(64 or 32 bytes). If stamp will be rendered on mjpg or jpeg, width must be extended to multiple of 4 to calculate buffer size.","title":"2.3.18 HD_VIDEOENC_PARAM_IN_STAMP_BUF"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2319-hd_videoenc_param_in_stamp_img","text":"[Description] Stamp image settings [Parameter] Value Description fmt RGB565/ARGB1555/ARGB4444/ARGB8888/ Using HD_VIDEO_PXLFMT struct dim image\u2019s width and height, using HD_DIM struct p_addr image\u2019s bitmap content ddr_id p_addr\u2019s ddr id [Difference] Chip Description NT9668X Palette and ddr_id are not supported. NT9852X NT9856X NT98530 ddr_id Is not supported. NT9831X NT9832X NT9833X NT98331 All functions are supported [Apply Require] set [Note] For NT9668X / NT9852X / NT9856X / NT98530: Only RGB565/ARGB1555/ARGB4444 are supported Image width is best to be multiple of 4 bytes for best compatibility. For example, image width of an argb1555 is multiple of 2 and image width of a palette2 (a pixels takes 2 bits) is multiple of 16. Image height is best to be multiple of 2 for best compatibility. In addition to the whole image width and height, every color area(e.g. timestamp and border)\u2019s width and height should be multiple of 2. hd_videoenc_get retrieves free buffer(not accessed by hardware) for OSG of ping pong buffer For NT9831X / NT9832X / NT98331 1. User needs to use external OSG for JPEG codec. Please refer to hd_videoout.doc.","title":"2.3.19 HD_VIDEOENC_PARAM_IN_STAMP_IMG"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2320-hd_videoenc_param_in_stamp_attr","text":"[Description] Stamp attr settings [Parameter] Value Description align_type to which corner is stamp aligned Using HD_OSG_ALIGN_TYPE struct alpha (DISP)alpha value position (DISP)stamp\u2019s x,y position, using HD_IPOINT struct colorkey_en colorkey used to filter background colorkey_val filtered background color qp_en does stamp have its own qp qp_fix qp_val is fixed or relative to streaming qp qp_val qp value layer set layer attribute for videoenc region set region attribute for videoenc gcac_enable (GCAC)gcac enable gcac_blk_width unit width of GCAC gcac_blk_height unit height of GCAC. Note: OSG dim / (gcac_blk_width* gcac_blk_height) must less than 64 [Difference] Chip Description NT9668X alpha only for rgb565. align_type, gcac_enable, gcac_blk_width and gcac_blk_width are not supported. NT9852X NT9856X NT98530 alpha for argb4444, argb1555, rgb565. align_type, gcac_enable, gcac_blk_width and gcac_blk_width are not supported. NT9831X NT9832X NT9833X NT98331 colorkey_en, colorkey_val, qp_en, qp_fix, qp_val, layer and region are not supported. [Apply Require] set [Note] For NT9668X / NT9852X / NT9856X / NT98530: align_type, gcac_* are not supported For ARGB4444, alpha field is not applicable. For ARGB1555. alpha[3..0] is for pixels of A = 0 and alpha[7..4] is for pixels of A = 1. For best compatibility, set alpha to 0xf0. Other values may lead to missing stamp or opaque background. X y are best to be multiple of 2 for best compatibility. For h264, any 16*16 macro block can have only one OSG. For h265, any 64*64 macro block can have only one OSG. If two OSGs are inside a macro block or even overlapped, they must be in different layer(currently, there are only two layers : 0 and 1. Layer 1 will be rendered above layer 0.) region is a serial number(each layer has 16 regions : 0 ~ 15) qp_* are used to resolve conflicting qp value between streaming and OSG. Ext stamp doesn\u2019t support colorkey_en, colorkey_val, qp_en, qp_fix, qp_val, layer, region, gcac_enable, gcac_blk_width, gcac_blk_height Ext stamp opened with higher HD_STAMP_EX value will override ext stamps with lower value For NT9831X / NT9832X / NT9833X / NT98331: 1.x/y need to be multiple of 2 for best compatibility. 2. For NT9831X / NT9832X / NT98331, user needs to use external OSG for JPEG codec. Please refer to hd_videoout.doc.","title":"2.3.20 HD_VIDEOENC_PARAM_IN_STAMP_ATTR"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2321-hd_videoenc_param_in_mask_attr","text":"[Description] Mask attribute settings [Parameter] Value Description type mask is solid or hollow. Using HD_OSG_MASK_TYPE color mask color in rgb, mask palette index alpha mask transparency position 4 vertices\u2019 position, using HD_UPOINT struct thickness border width for hollow mask [Difference] Chip Description NT9668X only support ext mask. NT9852X support builtin mask and builtin mask should be set through vendor_videoenc_set NT9853X support builtin mask and builtin mask should be set through hd_videoenc_set. Irregular rectangle is supported. NT9831X NT9832X NT9833X NT98331 color and thickness are not supported. [Apply Require] set [Note] For NT9668X / NT9852X / NT9856X / NT98530: position[0] should be the top left. Others should be in clockwise order. thickness should be multiple of 2 Hollow mask takes more time to complete than solid mask. Don\u2019t set over 4 hollow masks in a path. mask opened with higher HD_MASK_EX value will override ext masks with lower value DDR consumption is proportional to ext mask\u2019s area. This is true even for hollow ext masks with thin border. For NT9831X / NT9832X / NT9833X / NT98331 1. JPEG doesn\u2019t have relative engine, so user needs to use external OSG for JPEG mask. Please refer to hd_videoout.doc.","title":"2.3.21 HD_VIDEOENC_PARAM_IN_MASK_ATTR"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2322-hd_videoenc_param_in_mosaic_attr","text":"[Description] Mosaic attribute settings [Parameter] Value Description Type mask is solid or inversion. Using HD_OSG_MASK_TYPE struct Alpha mask alpha blending. range: 0 ~ 256 (0: foreground, 256: background) mosaic_blk_w witdh of internal block mosaic_blk_h height of internal block position 4 vertices\u2019 position, using HD_UPOINT struct [Difference] Chip Description NT9853X type and alpha are not supported. NT9831X NT9832X NT9833X NT98331 All functions are supported. [Apply Require] set [Note] For NT9668X / NT9852X / NT9856X / NT98530: Mosaic is not supported For NT9831X / NT9832X / NT9833X / NT98331 1. JPEG doesn\u2019t have relative engine, so user needs to use external OSG for JPEG mosaic. Please refer to hd_videoout.doc.","title":"2.3.22 HD_VIDEOENC_PARAM_IN_MOSAIC_ATTR"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2323-hd_videoenc_param_in_palette_table","text":"[Description] Palette table settings [Parameter] Value Description pal_y palette colors y. range: 0 ~ 255 pal_cb palette colors cb. range: 0 ~ 255 pal_cr palette colors cr. range: 0 ~ 255 [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 All functions are not supported. NT9831X NT9832X NT9833X NT98331 All functions are supported. [Apply Require] set For NT9831X / NT9832X / NT9833X / NT98331 1. JPEG doesn\u2019t have relative engine, so user needs to use external OSG for JPEG palette table. Please refer to hd_videoout.doc.","title":"2.3.23 HD_VIDEOENC_PARAM_IN_PALETTE_TABLE"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2324-hd_videoenc_param_func_config","text":"[Description] Function configure [Parameter] Value Description ddr_id Configure which ddr to work & output bitstream in_func additional function of in (bit-wise mask). enable ONEBUFF/ LOWLATENCY mode. [Difference] Chip Description NT9668X ddr_id and in_func are not supported. NT9852X NT9856X NT98530 All functions are supported. NT9831X NT9832X NT9833X NT98331 ddr_id and in_func are not supported.","title":"2.3.24 HD_VIDEOENC_PARAM_FUNC_CONFIG"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2325-hd_videoenc_poll_list","text":"[Description] The polling item including path information Use this type to form an array in hd_videoenc_poll_list() to get the results for all paths. [Parameter] Value Description path_id path ID revent The returned event value [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 NOT supported. NT9831X NT9832X NT9833X NT98331 Supported.","title":"2.3.25 HD_VIDEOENC_POLL_LIST"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2326-hd_videoenc_user_bs","text":"[Description] Video bitstream data and relative information [Parameter] Value Description sign signature = MAKEFOURCC(\u2018V\u2019,\u2019S\u2019,\u2019T\u2019,\u2019M\u2019) p_next pointer to next meta vcodec_format Encoded format of video frame pack_num Pack number in video frame timestamp Encode bs timestamp frame_type The frame type svc_layer_type svc layer type video_pack Pack array of encoded data psnr_info The PSNR information blk_info The block partition information newbs_flag Flag notification of new seting qp The qp value slice_offset multi-slice offset 0~VENC_USER_SLICE_MAX p_user_buf Bitstream buffer pointer user_buf_size AP provide bs_buf max size [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 NOT supported. NT9831X NT9832X NT9833X NT98331 Supported.","title":"2.3.26 HD_VIDEOENC_USER_BS"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2327-hd_videoenc_recv_list","text":"[Description] The video bitstream item including path information Use this type to form an array in hd_videoenc_recv_list() to get the video bitstreams for all paths. [Parameter] Value Description path_id path ID user_bs video encode user bitstream retval less than 0: recv bistream fail. [Difference] Chip Description NT9668X NT9852X NT9856X NT98530 NOT supported. NT9831X NT9832X NT9833X NT98331 Supported.","title":"2.3.27 HD_VIDEOENC_RECV_LIST"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2328-hd_h26x_config","text":"[Description] The basic parameters for H264/H265. [Parameter] Value Description gop_num I-frame period chrm_qp_idx chroma qp offset sec_chrm_qp_idx Second chroma QP offset ltr_interval Long-term reference frame interval 0: all long-term reference to IDR frame, 1: reference latest long-term reference frame ltr_pre_ref Long-term reference setting gray_en Encode color to gray source_output Source output profile Profile IDC level_idc Level IDC svc_layer SVC Layer entropy_mode Entropy coding method","title":"2.3.28 HD_H26X_CONFIG"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#2329-hd_jpeg_config","text":"[Description] The basic parameters for JPEG. [Parameter] Value Description retstart_interval Specifies the interval between RSTn markers, in Minimum Coded Units (MCUs). This marker is followed by two bytes indicating the fixed size so it can be treated like any other variable size segment. Restart interval default setting is zero. The user can setting interval value from 0 to image size/256. image_quality Specify the picture quality","title":"2.3.29 HD_JPEG_CONFIG"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#3-trouble-shooting","text":"The hd_videoenc provides a useful feature to debug, it is called debug menu.","title":"3 Trouble shooting"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#31-debug-menu-nt9668x-nt9852x-nt9856x-nt98530","text":"In application, call hd_debug_run_menu() to open the debug menu. ============================== ?HDAL ------------------------------ ?01 : AUDIOCAPTURE ?02 : AUDIOOUT ?03 : AUDIOENC ?04 : AUDIODEC ?05 : VIDEOCAPTURE ?06 : VIDEOOUT ?07 : VIDEOPROCESS ?08 : VIDEOENC ?09 : VIDEODEC ?10 : OSG ?11 : COMMON ?12 : UTIL ?13 : DEBUG ------------------------------ ?254 : Quit ?255 : Return ------------------------------ Enter \u201c8\u201d to open VIDEOENC debug menu ============================== ?VIDEOENC ------------------------------ ?01 : dump status ?02 : enc info ?03 : rc info ON ?04 : rc info OFF ------------------------------ ?254 : Quit ?255 : Return ------------------------------ Note: The items in the menu may vary for each chip.","title":"3.1 debug  menu (NT9668X / NT9852X / NT9856X / NT98530)"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#311-dump-status","text":"Enter \u201c1\u201d to show the status of videoenc Run: 01 : dump status HDAL_VERSION: 00010001:00010001 ------------------------- VIDEOENC 0? PATH & BIND ------------------------------ in??? out?? state bind_src????????????? bind_dest 0???? 0???? START VIDEOPROC_0_OUT_0???? (null) ------------------------- VIDEOENC 0? PATH CONFIG ------------------------------ in??? out?? max_w max_h? svc? ltr? rotate? bitrate?? enc_ms 0???? 0???? 1920? 1080??? 2??? 1????? 0??? 2097152?? 3000 ------------------------- VIDEOENC 0? IN FRAME --------------------------------- in??? w???? h???? pxlfmt? frc?? dir 0???? 1920? 1080? YUV420? 1/1?? .... ------------------------- VIDEOENC 0? OUT BS ----------------------------------- --- [H26x] \u2014 out?? codec? gop? ltr_int? ltr_ref? gray? src_out? profile? level? svc? entropy 0???? H265?? 15?? 0??????? 0??????? 0???? 0??????? MAIN???? 150? ??0??? CABAC ------------------------- VIDEOENC 0? VUI -------------------------------------- out?? vui_en? sar_w? sar_h? mat_c? tran_c? col_prim? vid_fmt? col_rng? time_pre 0???? 0?????? .....? .....? .....? ......? ........? .......? .......? ........ ------------------------- VIDEOENC 0? DEBLOCK ---------------------------------- out?? dis_ilf_idc? alpha? beta 0???? 0??????????? 0????? 0 ------------------------- VIDEOENC 0? RC --------------------------------------- out?? mode? bitrate? fr? I(int/min/max)? P(int/min/max)? sta? ip_w 0???? CBR?? 2097152? 30?? ( 26/ 10/ 45)?? ( 26/ 10/ 45)? 4??? 0 ------------------------- VIDEOENC 0? USER QP ---------------------------------- out?? en? map_addr 0???? 0?? ........ ------------------------- VIDEOENC 0? SLICE SPLIT ------------------------------ out?? en? row_num 0???? 0?? ....... ------------------------- VIDEOENC 0? GDR -------------------------------------- out?? en? period? row_num 0???? 0?? ......? ....... ------------------------- VIDEOENC 0? ROI -------------------------------------- out?? qp_mode? win? qp? rect(x,y,w,h) ------------------------- VIDEOENC 0? ROW RC ----------------------------------- out?? en? qp_rng? qp_step 0???? 1?? 2?????? 1 ------------------------- VIDEOENC 0? AQ --------------------------------------- out?? en? i_str? p_str? max_delta? min_delta 0???? 0?? .....? .....? .........? ......... ------------------------- VIDEOENC 0? IN WORK STATUS -------------------------- in??? PUSH? drop? wrn?? err?? PROC? drop? wrn?? err?? REL 0???? 30?? ??0??? ??0???? 0???? 30??? ?0???? 0???? ?0???? 30 ------------------------- VIDEOENC 0? OUT WORK STATUS ------------------------- out?? NEW?? drop? wrn?? err?? PROC? drop? wrn?? err?? PUSH? drop? wrn?? err 0???? ?30??? 0???? ?0???? 0???? 30?? ??0???? 0?? ???0???? 30?? ?0??? ??0???? 0 ------------------------- VIDEOENC 0? USER WORK STATUS ------------------------- out?? PULL?? drop? wrn?? err?? REL 0??? ?30???? ?0??? ??0???? 0???? 30 As above, the debug menu shows the path & bind information, path_config , input frame / output bitstream information. The detail for each count value is as following, [IN] IN PUSH => get YUV from previous unit / user push_in err (1) module is NOT start ??? (2) for auto-bind mod, check YUV lineoffset is wrong wrn (1) YUV ping-pong buffer if full ??? (2) bitstream buffer is full, drop this YUV drop (1) module is stop, drop any YUV that is not processed PROC => prepare to encode err (1) encode fail wrn (1) N/A drop (1) N/A REL => release YUV [OUT] OUT NEW => search for bitstream buffer to put encode result err (1) N/A wrn (1) bitstream buffer is full, could not encode this YUV drop (1) N/A PROC => prepare to encode err (1) encode fail wrn (1) N/A drop (1) N/A PUSH => push encoded bitstream to pull queue (for user pull later) err (1) N/A wrn (1) pull queue is full drop (1) N/A [USER] USER PULL => user call hd_videoenc_pull_out_buf() to get bitstream err (1) N/A wrn (1) pull fail due to timeout drop (1) N/A REL => user call hd_videoenc_release_out_buf() to release bitstream","title":"3.1.1 dump status"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#312-enc-info","text":"Enter \u201c2\u201d and then enter which path to show encoder information Run: 02 : enc info Please enter which path (0~15)? => : 0 [ 2855.827904] [VDOENC][0] Codec = H265, RC Mode = CBR, W = 1920, H = 1080, BitRate = 2097152, Fps = 30, Gop = 15, SVC = 0, IQP = (26, 10, 45), PQP = (26, 10, 45), Static = 4, Weight = 0, RowRc = (1, 2, 1), SmartRoi = 0, LTR = (0, 0), DB = (0, 0, 0), VUI = (0, 1, 1, 2, 2, 2, 5, 0, 0), 3DNR Callback = 0x7ed68f20, AQ = (0, 3, 1, 36, 6, -6, 0), Rotate = 0, GDR = (0, 0, 1), SLICE = (0, 1), QPMap = (0, 80000000), Enc(Drop, In, Out, Re-Enc, Err) = (0, 8444, 8444, 0, 0) As above, the debug menu shows the encoder settings for certain path.","title":"3.1.2 enc info"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#313-rc-info-on","text":"Enter \u201c3\u201d and then enter which path to START dump rate control information Run: 03 : rc info ON Please enter which path (0~15)? => : 0 [ 3034.766550] h265Enc_DumpRcInfo:mode CBR, frame rate 30/1, gop 15, GOP bitrate 1048576, QP (I 10/45, P 10/45), cur qp 23 (23) [ 3035.795426] dal_h265enc_encodeone:[H265ENC][0] [ 3035.799832] h265Enc_DumpRcInfo:mode CBR, frame rate 30/1, gop 15, GOP bitrate 1048576, QP (I 10/45, P 10/45), cur qp 24 (24) [ 3036.828812] dal_h265enc_encodeone:[H265ENC][0] [ 3036.833193] h265Enc_DumpRcInfo:mode CBR, frame rate 30/1, gop 15, GOP bitrate 1048576, QP (I 10/45, P 10/45), cur qp 26 (26) [ 3037.862142] dal_h265enc_encodeone:[H265ENC][0] [ 3037.866552] h265Enc_DumpRcInfo:mode CBR, frame rate 30/1, gop 15, GOP bitrate 1048576, QP (I 10/45, P 10/45), cur qp 24 (24) As above, the debug menu START dump rate control information.","title":"3.1.3 rc info on"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#314-rc-info-off","text":"Enter \u201c4\u201d and then enter which path to STOP dump rate control information Run: 04 : rc info OFF Please enter which path (0~15)? => : 0 As above, the debug menu STOP dump rate control information.","title":"3.1.4 rc info off"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#32-proc-command-nt9668x-nt9852x-nt9856x-nt98530","text":"","title":"3.2 proc command (NT9668X / NT9852X / NT9856X / NT98530)"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#321-dump-status","text":"[dump info] Cat /proc/hdal/venc/info the result is exactly the same as 3.1.1 Dump status root@NVTEVM:~$ cat /proc/hdal/venc/info HDAL_VERSION: 00010001:00010001 ------------------------- VIDEOENC 0? PATH & BIND ------------------------------ in??? out?? state bind_src????????????? bind_dest 0???? 0???? START VIDEOPROC_0_OUT_0???? (null) ------------------------- VIDEOENC 0? PATH CONFIG ------------------------------ in??? out?? max_w max_h? svc? ltr? rotate? bitrate?? enc_ms 0???? 0???? 1920? 1080??? 2??? 1????? 0??? 2097152?? 3000 ------------------------- VIDEOENC 0? IN FRAME --------------------------------- in??? w???? h???? pxlfmt? frc?? dir 0???? 1920? 1080? YUV420? 1/1?? .... ------------------------- VIDEOENC 0? OUT BS ----------------------------------- --- [H26x] \u2014 out?? codec? gop? ltr_int? ltr_ref? gray? src_out? profile? level? svc? entropy 0???? H265?? 15?? 0??????? 0??????? 0???? 0??????? MAIN???? 150??? 0??? CABAC ------------------------- VIDEOENC 0? VUI -------------------------------------- out?? vui_en? sar_w? sar_h? mat_c? tran_c? col_prim? vid_fmt? col_rng? time_pre 0???? 0?????? .....? .....? .....? ......? ........? .......? .......? ........ ------------------------- VIDEOENC 0? DEBLOCK ---------------------------------- out?? dis_ilf_idc? alpha? beta 0???? 0??????????? 0????? 0 ------------------------- VIDEOENC 0? RC --------------------------------------- out?? mode? bitrate? fr? I(int/min/max)? P(int/min/max)? sta? ip_w 0???? CBR?? 2097152? 30?? ( 26/ 10/ 45)?? ( 26/ 10/ 45)? 4??? 0 ------------------------- VIDEOENC 0? USER QP ---------------------------------- out?? en? map_addr 0???? 0?? ........ ------------------------- VIDEOENC 0? SLICE SPLIT ------------------------------ out?? en? row_num 0???? 0?? ....... ------------------------- VIDEOENC 0? GDR -------------------------------------- out?? en? period? row_num 0???? 0?? ......? ....... ------------------------- VIDEOENC 0? ROI -------------------------------------- out?? qp_mode? win? qp? rect(x,y,w,h) ------------------------- VIDEOENC 0? ROW RC ----------------------------------- out?? en? qp_rng? qp_step 0???? 1?? 2?????? 1 ------------------------- VIDEOENC 0? AQ --------------------------------------- out?? en? i_str? p_str? max_delta? min_delta 0???? 0?? .....? .....? .........? ......... ------------------------- VIDEOENC 0? IN WORK STATUS -------------------------- in??? PUSH? drop? wrn?? err?? PROC? drop? wrn?? err?? REL 0???? 30??? ?0???? 0??? ??0???? 30??? ?0???? 0??? ??0???? 30 ------------------------- VIDEOENC 0? OUT WORK STATUS ------------------------- out?? NEW ??drop? wrn?? err?? PROC? drop? wrn?? err?? PUSH? drop? wrn?? err 0???? ?30??? 0???? ?0???? 0???? 30?? ??0???? 0?? ???0???? 30?? ?0??? ??0???? 0 ------------------------- VIDEOENC 0? USER WORK STATUS ------------------------- out?? PULL?? drop? wrn?? err? ?REL 0???? 30?? ???0??? ??0???? 0???? 30","title":"3.2.1 dump status"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#322-debug-command","text":"[debug port] echo debug [dev] [i/o] [mask] > /proc/hdal/venc/cmd where [dev] = d0 , [i/o] = i0, i1, i2, \u2026, o0, o1, o2, \u2026 , [mask] = show info mask [ Sample ] echo debug d0 o0 mfff > /proc/hdal/venc/cmd this debug command can show more debug log on console root@NVTEVM:/mnt/sd$ hd_video_record [ 4376.440341] hd_reset - begin [ 4376.445192] hd_reset - end HDAL_VERSION: 00010001:00010001 [ 4376.467841] [ 4376.467841]? \u201cvdoenc\u201d.out[0]: open begin, state=0 [ 4376.475047]? \u201cvdoenc\u201d.out[0]: cmd OPEN [ 4376.479852] _ISF_VdoEnc_ImgCap_Open:bIs_NMI_ImgCap_ON = 0 [ 4376.485364]? \u201cvdoenc\u201d.out[0]: open end, state=1 [ 4376.490942] ?\u201dvdoenc\u201d.out[0]: set param(0000f000)=2 [ 4376.496720] ?\u201dvdoenc\u201d.out[0]: set param(0000f005)=3000 [ 4376.502745]? \u201cvdoenc\u201d.out[0]: set param(0000f039)=0 [ 4376.508512] ?\u201dvdoenc\u201d.out[0]: set param(0000f004)=2 [ 4376.514284] [VDOENC][0] Set max alloc size, codec = 2, w = 1920, h = 1080, byterate = 262144, recformat = 7, rotate = 0, svc = 2, ltr = 1, snapshot size = 0, codec size = 9581988, enc buf size = 786432 [ 4376.532280]? \u201cvdoenc\u201d.out[0]: set vdo-size(1920,1080) vdo-format(520C0420) vdo-dir(0) [ 4376.540977]? \u201cvdoenc\u201d.out[0]: set vdo-framerate(1,1) enc_type=0 [ 4377.711187]? \u201cvdoenc\u201d.out[0]: set param(0000f015)=0 [ 4377.717186]? \u201cvdoenc\u201d.out[0]: set param(0000f018)=1 [ 4377.722982]? \u201cvdoenc\u201d.out[0]: set param(0000f01c)=0 [ 4377.728742]? \u201cvdoenc\u201d.out[0]: set param(0000f023)=0 [ 4377.734515]? \u201cvdoenc\u201d.out[0]: set param(0000f03d)=0 [ 4377.740272]? \u201cvdoenc\u201d.out[0]: set param(0000f03e)=0 [ 4377.748686]? \u201cvdoenc\u201d.out[0]: set param(0000f03f)=0 [ 4377.754662]? \u201cvdoenc\u201d.out[0]: set param(0000f040)=0 [ 4377.760429]? \u201cvdoenc\u201d.out[0]: set param(0000f041)=0 [ 4377.767241]? \u201cvdoenc\u201d.out[0]: set param(0000f000)=3 [ 4377.773002]? \u201cvdoenc\u201d.out[0]: set param(0000f001)=1 [ 4377.779520] ?\u201dvdoenc\u201d.out[0]: set param(0000f005)=3000 [ 4377.785535]? \u201cvdoenc\u201d.out[0]: set param(0000f008)=0 [ 4377.791287] ?\u201dvdoenc\u201d.out[0]: set param(0000f009)=15 [ 4377.797124]? \u201cvdoenc\u201d.out[0]: set param(0000f00a)=7 [ 4377.802874]? \u201cvdoenc\u201d.out[0]: set param(0000f014)=0 [ 4377.808624] ?\u201dvdoenc\u201d.out[0]: set param(0000f030)=0 [ 4377.815039]? \u201cvdoenc\u201d.out[0]: set param(0000f035)=0 [ 4377.820793] ?\u201dvdoenc\u201d.out[0]: set param(0000f03a)=150 [ 4377.826717]? \u201cvdoenc\u201d.out[0]: set param(0000f03b)=1 [ 4377.832467]? \u201cvdoenc\u201d.out[0]: set param(0000f03c)=0 [ 4377.839343] [ 4377.839343]? \u201cvdoenc\u201d.out[0]: start begin, state=1 [ 4377.846625]? \u201cvdoenc\u201d.out[0]: cmd RDYSYNC [ 4377.851524] ?\u201dvdoenc\u201d.out[0]: cmd START [ 4377.856325] [VDOENC][0] Action = 0, Codec = 3, Mode = 7, Size = (1920, 1080), Fr = 30, Trig = 1, Alloc size = (0, 3239692, 786432), Enc Buf = (3000 ms, 0 ms, 0x95575f0c, 0x95635f08, 0x95635f08, 786428), Min Size(I, P) = (393216, 262144) [ 4377.877363] dal_h265enc_init:[H265ENC][0] Init Codec = (0x9525f000, 3239692), W = 1920, H = 1080, Prof = 1, Br = 2097152, Fps = 30, Gop = 15, SVC = 0, IQP = (26, 10, 45), PQP = (26, 10, 45), Sta = 4, Wei = 0, RowRc = (1, 2, 1), LTR = (0, 0), MultiT = 0, Rot = 0, FastSr = 0, ColorR = 0, Mode = 0, SEI = 0 [ 4377.904386] h26x_open:H26X Version = 0x20161211 [ 4377.909023] _h265enc_setratecontrol:[H265ENC][0] Set CBR [ 4377.914457]? \u201cvdoenc\u201d.out[0]: start end, state=2 [ 4377.920980]? \u201cvdoenc\u201d.out[0]: get param(0000f037)=329641984 [ 4377.927623]? \u201cvdoenc\u201d.out[0]: get param(0000f038)=10384808 Enter q to exit [ 4377.936965] dal_h265enc_encodeone:[H265ENC][0] Reset I OK, idx = 0, Frame Type = 3, Frame = (0x95575f0c, 258106), Buf = (0x95575f0c, 0x95635f08), t = 103465566 us dump main bitstream to file (/mnt/sd/dump_bs_main.dat) .... if you want to stop, enter \u201cq\u201d to exit !!","title":"3.2.2 debug command"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#323-trace-command","text":"[trace port] echo trace [dev] [i/o] [mask] > /proc/hdal/venc/cmd where [dev] = d0 , [i/o] = i0, i1, i2, \u2026, o0, o1, o2, \u2026 , [mask] = show info mask [ Sample ] echo trace d0 o0 mfff > /proc/hdal/venc/cmd this trace command could enable module internal debug message to know what\u2019s going on for the VIDEOENC module.","title":"3.2.3 trace command"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#324-probe-command","text":"[probe port] echo probe [dev] [i/o] [mask] > /proc/hdal/venc/cmd where [dev] = d0 , [i/o] = i0, i1, i2, \u2026, o0, o1, o2, \u2026 , [mask] = show info mask [ Sample ] echo probe d0 o0 mffff > /proc/hdal/venc/cmd this probe command could print per-data status [ 5692.621611] \u201cvdoenc\u201d.out[0] - NEW - new \u2013 h=9558697c size=00000000 addr=9558697c OK [ 5692.631780] \u201cvdoenc\u201d.out[0] - PUSH - rel \u2013 h=9558697c (result=0) OK [ 5692.652093] \u201cvdoenc\u201d.out[0] - NEW - new \u2013 h=9558779c size=00000000 addr=9558779c OK [ 5692.662281] \u201cvdoenc\u201d.out[0] - PUSH - rel \u2013 h=9558779c (result=0) OK [ 5692.682488] \u201cvdoenc\u201d.out[0] - NEW - new \u2013 h=95588474 size=00000000 addr=95588474 OK [ 5692.691369] \u201cvdoenc\u201d.out[0] - PUSH - rel \u2013 h=95588474 (result=0) OK [ 5692.718160] \u201cvdoenc\u201d.out[0] - NEW - new \u2013 h=95589084 size=00000000 addr=95589084 OK [ 5692.729104] \u201cvdoenc\u201d.out[0] - PUSH - rel \u2013 h=95589084 (result=0) OK [ 5692.749191] \u201cvdoenc\u201d.out[0] - NEW - new \u2013 h=95589e88 size=00000000 addr=95589e88 OK [ 5692.758027] \u201cvdoenc\u201d.out[0] - PUSH - rel \u2013 h=95589e88 (result=0) OK [ 5692.785621] \u201cvdoenc\u201d.out[0] - NEW - new \u2013 h=9558a9f0 size=00000000 addr=9558a9f0 OK [ 5692.796616] \u201cvdoenc\u201d.out[0] - PUSH - rel \u2013 h=9558a9f0 (result=0) OK","title":"3.2.4 probe command"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#325-perf-command","text":"[perf port] echo perf [dev] [i/o] > /proc/hdal/venc/cmd [ Sample ] echo perf d0 i0 > /proc/hdal/venc/cmd this perf command could print data count per second [?? 37.463860] \u201cvdoenc\u201d.in[0] Perf! \u2013 (Video) 30 Frame/sec [?? 38.495429] \u201cvdoenc\u201d.in[0] Perf! \u2013 (Video) 30 Frame/sec [?? 39.495233] \u201cvdoenc\u201d.in[0] Perf! \u2013 (Video) 30 Frame/sec","title":"3.2.5 perf command"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#326-save-command","text":"[save port] echo save [dev] [i/o] [count] > /proc/hdal/venc/cmd where [count] means how many i/o datas to save [ Sample ] echo perf d0 i0 1 > /proc/hdal/venc/cmd this save command could save i/o data to SDCard for debug purpose. [? 140.135994] save i/o begin: \u201cvdoenc\u201d.in[0] count=1 [? 140.153779] \u201cvdoenc\u201d.in[0] Save \u2013 h=94f5bfc0 t=00000000099334e3 (YUV: 1920x1080.520c0420 94f5c000 95156400 1920 1920) [? 141.330243] \u201cvdoenc\u201d.in[0] Save \u2013 //mnt//sd//isf_? vdoenc_in[0]_520c0420_1920_1080_1920_c208.vdo ok [? 141.340271] save port end","title":"3.2.6 save command"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#33-osg-proc-command","text":"","title":"3.3 OSG proc command"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#331-dump-status","text":"cat /proc/hdal/osg/info to show the status of OSG and focus on VIDEOENC ------------------------- VIDEOENC 0 BUFFER ------------------------------------ pid???? type??? fmt???? w?????? h?????? addr??? ????size??????? draw 0?????? pp????? 4444??? 1000??? 200???? 13a55000??? 400000????? 1 0?????? pp????????????? ?0?????? ?0?????? 13ab6a80??? 400000????? 0 ------------------------- VIDEOENC 0 STAMP ------------------------------------- pid???? start?? x? ?????y?????? alpha?? cken??? ckval?? layer?? rgn 0?????? 1?????? ?0?????? 0?????? 255???? ?0?????? ?0?????? 0?????? ?0 ------------------------- VIDEOENC 0 MASK -------------------------------------- pid???? start?? x?????? y?????? w?????? h?????? solid?? thick?? color?????????? alpha 0?????? 1?????? ?500???? 0?????? 100???? 120???? 1?????? 0?????? ff0000????????? 255 As above, the debug menu shows buffer, stamp and mask configuration of all videoenc\u2019s OSGs. Most values are simply from hd_videoenc_set and self-explained. pid serves as an internal serial number and is mainly used to associate stamp and buffer information. start reflects if hd_videoenc_start/hd_videoenc_stop had been applied to that OSG.","title":"3.3.1 dump status"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#332-change-status","text":"OSG attr can be changed through debug menu while buffer and image can\u2019t because buffer and image typically require a buffer which can\u2019t be created by shell console. To change an OSG\u2019s attr, echo data > /proc/hdal/osg/cmd. Below are the format of data : For stamp: phase osg pid io start x y alpha cken ckval layer region example: to set the 5th stamp of output id 3 of videoenc to position[1024,512] and layer(1) region(8), run \u201cecho videoenc stamp 5 3 1 1024 512 255 0 0 1 8\u201d For mask : phase osg pid io start x y w h solid thick color alpha example: to set the 5th green mask of output id 3 of videoenc to position[1024,512] and size 256x128, run \u201cecho videoenc mask 5 3 1 1024 512 256 128 1 0 0x0FF00 255\u201d","title":"3.3.2 change status"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#34-debug-menu-nt9831x-nt9832x-nt9833x-nt98331","text":"","title":"3.4 Debug menu (NT9831X / NT9832X / NT9833X / NT98331)"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#341-dump-status","text":"In application, call hd_debug_run_menu() to open the debug menu. Run: 01 : dump status ------------------------- VIDEOENC 0? PATH & BIND ----------------------------- in????? out???? state?? bind_src??????????????? bind_dest 0?????? 0?????? START?? VIDEOCAP_0_OUT_1??????? - 0?????? 1?????? START?? VIDEOCAP_1_OUT_1??????? - 0?????? 2?????? START?? VIDEOCAP_2_OUT_1??????? - 0?????? 3?????? START?? VIDEOCAP_3_OUT_1??????? - 0?????? 4?????? START?? VIDEOCAP_0_OUT_2??????? - 0?????? 5?????? START?? VIDEOCAP_1_OUT_2??????? - 0?????? 6?????? START?? VIDEOCAP_2_OUT_2??????? - 0?????? 7?????? START?? VIDEOCAP_3_OUT_2??????? - ------------------------- VIDEOENC 0? IN FRAME ----------------------------- in????? w?????? h?????? pxlfmt 0?????? 1920??? 1080??? YUV420 1?????? 1920??? 1080??? YUV420 2?????? 1920??? 1080??? YUV420 3?????? 1920??? 1080??? YUV420 4?????? 960???? 480???? YUV420_NVX3 5?????? 960???? 480???? YUV420_NVX3 6?????? 960???? 480???? YUV420_NVX3 7?????? 960???? 480???? YUV420_NVX3 ------------------------- VIDEOENC 0? OUT FRAME ----------------------------- in????? codec?? gop???? profile svc???? level?? entropy 0?????? -?????? -?????? 0001??? -??????? - 1?????? -?????? -?????? 0001??? -??????? - 2?????? -?????? -?????? 0001??? -??????? - 3?????? -?????? -?????? 0001??? -??????? - 4?????? - ??????-?????? 0001??? -??????? - 5?????? -?????? -?????? 0001??? -??????? - 6?????? -?????? -?????? 0001??? -??????? - 7?????? -?????? -?????? 0001??? -??????? - ------------------------- VIDEOENC 0? RC ----------------------------- in????? mode??? base?? ?incr??? bitrate 0?????? CBR???? 0025??? 0001??? 4096Kbps 1?????? CBR???? 0025??? 0001??? 4096Kbps 2?????? CBR???? 0025??? 0001??? 4096Kbps 3?????? CBR???? 0025??? 0001??? 4096Kbps 4?????? CBR???? 0025??? 0001??? 1024Kbps 5?????? CBR???? 0025??? 0001??? 1024Kbps 6?????? CBR???? 0025??? 0001??? 1024Kbps 7?????? CBR???? 0025??? 0001??? 1024Kbps","title":"3.4.1 dump status"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#35-proc-command-nt9831x-nt9832x-nt9833x","text":"","title":"3.5 proc command (NT9831X / NT9832X / NT9833X)"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#351-dump-status","text":"[dump info] Cat /proc/videograph/hdal_setting the result is similar to 3.1.1 Dump status root@NVTEVM:/$ cat /proc/videograph/hdal_setting ========================== VIDEOCAP 0? SYSCAP ========================== w?????? h?????? fps???? scaling 1920??? 1080??? 25????? 4088 ------------------------- VIDEOCAP 0? PATH & BIND ----------------------------- in????? out???? state?? bind_src??????????????? bind_dest 0?????? 0?????? START?? -?????????????????????? VIDEOENC_0_IN_0 ------------------------- VIDEOCAP 0? OUT FRAME ----------------------------- out???? w?????? h?????? pxlfmt 0???? ??1920??? 1080??? YUV420_NVX3 ------------------------- VIDEOCAP 0? PATH POOL ----------------------------- out???? pool??? ddr_id? count?? max_count 0?????? 0?????? 0?????? 4.0???? 4.0 ------------------------- VIDEOENC 0? PATH & BIND ----------------------------- in????? out???? state?? bind_src??????????????? bind_dest 0?????? 0?????? START?? VIDEOCAP_0_OUT_0??????? - ------------------------- VIDEOENC 0? IN FRAME ----------------------------- in????? w?????? h?????? pxlfmt 0?????? 1920??? 1080??? YUV420_NVX3 ------------------------- VIDEOENC 0? OUT FRAME ----------------------------- in????? codec?? gop???? profile svc???? level?? entropy 0?????? -?????? -?????? 1992728576??? -??????? CABAC ------------------------- VIDEOENC 0? RC ----------------------------- in????? mode??? base??? incr??? bitrate 0?????? CBR???? 0030??? 0001??? 2048Kbps","title":"3.5.1 dump status"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#4-sample-codes","text":"","title":"4 Sample Codes"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#41-hd_videoenc_only","text":"This sample code is used in NT9668X / NT9852X / NT9856X / NT98530. The hd_videoenc_only demonstrates how to use the single trigger operation to process the input image. /* Allocate common buffer */ ? mem_cfg.pool_info[0].type???? = HD_COMMON_MEM_COMMON_POOL; ? mem_cfg.pool_info[0].blk_size = YUV_BLK_SIZE; ? mem_cfg.pool_info[0].blk_cnt? = MAX_YUV_BLK_CNT; ? mem_cfg.pool_info[0].ddr_id?? = DDR_ID0; ? ret = hd_common_mem_init(&mem_cfg); /* set enc path configuration */ ? video_path_config.max_mem.codec_type = HD_CODEC_TYPE_H265; ? video_path_config.max_mem.max_dim.w? = 1920; ? video_path_config.max_mem.max_dim.h? = 1080; ? video_path_config.max_mem.bitrate??? = 2 * 1024 * 1024; // 2 Mb/s = 512 MB/s ? video_path_config.max_mem.enc_buf_ms = 3000; ? video_path_config.max_mem.svc_layer? = HD_SVC_4X; ? video_path_config.max_mem.ltr??????? = TRUE; ? video_path_config.max_mem.rotate???? = FALSE; ? video_path_config.max_mem.source_output?? = FALSE; ? video_path_config.isp_id???????????? = 0; ? ret = hd_videoenc_set(video_enc_path0, HD_VIDEOENC_PARAM_PATH_CONFIG, &video_path_config); /* set enc parameters */ ? //--- HD_VIDEOENC_PARAM_IN \u2014 ? video_in_param.dir???? = HD_VIDEO_DIR_NONE; ? video_in_param.pxl_fmt = HD_VIDEO_PXLFMT_YUV420; ? video_in_param.dim.w?? = main_dim.w; ? video_in_param.dim.h?? = main_dim.h; ? ret = hd_videoenc_set(video_enc_path0, HD_VIDEOENC_PARAM_IN, &video_in_param); ? //--- HD_VIDEOENC_PARAM_OUT_ENC_PARAM \u2014 ? video_out_param.codec_type???????? = HD_CODEC_TYPE_H264; ? video_out_param.h26x.profile?????? = HD_H264E_HIGH_PROFILE; ? video_out_param.h26x.level_idc???? = HD_H264E_LEVEL_5_1; ? video_out_param.h26x.gop_num?????? = 15; ? video_out_param.h26x.ltr_interval? = 0; ? video_out_param.h26x.ltr_pre_ref?? = 0; ? video_out_param.h26x.gray_en?????? = 0; ? video_out_param.h26x.source_output = 0; ? video_out_param.h26x.svc_layer???? = HD_SVC_DISABLE; ? video_out_param.h26x.entropy_mode? = HD_H264E_CABAC_CODING; ? ret = hd_videoenc_set(video_enc_path0, HD_VIDEOENC_PARAM_OUT_ENC_PARAM, &video_out_param); ? //--- HD_VIDEOENC_PARAM_OUT_RATE_CONTROL \u2014 ? rc_param.rc_mode???????????? = HD_RC_MODE_CBR; ? rc_param.cbr.bitrate???????? = 2 * 1024 * 1024; ? rc_param.cbr.frame_rate_base = 30; ? rc_param.cbr.frame_rate_incr = 1; ? rc_param.cbr.init_i_qp?????? = 26; ? rc_param.cbr.min_i_qp??????? = 10; ? rc_param.cbr.max_i_qp??????? = 45; ? rc_param.cbr.init_p_qp?????? = 26; ? rc_param.cbr.min_p_qp??????? = 10; ? rc_param.cbr.max_p_qp?? ?????= 45; ? rc_param.cbr.static_time???? = 4; ? rc_param.cbr.ip_weight?????? = 0; ? ret = hd_videoenc_set(video_enc_path0, HD_VIDEOENC_PARAM_OUT_RATE_CONTROL, &rc_param); /* Push in buffer */ ? blk = hd_common_mem_get_block(HD_COMMON_MEM_COMMON_POOL, blk_size, ddr_id); ? pa = hd_common_mem_blk2pa(blk); ? va = (UINT32)hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_CACHE, pa, blk_size); ? fread((void *)va, 1, yuv_size, fd_yuv); ? video_frame.sign??????? = MAKEFOURCC(\u2018V\u2019,\u2019F\u2019,\u2019R\u2019,\u2019M\u2019); ? video_frame.p_next????? = NULL; ? video_frame.ddr_id????? = ddr_id; ? video_frame.pxlfmt????? = HD_VIDEO_PXLFMT_YUV420; ? video_frame.dim.w?????? = VDO_SIZE_W; ? video_frame.dim.h?????? = VDO_SIZE_H; ? video_frame.count?????? = 0; ? video_frame.timestamp?? = 0; ? video_frame.loff[0]???? = VDO_SIZE_W; // Y ? video_frame.loff[1]???? = VDO_SIZE_W; // UV ? video_frame.phy_addr[0] = pa;? ????????????????????????????// Y ? video_frame.phy_addr[1] = pa + VDO_SIZE_W*VDO_SIZE_H;? // UV pack ? video_frame.blk???????? = blk; ? ret = hd_videoenc_push_in_buf(video_enc_path0, &video_frame, NULL, 0); //--- release buffer \u2014 ? hd_common_mem_release_block(blk); ? hd_common_mem_munmap((void *)va, blk_size); /* pull out buffer */ ? ret = hd_videoenc_pull_out_buf(video_enc_path0, &data_pull, -1); ? if (ret == HD_OK) { ? ???? hd_videoenc_get(video_enc_path0, HD_VIDEOENC_PARAM_BUFINFO, &phy_buf_main); ?????? vir_addr_main = (UINT32)hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_CACHE, phy_buf_main.buf_info.phy_addr, phy_buf_main.buf_info.buf_size);","title":"4.1 hd_videoenc_only"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#define-phy2virt_mainpa-vir_addr_main-pa-phy_buf_mainbuf_infophy_addr","text":"for (j=0; j< data_pull.pack_num; j++) { ?????????? va ??= PHY2VIRT_MAIN(data_pull.video_pack[j].phy_addr); ?????????? size = data_pull.video_pack[j].size; ?????????? fwrite(va, 1, size, fd_bs); ?????? } ???????? //--- release buffer \u2014 ret = hd_videoenc_release_out_buf(video_enc_path0, &data_pull); hd_common_mem_munmap((void *)vir_addr_main, phy_buf_main.buf_info.buf_size); }","title":"define PHY2VIRT_MAIN(pa) (vir_addr_main + (pa - phy_buf_main.buf_info.phy_addr))"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#42-user_videoenc","text":"This sample code is used in NT9831X / NT9832X / NT9833X. The user_videoenc demonstrates how to use the single trigger operation to process the input image. typedef struct { ? union { ?????? HD_VIDEO_FRAME frame; ?????? HD_VIDEOENC_BS bs; ? }; ? UINT64 pool; ? int size; ? HD_COMMON_MEM_DDR_ID ddr_id; ? HD_COMMON_MEM_VB_BLK blk; ? void *va; ? UINT32 pa; } app_buffer_t; typedef struct _USER_VIDEOENC { ? app_buffer_t enc_in_buffer[MAX_IN_FRAME_COUNT]; ? int mem_fd; ? HD_PATH_ID videoenc_path_id; } USER_VIDEOENC; void save_output(char *filename, void *data, int size) { ? FILE *pfile; ? if ((pfile = fopen(filename, \u201cwb\u201d)) == NULL) { ?????? printf(\u201c[ERROR] Open File %s failed!!\\n\u201d, filename); ?????? exit(1); ? } ? fwrite(data, 1, size, pfile); ? fclose(pfile); ? printf(\u201cWrite file: %s\\n\u201d, filename); } int read_input(char *filename, void *buffer, int max_buf_size, int read_size) { ? FILE *pfile; ? INT ret; ? if ((pfile = fopen(filename, \u201crb\u201d)) == NULL) { ?????? printf(\u201c[ERROR] Open File %s failed!!\\n\u201d, filename); ?????? exit(1); ? } ? //if read_size is zero, read whole file. ? if (read_size == 0) { ? ??? fseek(pfile, 0, SEEK_END); ? ??? read_size = ftell(pfile); ?????? fseek(pfile, 0, SEEK_SET); ? } ? if (read_size > max_buf_size) ?????? read_size = max_buf_size; ? if (read_size > 0) { ?????? ret = fread(buffer, 1, read_size, pfile); ? } ? fclose(pfile); ? return ret; } HD_RESULT allocate_buffer(UINT64 pool, int size, HD_COMMON_MEM_DDR_ID ddr_id, app_buffer_t *p_app_buf) { ? HD_RESULT ret = HD_OK; ? HD_COMMON_MEM_VB_BLK blk; ? UINT32 pa, sign; ? VOID *va; ? p_app_buf->pool = pool; ? p_app_buf->size = size; ? p_app_buf->ddr_id = ddr_id; ? blk = hd_common_mem_get_block(pool, size, ddr_id); ? if (HD_COMMON_MEM_VB_INVALID_BLK == blk) { ?????? printf(\u201chd_common_mem_get_block fail\\r\\n\u201d); ?????? ret = HD_ERR_NG; ?????? goto exit; ? } ? pa = hd_common_mem_blk2pa(blk); ? if (pa == 0) { ?????? printf(\u201chd_common_mem_blk2pa fail, blk = %#lx\\r\\n\u201d, blk); ?????? hd_common_mem_release_block(blk); ?????? ret = HD_ERR_NG; ?????? goto exit; ? } ? va = hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_NONCACHE, pa, size); ? p_app_buf->blk = blk; ? p_app_buf->va = va; ? p_app_buf->pa = pa; ? sign = p_app_buf->frame.sign; ? if (sign == MAKEFOURCC(\u2018V\u2019,\u2019F\u2019,\u2019R\u2019,\u2019M\u2019)) { ?????? p_app_buf->frame.phy_addr[0] = pa; ? } else { ?????? p_app_buf->bs.video_pack[0].phy_addr = pa; ? } exit: ? return ret; } HD_RESULT free_buffer(app_buffer_t *p_app_buf) { ? HD_RESULT hd_ret; ? hd_ret = hd_common_mem_munmap(p_app_buf->va, p_app_buf->size); ? if (hd_ret != HD_OK) { ?????? printf(\u201chd_common_mem_munmap fail\\r\\n\u201d); ?????? goto exit; ? } ? hd_ret = hd_common_mem_release_block((HD_COMMON_MEM_VB_BLK)p_app_buf->blk); ? if (hd_ret != HD_OK) { ?????? printf(\u201chd_common_mem_munmap fail\\r\\n\u201d); ?????? goto exit; ? } exit: ? return hd_ret; } HD_RESULT prepare_buffers(USER_VIDEOENC *p_usr_videoenc) { ? INT i, x, y, raw_frame_size; ? UINT16 *pixel; ? HD_VIDEO_FRAME *p_frame; ? HD_RESULT ret = HD_OK; ? for (i = 0; i < MAX_IN_FRAME_COUNT; i++) { ?????? p_frame = &p_usr_videoenc->enc_in_buffer[i].frame; ?????? p_frame->sign = MAKEFOURCC(\u2018V\u2019,\u2019F\u2019,\u2019R\u2019,\u2019M\u2019); ?????? p_frame->ddr_id = 0; ?????? p_frame->dim.w = RAW_FRAME_WIDTH; ?????? p_frame->dim.h = RAW_FRAME_HEIGHT; ?????? p_frame->pxlfmt = HD_VIDEO_PXLFMT_YUV420; ?????? raw_frame_size = p_frame->dim.w * p_frame->dim.h * 2; ?????? ret = allocate_buffer(HD_COMMON_MEM_ENC_CAP_OUT_POOL, raw_frame_size, p_frame->ddr_id, &p_usr_videoenc->enc_in_buffer[i]); ?????? if (ret != 0) { ?????????? goto exit; ?????? } ?????? read_input(RAW_FRAME_FILE, p_usr_videoenc->enc_in_buffer[i].va, FRAME_BUF_SIZE, 0); ????? // Set moving black block ?????? for (y = 300; y < 330; y ++) ?????? for (x = (i * 10 + 300); x < (i * 10 + 330); x ++) { ?????????? pixel = (unsigned short *) (p_usr_videoenc->enc_in_buffer[i].va + ((y * p_frame->dim.w) + x) * 2); ?????????? *pixel = 0x1080; ?????? } ? } exit: ? return ret; } HD_RESULT return_buffers(USER_VIDEOENC *p_usr_videoenc) { ? INT i; ? HD_RESULT ret = HD_OK; ? for (i = 0; i < MAX_IN_FRAME_COUNT; i++) { ?????? ret = free_buffer(&p_usr_videoenc->enc_in_buffer[i]); ?????? if (ret != HD_OK) { ?????????? printf(\u201cfree_buffer fail\\n\u201d); ?????????? break; ?????? } ? } ? return ret; } HD_RESULT set_param(USER_VIDEOENC *p_usr_videoenc) { ? HD_RESULT ret = HD_OK; ? HD_VIDEOENC_IN video_in_param; ? HD_VIDEOENC_OUT enc_param; ? HD_H26XENC_RATE_CONTROL rc_param; ? //set main stream param ? video_in_param.dim.w = RAW_FRAME_WIDTH; ? video_in_param.dim.h = RAW_FRAME_HEIGHT; ? ret = hd_videoenc_set(p_usr_videoenc->videoenc_path_id, HD_VIDEOENC_PARAM_IN, &video_in_param); ? if (ret != HD_OK) { ?????? printf(\u201chd_videoenc_set(HD_VIDEOENC_PARAM_IN) fail\\n\u201d); ?????? goto exit; ? } ? ret = hd_videoenc_get(p_usr_videoenc->videoenc_path_id, HD_VIDEOENC_PARAM_OUT_ENC_PARAM, &enc_param); ? if (ret != HD_OK) { ?????? printf(\u201chd_videoenc_get(HD_VIDEOENC_PARAM_OUT_ENC_PARAM) fail\\n\u201d); ?????? goto exit; ? } ? enc_param.codec_type = HD_CODEC_TYPE_H264; ? enc_param.h26x.gop_num = 60; ? ret = hd_videoenc_set(p_usr_videoenc->videoenc_path_id, HD_VIDEOENC_PARAM_OUT_ENC_PARAM, &enc_param); ? if (ret != HD_OK) { ?????? printf(\u201chd_videoenc_set(HD_VIDEOENC_PARAM_OUT_ENC_PARAM) fail\\n\u201d); ?????? goto exit; ? } ? ret = hd_videoenc_get(p_usr_videoenc->videoenc_path_id, HD_VIDEOENC_PARAM_OUT_RATE_CONTROL, &rc_param); ? if (ret != HD_OK) { ?????? printf(\u201chd_videoenc_get(HD_VIDEOENC_PARAM_OUT_RATE_CONTROL) fail\\n\u201d); ?????? goto exit; ? } ? rc_param.rc_mode = HD_RC_MODE_CBR; ? rc_param.cbr.frame_rate_base = 30;?? //fps = 30/1 = 30 ? rc_param.cbr.frame_rate_incr = 1; ? rc_param.cbr.bitrate = 2048 * 1024; ? ret = hd_videoenc_set(p_usr_videoenc->videoenc_path_id, HD_VIDEOENC_PARAM_OUT_RATE_CONTROL, &rc_param); ? if (ret != HD_OK) { ?????? printf(\u201chd_videoenc_set(HD_VIDEOENC_PARAM_OUT_RATE_CONTROL) fail\\n\u201d); ?????? goto exit; ? } exit: ? return ret; } int encode_the_buffer(USER_VIDEOENC *p_usr_videoenc) { ? INT i, pattern_idx, bs_max_size; ? FILE *bs_file; ? HD_VIDEOENC_BS video_bitstream; ? app_buffer_t bs_out_buffer; ? HD_RESULT ret = HD_OK; ? //open files for writing ? if ((bs_file = fopen(OUT_BS_FILE, \u201cwb\u201d)) == NULL) { ?????? printf(\u201c[ERROR] Open File %s failed!!\\n\u201d, OUT_BS_FILE); ?????? exit(1); ? } ? //prepare bitstream buffer ? bs_max_size = BS_BUF_SIZE; ? bs_out_buffer.bs.sign = MAKEFOURCC(\u2018V\u2019,\u2019S\u2019,\u2019T\u2019,\u2019M\u2019); ? bs_out_buffer.bs.video_pack[0].size = bs_max_size; ? bs_out_buffer.bs.ddr_id = 0; ? ret = allocate_buffer(HD_COMMON_MEM_ENC_CAP_OUT_POOL, bs_max_size, bs_out_buffer.bs.ddr_id, &bs_out_buffer); ? if (ret != 0) { ?????? printf(\u201callocate_buffer fail\\n\u201d); ?????? goto exit; ? } ? //encode frames for LOOP_COUNT times ? pattern_idx = 0; ? for (i = 0; i < LOOP_COUNT; i++) { ?????? bs_out_buffer.bs.video_pack[0].size = bs_max_size; ?????? //trigger it ?????? ret = hd_videoenc_push_in_buf(p_usr_videoenc->videoenc_path_id, &p_usr_videoenc->enc_in_buffer[pattern_idx++].frame, &(bs_out_buffer.bs), 500); ?????? if (ret != HD_OK) { ?????????? printf(\u201chd_videoenc_push_in_buf fail\\n\u201d); ?????????? goto exit; ?????? } ?????? //get the result ?????? ret = hd_videoenc_pull_out_buf(p_usr_videoenc->videoenc_path_id, &video_bitstream, 500); ?????? if (ret != HD_OK) { ?????????? printf(\u201chd_videoenc_pull_out_buf fail\\n\u201d); ?????? } else { ?????????? INT bs_size = 0, pack_num, pa_offset; ?????????? for (pack_num = 0; pack_num < video_bitstream.pack_num; pack_num++) { ??????????????? pa_offset = video_bitstream.video_pack[pack_num].phy_addr - bs_out_buffer.pa; ??????????????? bs_size += fwrite(bs_out_buffer.va+pa_offset, 1, video_bitstream.video_pack[pack_num].size, bs_file); ?????????? } ?????????? printf(\u201d Encode output size: %d\\n\u201d, bs_size); ?????? } ?????? if (pattern_idx >= MAX_IN_FRAME_COUNT) ?????????? pattern_idx = 0; ? } ? //free bitstream buffer ? ret = free_buffer(&bs_out_buffer); ? if (ret != HD_OK) { ?????? printf(\u201cfree_buffer fail\\n\u201d); ? } exit: ? if (bs_file) ?????? fclose(bs_file); ? return ret; } int main(int argc, char *argv[]) { ? HD_RESULT ret = HD_OK; ? USER_VIDEOENC usr_videoenc; ? memset(&usr_videoenc, 0, sizeof(usr_videoenc)); ? usr_videoenc.mem_fd = -1; ? if ((usr_videoenc.mem_fd = open(\u201c/dev/mem\u201d, O_RDWR | O_SYNC)) < 0) { ?????? printf(\u201copen /dev/mem failed.\\n\u201d); ?????? goto exit; ? } ? //init hdal and open modules ? ret = hd_common_init(1); ? if (ret != HD_OK) { ?????? printf(\u201chd_common_init fail\\n\u201d); ?????? goto exit; ? } ? ret = hd_videoenc_init(); ? if (ret != HD_OK) { ?????? printf(\u201chd_videoenc_init fail\\n\u201d); ?????? goto exit; ? } ? ret = hd_videoenc_open(HD_VIDEOENC_0_IN_0, HD_VIDEOENC_0_OUT_0, &usr_videoenc.videoenc_path_id); ? if (ret != HD_OK) { ?????? printf(\u201chd_videoenc_open fail\\n\u201d); ?????? goto exit; ? } ? //setup encoder parameters ? ret = set_param(&usr_videoenc); ? if (ret < 0) { ?????? printf(\u201cset_param fail\\n\u201d); ?????? goto exit; ? } ? //generate source frame for encoding ? ret = prepare_buffers(&usr_videoenc); ? if (ret < 0) { ?????? printf(\u201cprepare_buffers fail\\n\u201d); ?????? goto exit; ? } ? //encode the frames ? ret = encode_the_buffer(&usr_videoenc); ? if (ret < 0) { ?????? printf(\u201cencode_the_buffer fail\\n\u201d); ?????? goto exit; ? } ? //release source frames ? ret = return_buffers(&usr_videoenc); ? if (ret < 0) { ?????? printf(\u201creturn_buffers fail\\n\u201d); ?????? goto exit; ? } exit: ? //close modules, release resources and exit hdal ? ret = hd_videoenc_close(usr_videoenc.videoenc_path_id); ? if (ret != HD_OK) { ?????? printf(\u201chd_videoenc_close fail\\n\u201d); ?????? return -1; ? } ? ret = hd_videoenc_uninit(); ? if (ret != HD_OK) { ?????? printf(\u201chd_videoenc_uninit fail\\n\u201d); ?????? return -1; ? } ? ret = hd_common_uninit(); ? if (ret != HD_OK) { ?????? printf(\u201chd_common_uninit fail\\n\u201d); ?????? return -1; ? } ? if (usr_videoenc.mem_fd != -1) { ?????? close(usr_videoenc.mem_fd); ? } ? return 0;","title":"4.2 user_videoenc"},{"location":"Novatek%2BHDAL%2BDesign%2BSpecification%2B-%2Bhd_videoenc.html#5-faq-nt9668x-nt9852x-nt9856x-nt98530","text":"What is the differnece from HD_VIDEOENC_PARAM_PATH_CONFIG.max_mem and HD_VIDEOENC_PARAM_OUT_ENC_PARAM? Answer: n HD_VIDEOENC_PARAM_PATH_CONFIG.max_mem sets \u201cMaximum requirement\u201d, while HD_VIDEOENC_PARAM_OUT_ENC_PARAM sets current encode settings. n For example, you may set PATH_CONFIG.max_mem.max_dim as 1920x1080. Then you can set HD_VIDEOENC_IN.dim as any resolution smaller than 1920x1080. n Another example, you may set PATH_CONFIG.max_mem.ltr as TRUE. Then you can set HD_VIDEOENC_PARAM_OUT_ENC_PARAM.h26x.ltr_interval > 0 to enable LTR, or, you can set ltr_interval = 0 to disable LTR. n But if you set PATH_CONFIG.max_mem.ltr as FALSE, then you can only set HD_VIDEOEC_PARAM_0UT_ENC_PARAM.h26x.ltr_interval = 0. n PATH_CONFIG set maximum requirement, if you don\u2019t need certain function, you should not set the function as TRUE because this will alloc extra memory. 2 svc_layer, ltr, source_output => each of those function will alloc extra YUV420 buffer to support function. What control flow should I apply for each param for hd_videoenc_set()? n stop -> close -> open -> set -> start 2 HD_VIDEOENC_PARAM_PATH_CONFIG O because this will involve memory re-alloc. n stop -> set -> start 2 HD_VIDEOENC_PARAM_IN O If videoproc is binding to videoenc, and videoproc.out setting=0 (auto sync videoenc settings), you have to call videoproc_start to sync videoenc new settings. 2 HD_VIDEOENC_PARAM_OUT_ENC_PARAM 2 HD_VIDEOENC_PARAM_OUT_VUI 2 HD_VIDEOENC_PARAM_OUT_DEBLOCK 2 HD_VIDEOENC_PARAM_IN_FRC O If change between (dst <= src) and (dst > src)? (both direction) O If change between (dst > src) and (dst > src) n set -> start 2 HD_VIDEOENC_PARAM_OUT_RATE_CONTROL 2 HD_VIDEOENC_PARAM_OUT_USR_QP 2 HD_VIDEOENC_PARAM_OUT_SLICE_SPLIT 2 HD_VIDEOENC_PARAM_OUT_ENC_GDR 2 HD_VIDEOENC_PARAM_OUT_ROI 2 HD_VIDEOENC_PARAM_OUT_ROW_RC 2 HD_VIDEOENC_PARAM_OUT_AQ 2 HD_VIDEOENC_PARAM_OUT_REQUEST_IFRAME 2 HD_VIDEOENC_PARAM_OUT_TRIG_SNAPSHOT 2 HD_VIDEOENC_PARAM_IN_FRC O If change between (dst <= src) and (dst <= src) Is there anything I should take care for codec JPG with HD_VIDEOENC_PARAM_IN.dir rotate90/270? n Yes : because JPG rotate depends on gximage library 2 You have to alloc extra YUV buffer. On the other word, hd_common_mem_init() for YUV buffer, set blk_cnt from 3 to 4 2 Also, the YUV buffer width/height MUST be ALIGN_CEIL_16. Calling hd_videoenc_open() failed with return value HD_ERR_IO, what does it mean? n It means that user is accessing invalid HD_IN_ID or HD_OUT_ID. It possibly occurs due to configuration for maxpath in dts file is smaller than needed path. n For example, in dts file, user set vdoenc_maxpath = 4, but calling hd_videoenc_open(HD_VIDEOENC_0_IN_4, \u2026 ) is invalid !! => because dts max_path = 4, but attempt to open path 5 => if user really need to open path 5, user have to modify dts file for vdoenc_maxpath = 5 Can an osd image shared between videoprocess, videoenc and videoout? n Yes : Just set the same p_addr value of HD_OSG_STAMP_BUF to videoprocess, videoenc and videoout pathid. n Subsequent upate through any pathid with automatically reflect on other pathid Why an osd/mask disappear without error or warning message? n In any macro block, only an osd will be rendered in a layer. n Since there are only two layers, this means at most two images can be rendered in a macro block n In h264, a macro block is 16x16 n In h265, a macro block is 64x64 n Osd on layer 0 will be rendered above layer 1 Any constrain on osd image and buffer? n Width of an image is best to be 4 aligned n Height of an image is best to be 2 aligned n Buffer address is best to be 128 aligned Ex stamp and mask consume much system resource. Any advice on the number? n It\u2019s hard to say. System with heavy loading has less margin for ex stamp and mask n For a 30fps system, 4 ex stamps or 4 ex masks are safe How to set alpha for an osd image n This is conditional to image formats n Alpha of argb4444 is completely determined by pixel\u2019s 4-bits alpha value n Alpha of argb1555 is determined by pixel\u2019s 1-bit alpha value and the alpha field of HD_OSG_STAMP_ATTR. If pixel\u2019s alpha value is 0, bits 3 ~ bits 0 of HD_OSG_STAMP_ATTR\u2019s alpha field determines transparency. If pixel\u2019s alpha value is 1, bits 7 ~ bits 4 of HD_OSG_STAMP_ATTR\u2019s alpha field determines transparency n Alpha of rgb565 is completely determined by the alpha field of HD_OSG_STAMP_ATTR. If an osd is configured with ping pong buffer. Is it possible to directly draw the free buffer? n Yes n Use HD_VIDEOENC_PARAM_IN_STAMP_IMG to get the physical address of the free buffer n Draw this free buffer n Apply the drawing by set HD_VIDEOENC_PARAM_IN_STAMP_IMG. The p_addr field of HD_OSG_STAMP_IMG should be the same physical address. I set vdoenc_maxpath = 17 in dtsi, why show warning message \u201cdts max_path=17 is larger than built-in max_path=16\u201d? n VDOENC_MAX_PATH_NUM is defined as 16 in isf_vdoenc, which means video encode path maximum is 16. Please set vdoenc_maxpath <= 16 in dtsi. OSG nvt-mem-tbl.dtsi n In nvt-mem-tbl.dtsi of cfg_model, stamp_maximg, vdoenc_maxstamp and vdoenc_maxmask determine osd numbers. ???? \\configs\\Linux\\cfg_xxx\\nvt-mem-tbl.dtsi ???? hdal-maxpath-cfg { stamp_maximg???? = <16>; ???????? vdoenc_maxstamp? = <32 16>; ???????? vdoenc_maxmask?? = <0? 64>; n stamp_maximg is the max number of stamps across videoprocess, videoencoder and videoout. 16 means vproc, venc and vout can create up to 16 stamps. There is no limit on this number. n vdoenc_maxstamp is the max number of stamps on videoenc. The left number is for built-in stamp and the right number is for ext stamp. Max left number is 32 and max right number is 16 n vdoenc_maxmask is the max number of masks on videoenc. The left number is for built-in mask and the right number is for ext mask. Since videoenc has no built-in osd, the left number is always 0. Max right number is 64 To update an existing OSG, simply set image. No need to start OSG, stop OGG or reset buffer. If a buffer is shared among many OSG, updating through any of OSG also refreshes other OSG. No need to update every OSG with the same share buffer. To setup a new buffer on OSG with shared buffer, all OSG with this shared buffer should be stopped and closed.","title":"5 FAQ (NT9668X / NT9852X / NT9856X / NT98530)"}]}