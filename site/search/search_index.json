{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"NT98336/NT98633 Documents","title":"Home"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html","text":"1 Introduction \u00b6 This document describes the overview of the NT9833x DVR/NVR SDK. It introduces the software/hardware requirements, step-by-step instructions to setup the development environment and how to build and run the image. Chapter 4 introduces the boot up sequence. Chapter 5 introduces the concept of HDAL APIs and gives several sample codes to explain these APIs usage. 2 Environment Overview \u00b6 2.1 General Description \u00b6 This SDK will use Linux OS as development environment. To install Ubuntu OS, please refer NT9833x_SDK_Pure_Linux_Programming_Guide_en.pdf . After Linux OS installed, unpack SDK package under Linux, then you can build your DVR/NVR firmware. When your Firmware is ready, connect EVB to PC, and upgrade it to EVB. 2.2 SDK Package \u00b6 Using the following instructions to decompress SDK package under Linux: \\$ tar -jxvf NT9833x_SDK_release_{VERSION}.tar.bz2 You will get the folder tree as below: \u251c\u2500\u2500 hardware hardware document folder \u251c\u2500\u2500 board \u251c\u2500\u2500 document HW application note, and PCB/EVB document \u251c\u2500\u2500 chip \u251c\u2500\u2500 document chip datasheet \u251c\u2500\u2500 software software folder \u251c\u2500\u2500 board Linux SDK package and loader \u251c\u2500\u2500 document Linux and HDAL library document \u251c\u2500\u2500 chip \u251c\u2500\u2500 document chip document \u251c\u2500\u2500 pc PC upgrade, display and IQ tools. \u251c\u2500\u2500 document PC tool document \u251c\u2500\u2500Disclaimer.pdf Disclaimer document 2.3 System Board Connection \u00b6 1. 12V input 2. eth1 3. Top: eth0; middle: Not use; bottom: USB 2.0 4. USB 3.0 5. VGA output 6. HDMI output 7. USB 2.0 8. UART console 9. Boot sequence switch To update FW on the system board, please follow the following steps. 1. Connect UART console port to PC. 2. Connect 12V to power connector. 3. Connect the bottom USB port to PC. 4. Set J20 to 0, J21 to 1 and J22 to 0 to enter UART FW upgrade mode. And set J20 to 0, J21 to 0 and J22 to 1 to boot from NAND flash. 5. Connect HDMI output to your display device. Please refer to NT9833x_Quick_Bringup_User_Guide_en.pdf for detail information about the FW update. 2.3.1 98633 EVB \u00b6 The 98633 board is different from the 98336 board, please refer to the below figure or refer to NT98633_NVR_EVB_User Guide_V1.0.pdf to setup the hardware environment. 3 Environment Setup \u00b6 3.1 Cross Compiler Setup \u00b6 Toolchain: \uf06c glib: aarch64-ca53-linux-gnueabihf-8.4 Please install the toolchain as following command \\$ sudo tar \u2013jxvf aarch64-ca53-linux-gnueabihf-8.4.tar.bz2 -C /opt If you want to change path, please modify the CROSS_TOOLCHAIN_PATH parameter in the build/envsetup.sh . 3.2 SDK Setup \u00b6 Using the following instructions to decompress SDK pack under Linux. \\$tar \u2013jxvf na51090_linux_sdk.tar.bz2 You will get the folder tree as below: \u251c\u2500\u2500na51090_linux_sdk\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..Used to put unpacked SDK source code, \u251c\u2500\u2500 BSP \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026Include linux, busybox, uboot and rootfs source \u251c\u2500\u2500 build \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..scripts for the environment setup \u251c\u2500\u2500 code \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026HDAL linux drivers and sample code \u251c\u2500\u2500 configs\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026Model settings \u251c\u2500\u2500 Makefile\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026Top level Makefile \u251c\u2500\u2500 tools\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.target board tool Before each opened a new Terminal window needs to compiler environment setting, the relevant variables set up, please follow the below instructions to finish it, \\$ cd na51090_linux_sdk \\$ source build/envsetup.sh Please do a complete compilation for first time. Select your model: \\$lunch List your nvt build setting \\$get_stuff_forenvironment Build overall system: \\$make all 3.3 Build Image \u00b6 After the \u201cmake all\u201d command. It will generate the images under \u201cna51090_linux_sdk/output\u201d folder. The details are listed as below: \u251c\u2500\u2500 na51090_linux_sdk/\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 Put unpacked source code and image \u251c\u2500\u2500 Makefile\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. Top level Makefile \u251c\u2500\u2500 output/\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.. Compiled output image \u251c\u2500\u2500 packed/ \u251c\u2500\u2500 FW98336A.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026 nvtpack image (All-in-one image) \u251c\u2500\u2500 preburn_image/ \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026 the pre-burn images, you can copy these files into \\DFUTools\\image, and burn into the system board via DFU tool. \u251c\u2500\u2500 raw/ \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. raw format of the output image \u251c\u2500\u2500 Image.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.. Linux Image \u251c\u2500\u2500 u-boot.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 uboot image with nvt checksum \u251c\u2500\u2500 u-boot.lz.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 uboot image (LZ compressed) \u251c\u2500\u2500 u-boot.lzma.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 uboot image (LZMA compressed) \u251c\u2500\u2500 rootfs.ramdisk.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. ramdisk image (rootfs) \u251c\u2500\u2500 rootfs_1.rw.ubifs.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026. rootfs overlay \u251c\u2500\u2500 DVRxxxxxxx.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 mnt\\mtd partition \u251c\u2500\u2500 nvt-all.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. linux kernel fdt \u251c\u2500\u2500 atf.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..\u2026\u2026\u2026\u2026. arm-trusted-\u200bfirmware \u251c\u2500\u2500 FW98336A.ini\u2026\u2026\u2026\u2026\u2026..\u2026\u2026\u2026\u2026. the layout to pack to FW98336A.bin The na51090_linux_sdk folder has a top level Makefile , it supports many of the make command, such as \u201c make linux \u201d is to compile linux-kernel, \u201c make uboot \u201d can compile u-boot, \u201c make rootfs \u201d\u2026you can use \u201c make help \u201d to find what its commands are support. Please use top level Makefile to do SDK compilation to avoid some link error occurred . Its help description is as follows: \\$ make help make help -> show make command info make all -> build all make linux -> build linux-kernel make linuxram -> build linux-kernel with ramdisk support make modules -> build built-in kernel modules make driver -> build NVT linux driver modules make atf -> build ARM trusted firmware make uboot -> build loader(uboot) make optee_os -> build OPTEE kernel make optee_client -> build OPTEE client make library -> build library make busybox -> build busybox make rootfs -> build rootfs make app -> build applications make tools -> build tools make sample -> build sample code make post -> run postprocessing script make pack -> Generate nvtpack image and preburn images make publish -> remove some sources for publish ===================================================== make linux_config -> config linux-kernel make linux_config_gcov-> modify kernel config for code coverage tool make uboot_config -> config uboot make busybox_config -> config busybox make linux_header -> generate linux-kernel out of tree headers ===================================================== make clean -> clean all make linux_clean -> clean linux-kernel & built-in kernel modules make driver_clean -> clean NVT linux driver modules make atf_clean -> clean ARM trusted firmware make uboot_clean -> clean loader(uboot) make optee_os_clean -> clean optee kernel make optee_client_clean -> clean optee client application make library_clean -> clean library make busybox_clean -> clean busybox make rootfs_clean -> clean rootfs make app_clean -> clean applications make tools_clean -> clean tools make sample_clean -> clean sample code make post_clean -> run postprocessing clean script make pack_clean -> Remove nvtpack image ===================================================== 3.4 Run the First Sample \u00b6 After \u201c make all \u201d, you can get the images in \u201cna51090_linux_sdk/output\u201d . And to try the images, you can select the jumper setting in EVB to enter FW upgrade mode first, and then use the following tool \u201c FwUpgrade.exe \u201d to burn the images into the flash memory. The all-in-one image (\\na51090_linux_sdk\\output\\packed\\FW98336A.bin) is packed by the description in \\na51090_linux_sdk\\configs\\Linux\\cfg_XXX\\nvt-nvtpack.dtsi: /* * Novatek Ltd. BSP part of dts */ \\&nand { /** * partition_name is \\$1 as in partition_\\$1 is referred * to nvt-na51090-storage-partition. dtsi */ nvtpack { ver = \u201cNVTPACK_FW_INI_16072017\u201d; /* Fixed */ method = \\<1>; /* Fixed */ index { id0 { partition_name = \u201cloader\u201d; source_file = \u201c\u201d; }; /* Fixed */ id1 { partition_name = \u201cfdt\u201d; source_file = \u201cnvt-all.bin\u201d; }; /* Fixed */ id2 { partition_name = \u201cfdt.restore\u201d; source_file = \u201c\u201d; }; /* Fixed */ id3 { partition_name = \u201catf\u201d; source_file = \u201catf.bin\u201d; }; id4 { partition_name = \u201cuboot\u201d; source_file = \u201cu-boot.bin\u201d; }; id5 { partition_name = \u201cuenv\u201d; source_file = \u201c\u201d; }; id6 { partition_name = \u201ckernel\u201d; source_file = \u201cImage.bin\u201d; }; id7 { partition_name = \u201crootfs\u201d; source_file = \u201crootfs.ramdisk.bin\u201d; }; id8 { partition_name = \u201crootfs1\u201d; source_file = \u201crootfs_1.rw.ubifs.bin\u201d; }; id9 { partition_name = \u201capp\u201d; source_file = \u201cDVR_16CH.nand.ubifs.bin\u201d; }; }; }; }; And the partition order must be the same as \\na51090_linux_sdk\\configs\\Linux\\cfg_XXX\\nvt-storage-partition.dtsi. After the upgrade is done, power on the target board, you can get the sample in the \u201c /mnt/mtd \u201d folder. And you can run the first sample code: root@NVTEVM:/mnt/mtd\\$ ./liveview_1div_to_4div Note: You may run the \u201cdisplay_with_change_mode\u201d first to select your LCD resolution. The more sample codes are placed in \u201c na51090_linux_sdk/code/hdal/samples \u201d. For more information about the firmware upgrade tool, you can refer to the document \u201c NT9833x_Quick_Bringup_User_Guide_en.pdf \u201d. 4 Boot-up Sequence \u00b6 4.1 Overview of Booting Procedure \u00b6 The following figure shows the booting sequence of NT9833x SDK. When the NT9833x system is powered on, the embedded ROM code is executed. The ROM code loads the loader code from the flash into the embedded SRAM and then executes the loader. The loader initializes DDR and loads FDT, ATF, OPTEE(optional) and uboot from the flash into DDR and jump into ATF. The ATF runs the arm trusted firmware and boot OPTEE(optional) and then jump into the uboot. The uboot initializes the basic hardware and loads linux image from the flash into DDR, and then bring up the linux kernel. Two stages during the linux bring up: the vg_boot.sh add the device modules into the linux kernel and the module_init initiates the external devices, such as AD, audio and the displayer. 4.2 vg_boot.sh \u00b6 The script file \u201cvg_boot.sh\u201d: #boot_ver=v1.5 #chipver=`head -1 /proc/pmu/chipver` #chipid=`echo \\$chipver | cut -c 1-4` echo ----------------------------------------------------------- echo \u201d Boot DVR_16CH\u201d echo ----------------------------------------------------------- echo \u201c/sbin/mdev\u201d > /proc/sys/kernel/hotplug MODEL_PATH=\\$(dirname \\$MODEL) MODEL_NAME=\u201d\\${MODEL_PATH##*/}\u201d AD_MODULE=\u201dtechpoint\u201d echo This model is \\$MODEL_NAME modprobe nvt_dmasys modprobe log log_ksize=4096 crash_notify=/mnt/mtd/crash.sh #crash to execute /mnt/mtd/crash.sh echo /tmp > /proc/videograph/dumplog #change log path to /tmp modprobe kdrv_cc_event modprobe ms max_channels=16 modprobe em max_channels=16 modprobe lcd_codec modprobe nvt_tve100 modprobe nvt_hdmi20 modprobe flcd300-common modprobe flcd300-pip gui_ddr=0 suspend_state=1 modprobe flcd300-pip1 gui_ddr=0 suspend_state=1 modprobe flcd200-common modprobe flcd200-pip gui_ddr=0 suspend_state=1 echo i2c 0x10011 > /proc/nvt_info/nvt_pinmux/pinmux_set ## [NT98336 SYS] 16CH, camera support to 1080P@30, 4M@15, 5M@10 #if [ \u201c\\$AD_MODULE\u201d == \u201ctechpoint\u201d ]; then ## modprobe tp28xx_kdrv drv_mode=0 dev_num=2 ibus=0,1 iaddr=0x88,0x8a vout_mode=3,3 video_mux=1 vout_xcap=0x03040000,0x01020000 vout_vi=0x03040000,0x01020000 clk_dly=0x00000000,0x00000000 clk_inv=0x01010000,0x01010000 ch_map=2 clk_used=0x1 rstb_used=106 clk_driving=2 #else ## modprobe nvp6158_kdrv drv_mode=0 dev_num=2 ibus=0,0 iaddr=0x60,0x62 vout_mode=4,4 vout_xcap=0x0201,0x0403 vout_vi=0x0201,0x0403 vout_cdly=0x0606,0x0606 clk_dly=0x0000,0x0000 clk_inv=0x0000,0x0000 ch_map=1 clk_used=0x1 rstb_used=106 clk_driving=2 #fi modprobe tp28xx_kdrv dev_num=4 ibus=0,0,1,1 iaddr=0x88,0x8a,0x8c,0x8e vout_mode=3,3,3,3 video_mux=1 vout_xcap=0x0201,0x0304,0x0506,0x0708 vout_vi=0x0201,0x0304,0x0506,0x0708 vout_cdly=0x0300,0x0300,0x0300,0x0200 ch_map=1 clk_used=0xf clk_driving=2 modprobe vcap316_common modprobe vcap316_host0 sync_time_div=90 modprobe kdrv_vpe modprobe kflow_vpe mod_init=1 max_chip_num=1 max_eng_num=2 max_minor_num=127 max_md_lv_num=16 max_total_cam_ch=85 sw_bal_mode=1 modprobe nvt_audio modprobe kflow_audio modprobe kdrv_dei modprobe kflow_dei max_chip_num=2 max_eng_num=1 max_minor_num=64 max_total_cam_ch=85 modprobe kdrv_jpg jpeg_enc_max_chn=53 jpeg_dec_max_chn=32 modprobe kdrv_venc h26x_enc_max_width=2560 h26x_enc_max_height=1440 max_total_cam_ch=53 modprobe nvt_vencrc modprobe kflow_videoenc modprobe h26xdec h26xd_max_width=2560 h26xd_max_height=1440 max_total_cam_ch=32 modprobe kflow_videodec modprobe kdrv_osg modprobe kflow_osg modprobe kdrv_ssca modprobe kdrv_age modprobe kflow_gfx modprobe kdrv_ai modprobe kflow_cnn modprobe kflow_nue modprobe kflow_nue2 modprobe kflow_cpu modprobe kflow_dsp modprobe kflow_ai_net modprobe gs max_channels=16 modprobe usr_proc modprobe vpd quiet=0 max_channels=16 modprobe ddr_arb echo doing mdev-s mdev -s echo done!! ## Syntax: module_init [dtb_file] [is_dump_dts] [is_init_videocap] [is_init_videoout] [is_init_audio] [is_show_logo] if [ \u201c\\$AD_MODULE\u201d == \u201ctechpoint\u201d ]; then /mnt/mtd/module_init /mnt/mtd/cfg_DVR_16CH.dtb 0 1 1 1 0 & else /mnt/mtd/module_init /mnt/mtd/cfg_DVR_16CH.dtb 0 2 1 1 0 & fi The vg_boot.sh insert the device modules into the linux kernel and finally run the module_init program to initiate the video input/output. For more information about the parameters of the device module, please refer to NT9833x_Module_Parameters_en.pdf . 4.3 module_init.c \u00b6 The main functions of module_init.c are the buffer management and the external devices handling. The following figure shows the program flow of module_init.c . 4.3.1 Memory Pool Setup \u00b6 9833x system memory placement descripts in the file nvt-mem-tbl.dtsi : /* Linux system memory region*/ memory { device_type = \u201cmemory\u201d; reg = \\<0x0 0x00000000 0x0 0x2FD00000>; /* [addr-H] [addr-L] [size-H] [size-L] */ }; hdal-memory { #address-cells = \\<4>; #size-cells = \\<2>; media { reg = \\< 0x0 0x0 0x0 0x2FD00000 0x0 0x10300000 /* DDR ID H, L ADDR H, L, SIZE H, L */ 0x0 0x1 0x1 0x00000000 0x0 0x40000000 /* DDR ID H, L ADDR H, L, SIZE H, L */ >; }; }; /* To config the nvt chip mapping relationship */ nvt_chip_mapping { #address-cells = \\<4>; #size-cells = \\<2>; dram_map { reg = \\< 0x0 0x0 0x0 0x00000000 0x0 0x40000000 /* DDR ID, CHIPID, ADDR H, L, SIZE H, L */ 0x1 0x0 0x1 0x00000000 0x0 0x40000000 /* DDR ID, CHIPID, ADDR H, L, SIZE H, L */ >; }; }; And about the memory pool placement in HDAL, you can use DVR_XXX.xls to calculate the pool size, and then copy the results into the cfg_DVR_XXX.dts . The HDAL memory is used in the HDAL and the module drivers. The following figure shows three scenarios for using the HDAL memory. The assign_pool_addr() in module_init.c will assign the physical address to each pool, and the memory placement will be as: 4.3.2 Video Output Setup \u00b6 The videoout0_setup() , videoout1_setup() and videoout2_setup() setup the video output for HDMI/VGA/CVBS: 1. hd_videoout_set(, HD_VIDEOOUT_PARAM_DEV_CONFIG, ) to setup the control parameters, such as the width, the height, the buffer address of the video plane and the GUI plane. 2. hd_videoout_set(, HD_VIDEOOUT_PARAM_FB_FMT,) to set the video format of the frame buffer of the plane. 3. hd_videoout_set(, HD_VIDEOOUT_PARAM_FB_ENABLE, ) to enable the plane. To set the video output for the same and different source, you can modify the mode and the homology parameters in the file cfg_DVR_XXX.dts . HDMI and VGA are from the same source. HDMI and VGA are from the different source. videoout0 {/*lcd300*/ mode = \u201cHD_COMMON_VIDEO_OUT_HDMI\u201d, \u2026 homology = \u201cHD_COMMON_VIDEO_OUT_VGA\u201d; \u2026 } videoout0 {/*lcd300*/ mode = \u201cHD_COMMON_VIDEO_OUT_HDMI\u201d, \u2026 homology = \u201c\u201d; \u2026 } videoout1 {/*lcd300 lite*/ mode = \u201cHD_COMMON_VIDEO_OUT_VGA\u201d, \u2026 homology = \u201c\u201d; \u2026 } 4.3.3 Video Input Setup \u00b6 The main procedure of the videocap_module_init_tp()/videocap_module_init_nvp() are as the following: 1. Initiate the AD device. For example, open \u201c/dev/tp2823dev\u201d device node. ret = vendor_ad_init(ad_dev_name); if (ret != HD_OK) goto exit; 2. Get the AD information, and organize this information as host, vi and channel information, and set them to the capture. ret = vendor_ad_get(VENDOR_AD_PARAM_TP28XX_DEVICE_INFO, \\&dev_info); \u2026 /* vcap host init, to specify vcap system vi usage and prepare requirement memory */ memset(&vcap_host, 0, sizeof(vcap_host)); vcap_host.host = 0;//only support 0 vcap_host.md.enable = dt_hdal_spec.vcap_host.md.enable; vcap_host.md.mb_x_num_max = dt_hdal_spec.vcap_host.md.mb_x_num_max; vcap_host.md.mb_y_num_max = dt_hdal_spec.vcap_host.md.mb_y_num_max; vcap_host.md.buf_src = dt_hdal_spec.vcap_host.md.buf_src; for (i = 0; i\\< dev_info.dev_num; i++) { for(j = 0; j\\< VENDOR_AD_TP28XX_VOUT_MAX; j++) { \u2026 vcap_host.vi[vcap_host.nr_of_vi].chip = VENDOR_AD_PLAT_VI_TO_CHIP_ID(dev_info.dev[i].vout[j].vi - 1); vcap_host.vi[vcap_host.nr_of_vi].vcap = VENDOR_AD_PLAT_VI_TO_CHIP_VCAP_ID(dev_info.dev[i].vout[j].vi - 1); vcap_host.vi[vcap_host.nr_of_vi].vi = VENDOR_AD_PLAT_VI_TO_VCAP_VI_ID(dev_info.dev[i].vout[j].vi - 1); \u2026 } } \u2026 ret = hd_videocap_drv_set(HD_VIDEOCAP_DRV_PARAM_INIT_HOST, \\&vcap_host); \u2026 /* VCAP VI Register */ for (i=0; i\\<dev_info.dev_num; i++) { for (j=0; j\\<VENDOR_AD_TP28XX_CHANNELS_PER_CHIP; j++) { \u2026 memset(&vcap_vi, 0, sizeof(vcap_vi)); vcap_vi.chip = VENDOR_AD_PLAT_VI_TO_CHIP_ID(dev_info.dev[i].vout[j].vi - 1); vcap_vi.vcap = VENDOR_AD_PLAT_VI_TO_CHIP_VCAP_ID(dev_info.dev[i].vout[j].vi - 1); vcap_vi.vi = VENDOR_AD_PLAT_VI_TO_VCAP_VI_ID(dev_info.dev[i].vout[j].vi - 1); vcap_vi.global.src = dev_info.dev[i].vout[j].xcap - 1; vcap_vi.global.format = HD_VIDEOCAP_VI_FMT_BT656; vcap_vi.global.id_extract = HD_VIDEOCAP_VI_CHID_EAV_SAV; \u2026 ret = hd_videocap_drv_set(HD_VIDEOCAP_DRV_PARAM_REGISTER_VI, \\&vcap_vi); } } \u2026 /* VCH ID */ for (i=0; i\\<dev_info.dev_num; i++) { for (j=0; j\\<VENDOR_AD_TP28XX_CHANNELS_PER_CHIP; j++) { \u2026 memset(&ch_param, 0, sizeof(ch_param)); ch_param.chip = dev_info.dev[i].vin[j].chip; ch_param.vcap = dev_info.dev[i].vin[j].vcap; ch_param.vi = dev_info.dev[i].vin[j].vi; ch_param.ch = dev_info.dev[i].vin[j].ch; ch_param.value = dev_info.dev[i].vin[j].vch_id; ch_param.pid = HD_VIDEOCAP_VI_CH_PARAM_VCH_ID; \u2026 ret = hd_videocap_drv_set(HD_VIDEOCAP_DRV_PARAM_VI_CH_PARAM, \\&ch_param); } } 3. Polling and notify the channel video norm switch. ret = vendor_ad_get(VENDOR_AD_PARAM_TP28XX_VIDEO_NORM, \\&video_norm); \u2026 /* check video norm */ if (memcmp(&video_norm, \\&p_init_info->g_ch_norm[i][j], sizeof(video_norm)) == 0) goto chk_loss; ch_norm.chip = dev_info.dev[i].vin[j].chip; ch_norm.vcap = dev_info.dev[i].vin[j].vcap; ch_norm.vi = dev_info.dev[i].vin[j].vi; \u2026 ret = hd_videocap_drv_set(HD_VIDEOCAP_DRV_PARAM_VI_CH_NORM3, \\&ch_norm); \u2026 memcpy(&p_init_info->g_ch_norm[i][j], \\&video_norm, sizeof(video_norm)); 4. Polling and notify the channel video loss. ret = vendor_ad_get(VENDOR_AD_PARAM_TP28XX_VIDEO_LOSS, \\&ch_loss); \u2026 /* check video loss */ if (ch_loss.is_lost == p_init_info->g_ch_loss[i][j]) continue; ch_param.chip = dev_info.dev[i].vin[j].chip; ch_param.vcap = dev_info.dev[i].vin[j].vcap; ch_param.vi = dev_info.dev[i].vin[j].vi; ch_param.pid = HD_VIDEOCAP_VI_CH_PARAM_VLOS; \u2026 ret = hd_videocap_drv_set(HD_VIDEOCAP_DRV_PARAM_VI_CH_PARAM, \\&ch_param); \u2026 p_init_info->g_ch_loss[i][j] = ch_loss.is_lost; 5 Hardware Device Abstraction Layer (HDAL) \u00b6 5.1 Concept \u00b6 HDAL is the acronym of Hardware Device Abstraction Layer. It replaces the part being occupied by HAL (Hardware Abstraction Layer) in existing SW Architecture for the device transparent from independent devices and platforms, including the product, IP Camera, DVR and NVR. For the existing HAL, it is created in the Chip-dependent structure, therefore when the chip is changed to Novatek or others, the APIs of HAL have to be changed depending on the change of chip at times. It is the object of HDAL to replace HAL and perform the function using Chip-independent Common API. Moreover, by providing only the header of HDAL API to chip venders and letting them implement the contents by themselves, the Middleware developers can implement this even though they are not aware of technological details. That is the HDAL is the common modules with common reused APIs, there is vendor interfaces for the customization for the dependent appliance, like AI or image quality modules. There are 2 types of modules, the streaming and utility modules. The streaming modules defined for audio input, video input, audio output, video output, audio encoder, video encoder, audio decoder, video decoder and video processing. The streaming module is the code to control the flow of video or audio content sent in compressed or raw form over the Internet or device. If the modules are not related with streaming, we called utility modules. That is to perform, like initialize the HDAL, graphics functions, debug functions and etc. Streaming modules: Module Function HD_VIDEOCAP As it is for the video input features, it performs the feature of informing the video input state information. HD_VIDEOOUT It performs the controlling related to Video output which is connected like to the Panel or HDMI and the Video Post controlling features HD_VIDEOENC It provides the APIs which can control the Video Encoder. HD_VIDEODEC It takes the charge of filtering the Video, Video Decoding and the feature of controlling video Decoder. HD_VIDEOPROC Being divided as the video processing feature separately, it is the API which sets the Resolution, Video Size and Video Position and performs the frame rate conversion feature. The main feature is video process controlling however, the features of which the video out are controlled separately should be performed by this instance. HD_AUDIOCAP As it is for the audio input features, it performs the feature of informing the audio input setting and state information. HD_AUDIOOUT It performs the auxiliary output features of Audio. The Audio auxiliary output refers like to Analog Audio output and HDMI digital output. HD_AUDIOENC It provides the APIs which can control the Audio Encoder. HD_AUDIODEC It takes the charge of Audio Decoding and the feature of controlling Audio Decoder flow and format. Utility modules: Module Function hd_gfx In charge of functions related to Graphic plane. hd_debug In charge of debug function, like HDAL Debug Menu entry point. hd_logger Directive printf function to difference interfaces. hd_util Supplies utility function which could be used in HDAL such as key input, Print etc. Basic APIs: API name Description hd_xxx_init() Responsible for initializing the class, especially for the global setting. Generally it is Called only once at system initialization, or when memory state changes. hd_xxx_uninit() Responsible for un-initializing the global setting of the class. Generally it is Called only once at system un-initialization, or when memory state changes. hd_xxx_open() Responsible for opening an instance from the class. Generally it is Called after the class was initialized. The function is used to call for opening multiple instances. hd_xxx_close() Responsible for closing an instance of the class. Generally it is Called to close the instance setting. The instance will be removed after calling this function. hd_xxx_bind() Each Instance is called up when it is connected with fore-end or back-end of Instance. Generally, relevant Instance ID and front terminal Instance ID are used for input parameter, but for some instances, additional input parameter is needed. Call for hd_xxx_bind() function is only valid under Disconnect status and if tried to Connect to change connection status without disconnecting at Bind status, Error will occur. hd_xxx_unbind() It is called up when unbind is required after each instance is connected. Since only the concerned instance\u2019s ID will be given as parameter, the hd_xxx_unbind() disconnects the front and back connection as referring to the concerned Instance\u2019s ID. hd_xxx_get() It is used upon taking the information of each Instance\u2019s settings. This API is used when taking the previous setting information before calling up the hd_xxx_set() and then changing only the settings value to be changed. The using method will be displayed along with the hd_xxx_set() example. hd_xxx_set() It is used upon setting the information for each instance settings. There is the structure for the instance-wise setting information, in order to change the setting information, call the hd_xxx_get() to get the structure for the previous setting information and then change only the value which is wished to be changed and then call up the hd_xxx_set(). If the hd_xxx_get() is called up after calling up hd_xxx_init(), the settings value will be all entered in to the HD_INVALID. If the setting variable in the implementation part of the hd_xxx_set() is HD_INVALID, it should be implemented not to set the variable but to skip it. For more information, please refer to the document \u201c Novatek HDAL Programmer\u2019s Guide.pdf \u201d. 5.2 Sample Codes \u00b6 5.2.1 Encode \u00b6 I. encode_with_nr.c Stream Flow: root@NVTEVM:\\~\\$ cat /proc/videograph/graph entity (jobs) pool name (done buffers/max buffers) ----------------------------------------------------------- vcap0_0_4_0 (4) (enc_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->*kflow_osg_0_0_10 (0) (enc_cap_out_ddr0, \u2013, \u2013, \u2013) (0/0) ->h26xenc_0_0_0 (0) (enc_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->dataout_0_0_0 (0) Sample code flow: 1. Initiate the HDAL. ret = hd_common_init(1); //the parameter is reserved for the future. 2. Initiate the capture and the encoder modules. if ((ret = hd_videocap_init()) != HD_OK) { return ret; } if ((ret = hd_videoenc_init()) != HD_OK) { return ret; } 3. Open the capture and the encoder modules. if ((ret = hd_videocap_open(SAMPLE_VCAP_IN_ID, SAMPLE_VCAP_OUT_ID, \\&p_streams->cap0_path_id)) != HD_OK) { return ret; } if ((ret = hd_videoenc_open(SAMPLE_VENC_IN_ID, SAMPLE_VENC_OUT_ID, \\&p_streams->enc0_path_id)) != HD_OK) { return ret; } 4. Initiate the video process, such as Noise Reduction. ret = vendor_video_init(streams.videoenc_path); if (ret != HD_OK) { goto exit; } 5. Set the capture configure and parameters. The data_pool (the buffer name is enc_cap_out_ddr0) is allocated from the HD_COMMON_MEM_ENC_CAP_OUT_POOL, the buffer size of the capture output is fixed and the counts/max_counts should not be larger than \u201cYUV buffer count\u201d in the \u201cencode\u201d sheet of DVR_xch.xls. Only one data_pool is valid for the capture, so data_pool[1\\~3].mode must set to disable. //use HD_VIDEOCAP_PARAM_PATH_CONFIG to set the memory pool configure. cap_config.data_pool[0].mode = HD_VIDEOCAP_POOL_ENABLE; cap_config.data_pool[0].ddr_id = SAMPLE_VCAP_DDR_ID; cap_config.data_pool[0].counts = HD_VIDEOCAP_SET_COUNT(4, 0); cap_config.data_pool[0].max_counts = HD_VIDEOCAP_SET_COUNT(4, 0); cap_config.data_pool[1].mode = HD_VIDEOCAP_POOL_DISABLE; cap_config.data_pool[2].mode = HD_VIDEOCAP_POOL_DISABLE; cap_config.data_pool[3].mode = HD_VIDEOCAP_POOL_DISABLE; ret = hd_videocap_set(cap_path_id, HD_VIDEOCAP_PARAM_PATH_CONFIG, \\&cap_config); //use HD_VIDEOCAP_PARAM_OUT to set the output dimension and the pixel format. ret = hd_videocap_set(cap_path_id, HD_VIDEOCAP_PARAM_OUT, \\&cap_out); 6. Set the encoder configure and parameters. The data_pool (the buffer name is enc_out_ddr0) is allocated from the HD_COMMON_MEM_ENC_OUT_POOL. And only one data_pool is valid for the encoder, so data_pool[1\\~3].mode must set to disable. //use HD_VIDEOENC_PARAM_PATH_CONFIG to set the memory pool configure. enc_config.data_pool[0].mode = HD_VIDEOENC_POOL_ENABLE; enc_config.data_pool[0].ddr_id = 0; enc_config.data_pool[0].counts = HD_VIDEOENC_SET_COUNT(4, 0); enc_config.data_pool[0].max_counts = HD_VIDEOENC_SET_COUNT(4, 0); enc_config.data_pool[1].mode = HD_VIDEOENC_POOL_DISABLE; enc_config.data_pool[2].mode = HD_VIDEOENC_POOL_DISABLE; enc_config.data_pool[3].mode = HD_VIDEOENC_POOL_DISABLE; ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_PATH_CONFIG, \\&enc_config); //use HD_VIDEOENC_PARAM_IN to set the input dimension and the pixel format. ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_IN, \\&video_in_param); //use HD_VIDEOENC_PARAM_OUT_ENC_PARAM to set the parameters of the codec. ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_OUT_ENC_PARAM, \\&enc_param); //use HD_VIDEOENC_PARAM_OUT_RATE_CONTROL to set the parameters of the rate control. ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_OUT_RATE_CONTROL, \\&rc_param); 7. Bind the capture and the encoder modules, and then the stream will flow from the capture to the encoder. ret = hd_videocap_bind(SAMPLE_VCAP_OUT_ID, SAMPLE_VENC_IN_ID); if (ret != HD_OK) { printf(\u201cvideocap bind fail\\n\u201d); goto exit; } 8. Start the capture and the encoder modules. ret = hd_videocap_start(streams.cap0_path_id); if (ret != HD_OK) { printf(\u201cstart cap fail\\n\u201d); goto exit; } ret = hd_videoenc_start(streams.enc0_path_id); if (ret != HD_OK) { printf(\u201cstart enc fail\\n\u201d); goto exit; } 9. Create a thread to encode the stream from the capture. The main procedure in this thread is using the hd_videoenc_poll_list() API to check the stream is ready or not. If the stream is ready, use hd_videoenc_recv_list() API to receive it. static void *encode_thread(void *arg) { \u2026 while (0 == p_streams->enc_exit) { ret = hd_videoenc_poll_list(poll_list, MAX_BITSTREAM_NUM, 500); \u2026 if ((ret = hd_videoenc_recv_list(recv_list, MAX_BITSTREAM_NUM)) \\< 0) { printf(\u201cError return value %d\\n\u201d, ret); } else { for (i = 0; i \\< MAX_BITSTREAM_NUM; i++) { //process the receive the encoded bitstreams } } } \u2026 } 10. Wait the key press \u2018q\u2019 to exit the thread. 11. Stop the capture and the encoder modules. if (HD_OK != hd_videocap_stop(streams.cap0_path_id)) { printf(\u201cstop cap fail\\n\u201d); } if (HD_OK != hd_videoenc_stop(streams.enc0_path_id)) { printf(\u201cstop enc fail\\n\u201d); } 12. Unbind the capture and the encoder modules. if (HD_OK != hd_videocap_unbind(SAMPLE_VCAP_OUT_ID)) { printf(\u201chd_videocap_unbind fail\\n\u201d); } 13. Close the capture and the encoder modules. if ((ret = hd_videocap_close(p_streams->cap0_path_id)) != HD_OK) { return ret; } if ((ret = hd_videoenc_close(p_streams->enc0_path_id)) != HD_OK) { return ret; } 14. Un-initiate the capture and the encoder modules. if ((ret = hd_videocap_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoenc_uninit()) != HD_OK) { return ret; } 15. Un-initiate the HDAL. ret = hd_common_uninit(); II. encode_with_osg.c Stream flow: root@NVTEVM:\\~\\$ cat /proc/videograph/graph entity (jobs) pool name (done buffers/max buffers) ----------------------------------------------------------- vcap0_0_4_0 (4) (enc_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->*kflow_osg_0_0_10 (0) (enc_cap_out_ddr0, \u2013, \u2013, \u2013) (0/0) ->h26xenc_0_0_0 (0) (enc_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->dataout_0_0_0 (1) root@NVTEVM:\\~\\$ cat /proc/hdal/flow \u2026 hd_videoenc_set(IN_STAMP_IMG): path_id(0x22008201) pxlfmt(0x21101555) dim(400,100) ddr(0) pa(0x1655a000) hd_videoenc_set(IN_STAMP_ATTR): path_id(0x22008201) type(0) alpha(7) pos(0,0) gcac_en(0) gcac_w(64) gcac_h(32) pa(0x1655a000) ddr(0) \u2026 The sample code flow is the same as the \u201c encode_with_nr.c \u201d, except for the additional function of OSG. 1. Open the OSG stamp module. if ((ret = hd_videoenc_open(HD_VIDEOENC_IN(SAMPLE_VENC_DEV_ID, HD_STAMP(i)), SAMPLE_VENC_OUT_ID, \\&p_streams->stamp_path_id[i])) != HD_OK) { return ret; } 2. Set the OSG parameters. //use HD_VIDEOENC_PARAM_IN_STAMP_IMG to set OSG image dimension and the pixel format. img.p_addr = p_stamp->pa; img.dim.w = p_stamp->dim.w; img.dim.h = p_stamp->dim.h; img.ddr_id = SAMPLE_STAMP_DDR_ID; img.fmt = HD_VIDEO_PXLFMT_ARGB1555; ret = hd_videoenc_set(stamp_path_id, HD_VIDEOENC_PARAM_IN_STAMP_IMG, \\&img); //use HD_VIDEOENC_PARAM_IN_STAMP_ATTR to set alpha, align, background dimension\u2026 attr.align_type = HD_OSG_ALIGN_TYPE_TOP_LEFT; attr.alpha = ALPHA_100; attr.position.x = p_pos->x; attr.position.y = p_pos->y; attr.gcac_enable = 0; attr.gcac_blk_width = 64; attr.gcac_blk_height = 32; ret = hd_videoenc_set(stamp_path_id, HD_VIDEOENC_PARAM_IN_STAMP_ATTR, \\&attr); 3. Start the OSG module. After starting the module, the OSG image will paste on the encoded stream. ret = hd_videoenc_start(streams.stamp_path_id[idx]); if (ret != HD_OK) { printf(\u201cstart enc stamp fail = %d\\n\u201d, ret); goto exit; } 4. Run the encode_thread() and wait \u2018q\u2019 key to exit the program. 5. Stop the OSG module. if (HD_OK != hd_videoenc_stop(streams.stamp_path_id[idx])) { printf(\u201cstop enc stamp [%ld] fail\\n\u201d, idx); } 6. Close the OSG stamp module. if ((ret = hd_videoenc_close(p_streams->stamp_path_id[i])) != HD_OK) { return ret; } III. encode_with_mask.c Stream flow: root@NVTEVM:\\~\\$ cat /proc/videograph/graph entity (jobs) pool name (done buffers/max buffers) ----------------------------------------------------------- vcap0_0_4_0 (4) (enc_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->*kflow_osg_0_0_10 (0) (enc_cap_out_ddr0, \u2013, \u2013, \u2013) (0/0) ->h26xenc_0_0_0 (0) (enc_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->dataout_0_0_0 (1) root@NVTEVM:\\~\\$ cat /proc/hdal/flow \u2026 hd_videoenc_set(IN_MASK_ATTR): path_id(0x2200e201) type(0x1) alpha(128) color(0) pos0(0,0) pos1(64,0) pos2(64,32) pos3(0,32) hd_videoenc_start: path_id(0x2200e201) \u2026 hd_videoenc_set(IN_MOSAIC_ATTR): path_id(0x2200e601) type(0x1) alpha(256) blk_wh(32,32) pos0(240,135) pos1(368,135) pos2(368,263) pos3(240,263) hd_videoenc_start: path_id(0x2200e601) \u2026 The sample code flow is the same as the \u201c encode_with_nr.c \u201d, except for the additional functions of the capture mask and the encode mask. 1. Open the modules of the capture mask and the encode mask. //Open the module of the capture make. if ((ret = hd_videocap_open(SAMPLE_VCAP_IN_ID, HD_VIDEOCAP_OUT(SAMPLE_VCAP_DEV_ID, HD_MASK(i)), \\&p_streams->cap0_mask_path[i])) != HD_OK) { return ret; } //Open the module of the encoder make. if ((ret = hd_videoenc_open(HD_VIDEOENC_IN(SAMPLE_VENC_DEV_ID, HD_MASK(i)), SAMPLE_VENC_OUT_ID, \\&p_streams->mask_mosaic_id[i])) != HD_OK) { return ret; } 2. Set the parameters of the capture mask and the encode mask. //use HD_VIDEOCAP_PARAM_OUT_MASK_ATTR to set the capture mask type, alpha, color, position\u2026 HD_OSG_MASK_ATTR mask = {0}; mask.type = HD_OSG_MASK_TYPE_SOLID; mask.alpha = 255; mask.color = idx; mask.position[0].x = (idx % 2) * (p_dim->w / 2) + p_dim->w / 8; mask.position[0].y = (idx / 2) * (p_dim->h / 2); mask.position[1].x = mask.position[0].x + 64; mask.position[1].y = mask.position[0].y; mask.position[2].x = mask.position[1].x; mask.position[2].y = mask.position[1].y + 64; mask.position[3].x = mask.position[0].x; mask.position[3].y = mask.position[2].y; ret = hd_videocap_set(vcap_mask_path_id, HD_VIDEOCAP_PARAM_OUT_MASK_ATTR, \\&mask); //use HD_VIDEOENC_PARAM_IN_MASK_ATTR to set the encoder mask type, alpha, color, position\u2026 HD_OSG_MASK_ATTR mask_attr = {0}; mask_attr.type = HD_OSG_MASK_TYPE_SOLID; mask_attr.color = idx; mask_attr.alpha = 128; //50% transparent mask_attr.position[0].x = (idx % 2) * (p_dim->w / 2); mask_attr.position[0].y = (idx / 2) * (p_dim->h / 2); mask_attr.position[1].x = mask_attr.position[0].x + (mask_w); mask_attr.position[1].y = mask_attr.position[0].y; mask_attr.position[2].x = mask_attr.position[1].x; mask_attr.position[2].y = mask_attr.position[1].y + (mask_h); mask_attr.position[3].x = mask_attr.position[2].x - (mask_w); mask_attr.position[3].y = mask_attr.position[2].y ; ret = hd_videoenc_set(mask_path_id, HD_VIDEOENC_PARAM_IN_MASK_ATTR, \\&mask_attr); //use HD_VIDEOENC_PARAM_IN_MOSAIC_ATTR to set the encoder mosaic type, alpha, background color, position\u2026 HD_OSG_MOSAIC_ATTR mosaic_attr = {0}; mosaic_attr.type = HD_OSG_MASK_TYPE_SOLID; mosaic_attr.alpha = 256; //100% background mosaic_attr.mosaic_blk_w = mosaic_blk_w; mosaic_attr.mosaic_blk_h = mosaic_blk_h; mosaic_attr.position[0].x = (idx % 2) * (p_dim->w / 2) + (p_dim->w / 8) + 100; mosaic_attr.position[0].y = (idx / 2) * (p_dim->h / 2) + (p_dim->h / 8) + 100; mosaic_attr.position[1].x = mosaic_attr.position[0].x + (mosaic_blk_w)*4; mosaic_attr.position[1].y = mosaic_attr.position[0].y; mosaic_attr.position[2].x = mosaic_attr.position[1].x; mosaic_attr.position[2].y = mosaic_attr.position[1].y + (mosaic_blk_h)*4; mosaic_attr.position[3].x = mosaic_attr.position[2].x - (mosaic_blk_w)*4; mosaic_attr.position[3].y = mosaic_attr.position[2].y; ret = hd_videoenc_set(mosaic_path_id, HD_VIDEOENC_PARAM_IN_MOSAIC_ATTR, \\&mosaic_attr); 3. Start the modules of the capture mask and the encode mask. After starting these modules, the mask images will paste on the encoded stream. //Start the module of the capture make. cur_path_id = p_path_id_list[mask_idx]; ret = hd_videocap_start(cur_path_id); //Start the module of the encoder make. ret = hd_videoenc_start(p_path_id[idx]); 4. Run the encode_thread() and wait \u2018q\u2019 key to exit the program. And you can press \u2018e\u2019 key to use hd_videocap_start() / hd_videocap_stop() to switch the capture mask to ON or OFF. And you can also press \u2018y\u2019 key to use hd_videoenc_set() to update the position of the encode mask, and then use hd_videoenc_start() to activate the new position parameters. 5. Stop the modules of the capture mask and the encode mask. //Stop the module of the capture make. if (HD_OK != hd_videocap_stop(streams.cap0_mask_path[mask_idx])) { printf(\u201cstop vcap mask [%d] fail\\n\u201d, mask_idx); } //Stop the module of the encoder make. if (HD_OK != hd_videoenc_stop(streams.mask_mosaic_id[mask_idx])) { printf(\u201cstop enc mask [%d] fail\\n\u201d, mask_idx); } 6. Close the modules of the capture mask and the encode mask. //Close the module of the capture make. if ((ret = hd_videocap_close(p_streams->cap0_mask_path[i])) != HD_OK) { return ret; } //Close the module of the encoder make. if ((ret = hd_videoenc_close(p_streams->mask_mosaic_id[i])) != HD_OK) { return ret; } 5.2.2 Liveview \u00b6 The stream flow of the sample code \u201c liveview_1div_to_4div.c \u201d: root@NVTEVM:\\~\\$ cat /proc/videograph/graph entity (jobs) pool name (done buffers/max buffers) ----------------------------------------------------------- vcap0_0_4_0 (3) (disp0_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->kflow_vpe_0_0_0 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) ->*kflow_osg_0_0_0 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/0) ->lcd0vg_0_0_0 (2) vcap0_0_6_0 (3) (disp0_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->kflow_vpe_0_0_1 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) vcap0_0_0_0 (3) (disp0_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->kflow_vpe_0_0_2 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) vcap0_0_2_0 (3) (disp0_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->kflow_vpe_0_0_3 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) Sample code flow: 1. Initiate the HDAL. ret = hd_common_init(1); //the parameter is reserved for the future. 2. Initiate the capture, the video process and the video out modules. if ((ret = hd_videocap_init()) != HD_OK) { return ret; } if ((ret = hd_videoproc_init()) != HD_OK) { return ret; } if ((ret = hd_videoout_init()) != HD_OK) { return ret; } 3. Open the capture, the video process and the video out modules. HD_VIDEOOUT_OUT(0, 0) indicates the video output 0 (LCD300) and HD_VIDEOOUT_OUT(1, 0) indicates the video output 1 (LCD200). In cfg_DVR_xxx.dts, the default setting \u2018videoout0\u2026homology = \u201cHD_COMMON_VIDEO_OUT_VGA\u201d;\u2019 of the HDMI and VGA are set to homology, it means HD_VIDEOOUT_OUT(0, 0) indicates to output to HDMI and VGA simultaneously. HD_VIDEOOUT_0_CTRL indicates the HDMI control, and we can use hd_videoout_get() to get LCD capability. for (i = 0; i \\< SAMPLE_LV_COUNT; i++) { if((ret = hd_videocap_open(HD_VIDEOCAP_IN(i, 0), HD_VIDEOCAP_OUT(i, 0), \\&p_liveview_info->cap_path[i])) != HD_OK) return ret; if((ret = hd_videoproc_open(HD_VIDEOPROC_IN(i, 0), HD_VIDEOPROC_OUT(i, 0), \\&p_liveview_info->proc_path[i])) != HD_OK) return ret; if((ret = hd_videoout_open(HD_VIDEOOUT_IN(0, i), HD_VIDEOOUT_OUT(0, 0), \\&p_liveview_info->out_path[i])) != HD_OK) return ret; } if ((ret = hd_videoout_open(0, HD_VIDEOOUT_0_CTRL, \\&p_liveview_info->out_ctrl)) != HD_OK) return ret; 4. Set the capture configure and parameters. The data_pool (the buffer name is disp0_cap_out_ddr0) is allocated from the HD_COMMON_MEM_DISP0_CAP_OUT_POOL, the buffer size of the capture output is fixed and the counts/max_counts should not be larger than \u201cCapture Count\u201d in the \u201cDisplay\u201d sheet of DVR_xch.xls. Only one data_pool is valid for the capture, so data_pool[1\\~3].mode must set to disable. //use HD_VIDEOCAP_PARAM_PATH_CONFIG to set the memory pool configure. cap_config.data_pool[0].mode = HD_VIDEOCAP_POOL_ENABLE; cap_config.data_pool[0].ddr_id = 0; cap_config.data_pool[0].counts = HD_VIDEOCAP_SET_COUNT(4, 0); cap_config.data_pool[0].max_counts = HD_VIDEOCAP_SET_COUNT(4, 0); cap_config.data_pool[1].mode = HD_VIDEOCAP_POOL_DISABLE; cap_config.data_pool[2].mode = HD_VIDEOCAP_POOL_DISABLE; cap_config.data_pool[3].mode = HD_VIDEOCAP_POOL_DISABLE; ret = hd_videocap_set(liveview_info.cap_path[i], HD_VIDEOCAP_PARAM_PATH_CONFIG, \\&cap_config); //use HD_VIDEOCAP_PARAM_OUT to set the output dimension and the pixel format. ret = hd_videocap_set(cap_path_id, HD_VIDEOCAP_PARAM_OUT, \\&cap_out); 5. Set the video process configure and parameters. The data_pool (the buffer name is disp0_in_ddr0) is allocated from the HD_COMMON_MEM_DISPLAY_IN_POOL, the buffer size of the video process output is fixed and the counts/max_counts should not be larger than \u201cDisplay Count\u201d in the \u201cDisplay\u201d sheet of DVR_xch.xls. And only one data_pool is valid for the video process, so data_pool[1\\~3].mode must set to disable. //use HD_VIDEOPROC_PARAM_DEV_CONFIG to set the memory pool configure. vpe_config.data_pool[0].mode = HD_VIDEOPROC_POOL_ENABLE; vpe_config.data_pool[0].ddr_id = 0; vpe_config.data_pool[0].counts = HD_VIDEOPROC_SET_COUNT(3, 0); vpe_config.data_pool[0].max_counts = HD_VIDEOPROC_SET_COUNT(3, 0); vpe_config.data_pool[1].mode = HD_VIDEOPROC_POOL_DISABLE; vpe_config.data_pool[2].mode = HD_VIDEOPROC_POOL_DISABLE; vpe_config.data_pool[3].mode = HD_VIDEOPROC_POOL_DISABLE; ret = hd_videoproc_set(liveview_info.proc_path[i], HD_VIDEOPROC_PARAM_DEV_CONFIG, \\&vpe_config); //use HD_VIDEOPROC_PARAM_OUT to set the position, dimension, background dimension\u2026 proc_out.rect.x = 0; proc_out.rect.y = 0; proc_out.rect.w = liveview_info.lcd_syscaps.input_dim.w; proc_out.rect.h = liveview_info.lcd_syscaps.input_dim.h; proc_out.bg.w = liveview_info.lcd_syscaps.input_dim.w; proc_out.bg.h = liveview_info.lcd_syscaps.input_dim.h; proc_out.pxlfmt = fb_fmt.fmt; proc_out.dir = HD_VIDEO_DIR_NONE; ret = hd_videoproc_set(liveview_info.proc_path[i], HD_VIDEOPROC_PARAM_OUT, \\&proc_out); 6. Set the parameters of the video out module. //use HD_VIDEOOUT_PARAM_IN_WIN_ATTR to set the position, dimension, and visible. win.rect.x = 0; win.rect.y = 0; win.rect.w = liveview_info.lcd_syscaps.input_dim.w; win.rect.h = liveview_info.lcd_syscaps.input_dim.h; win.visible = 1; ret = hd_videoout_set(liveview_info.out_path[i], HD_VIDEOOUT_PARAM_IN_WIN_ATTR, \\&win); 7. Bind the capture, the video process and the video out modules, and then the video stream will flow from the capture to the video out. if ((ret = hd_videocap_bind(HD_VIDEOCAP_OUT(i, 0), HD_VIDEOPROC_IN(i, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_bind(HD_VIDEOPROC_OUT(i, 0), HD_VIDEOOUT_IN(0, i))) != HD_OK) { return ret; } 8. Start the capture, the video process and the video out modules. The different between hd_videoXXX_start_list() and hd_videoXXX_start() is that hd_videoXXX_start_list() will start a \u201clist\u201d of XXX modules. if ((ret = hd_videocap_start_list(liveview_info.cap_path, SAMPLE_LV_COUNT)) != HD_OK) { return ret; } if ((ret = hd_videoproc_start_list(liveview_info.proc_path, SAMPLE_LV_COUNT)) != HD_OK) { return ret; } if ((ret = hd_videoout_start_list(liveview_info.out_path, SAMPLE_LV_COUNT)) != HD_OK) { return ret; } 9. After starting the modules, the video stream will flow from the capture module via the video process module to the video out module. If you press \u2018y\u2019 key, it will toggle single window and 2x2 grid windows by changing the parameters of the video process and the video out modules. And then use hd_videoXXX_start_list() to activate the new parameters. 10. Wait the key press \u2018q\u2019 to exit the thread. 11. Stop the capture, the video process and the video out modules. if ((ret = hd_videocap_stop_list(liveview_info.cap_path, SAMPLE_LV_COUNT)) != HD_OK) { return ret; } if ((ret = hd_videoproc_stop_list(liveview_info.proc_path, SAMPLE_LV_COUNT)) != HD_OK) { return ret; } if ((ret = hd_videoout_stop_list(liveview_info.out_path, SAMPLE_LV_COUNT)) != HD_OK) { return ret; } 12. Unbind the capture, the video process and the video out modules. if ((ret = hd_videocap_unbind(HD_VIDEOCAP_OUT(i, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_unbind(HD_VIDEOPROC_OUT(i, 0))) != HD_OK) { return ret; } 13. Close the capture, the video process and the video out modules. if ((ret = hd_videocap_close(liveview_info.cap_path[i])) != HD_OK) { return ret; } if ((ret = hd_videoproc_close(liveview_info.proc_path[i])) != HD_OK) { return ret; } if ((ret = hd_videoout_close(liveview_info.out_path[i])) != HD_OK) { return ret; } 14. Un-initiate the capture, the video process and the video out modules. if ((ret = hd_videocap_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoproc_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoout_uninit()) != HD_OK) { return ret; } 15. Un-initiate the HDAL. ret = hd_common_uninit(); 5.2.3 Playback \u00b6 The stream flow of the sample code \u201c playback_1div_to_4div.c \u201d: root@NVTEVM:\\~\\$ cat /proc/videograph/graph entity (jobs) pool name (done buffers/max buffers) ----------------------------------------------------------- datain_0_0_0 (1) (disp_dec_in_ddr0, \u2013, \u2013, \u2013) (5/8) ->decode_0_0_0 (1) (disp_dec_out_ddr0, disp_dec_out_ratio_ddr0, \u2013, \u2013) (2/3) ->kflow_vpe_0_0_0 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) ->*kflow_osg_0_0_0 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/0) ->lcd0vg_0_0_0 (2) datain_0_0_1 (0) (disp_dec_in_ddr0, \u2013, \u2013, \u2013) (5/8) ->decode_0_0_1 (1) (disp_dec_out_ddr0, disp_dec_out_ratio_ddr0, \u2013, \u2013) (2/3) ->kflow_vpe_0_0_1 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) datain_0_0_2 (0) (disp_dec_in_ddr0, \u2013, \u2013, \u2013) (5/8) ->decode_0_0_2 (1) (disp_dec_out_ddr0, disp_dec_out_ratio_ddr0, \u2013, \u2013) (2/3) ->kflow_vpe_0_0_2 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) datain_0_0_3 (0) (disp_dec_in_ddr0, \u2013, \u2013, \u2013) (5/8) ->decode_0_0_3 (1) (disp_dec_out_ddr0, disp_dec_out_ratio_ddr0, \u2013, \u2013) (2/3) ->kflow_vpe_0_0_3 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) Sample code flow: 1. Initiate the HDAL. ret = hd_common_init(1); //the parameter is reserved for the future. 2. Initiate the video decoder, the video process, the video out and the video encoder modules. if ((ret = hd_videodec_init()) != HD_OK) { return ret; } if ((ret = hd_videoproc_init()) != HD_OK) { return ret; } if ((ret = hd_videoout_init()) != HD_OK) { return ret; } if ((ret = hd_videoenc_init()) != HD_OK) { return ret; } 3. Open the video decoder, the video process, the video out and the video encoder modules. The video process 0 \\~ ( MAX_BITSTREAM_NUM \u2013 1) are used for the bitstream decode to the video out, and the video process MAX_BITSTREAM_NUM is used for the bitstream decode to the video encoder for JPEG. for (i = 0; i \\< MAX_BITSTREAM_NUM; i++) { if ((ret = hd_videodec_open(HD_VIDEODEC_IN(0, i), HD_VIDEODEC_OUT(0, i), \\&p_playback_info->video_dec[i])) != HD_OK) return ret; if ((ret = hd_videoproc_open(HD_VIDEOPROC_IN(i, 0), HD_VIDEOPROC_OUT(i, 0), \\&p_playback_info->video_proc[i])) != HD_OK) return ret; if ((ret = hd_videoout_open(HD_VIDEOOUT_IN(0, i), HD_VIDEOOUT_OUT(0, 0), \\&p_playback_info->video_out[i])) != HD_OK) return ret; } if ((ret = hd_videoproc_open(HD_VIDEOPROC_IN(MAX_BITSTREAM_NUM, 0), HD_VIDEOPROC_OUT(MAX_BITSTREAM_NUM, 0), \\&p_playback_info->video_proc[MAX_BITSTREAM_NUM])) != HD_OK) { return ret; } if ((ret = hd_videoenc_open(HD_VIDEOENC_0_IN_0, HD_VIDEOENC_0_OUT_0, \\&p_playback_info->video_enc)) != HD_OK) { return ret; } if ((ret = hd_videoout_open(0, HD_VIDEOOUT_0_CTRL, \\&p_playback_info->video_out_ctrl)) != HD_OK) //open this for device control return ret; 4. Set the decoder configure and parameters. The max_mem (the buffer name is disp_dec_in_ddr0) is allocated from the HD_COMMON_MEM_DISP_DEC_IN_POOL. Only two data_pool are valid for the decoder, so data_pool[2\\~3].mode must set to disable. The first data_pool (the buffer name is disp_dec_out_ddr0) is allocated from the HD_COMMON_MEM_DISP_DEC_OUT_POOL, the counts/max_counts should not be larger than \u201cYUV Buffer count\u201d in the \u201cdecode\u201d sheet of DVR_xch.xls. The second data_pool (the buffer name is disp_dec_out_ratio_ddr0) is allocated from the HD_COMMON_MEM_DISP_DEC_OUT_RATIO_POOL, the counts/max_counts should not be larger than \u201cYUV Buffer count\u201d in the \u201cdecode\u201d sheet of DVR_xch.xls. While enable data_pool[1].mode, the decoder will output two different sizes of the frame, one is original size, the other is 1/4 of the original size (the decode ratio frame must set to 0.25 in the \u201cdecode\u201d sheet of DVR_xch.xls.). The small size frame is used for the multi-grid display on LCD to reduce the VPE scaling bandwidth. dec_config.max_mem.dim.w = ALIGN_CEIL(playback_info.video_pattern[i].img_width); dec_config.max_mem.dim.h = ALIGN_CEIL(playback_info.video_pattern[i].img_height); dec_config.max_mem.frame_rate = playback_info.video_pattern[i].frame_rate; dec_config.max_mem.bs_counts = 8; dec_config.max_mem.codec_type = HD_CODEC_TYPE_H265; dec_config.max_mem.max_ref_num = 1; dec_config.data_pool[0].mode = HD_VIDEODEC_POOL_ENABLE; dec_config.data_pool[0].ddr_id = 0; dec_config.data_pool[0].counts = HD_VIDEODEC_SET_COUNT(3, 0); dec_config.data_pool[0].max_counts = HD_VIDEODEC_SET_COUNT(3, 0); dec_config.data_pool[1].mode = HD_VIDEODEC_POOL_ENABLE; dec_config.data_pool[1].ddr_id = 0; dec_config.data_pool[1].counts = HD_VIDEODEC_SET_COUNT(3, 0); dec_config.data_pool[1].max_counts = HD_VIDEODEC_SET_COUNT(3, 0); dec_config.data_pool[2].mode = HD_VIDEODEC_POOL_DISABLE; dec_config.data_pool[3].mode = HD_VIDEODEC_POOL_DISABLE; ret = hd_videodec_set(playback_info.video_dec[i], HD_VIDEODEC_PARAM_PATH_CONFIG, \\&dec_config); 5. Set the video process configure and parameters. //use HD_VIDEOPROC_PARAM_DEV_CONFIG to set the memory pool configure. vpe_config.data_pool[0].mode = HD_VIDEOPROC_POOL_ENABLE; vpe_config.data_pool[0].ddr_id = 0; vpe_config.data_pool[0].counts = HD_VIDEOPROC_SET_COUNT(3, 0); vpe_config.data_pool[0].max_counts = HD_VIDEOPROC_SET_COUNT(3, 0); vpe_config.data_pool[1].mode = HD_VIDEOPROC_POOL_DISABLE; vpe_config.data_pool[2].mode = HD_VIDEOPROC_POOL_DISABLE; vpe_config.data_pool[3].mode = HD_VIDEOPROC_POOL_DISABLE; ret = hd_videoproc_set(playback_info.video_proc[i], HD_VIDEOPROC_PARAM_DEV_CONFIG, \\&vpe_config); //use HD_VIDEOPROC_PARAM_OUT to set the position, dimension, background dimension\u2026 proc_out.rect.x = 0; proc_out.rect.y = 0; proc_out.rect.w = playback_info.lcd_syscaps.input_dim.w; proc_out.rect.h = playback_info.lcd_syscaps.input_dim.h; proc_out.bg.w = playback_info.lcd_syscaps.input_dim.w; proc_out.bg.h = playback_info.lcd_syscaps.input_dim.h; proc_out.pxlfmt = fb_fmt.fmt; proc_out.dir = HD_VIDEO_DIR_NONE; ret = hd_videoproc_set(playback_info.video_proc[i], HD_VIDEOPROC_PARAM_OUT, \\&proc_out); 6. Set the parameters of the video out module. //use HD_VIDEOOUT_PARAM_IN_WIN_ATTR to set the position, dimension, and visible. win.rect.x = 0; win.rect.y = 0; win.rect.w = playback_info.lcd_syscaps.input_dim.w; win.rect.h = playback_info.lcd_syscaps.input_dim.h; win.visible = 1; ret = hd_videoout_set(playback_info.video_out[i], HD_VIDEOOUT_PARAM_IN_WIN_ATTR, \\&win); 7. Set the encoder parameters. //use HD_VIDEOENC_PARAM_IN to set the input dimension and the pixel format. ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_IN, \\&video_in_param); //use HD_VIDEOENC_PARAM_OUT_ENC_PARAM to set the parameters of the codec. ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_OUT_ENC_PARAM, \\&enc_param); //use HD_VIDEOENC_PARAM_OUT_RATE_CONTROL to set the parameters of the rate control. ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_OUT_RATE_CONTROL, \\&rc_param); 8. Bind the video decoder, the video process and the video out modules, and then the video stream will flow from the decoder to the video out. for (i = 0; i \\< MAX_BITSTREAM_NUM; i++) { if ((ret = hd_videodec_bind(HD_VIDEODEC_OUT(0, i), HD_VIDEOPROC_IN(i, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_bind(HD_VIDEOPROC_OUT(i, 0), HD_VIDEOOUT_IN(0, i))) != HD_OK) { return ret; } } 9. Start the video decoder, the video process and the video out modules. if ((ret = hd_videodec_start_list(playback_info.video_dec, MAX_BITSTREAM_NUM)) != HD_OK) { return ret; } if ((ret = hd_videoproc_start_list(playback_info.video_proc, MAX_BITSTREAM_NUM)) != HD_OK) { return ret; } if ((ret = hd_videoout_start_list(playback_info.video_out, MAX_BITSTREAM_NUM)) != HD_OK) { return ret; } 10. Create a thread to read the h.265 bitstream files, and then uses hd_videodec_send_list() to send the bitstream to the decode module. The YUV output from the decode module will flow to the video out module via the video process module. static void *playback_thread(void *arg) { \u2026 while (1) { \u2026 fread(data[ch], 1, length, bs_fd[ch]); video_bs[ch].path_id = playback_info->video_dec[ch]; video_bs[ch].user_bs.p_bs_buf = data[ch]; video_bs[ch].user_bs.bs_buf_size = length; \u2026 hd_videodec_send_list(video_bs, MAX_BITSTREAM_NUM, 1000); \u2026 } \u2026 } 11. If you press \u2018y\u2019 key, it will toggle single window and 2x2 grid windows by changing the parameters of the video process and the video out modules. 12. If you press \u2018p\u2019 key, it will snapshot one JPEG file. This sample will demo how to use the push/pull APIs to scale and encode a single frame. Compare with the binding mode, this single mode must prepare the input/output buffer of the modules first. HD_RESULT pull_decout_and_scale_jpg(VIDEO_PLAYBACK playback_info, int enc_num) { \u2026 // Pull out the output buffer of the decoder module ret = hd_videodec_pull_out_buf(dec_path_id, \\&out_buffer, 500); \u2026 // prepare the input buffer of the video process for scaling scale_in_va = (UINT32)hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_NONCACHE, scale_in_pa, scale_in_blk_size); \u2026 // set the crop input parameters of the video process ret = hd_videoproc_set(proc_path_id, HD_VIDEOPROC_PARAM_IN_CROP, (void *)&crop); \u2026 // set the output parameters of the video process ret = hd_videoproc_set(proc_path_id, HD_VIDEOPROC_PARAM_OUT, (void *)&out); \u2026 // Push the decode output buffer into the video process module scale_out_va = (UINT32)hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_NONCACHE, scale_out_pa, scale_out_blk_size); scale_in_buffer.phy_addr[0] = scale_in_pa; scale_out_buffer.phy_addr[0] = scale_out_pa; ret = hd_videoproc_push_in_buf(proc_path_id, \\&scale_in_buffer, \\&scale_out_buffer, 500); \u2026 // Pull out the output buffer of the video process module ret = hd_videoproc_pull_out_buf(proc_path_id, \\&scale_out_buffer, 500); \u2026 // Push the video process output buffer into the encode module ret = hd_videoenc_push_in_buf(videoenc_path_id, \\&enc_in_buffer.frame, &(bs_out_buffer.bs), 500); \u2026 // pull out the output buffer of the encode module ret = hd_videoenc_pull_out_buf(videoenc_path_id, \\&video_bitstream, 500); // save to the JPEG file fwrite(bs_out_buffer.va, 1, video_bitstream.video_pack[0].size, bs_file); \u2026 } 13. Wait the key press \u2018q\u2019 to exit the thread. 14. Stop the video decoder, the video process and the video out modules. if ((ret = hd_videodec_stop_list(playback_info.video_dec, MAX_BITSTREAM_NUM)) != HD_OK) { return ret; } if ((ret = hd_videoproc_stop_list(playback_info.video_proc, MAX_BITSTREAM_NUM)) != HD_OK) { return ret; } if ((ret = hd_videoout_stop_list(playback_info.video_out, MAX_BITSTREAM_NUM)) != HD_OK) { return ret; } 15. Unbind the video decoder, the video process and the video out modules. for (i = 0; i \\< MAX_BITSTREAM_NUM; i++) { if ((ret = hd_videodec_unbind(HD_VIDEODEC_OUT(0, i))) != HD_OK) { return ret; } if ((ret = hd_videoproc_unbind(HD_VIDEOPROC_OUT(i, 0))) != HD_OK) { return ret; } } 16. Close the video decoder, the video process, the video out and the video encoder modules. for (i = 0; i \\< MAX_BITSTREAM_NUM; i++) { if ((ret = hd_videodec_close(p_playback_info.video_dec[i])) != HD_OK) { return ret; } if ((ret = hd_videoproc_close(p_playback_info.video_proc[i])) != HD_OK) { return ret; } if ((ret = hd_videoout_close(p_playback_info.video_out[i])) != HD_OK) { return ret; } } if ((ret = hd_videoproc_close(p_playback_info.video_proc[MAX_BITSTREAM_NUM])) != HD_OK) { return ret; } if ((ret = hd_videoenc_close(p_playback_info.video_enc)) != HD_OK) { return ret; } if ((ret = hd_videoout_close(p_playback_info.video_out_ctrl)) != HD_OK) { return ret; } 17. Un-initiate the video decoder, the video process, the video out and the video encoder modules. if ((ret = hd_videodec_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoproc_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoout_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoenc_uninit()) != HD_OK) { return ret; } 18. Un-initiate the HDAL. ret = hd_common_uninit(); 5.2.4 Display to Encode \u00b6 The stream flow of the sample code \u201c display_to_encode.c \u201d: root@NVTEVM:\\~\\$ cat /proc/videograph/graph entity (jobs) pool name (done buffers/max buffers) ----------------------------------------------------------- vcap0_0_4_0 (2) (disp0_cap_out_ddr0, \u2013, \u2013, \u2013) (1/4) ->kflow_vpe_0_0_0 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) ->*kflow_osg_0_0_0 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/0) ->lcd0vg_0_0_0 (2) ->kflow_vpe_0_0_4 (0) (enc_scl_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->*kflow_osg_0_0_10 (0)(enc_scl_out_ddr0, \u2013, \u2013, \u2013) (0/0) ->h26xenc_0_0_0 (0) (enc_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->dataout_0_0_0 (1) vcap0_0_6_0 (3) (disp0_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->kflow_vpe_0_0_1 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) vcap0_0_0_0 (3) (disp0_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->kflow_vpe_0_0_2 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) vcap0_0_2_0 (3) (disp0_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->kflow_vpe_0_0_3 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) Sample code flow: 1. Initiate the HDAL. ret = hd_common_init(1); //the parameter is reserved for the future. 2. Initiate the capture, the video process, the video out and the video encoder modules. if ((ret = hd_videocap_init()) != HD_OK) { return ret; } if ((ret = hd_videoproc_init()) != HD_OK) { return ret; } if ((ret = hd_videoout_init()) != HD_OK) { return ret; } if ((ret = hd_videoenc_init()) != HD_OK) { return ret; } 3. Open the capture, the video process, the video out and the video encoder modules. 0 \\~ ( MAX_BITSTREAM_NUM \u2013 1) modules are used for capturing the video frames and display on LCD, and MAX_BITSTREAM_NUM modules are used for encoding the video out to be as h.265 file. for (i = 0; i \\< MAX_VI_NU; i++) { if((ret = hd_videocap_open(HD_VIDEOCAP_IN(i, 0), HD_VIDEOCAP_OUT(i, 0), \\&p_disp_to_enc->video_cap[i])) != HD_OK) return ret; if((ret = hd_videoproc_open(HD_VIDEOPROC_IN(i, 0), HD_VIDEOPROC_OUT(i, 0), \\&p_disp_to_enc->video_proc[i])) != HD_OK) return ret; if((ret = hd_videoout_open(HD_VIDEOOUT_IN(p_disp_to_enc->lcd_devid, i), HD_VIDEOOUT_OUT(p_disp_to_enc->lcd_devid, 0), \\&p_disp_to_enc->video_out[i])) != HD_OK) return ret; } if ((ret = hd_videoproc_open(HD_VIDEOPROC_IN(i, 0), HD_VIDEOPROC_OUT(i, 0), \\&p_disp_to_enc->vpe_path[0])) != HD_OK) { return ret; } if ((ret = hd_videoenc_open(HD_VIDEOENC_IN(0, 0), HD_VIDEOENC_OUT(0, 0), \\&p_disp_to_enc->enc_path[0])) != HD_OK) { return ret; } if ((ret = hd_videoout_open(0, HD_VIDEOOUT_CTRL(p_disp_to_enc->lcd_devid), \\&p_disp_to_enc->video_out_ctrl)) != HD_OK) //open this for device control return ret; 4. Set the capture configure and parameters. //use HD_VIDEOCAP_PARAM_PATH_CONFIG to set the memory pool configure. cap_config.data_pool[0].mode = HD_VIDEOCAP_POOL_ENABLE; cap_config.data_pool[0].ddr_id = SAMPLE_VCAP_DDR_ID; cap_config.data_pool[0].counts = HD_VIDEOCAP_SET_COUNT(4, 0); cap_config.data_pool[0].max_counts = HD_VIDEOCAP_SET_COUNT(4, 0); cap_config.data_pool[1].mode = HD_VIDEOCAP_POOL_DISABLE; cap_config.data_pool[2].mode = HD_VIDEOCAP_POOL_DISABLE; cap_config.data_pool[3].mode = HD_VIDEOCAP_POOL_DISABLE; ret = hd_videocap_set(cap_path_id, HD_VIDEOCAP_PARAM_PATH_CONFIG, \\&cap_config); //use HD_VIDEOCAP_PARAM_OUT to set the output dimension and the pixel format. ret = hd_videocap_set(cap_path_id, HD_VIDEOCAP_PARAM_OUT, \\&cap_out); 5. Set the video process configure and parameters. //use HD_VIDEOPROC_PARAM_DEV_CONFIG to set the memory pool configure. vpe_config.data_pool[0].mode = HD_VIDEOPROC_POOL_ENABLE; vpe_config.data_pool[0].ddr_id = 0; vpe_config.data_pool[0].counts = HD_VIDEOPROC_SET_COUNT(3, 0); vpe_config.data_pool[0].max_counts = HD_VIDEOPROC_SET_COUNT(3, 0); vpe_config.data_pool[1].mode = HD_VIDEOPROC_POOL_DISABLE; vpe_config.data_pool[2].mode = HD_VIDEOPROC_POOL_DISABLE; vpe_config.data_pool[3].mode = HD_VIDEOPROC_POOL_DISABLE; ret = hd_videoproc_set(p_disp_to_enc->video_proc[i], HD_VIDEOPROC_PARAM_DEV_CONFIG, \\&vpe_config); //use HD_VIDEOPROC_PARAM_OUT to set the position, dimension, background dimension\u2026 ret = hd_videoproc_set(playback_info.video_proc[i], HD_VIDEOPROC_PARAM_OUT, \\&proc_out); 6. Set the parameters of the video out module. //use HD_VIDEOOUT_PARAM_IN_WIN_ATTR to set the position, dimension, and visible. win.rect.x = (i % 2) * (p_disp_to_enc->lcd_syscaps.input_dim.w / 2); win.rect.y = (i / 2) * (p_disp_to_enc->lcd_syscaps.input_dim.h / 2); win.rect.w = (p_disp_to_enc->lcd_syscaps.input_dim.w / 2); win.rect.h = (p_disp_to_enc->lcd_syscaps.input_dim.h / 2); win.visible = 1; ret = hd_videoout_set(p_disp_to_enc->video_out[i], HD_VIDEOOUT_PARAM_IN_WIN_ATTR, \\&win); 7. Set the encoder parameters. //use HD_VIDEOENC_PARAM_IN to set the input dimension and the pixel format. ret = hd_videoenc_set(p_disp_to_enc->enc_path[0], HD_VIDEOENC_PARAM_IN, \\&video_in_param); //use HD_VIDEOENC_PARAM_OUT_ENC_PARAM to set the parameters of the codec. ret = hd_videoenc_set(p_disp_to_enc->enc_path[0], HD_VIDEOENC_PARAM_OUT_ENC_PARAM, \\&enc_param); //use HD_VIDEOENC_PARAM_OUT_RATE_CONTROL to set the parameters of the rate control. ret = hd_videoenc_set(p_disp_to_enc->enc_path[0], HD_VIDEOENC_PARAM_OUT_RATE_CONTROL, \\&rc_param); 8. First, bind the capture, the video process and the video out modules, and then the video stream will flow from the capture to the video out. Second, bind the video out, the video process and the video encoder modules, and then the video stream will flow from the video out to the video encoder module. for (i = 0; i \\< MAX_VI_NU; i++) { if ((ret = hd_videocap_bind(HD_VIDEOCAP_OUT(i, 0), HD_VIDEOPROC_IN(i, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_bind(HD_VIDEOPROC_OUT(i, 0), HD_VIDEOOUT_IN(p_disp_to_enc->lcd_devid, i))) != HD_OK) { return ret; } } //connect liveview to encode if ((ret = hd_videoout_bind(HD_VIDEOOUT_OUT(p_disp_to_enc->lcd_devid, 0), HD_VIDEOPROC_IN(i, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_bind(HD_VIDEOPROC_OUT(i, 0), HD_VIDEOENC_IN(0, 0))) != HD_OK) { return ret; } 9. Start the capture, the video process, the video out and the video encoder modules. if ((ret = hd_videocap_start_list(p_disp_to_enc->video_cap, MAX_VI_NU)) != HD_OK) { return ret; } if ((ret = hd_videoproc_start_list(p_disp_to_enc->video_proc, MAX_VI_NU)) != HD_OK) { return ret; } if ((ret = hd_videoout_start_list(p_disp_to_enc->video_out, MAX_VI_NU)) != HD_OK) { return ret; } if ((ret = hd_videoproc_start_list(p_disp_to_enc->vpe_path, 1)) != HD_OK) { return ret; } if ((ret = hd_videoenc_start_list(p_disp_to_enc->enc_path, 1)) != HD_OK) { return ret; } 10. Create a thread to encode the stream from the video output. The main procedure in this thread is using the hd_videoenc_poll_list() API to check the stream is ready or not. If the stream is ready, use hd_videoenc_recv_list() API to receive it. static void *encode_thread(void *arg) { \u2026 while (p_disp_to_enc->enc_exit == 0) { //check bitstream status before receiving ret = hd_videoenc_poll_list(poll_list, MAX_BITSTREAM_NUM, 500); \u2026 if ((ret = hd_videoenc_recv_list(recv_list, MAX_BITSTREAM_NUM)) \\< 0) { printf(\u201cError return value %d\\n\u201d, ret); } else { for (i = 0; i \\< MAX_BITSTREAM_NUM; i++) { //Write the receive the encoded bitstreams to file } } } \u2026 } 11. Wait the key press \u2018q\u2019 to exit the thread. 12. Stop the capture, the video process, the video out and the video encoder modules. if ((ret = hd_videocap_stop_list(p_disp_to_enc->video_cap, MAX_VI_NU)) != HD_OK) { return ret; } if ((ret = hd_videoproc_stop_list(p_disp_to_enc->video_proc, MAX_VI_NU)) != HD_OK) { return ret; } if ((ret = hd_videoout_stop_list(p_disp_to_enc->video_out, MAX_VI_NU)) != HD_OK) { return ret; } if ((ret = hd_videoproc_stop_list(p_disp_to_enc->vpe_path, 1)) != HD_OK) { return ret; } if ((ret = hd_videoenc_stop_list(p_disp_to_enc->enc_path, 1)) != HD_OK) { return ret; } 13. Unbind the capture and the encoder modules. for (i = 0; i \\< MAX_VI_NU; i++) { if ((ret = hd_videocap_unbind(HD_VIDEOCAP_OUT(i, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_unbind(HD_VIDEOPROC_OUT(i, 0))) != HD_OK) { return ret; } } if ((ret = hd_videoout_unbind(HD_VIDEOOUT_OUT(p_disp_to_enc->lcd_devid, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_unbind(HD_VIDEOPROC_OUT(i, 0))) != HD_OK) { return ret; } 14. Close the capture, the video process, the video out and the video encoder modules. for (i = 0; i \\< MAX_VI_NU; i++) { if ((ret = hd_videocap_close(p_disp_to_enc->video_cap[i])) != HD_OK) { return ret; } if ((ret = hd_videoproc_close(p_disp_to_enc->video_proc[i])) != HD_OK) { return ret; } if ((ret = hd_videoout_close(p_disp_to_enc->video_out[i])) != HD_OK) { return ret; } } if ((ret = hd_videoproc_close(p_disp_to_enc->vpe_path[0])) != HD_OK) { return ret; } if ((ret = hd_videoenc_close(p_disp_to_enc->enc_path[0])) != HD_OK) { return ret; } if ((ret = hd_videoout_close(p_disp_to_enc->video_out_ctrl)) != HD_OK) { return ret; } 15. Un-initiate the capture, the video process, the video out and the video encoder modules. if ((ret = hd_videocap_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoproc_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoout_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoenc_uninit()) != HD_OK) { return ret; } 16. Un-initiate the HDAL. ret = hd_common_uninit(); 6 Appendix \u00b6 6.1 Video Format \u00b6 The following table lists the available video formats for the video path and HDAL APIs. Path/APIs Available Video Format (HD_VIDEO_PXLFMT_XXX) VCAP_OUT YUV422_ONE, YUV420 VCAP_OUT (compress mode) YUV420_NVX3, YUV422_NVX3 VOUT_IN YUV420, YUV422_ONE VOUT_IN (compress mode) YUV420_NVX3, YUV422_NVX3 VPE_IN YUV420, YUV422_ONE VPE_IN (compress mode) YUV420_NVX3, YUV420_NVX4 VPE_OUT YUV420, YUV422_ONE VPE_OUT (compress mode) YUV420_NVX3 VENC_IN (JPEG) YUV420 VENC_IN (JPEG) (compress mode) YUV420_NVX3 VENC_IN (H.265) YUV420 VENC_IN (H.265) (compress mode) YUV420_NVX3 VENC_IN (H.264) YUV420 VENC_IN (H.264) (compress mode) YUV420_NVX3 VENC OSG ARGB1555 VDEC_OUT (JPEG) YUV420 VDEC_OUT (H.265) YUV420_NVX4, YUV420_NVX3 (ratio) VDEC_OUT (H.264) YUV420_NVX4, YUV420_NVX3 (ratio) OSG IN ARGB1555, ARGB8888 OSG OUT YUV420, YUV422_NVX3 hd_gfx_xxx() APIs ARGB1555, ARGB8888, YUV422_ONE, YUV420 HD_VIDEOPROC_PARAM_PATTERN_IMG YUV422_ONE HD_VIDEOENC_PARAM_IN_STAMP_IMG ARGB1555, ARGB8888 HD_VIDEOOUT_PARAM_OUT_STAMP_IMG ARGB1555, ARGB8888 HD_VIDEOOUT_PARAM_CLEAR_WIN YUV422_ONE","title":"Quick Start"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#1-introduction","text":"This document describes the overview of the NT9833x DVR/NVR SDK. It introduces the software/hardware requirements, step-by-step instructions to setup the development environment and how to build and run the image. Chapter 4 introduces the boot up sequence. Chapter 5 introduces the concept of HDAL APIs and gives several sample codes to explain these APIs usage.","title":"1 Introduction"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#2-environment-overview","text":"","title":"2 Environment Overview"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#21-general-description","text":"This SDK will use Linux OS as development environment. To install Ubuntu OS, please refer NT9833x_SDK_Pure_Linux_Programming_Guide_en.pdf . After Linux OS installed, unpack SDK package under Linux, then you can build your DVR/NVR firmware. When your Firmware is ready, connect EVB to PC, and upgrade it to EVB.","title":"2.1 General Description"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#22-sdk-package","text":"Using the following instructions to decompress SDK package under Linux: \\$ tar -jxvf NT9833x_SDK_release_{VERSION}.tar.bz2 You will get the folder tree as below: \u251c\u2500\u2500 hardware hardware document folder \u251c\u2500\u2500 board \u251c\u2500\u2500 document HW application note, and PCB/EVB document \u251c\u2500\u2500 chip \u251c\u2500\u2500 document chip datasheet \u251c\u2500\u2500 software software folder \u251c\u2500\u2500 board Linux SDK package and loader \u251c\u2500\u2500 document Linux and HDAL library document \u251c\u2500\u2500 chip \u251c\u2500\u2500 document chip document \u251c\u2500\u2500 pc PC upgrade, display and IQ tools. \u251c\u2500\u2500 document PC tool document \u251c\u2500\u2500Disclaimer.pdf Disclaimer document","title":"2.2 SDK Package"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#23-system-board-connection","text":"1. 12V input 2. eth1 3. Top: eth0; middle: Not use; bottom: USB 2.0 4. USB 3.0 5. VGA output 6. HDMI output 7. USB 2.0 8. UART console 9. Boot sequence switch To update FW on the system board, please follow the following steps. 1. Connect UART console port to PC. 2. Connect 12V to power connector. 3. Connect the bottom USB port to PC. 4. Set J20 to 0, J21 to 1 and J22 to 0 to enter UART FW upgrade mode. And set J20 to 0, J21 to 0 and J22 to 1 to boot from NAND flash. 5. Connect HDMI output to your display device. Please refer to NT9833x_Quick_Bringup_User_Guide_en.pdf for detail information about the FW update.","title":"2.3 System Board Connection"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#231-98633-evb","text":"The 98633 board is different from the 98336 board, please refer to the below figure or refer to NT98633_NVR_EVB_User Guide_V1.0.pdf to setup the hardware environment.","title":"2.3.1 98633 EVB"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#3-environment-setup","text":"","title":"3 Environment Setup"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#31-cross-compiler-setup","text":"Toolchain: \uf06c glib: aarch64-ca53-linux-gnueabihf-8.4 Please install the toolchain as following command \\$ sudo tar \u2013jxvf aarch64-ca53-linux-gnueabihf-8.4.tar.bz2 -C /opt If you want to change path, please modify the CROSS_TOOLCHAIN_PATH parameter in the build/envsetup.sh .","title":"3.1 Cross Compiler Setup"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#32-sdk-setup","text":"Using the following instructions to decompress SDK pack under Linux. \\$tar \u2013jxvf na51090_linux_sdk.tar.bz2 You will get the folder tree as below: \u251c\u2500\u2500na51090_linux_sdk\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..Used to put unpacked SDK source code, \u251c\u2500\u2500 BSP \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026Include linux, busybox, uboot and rootfs source \u251c\u2500\u2500 build \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..scripts for the environment setup \u251c\u2500\u2500 code \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026HDAL linux drivers and sample code \u251c\u2500\u2500 configs\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026Model settings \u251c\u2500\u2500 Makefile\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026Top level Makefile \u251c\u2500\u2500 tools\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.target board tool Before each opened a new Terminal window needs to compiler environment setting, the relevant variables set up, please follow the below instructions to finish it, \\$ cd na51090_linux_sdk \\$ source build/envsetup.sh Please do a complete compilation for first time. Select your model: \\$lunch List your nvt build setting \\$get_stuff_forenvironment Build overall system: \\$make all","title":"3.2 SDK Setup"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#33-build-image","text":"After the \u201cmake all\u201d command. It will generate the images under \u201cna51090_linux_sdk/output\u201d folder. The details are listed as below: \u251c\u2500\u2500 na51090_linux_sdk/\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 Put unpacked source code and image \u251c\u2500\u2500 Makefile\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. Top level Makefile \u251c\u2500\u2500 output/\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.. Compiled output image \u251c\u2500\u2500 packed/ \u251c\u2500\u2500 FW98336A.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026 nvtpack image (All-in-one image) \u251c\u2500\u2500 preburn_image/ \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026 the pre-burn images, you can copy these files into \\DFUTools\\image, and burn into the system board via DFU tool. \u251c\u2500\u2500 raw/ \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. raw format of the output image \u251c\u2500\u2500 Image.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.. Linux Image \u251c\u2500\u2500 u-boot.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 uboot image with nvt checksum \u251c\u2500\u2500 u-boot.lz.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 uboot image (LZ compressed) \u251c\u2500\u2500 u-boot.lzma.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 uboot image (LZMA compressed) \u251c\u2500\u2500 rootfs.ramdisk.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. ramdisk image (rootfs) \u251c\u2500\u2500 rootfs_1.rw.ubifs.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026. rootfs overlay \u251c\u2500\u2500 DVRxxxxxxx.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 mnt\\mtd partition \u251c\u2500\u2500 nvt-all.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. linux kernel fdt \u251c\u2500\u2500 atf.bin\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..\u2026\u2026\u2026\u2026. arm-trusted-\u200bfirmware \u251c\u2500\u2500 FW98336A.ini\u2026\u2026\u2026\u2026\u2026..\u2026\u2026\u2026\u2026. the layout to pack to FW98336A.bin The na51090_linux_sdk folder has a top level Makefile , it supports many of the make command, such as \u201c make linux \u201d is to compile linux-kernel, \u201c make uboot \u201d can compile u-boot, \u201c make rootfs \u201d\u2026you can use \u201c make help \u201d to find what its commands are support. Please use top level Makefile to do SDK compilation to avoid some link error occurred . Its help description is as follows: \\$ make help make help -> show make command info make all -> build all make linux -> build linux-kernel make linuxram -> build linux-kernel with ramdisk support make modules -> build built-in kernel modules make driver -> build NVT linux driver modules make atf -> build ARM trusted firmware make uboot -> build loader(uboot) make optee_os -> build OPTEE kernel make optee_client -> build OPTEE client make library -> build library make busybox -> build busybox make rootfs -> build rootfs make app -> build applications make tools -> build tools make sample -> build sample code make post -> run postprocessing script make pack -> Generate nvtpack image and preburn images make publish -> remove some sources for publish ===================================================== make linux_config -> config linux-kernel make linux_config_gcov-> modify kernel config for code coverage tool make uboot_config -> config uboot make busybox_config -> config busybox make linux_header -> generate linux-kernel out of tree headers ===================================================== make clean -> clean all make linux_clean -> clean linux-kernel & built-in kernel modules make driver_clean -> clean NVT linux driver modules make atf_clean -> clean ARM trusted firmware make uboot_clean -> clean loader(uboot) make optee_os_clean -> clean optee kernel make optee_client_clean -> clean optee client application make library_clean -> clean library make busybox_clean -> clean busybox make rootfs_clean -> clean rootfs make app_clean -> clean applications make tools_clean -> clean tools make sample_clean -> clean sample code make post_clean -> run postprocessing clean script make pack_clean -> Remove nvtpack image =====================================================","title":"3.3 Build Image"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#34-run-the-first-sample","text":"After \u201c make all \u201d, you can get the images in \u201cna51090_linux_sdk/output\u201d . And to try the images, you can select the jumper setting in EVB to enter FW upgrade mode first, and then use the following tool \u201c FwUpgrade.exe \u201d to burn the images into the flash memory. The all-in-one image (\\na51090_linux_sdk\\output\\packed\\FW98336A.bin) is packed by the description in \\na51090_linux_sdk\\configs\\Linux\\cfg_XXX\\nvt-nvtpack.dtsi: /* * Novatek Ltd. BSP part of dts */ \\&nand { /** * partition_name is \\$1 as in partition_\\$1 is referred * to nvt-na51090-storage-partition. dtsi */ nvtpack { ver = \u201cNVTPACK_FW_INI_16072017\u201d; /* Fixed */ method = \\<1>; /* Fixed */ index { id0 { partition_name = \u201cloader\u201d; source_file = \u201c\u201d; }; /* Fixed */ id1 { partition_name = \u201cfdt\u201d; source_file = \u201cnvt-all.bin\u201d; }; /* Fixed */ id2 { partition_name = \u201cfdt.restore\u201d; source_file = \u201c\u201d; }; /* Fixed */ id3 { partition_name = \u201catf\u201d; source_file = \u201catf.bin\u201d; }; id4 { partition_name = \u201cuboot\u201d; source_file = \u201cu-boot.bin\u201d; }; id5 { partition_name = \u201cuenv\u201d; source_file = \u201c\u201d; }; id6 { partition_name = \u201ckernel\u201d; source_file = \u201cImage.bin\u201d; }; id7 { partition_name = \u201crootfs\u201d; source_file = \u201crootfs.ramdisk.bin\u201d; }; id8 { partition_name = \u201crootfs1\u201d; source_file = \u201crootfs_1.rw.ubifs.bin\u201d; }; id9 { partition_name = \u201capp\u201d; source_file = \u201cDVR_16CH.nand.ubifs.bin\u201d; }; }; }; }; And the partition order must be the same as \\na51090_linux_sdk\\configs\\Linux\\cfg_XXX\\nvt-storage-partition.dtsi. After the upgrade is done, power on the target board, you can get the sample in the \u201c /mnt/mtd \u201d folder. And you can run the first sample code: root@NVTEVM:/mnt/mtd\\$ ./liveview_1div_to_4div Note: You may run the \u201cdisplay_with_change_mode\u201d first to select your LCD resolution. The more sample codes are placed in \u201c na51090_linux_sdk/code/hdal/samples \u201d. For more information about the firmware upgrade tool, you can refer to the document \u201c NT9833x_Quick_Bringup_User_Guide_en.pdf \u201d.","title":"3.4 Run the First Sample"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#4-boot-up-sequence","text":"","title":"4 Boot-up Sequence"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#41-overview-of-booting-procedure","text":"The following figure shows the booting sequence of NT9833x SDK. When the NT9833x system is powered on, the embedded ROM code is executed. The ROM code loads the loader code from the flash into the embedded SRAM and then executes the loader. The loader initializes DDR and loads FDT, ATF, OPTEE(optional) and uboot from the flash into DDR and jump into ATF. The ATF runs the arm trusted firmware and boot OPTEE(optional) and then jump into the uboot. The uboot initializes the basic hardware and loads linux image from the flash into DDR, and then bring up the linux kernel. Two stages during the linux bring up: the vg_boot.sh add the device modules into the linux kernel and the module_init initiates the external devices, such as AD, audio and the displayer.","title":"4.1 Overview of Booting Procedure"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#42-vg_bootsh","text":"The script file \u201cvg_boot.sh\u201d: #boot_ver=v1.5 #chipver=`head -1 /proc/pmu/chipver` #chipid=`echo \\$chipver | cut -c 1-4` echo ----------------------------------------------------------- echo \u201d Boot DVR_16CH\u201d echo ----------------------------------------------------------- echo \u201c/sbin/mdev\u201d > /proc/sys/kernel/hotplug MODEL_PATH=\\$(dirname \\$MODEL) MODEL_NAME=\u201d\\${MODEL_PATH##*/}\u201d AD_MODULE=\u201dtechpoint\u201d echo This model is \\$MODEL_NAME modprobe nvt_dmasys modprobe log log_ksize=4096 crash_notify=/mnt/mtd/crash.sh #crash to execute /mnt/mtd/crash.sh echo /tmp > /proc/videograph/dumplog #change log path to /tmp modprobe kdrv_cc_event modprobe ms max_channels=16 modprobe em max_channels=16 modprobe lcd_codec modprobe nvt_tve100 modprobe nvt_hdmi20 modprobe flcd300-common modprobe flcd300-pip gui_ddr=0 suspend_state=1 modprobe flcd300-pip1 gui_ddr=0 suspend_state=1 modprobe flcd200-common modprobe flcd200-pip gui_ddr=0 suspend_state=1 echo i2c 0x10011 > /proc/nvt_info/nvt_pinmux/pinmux_set ## [NT98336 SYS] 16CH, camera support to 1080P@30, 4M@15, 5M@10 #if [ \u201c\\$AD_MODULE\u201d == \u201ctechpoint\u201d ]; then ## modprobe tp28xx_kdrv drv_mode=0 dev_num=2 ibus=0,1 iaddr=0x88,0x8a vout_mode=3,3 video_mux=1 vout_xcap=0x03040000,0x01020000 vout_vi=0x03040000,0x01020000 clk_dly=0x00000000,0x00000000 clk_inv=0x01010000,0x01010000 ch_map=2 clk_used=0x1 rstb_used=106 clk_driving=2 #else ## modprobe nvp6158_kdrv drv_mode=0 dev_num=2 ibus=0,0 iaddr=0x60,0x62 vout_mode=4,4 vout_xcap=0x0201,0x0403 vout_vi=0x0201,0x0403 vout_cdly=0x0606,0x0606 clk_dly=0x0000,0x0000 clk_inv=0x0000,0x0000 ch_map=1 clk_used=0x1 rstb_used=106 clk_driving=2 #fi modprobe tp28xx_kdrv dev_num=4 ibus=0,0,1,1 iaddr=0x88,0x8a,0x8c,0x8e vout_mode=3,3,3,3 video_mux=1 vout_xcap=0x0201,0x0304,0x0506,0x0708 vout_vi=0x0201,0x0304,0x0506,0x0708 vout_cdly=0x0300,0x0300,0x0300,0x0200 ch_map=1 clk_used=0xf clk_driving=2 modprobe vcap316_common modprobe vcap316_host0 sync_time_div=90 modprobe kdrv_vpe modprobe kflow_vpe mod_init=1 max_chip_num=1 max_eng_num=2 max_minor_num=127 max_md_lv_num=16 max_total_cam_ch=85 sw_bal_mode=1 modprobe nvt_audio modprobe kflow_audio modprobe kdrv_dei modprobe kflow_dei max_chip_num=2 max_eng_num=1 max_minor_num=64 max_total_cam_ch=85 modprobe kdrv_jpg jpeg_enc_max_chn=53 jpeg_dec_max_chn=32 modprobe kdrv_venc h26x_enc_max_width=2560 h26x_enc_max_height=1440 max_total_cam_ch=53 modprobe nvt_vencrc modprobe kflow_videoenc modprobe h26xdec h26xd_max_width=2560 h26xd_max_height=1440 max_total_cam_ch=32 modprobe kflow_videodec modprobe kdrv_osg modprobe kflow_osg modprobe kdrv_ssca modprobe kdrv_age modprobe kflow_gfx modprobe kdrv_ai modprobe kflow_cnn modprobe kflow_nue modprobe kflow_nue2 modprobe kflow_cpu modprobe kflow_dsp modprobe kflow_ai_net modprobe gs max_channels=16 modprobe usr_proc modprobe vpd quiet=0 max_channels=16 modprobe ddr_arb echo doing mdev-s mdev -s echo done!! ## Syntax: module_init [dtb_file] [is_dump_dts] [is_init_videocap] [is_init_videoout] [is_init_audio] [is_show_logo] if [ \u201c\\$AD_MODULE\u201d == \u201ctechpoint\u201d ]; then /mnt/mtd/module_init /mnt/mtd/cfg_DVR_16CH.dtb 0 1 1 1 0 & else /mnt/mtd/module_init /mnt/mtd/cfg_DVR_16CH.dtb 0 2 1 1 0 & fi The vg_boot.sh insert the device modules into the linux kernel and finally run the module_init program to initiate the video input/output. For more information about the parameters of the device module, please refer to NT9833x_Module_Parameters_en.pdf .","title":"4.2 vg_boot.sh"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#43-module_initc","text":"The main functions of module_init.c are the buffer management and the external devices handling. The following figure shows the program flow of module_init.c .","title":"4.3 module_init.c"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#431-memory-pool-setup","text":"9833x system memory placement descripts in the file nvt-mem-tbl.dtsi : /* Linux system memory region*/ memory { device_type = \u201cmemory\u201d; reg = \\<0x0 0x00000000 0x0 0x2FD00000>; /* [addr-H] [addr-L] [size-H] [size-L] */ }; hdal-memory { #address-cells = \\<4>; #size-cells = \\<2>; media { reg = \\< 0x0 0x0 0x0 0x2FD00000 0x0 0x10300000 /* DDR ID H, L ADDR H, L, SIZE H, L */ 0x0 0x1 0x1 0x00000000 0x0 0x40000000 /* DDR ID H, L ADDR H, L, SIZE H, L */ >; }; }; /* To config the nvt chip mapping relationship */ nvt_chip_mapping { #address-cells = \\<4>; #size-cells = \\<2>; dram_map { reg = \\< 0x0 0x0 0x0 0x00000000 0x0 0x40000000 /* DDR ID, CHIPID, ADDR H, L, SIZE H, L */ 0x1 0x0 0x1 0x00000000 0x0 0x40000000 /* DDR ID, CHIPID, ADDR H, L, SIZE H, L */ >; }; }; And about the memory pool placement in HDAL, you can use DVR_XXX.xls to calculate the pool size, and then copy the results into the cfg_DVR_XXX.dts . The HDAL memory is used in the HDAL and the module drivers. The following figure shows three scenarios for using the HDAL memory. The assign_pool_addr() in module_init.c will assign the physical address to each pool, and the memory placement will be as:","title":"4.3.1 Memory Pool Setup"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#432-video-output-setup","text":"The videoout0_setup() , videoout1_setup() and videoout2_setup() setup the video output for HDMI/VGA/CVBS: 1. hd_videoout_set(, HD_VIDEOOUT_PARAM_DEV_CONFIG, ) to setup the control parameters, such as the width, the height, the buffer address of the video plane and the GUI plane. 2. hd_videoout_set(, HD_VIDEOOUT_PARAM_FB_FMT,) to set the video format of the frame buffer of the plane. 3. hd_videoout_set(, HD_VIDEOOUT_PARAM_FB_ENABLE, ) to enable the plane. To set the video output for the same and different source, you can modify the mode and the homology parameters in the file cfg_DVR_XXX.dts . HDMI and VGA are from the same source. HDMI and VGA are from the different source. videoout0 {/*lcd300*/ mode = \u201cHD_COMMON_VIDEO_OUT_HDMI\u201d, \u2026 homology = \u201cHD_COMMON_VIDEO_OUT_VGA\u201d; \u2026 } videoout0 {/*lcd300*/ mode = \u201cHD_COMMON_VIDEO_OUT_HDMI\u201d, \u2026 homology = \u201c\u201d; \u2026 } videoout1 {/*lcd300 lite*/ mode = \u201cHD_COMMON_VIDEO_OUT_VGA\u201d, \u2026 homology = \u201c\u201d; \u2026 }","title":"4.3.2 Video Output Setup"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#433-video-input-setup","text":"The main procedure of the videocap_module_init_tp()/videocap_module_init_nvp() are as the following: 1. Initiate the AD device. For example, open \u201c/dev/tp2823dev\u201d device node. ret = vendor_ad_init(ad_dev_name); if (ret != HD_OK) goto exit; 2. Get the AD information, and organize this information as host, vi and channel information, and set them to the capture. ret = vendor_ad_get(VENDOR_AD_PARAM_TP28XX_DEVICE_INFO, \\&dev_info); \u2026 /* vcap host init, to specify vcap system vi usage and prepare requirement memory */ memset(&vcap_host, 0, sizeof(vcap_host)); vcap_host.host = 0;//only support 0 vcap_host.md.enable = dt_hdal_spec.vcap_host.md.enable; vcap_host.md.mb_x_num_max = dt_hdal_spec.vcap_host.md.mb_x_num_max; vcap_host.md.mb_y_num_max = dt_hdal_spec.vcap_host.md.mb_y_num_max; vcap_host.md.buf_src = dt_hdal_spec.vcap_host.md.buf_src; for (i = 0; i\\< dev_info.dev_num; i++) { for(j = 0; j\\< VENDOR_AD_TP28XX_VOUT_MAX; j++) { \u2026 vcap_host.vi[vcap_host.nr_of_vi].chip = VENDOR_AD_PLAT_VI_TO_CHIP_ID(dev_info.dev[i].vout[j].vi - 1); vcap_host.vi[vcap_host.nr_of_vi].vcap = VENDOR_AD_PLAT_VI_TO_CHIP_VCAP_ID(dev_info.dev[i].vout[j].vi - 1); vcap_host.vi[vcap_host.nr_of_vi].vi = VENDOR_AD_PLAT_VI_TO_VCAP_VI_ID(dev_info.dev[i].vout[j].vi - 1); \u2026 } } \u2026 ret = hd_videocap_drv_set(HD_VIDEOCAP_DRV_PARAM_INIT_HOST, \\&vcap_host); \u2026 /* VCAP VI Register */ for (i=0; i\\<dev_info.dev_num; i++) { for (j=0; j\\<VENDOR_AD_TP28XX_CHANNELS_PER_CHIP; j++) { \u2026 memset(&vcap_vi, 0, sizeof(vcap_vi)); vcap_vi.chip = VENDOR_AD_PLAT_VI_TO_CHIP_ID(dev_info.dev[i].vout[j].vi - 1); vcap_vi.vcap = VENDOR_AD_PLAT_VI_TO_CHIP_VCAP_ID(dev_info.dev[i].vout[j].vi - 1); vcap_vi.vi = VENDOR_AD_PLAT_VI_TO_VCAP_VI_ID(dev_info.dev[i].vout[j].vi - 1); vcap_vi.global.src = dev_info.dev[i].vout[j].xcap - 1; vcap_vi.global.format = HD_VIDEOCAP_VI_FMT_BT656; vcap_vi.global.id_extract = HD_VIDEOCAP_VI_CHID_EAV_SAV; \u2026 ret = hd_videocap_drv_set(HD_VIDEOCAP_DRV_PARAM_REGISTER_VI, \\&vcap_vi); } } \u2026 /* VCH ID */ for (i=0; i\\<dev_info.dev_num; i++) { for (j=0; j\\<VENDOR_AD_TP28XX_CHANNELS_PER_CHIP; j++) { \u2026 memset(&ch_param, 0, sizeof(ch_param)); ch_param.chip = dev_info.dev[i].vin[j].chip; ch_param.vcap = dev_info.dev[i].vin[j].vcap; ch_param.vi = dev_info.dev[i].vin[j].vi; ch_param.ch = dev_info.dev[i].vin[j].ch; ch_param.value = dev_info.dev[i].vin[j].vch_id; ch_param.pid = HD_VIDEOCAP_VI_CH_PARAM_VCH_ID; \u2026 ret = hd_videocap_drv_set(HD_VIDEOCAP_DRV_PARAM_VI_CH_PARAM, \\&ch_param); } } 3. Polling and notify the channel video norm switch. ret = vendor_ad_get(VENDOR_AD_PARAM_TP28XX_VIDEO_NORM, \\&video_norm); \u2026 /* check video norm */ if (memcmp(&video_norm, \\&p_init_info->g_ch_norm[i][j], sizeof(video_norm)) == 0) goto chk_loss; ch_norm.chip = dev_info.dev[i].vin[j].chip; ch_norm.vcap = dev_info.dev[i].vin[j].vcap; ch_norm.vi = dev_info.dev[i].vin[j].vi; \u2026 ret = hd_videocap_drv_set(HD_VIDEOCAP_DRV_PARAM_VI_CH_NORM3, \\&ch_norm); \u2026 memcpy(&p_init_info->g_ch_norm[i][j], \\&video_norm, sizeof(video_norm)); 4. Polling and notify the channel video loss. ret = vendor_ad_get(VENDOR_AD_PARAM_TP28XX_VIDEO_LOSS, \\&ch_loss); \u2026 /* check video loss */ if (ch_loss.is_lost == p_init_info->g_ch_loss[i][j]) continue; ch_param.chip = dev_info.dev[i].vin[j].chip; ch_param.vcap = dev_info.dev[i].vin[j].vcap; ch_param.vi = dev_info.dev[i].vin[j].vi; ch_param.pid = HD_VIDEOCAP_VI_CH_PARAM_VLOS; \u2026 ret = hd_videocap_drv_set(HD_VIDEOCAP_DRV_PARAM_VI_CH_PARAM, \\&ch_param); \u2026 p_init_info->g_ch_loss[i][j] = ch_loss.is_lost;","title":"4.3.3 Video Input Setup"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#5-hardware-device-abstraction-layer-hdal","text":"","title":"5 Hardware Device Abstraction Layer (HDAL)"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#51-concept","text":"HDAL is the acronym of Hardware Device Abstraction Layer. It replaces the part being occupied by HAL (Hardware Abstraction Layer) in existing SW Architecture for the device transparent from independent devices and platforms, including the product, IP Camera, DVR and NVR. For the existing HAL, it is created in the Chip-dependent structure, therefore when the chip is changed to Novatek or others, the APIs of HAL have to be changed depending on the change of chip at times. It is the object of HDAL to replace HAL and perform the function using Chip-independent Common API. Moreover, by providing only the header of HDAL API to chip venders and letting them implement the contents by themselves, the Middleware developers can implement this even though they are not aware of technological details. That is the HDAL is the common modules with common reused APIs, there is vendor interfaces for the customization for the dependent appliance, like AI or image quality modules. There are 2 types of modules, the streaming and utility modules. The streaming modules defined for audio input, video input, audio output, video output, audio encoder, video encoder, audio decoder, video decoder and video processing. The streaming module is the code to control the flow of video or audio content sent in compressed or raw form over the Internet or device. If the modules are not related with streaming, we called utility modules. That is to perform, like initialize the HDAL, graphics functions, debug functions and etc. Streaming modules: Module Function HD_VIDEOCAP As it is for the video input features, it performs the feature of informing the video input state information. HD_VIDEOOUT It performs the controlling related to Video output which is connected like to the Panel or HDMI and the Video Post controlling features HD_VIDEOENC It provides the APIs which can control the Video Encoder. HD_VIDEODEC It takes the charge of filtering the Video, Video Decoding and the feature of controlling video Decoder. HD_VIDEOPROC Being divided as the video processing feature separately, it is the API which sets the Resolution, Video Size and Video Position and performs the frame rate conversion feature. The main feature is video process controlling however, the features of which the video out are controlled separately should be performed by this instance. HD_AUDIOCAP As it is for the audio input features, it performs the feature of informing the audio input setting and state information. HD_AUDIOOUT It performs the auxiliary output features of Audio. The Audio auxiliary output refers like to Analog Audio output and HDMI digital output. HD_AUDIOENC It provides the APIs which can control the Audio Encoder. HD_AUDIODEC It takes the charge of Audio Decoding and the feature of controlling Audio Decoder flow and format. Utility modules: Module Function hd_gfx In charge of functions related to Graphic plane. hd_debug In charge of debug function, like HDAL Debug Menu entry point. hd_logger Directive printf function to difference interfaces. hd_util Supplies utility function which could be used in HDAL such as key input, Print etc. Basic APIs: API name Description hd_xxx_init() Responsible for initializing the class, especially for the global setting. Generally it is Called only once at system initialization, or when memory state changes. hd_xxx_uninit() Responsible for un-initializing the global setting of the class. Generally it is Called only once at system un-initialization, or when memory state changes. hd_xxx_open() Responsible for opening an instance from the class. Generally it is Called after the class was initialized. The function is used to call for opening multiple instances. hd_xxx_close() Responsible for closing an instance of the class. Generally it is Called to close the instance setting. The instance will be removed after calling this function. hd_xxx_bind() Each Instance is called up when it is connected with fore-end or back-end of Instance. Generally, relevant Instance ID and front terminal Instance ID are used for input parameter, but for some instances, additional input parameter is needed. Call for hd_xxx_bind() function is only valid under Disconnect status and if tried to Connect to change connection status without disconnecting at Bind status, Error will occur. hd_xxx_unbind() It is called up when unbind is required after each instance is connected. Since only the concerned instance\u2019s ID will be given as parameter, the hd_xxx_unbind() disconnects the front and back connection as referring to the concerned Instance\u2019s ID. hd_xxx_get() It is used upon taking the information of each Instance\u2019s settings. This API is used when taking the previous setting information before calling up the hd_xxx_set() and then changing only the settings value to be changed. The using method will be displayed along with the hd_xxx_set() example. hd_xxx_set() It is used upon setting the information for each instance settings. There is the structure for the instance-wise setting information, in order to change the setting information, call the hd_xxx_get() to get the structure for the previous setting information and then change only the value which is wished to be changed and then call up the hd_xxx_set(). If the hd_xxx_get() is called up after calling up hd_xxx_init(), the settings value will be all entered in to the HD_INVALID. If the setting variable in the implementation part of the hd_xxx_set() is HD_INVALID, it should be implemented not to set the variable but to skip it. For more information, please refer to the document \u201c Novatek HDAL Programmer\u2019s Guide.pdf \u201d.","title":"5.1 Concept"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#52-sample-codes","text":"","title":"5.2 Sample Codes"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#521-encode","text":"I. encode_with_nr.c Stream Flow: root@NVTEVM:\\~\\$ cat /proc/videograph/graph entity (jobs) pool name (done buffers/max buffers) ----------------------------------------------------------- vcap0_0_4_0 (4) (enc_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->*kflow_osg_0_0_10 (0) (enc_cap_out_ddr0, \u2013, \u2013, \u2013) (0/0) ->h26xenc_0_0_0 (0) (enc_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->dataout_0_0_0 (0) Sample code flow: 1. Initiate the HDAL. ret = hd_common_init(1); //the parameter is reserved for the future. 2. Initiate the capture and the encoder modules. if ((ret = hd_videocap_init()) != HD_OK) { return ret; } if ((ret = hd_videoenc_init()) != HD_OK) { return ret; } 3. Open the capture and the encoder modules. if ((ret = hd_videocap_open(SAMPLE_VCAP_IN_ID, SAMPLE_VCAP_OUT_ID, \\&p_streams->cap0_path_id)) != HD_OK) { return ret; } if ((ret = hd_videoenc_open(SAMPLE_VENC_IN_ID, SAMPLE_VENC_OUT_ID, \\&p_streams->enc0_path_id)) != HD_OK) { return ret; } 4. Initiate the video process, such as Noise Reduction. ret = vendor_video_init(streams.videoenc_path); if (ret != HD_OK) { goto exit; } 5. Set the capture configure and parameters. The data_pool (the buffer name is enc_cap_out_ddr0) is allocated from the HD_COMMON_MEM_ENC_CAP_OUT_POOL, the buffer size of the capture output is fixed and the counts/max_counts should not be larger than \u201cYUV buffer count\u201d in the \u201cencode\u201d sheet of DVR_xch.xls. Only one data_pool is valid for the capture, so data_pool[1\\~3].mode must set to disable. //use HD_VIDEOCAP_PARAM_PATH_CONFIG to set the memory pool configure. cap_config.data_pool[0].mode = HD_VIDEOCAP_POOL_ENABLE; cap_config.data_pool[0].ddr_id = SAMPLE_VCAP_DDR_ID; cap_config.data_pool[0].counts = HD_VIDEOCAP_SET_COUNT(4, 0); cap_config.data_pool[0].max_counts = HD_VIDEOCAP_SET_COUNT(4, 0); cap_config.data_pool[1].mode = HD_VIDEOCAP_POOL_DISABLE; cap_config.data_pool[2].mode = HD_VIDEOCAP_POOL_DISABLE; cap_config.data_pool[3].mode = HD_VIDEOCAP_POOL_DISABLE; ret = hd_videocap_set(cap_path_id, HD_VIDEOCAP_PARAM_PATH_CONFIG, \\&cap_config); //use HD_VIDEOCAP_PARAM_OUT to set the output dimension and the pixel format. ret = hd_videocap_set(cap_path_id, HD_VIDEOCAP_PARAM_OUT, \\&cap_out); 6. Set the encoder configure and parameters. The data_pool (the buffer name is enc_out_ddr0) is allocated from the HD_COMMON_MEM_ENC_OUT_POOL. And only one data_pool is valid for the encoder, so data_pool[1\\~3].mode must set to disable. //use HD_VIDEOENC_PARAM_PATH_CONFIG to set the memory pool configure. enc_config.data_pool[0].mode = HD_VIDEOENC_POOL_ENABLE; enc_config.data_pool[0].ddr_id = 0; enc_config.data_pool[0].counts = HD_VIDEOENC_SET_COUNT(4, 0); enc_config.data_pool[0].max_counts = HD_VIDEOENC_SET_COUNT(4, 0); enc_config.data_pool[1].mode = HD_VIDEOENC_POOL_DISABLE; enc_config.data_pool[2].mode = HD_VIDEOENC_POOL_DISABLE; enc_config.data_pool[3].mode = HD_VIDEOENC_POOL_DISABLE; ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_PATH_CONFIG, \\&enc_config); //use HD_VIDEOENC_PARAM_IN to set the input dimension and the pixel format. ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_IN, \\&video_in_param); //use HD_VIDEOENC_PARAM_OUT_ENC_PARAM to set the parameters of the codec. ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_OUT_ENC_PARAM, \\&enc_param); //use HD_VIDEOENC_PARAM_OUT_RATE_CONTROL to set the parameters of the rate control. ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_OUT_RATE_CONTROL, \\&rc_param); 7. Bind the capture and the encoder modules, and then the stream will flow from the capture to the encoder. ret = hd_videocap_bind(SAMPLE_VCAP_OUT_ID, SAMPLE_VENC_IN_ID); if (ret != HD_OK) { printf(\u201cvideocap bind fail\\n\u201d); goto exit; } 8. Start the capture and the encoder modules. ret = hd_videocap_start(streams.cap0_path_id); if (ret != HD_OK) { printf(\u201cstart cap fail\\n\u201d); goto exit; } ret = hd_videoenc_start(streams.enc0_path_id); if (ret != HD_OK) { printf(\u201cstart enc fail\\n\u201d); goto exit; } 9. Create a thread to encode the stream from the capture. The main procedure in this thread is using the hd_videoenc_poll_list() API to check the stream is ready or not. If the stream is ready, use hd_videoenc_recv_list() API to receive it. static void *encode_thread(void *arg) { \u2026 while (0 == p_streams->enc_exit) { ret = hd_videoenc_poll_list(poll_list, MAX_BITSTREAM_NUM, 500); \u2026 if ((ret = hd_videoenc_recv_list(recv_list, MAX_BITSTREAM_NUM)) \\< 0) { printf(\u201cError return value %d\\n\u201d, ret); } else { for (i = 0; i \\< MAX_BITSTREAM_NUM; i++) { //process the receive the encoded bitstreams } } } \u2026 } 10. Wait the key press \u2018q\u2019 to exit the thread. 11. Stop the capture and the encoder modules. if (HD_OK != hd_videocap_stop(streams.cap0_path_id)) { printf(\u201cstop cap fail\\n\u201d); } if (HD_OK != hd_videoenc_stop(streams.enc0_path_id)) { printf(\u201cstop enc fail\\n\u201d); } 12. Unbind the capture and the encoder modules. if (HD_OK != hd_videocap_unbind(SAMPLE_VCAP_OUT_ID)) { printf(\u201chd_videocap_unbind fail\\n\u201d); } 13. Close the capture and the encoder modules. if ((ret = hd_videocap_close(p_streams->cap0_path_id)) != HD_OK) { return ret; } if ((ret = hd_videoenc_close(p_streams->enc0_path_id)) != HD_OK) { return ret; } 14. Un-initiate the capture and the encoder modules. if ((ret = hd_videocap_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoenc_uninit()) != HD_OK) { return ret; } 15. Un-initiate the HDAL. ret = hd_common_uninit(); II. encode_with_osg.c Stream flow: root@NVTEVM:\\~\\$ cat /proc/videograph/graph entity (jobs) pool name (done buffers/max buffers) ----------------------------------------------------------- vcap0_0_4_0 (4) (enc_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->*kflow_osg_0_0_10 (0) (enc_cap_out_ddr0, \u2013, \u2013, \u2013) (0/0) ->h26xenc_0_0_0 (0) (enc_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->dataout_0_0_0 (1) root@NVTEVM:\\~\\$ cat /proc/hdal/flow \u2026 hd_videoenc_set(IN_STAMP_IMG): path_id(0x22008201) pxlfmt(0x21101555) dim(400,100) ddr(0) pa(0x1655a000) hd_videoenc_set(IN_STAMP_ATTR): path_id(0x22008201) type(0) alpha(7) pos(0,0) gcac_en(0) gcac_w(64) gcac_h(32) pa(0x1655a000) ddr(0) \u2026 The sample code flow is the same as the \u201c encode_with_nr.c \u201d, except for the additional function of OSG. 1. Open the OSG stamp module. if ((ret = hd_videoenc_open(HD_VIDEOENC_IN(SAMPLE_VENC_DEV_ID, HD_STAMP(i)), SAMPLE_VENC_OUT_ID, \\&p_streams->stamp_path_id[i])) != HD_OK) { return ret; } 2. Set the OSG parameters. //use HD_VIDEOENC_PARAM_IN_STAMP_IMG to set OSG image dimension and the pixel format. img.p_addr = p_stamp->pa; img.dim.w = p_stamp->dim.w; img.dim.h = p_stamp->dim.h; img.ddr_id = SAMPLE_STAMP_DDR_ID; img.fmt = HD_VIDEO_PXLFMT_ARGB1555; ret = hd_videoenc_set(stamp_path_id, HD_VIDEOENC_PARAM_IN_STAMP_IMG, \\&img); //use HD_VIDEOENC_PARAM_IN_STAMP_ATTR to set alpha, align, background dimension\u2026 attr.align_type = HD_OSG_ALIGN_TYPE_TOP_LEFT; attr.alpha = ALPHA_100; attr.position.x = p_pos->x; attr.position.y = p_pos->y; attr.gcac_enable = 0; attr.gcac_blk_width = 64; attr.gcac_blk_height = 32; ret = hd_videoenc_set(stamp_path_id, HD_VIDEOENC_PARAM_IN_STAMP_ATTR, \\&attr); 3. Start the OSG module. After starting the module, the OSG image will paste on the encoded stream. ret = hd_videoenc_start(streams.stamp_path_id[idx]); if (ret != HD_OK) { printf(\u201cstart enc stamp fail = %d\\n\u201d, ret); goto exit; } 4. Run the encode_thread() and wait \u2018q\u2019 key to exit the program. 5. Stop the OSG module. if (HD_OK != hd_videoenc_stop(streams.stamp_path_id[idx])) { printf(\u201cstop enc stamp [%ld] fail\\n\u201d, idx); } 6. Close the OSG stamp module. if ((ret = hd_videoenc_close(p_streams->stamp_path_id[i])) != HD_OK) { return ret; } III. encode_with_mask.c Stream flow: root@NVTEVM:\\~\\$ cat /proc/videograph/graph entity (jobs) pool name (done buffers/max buffers) ----------------------------------------------------------- vcap0_0_4_0 (4) (enc_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->*kflow_osg_0_0_10 (0) (enc_cap_out_ddr0, \u2013, \u2013, \u2013) (0/0) ->h26xenc_0_0_0 (0) (enc_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->dataout_0_0_0 (1) root@NVTEVM:\\~\\$ cat /proc/hdal/flow \u2026 hd_videoenc_set(IN_MASK_ATTR): path_id(0x2200e201) type(0x1) alpha(128) color(0) pos0(0,0) pos1(64,0) pos2(64,32) pos3(0,32) hd_videoenc_start: path_id(0x2200e201) \u2026 hd_videoenc_set(IN_MOSAIC_ATTR): path_id(0x2200e601) type(0x1) alpha(256) blk_wh(32,32) pos0(240,135) pos1(368,135) pos2(368,263) pos3(240,263) hd_videoenc_start: path_id(0x2200e601) \u2026 The sample code flow is the same as the \u201c encode_with_nr.c \u201d, except for the additional functions of the capture mask and the encode mask. 1. Open the modules of the capture mask and the encode mask. //Open the module of the capture make. if ((ret = hd_videocap_open(SAMPLE_VCAP_IN_ID, HD_VIDEOCAP_OUT(SAMPLE_VCAP_DEV_ID, HD_MASK(i)), \\&p_streams->cap0_mask_path[i])) != HD_OK) { return ret; } //Open the module of the encoder make. if ((ret = hd_videoenc_open(HD_VIDEOENC_IN(SAMPLE_VENC_DEV_ID, HD_MASK(i)), SAMPLE_VENC_OUT_ID, \\&p_streams->mask_mosaic_id[i])) != HD_OK) { return ret; } 2. Set the parameters of the capture mask and the encode mask. //use HD_VIDEOCAP_PARAM_OUT_MASK_ATTR to set the capture mask type, alpha, color, position\u2026 HD_OSG_MASK_ATTR mask = {0}; mask.type = HD_OSG_MASK_TYPE_SOLID; mask.alpha = 255; mask.color = idx; mask.position[0].x = (idx % 2) * (p_dim->w / 2) + p_dim->w / 8; mask.position[0].y = (idx / 2) * (p_dim->h / 2); mask.position[1].x = mask.position[0].x + 64; mask.position[1].y = mask.position[0].y; mask.position[2].x = mask.position[1].x; mask.position[2].y = mask.position[1].y + 64; mask.position[3].x = mask.position[0].x; mask.position[3].y = mask.position[2].y; ret = hd_videocap_set(vcap_mask_path_id, HD_VIDEOCAP_PARAM_OUT_MASK_ATTR, \\&mask); //use HD_VIDEOENC_PARAM_IN_MASK_ATTR to set the encoder mask type, alpha, color, position\u2026 HD_OSG_MASK_ATTR mask_attr = {0}; mask_attr.type = HD_OSG_MASK_TYPE_SOLID; mask_attr.color = idx; mask_attr.alpha = 128; //50% transparent mask_attr.position[0].x = (idx % 2) * (p_dim->w / 2); mask_attr.position[0].y = (idx / 2) * (p_dim->h / 2); mask_attr.position[1].x = mask_attr.position[0].x + (mask_w); mask_attr.position[1].y = mask_attr.position[0].y; mask_attr.position[2].x = mask_attr.position[1].x; mask_attr.position[2].y = mask_attr.position[1].y + (mask_h); mask_attr.position[3].x = mask_attr.position[2].x - (mask_w); mask_attr.position[3].y = mask_attr.position[2].y ; ret = hd_videoenc_set(mask_path_id, HD_VIDEOENC_PARAM_IN_MASK_ATTR, \\&mask_attr); //use HD_VIDEOENC_PARAM_IN_MOSAIC_ATTR to set the encoder mosaic type, alpha, background color, position\u2026 HD_OSG_MOSAIC_ATTR mosaic_attr = {0}; mosaic_attr.type = HD_OSG_MASK_TYPE_SOLID; mosaic_attr.alpha = 256; //100% background mosaic_attr.mosaic_blk_w = mosaic_blk_w; mosaic_attr.mosaic_blk_h = mosaic_blk_h; mosaic_attr.position[0].x = (idx % 2) * (p_dim->w / 2) + (p_dim->w / 8) + 100; mosaic_attr.position[0].y = (idx / 2) * (p_dim->h / 2) + (p_dim->h / 8) + 100; mosaic_attr.position[1].x = mosaic_attr.position[0].x + (mosaic_blk_w)*4; mosaic_attr.position[1].y = mosaic_attr.position[0].y; mosaic_attr.position[2].x = mosaic_attr.position[1].x; mosaic_attr.position[2].y = mosaic_attr.position[1].y + (mosaic_blk_h)*4; mosaic_attr.position[3].x = mosaic_attr.position[2].x - (mosaic_blk_w)*4; mosaic_attr.position[3].y = mosaic_attr.position[2].y; ret = hd_videoenc_set(mosaic_path_id, HD_VIDEOENC_PARAM_IN_MOSAIC_ATTR, \\&mosaic_attr); 3. Start the modules of the capture mask and the encode mask. After starting these modules, the mask images will paste on the encoded stream. //Start the module of the capture make. cur_path_id = p_path_id_list[mask_idx]; ret = hd_videocap_start(cur_path_id); //Start the module of the encoder make. ret = hd_videoenc_start(p_path_id[idx]); 4. Run the encode_thread() and wait \u2018q\u2019 key to exit the program. And you can press \u2018e\u2019 key to use hd_videocap_start() / hd_videocap_stop() to switch the capture mask to ON or OFF. And you can also press \u2018y\u2019 key to use hd_videoenc_set() to update the position of the encode mask, and then use hd_videoenc_start() to activate the new position parameters. 5. Stop the modules of the capture mask and the encode mask. //Stop the module of the capture make. if (HD_OK != hd_videocap_stop(streams.cap0_mask_path[mask_idx])) { printf(\u201cstop vcap mask [%d] fail\\n\u201d, mask_idx); } //Stop the module of the encoder make. if (HD_OK != hd_videoenc_stop(streams.mask_mosaic_id[mask_idx])) { printf(\u201cstop enc mask [%d] fail\\n\u201d, mask_idx); } 6. Close the modules of the capture mask and the encode mask. //Close the module of the capture make. if ((ret = hd_videocap_close(p_streams->cap0_mask_path[i])) != HD_OK) { return ret; } //Close the module of the encoder make. if ((ret = hd_videoenc_close(p_streams->mask_mosaic_id[i])) != HD_OK) { return ret; }","title":"5.2.1 Encode"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#522-liveview","text":"The stream flow of the sample code \u201c liveview_1div_to_4div.c \u201d: root@NVTEVM:\\~\\$ cat /proc/videograph/graph entity (jobs) pool name (done buffers/max buffers) ----------------------------------------------------------- vcap0_0_4_0 (3) (disp0_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->kflow_vpe_0_0_0 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) ->*kflow_osg_0_0_0 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/0) ->lcd0vg_0_0_0 (2) vcap0_0_6_0 (3) (disp0_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->kflow_vpe_0_0_1 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) vcap0_0_0_0 (3) (disp0_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->kflow_vpe_0_0_2 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) vcap0_0_2_0 (3) (disp0_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->kflow_vpe_0_0_3 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) Sample code flow: 1. Initiate the HDAL. ret = hd_common_init(1); //the parameter is reserved for the future. 2. Initiate the capture, the video process and the video out modules. if ((ret = hd_videocap_init()) != HD_OK) { return ret; } if ((ret = hd_videoproc_init()) != HD_OK) { return ret; } if ((ret = hd_videoout_init()) != HD_OK) { return ret; } 3. Open the capture, the video process and the video out modules. HD_VIDEOOUT_OUT(0, 0) indicates the video output 0 (LCD300) and HD_VIDEOOUT_OUT(1, 0) indicates the video output 1 (LCD200). In cfg_DVR_xxx.dts, the default setting \u2018videoout0\u2026homology = \u201cHD_COMMON_VIDEO_OUT_VGA\u201d;\u2019 of the HDMI and VGA are set to homology, it means HD_VIDEOOUT_OUT(0, 0) indicates to output to HDMI and VGA simultaneously. HD_VIDEOOUT_0_CTRL indicates the HDMI control, and we can use hd_videoout_get() to get LCD capability. for (i = 0; i \\< SAMPLE_LV_COUNT; i++) { if((ret = hd_videocap_open(HD_VIDEOCAP_IN(i, 0), HD_VIDEOCAP_OUT(i, 0), \\&p_liveview_info->cap_path[i])) != HD_OK) return ret; if((ret = hd_videoproc_open(HD_VIDEOPROC_IN(i, 0), HD_VIDEOPROC_OUT(i, 0), \\&p_liveview_info->proc_path[i])) != HD_OK) return ret; if((ret = hd_videoout_open(HD_VIDEOOUT_IN(0, i), HD_VIDEOOUT_OUT(0, 0), \\&p_liveview_info->out_path[i])) != HD_OK) return ret; } if ((ret = hd_videoout_open(0, HD_VIDEOOUT_0_CTRL, \\&p_liveview_info->out_ctrl)) != HD_OK) return ret; 4. Set the capture configure and parameters. The data_pool (the buffer name is disp0_cap_out_ddr0) is allocated from the HD_COMMON_MEM_DISP0_CAP_OUT_POOL, the buffer size of the capture output is fixed and the counts/max_counts should not be larger than \u201cCapture Count\u201d in the \u201cDisplay\u201d sheet of DVR_xch.xls. Only one data_pool is valid for the capture, so data_pool[1\\~3].mode must set to disable. //use HD_VIDEOCAP_PARAM_PATH_CONFIG to set the memory pool configure. cap_config.data_pool[0].mode = HD_VIDEOCAP_POOL_ENABLE; cap_config.data_pool[0].ddr_id = 0; cap_config.data_pool[0].counts = HD_VIDEOCAP_SET_COUNT(4, 0); cap_config.data_pool[0].max_counts = HD_VIDEOCAP_SET_COUNT(4, 0); cap_config.data_pool[1].mode = HD_VIDEOCAP_POOL_DISABLE; cap_config.data_pool[2].mode = HD_VIDEOCAP_POOL_DISABLE; cap_config.data_pool[3].mode = HD_VIDEOCAP_POOL_DISABLE; ret = hd_videocap_set(liveview_info.cap_path[i], HD_VIDEOCAP_PARAM_PATH_CONFIG, \\&cap_config); //use HD_VIDEOCAP_PARAM_OUT to set the output dimension and the pixel format. ret = hd_videocap_set(cap_path_id, HD_VIDEOCAP_PARAM_OUT, \\&cap_out); 5. Set the video process configure and parameters. The data_pool (the buffer name is disp0_in_ddr0) is allocated from the HD_COMMON_MEM_DISPLAY_IN_POOL, the buffer size of the video process output is fixed and the counts/max_counts should not be larger than \u201cDisplay Count\u201d in the \u201cDisplay\u201d sheet of DVR_xch.xls. And only one data_pool is valid for the video process, so data_pool[1\\~3].mode must set to disable. //use HD_VIDEOPROC_PARAM_DEV_CONFIG to set the memory pool configure. vpe_config.data_pool[0].mode = HD_VIDEOPROC_POOL_ENABLE; vpe_config.data_pool[0].ddr_id = 0; vpe_config.data_pool[0].counts = HD_VIDEOPROC_SET_COUNT(3, 0); vpe_config.data_pool[0].max_counts = HD_VIDEOPROC_SET_COUNT(3, 0); vpe_config.data_pool[1].mode = HD_VIDEOPROC_POOL_DISABLE; vpe_config.data_pool[2].mode = HD_VIDEOPROC_POOL_DISABLE; vpe_config.data_pool[3].mode = HD_VIDEOPROC_POOL_DISABLE; ret = hd_videoproc_set(liveview_info.proc_path[i], HD_VIDEOPROC_PARAM_DEV_CONFIG, \\&vpe_config); //use HD_VIDEOPROC_PARAM_OUT to set the position, dimension, background dimension\u2026 proc_out.rect.x = 0; proc_out.rect.y = 0; proc_out.rect.w = liveview_info.lcd_syscaps.input_dim.w; proc_out.rect.h = liveview_info.lcd_syscaps.input_dim.h; proc_out.bg.w = liveview_info.lcd_syscaps.input_dim.w; proc_out.bg.h = liveview_info.lcd_syscaps.input_dim.h; proc_out.pxlfmt = fb_fmt.fmt; proc_out.dir = HD_VIDEO_DIR_NONE; ret = hd_videoproc_set(liveview_info.proc_path[i], HD_VIDEOPROC_PARAM_OUT, \\&proc_out); 6. Set the parameters of the video out module. //use HD_VIDEOOUT_PARAM_IN_WIN_ATTR to set the position, dimension, and visible. win.rect.x = 0; win.rect.y = 0; win.rect.w = liveview_info.lcd_syscaps.input_dim.w; win.rect.h = liveview_info.lcd_syscaps.input_dim.h; win.visible = 1; ret = hd_videoout_set(liveview_info.out_path[i], HD_VIDEOOUT_PARAM_IN_WIN_ATTR, \\&win); 7. Bind the capture, the video process and the video out modules, and then the video stream will flow from the capture to the video out. if ((ret = hd_videocap_bind(HD_VIDEOCAP_OUT(i, 0), HD_VIDEOPROC_IN(i, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_bind(HD_VIDEOPROC_OUT(i, 0), HD_VIDEOOUT_IN(0, i))) != HD_OK) { return ret; } 8. Start the capture, the video process and the video out modules. The different between hd_videoXXX_start_list() and hd_videoXXX_start() is that hd_videoXXX_start_list() will start a \u201clist\u201d of XXX modules. if ((ret = hd_videocap_start_list(liveview_info.cap_path, SAMPLE_LV_COUNT)) != HD_OK) { return ret; } if ((ret = hd_videoproc_start_list(liveview_info.proc_path, SAMPLE_LV_COUNT)) != HD_OK) { return ret; } if ((ret = hd_videoout_start_list(liveview_info.out_path, SAMPLE_LV_COUNT)) != HD_OK) { return ret; } 9. After starting the modules, the video stream will flow from the capture module via the video process module to the video out module. If you press \u2018y\u2019 key, it will toggle single window and 2x2 grid windows by changing the parameters of the video process and the video out modules. And then use hd_videoXXX_start_list() to activate the new parameters. 10. Wait the key press \u2018q\u2019 to exit the thread. 11. Stop the capture, the video process and the video out modules. if ((ret = hd_videocap_stop_list(liveview_info.cap_path, SAMPLE_LV_COUNT)) != HD_OK) { return ret; } if ((ret = hd_videoproc_stop_list(liveview_info.proc_path, SAMPLE_LV_COUNT)) != HD_OK) { return ret; } if ((ret = hd_videoout_stop_list(liveview_info.out_path, SAMPLE_LV_COUNT)) != HD_OK) { return ret; } 12. Unbind the capture, the video process and the video out modules. if ((ret = hd_videocap_unbind(HD_VIDEOCAP_OUT(i, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_unbind(HD_VIDEOPROC_OUT(i, 0))) != HD_OK) { return ret; } 13. Close the capture, the video process and the video out modules. if ((ret = hd_videocap_close(liveview_info.cap_path[i])) != HD_OK) { return ret; } if ((ret = hd_videoproc_close(liveview_info.proc_path[i])) != HD_OK) { return ret; } if ((ret = hd_videoout_close(liveview_info.out_path[i])) != HD_OK) { return ret; } 14. Un-initiate the capture, the video process and the video out modules. if ((ret = hd_videocap_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoproc_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoout_uninit()) != HD_OK) { return ret; } 15. Un-initiate the HDAL. ret = hd_common_uninit();","title":"5.2.2 Liveview"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#523-playback","text":"The stream flow of the sample code \u201c playback_1div_to_4div.c \u201d: root@NVTEVM:\\~\\$ cat /proc/videograph/graph entity (jobs) pool name (done buffers/max buffers) ----------------------------------------------------------- datain_0_0_0 (1) (disp_dec_in_ddr0, \u2013, \u2013, \u2013) (5/8) ->decode_0_0_0 (1) (disp_dec_out_ddr0, disp_dec_out_ratio_ddr0, \u2013, \u2013) (2/3) ->kflow_vpe_0_0_0 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) ->*kflow_osg_0_0_0 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/0) ->lcd0vg_0_0_0 (2) datain_0_0_1 (0) (disp_dec_in_ddr0, \u2013, \u2013, \u2013) (5/8) ->decode_0_0_1 (1) (disp_dec_out_ddr0, disp_dec_out_ratio_ddr0, \u2013, \u2013) (2/3) ->kflow_vpe_0_0_1 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) datain_0_0_2 (0) (disp_dec_in_ddr0, \u2013, \u2013, \u2013) (5/8) ->decode_0_0_2 (1) (disp_dec_out_ddr0, disp_dec_out_ratio_ddr0, \u2013, \u2013) (2/3) ->kflow_vpe_0_0_2 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) datain_0_0_3 (0) (disp_dec_in_ddr0, \u2013, \u2013, \u2013) (5/8) ->decode_0_0_3 (1) (disp_dec_out_ddr0, disp_dec_out_ratio_ddr0, \u2013, \u2013) (2/3) ->kflow_vpe_0_0_3 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) Sample code flow: 1. Initiate the HDAL. ret = hd_common_init(1); //the parameter is reserved for the future. 2. Initiate the video decoder, the video process, the video out and the video encoder modules. if ((ret = hd_videodec_init()) != HD_OK) { return ret; } if ((ret = hd_videoproc_init()) != HD_OK) { return ret; } if ((ret = hd_videoout_init()) != HD_OK) { return ret; } if ((ret = hd_videoenc_init()) != HD_OK) { return ret; } 3. Open the video decoder, the video process, the video out and the video encoder modules. The video process 0 \\~ ( MAX_BITSTREAM_NUM \u2013 1) are used for the bitstream decode to the video out, and the video process MAX_BITSTREAM_NUM is used for the bitstream decode to the video encoder for JPEG. for (i = 0; i \\< MAX_BITSTREAM_NUM; i++) { if ((ret = hd_videodec_open(HD_VIDEODEC_IN(0, i), HD_VIDEODEC_OUT(0, i), \\&p_playback_info->video_dec[i])) != HD_OK) return ret; if ((ret = hd_videoproc_open(HD_VIDEOPROC_IN(i, 0), HD_VIDEOPROC_OUT(i, 0), \\&p_playback_info->video_proc[i])) != HD_OK) return ret; if ((ret = hd_videoout_open(HD_VIDEOOUT_IN(0, i), HD_VIDEOOUT_OUT(0, 0), \\&p_playback_info->video_out[i])) != HD_OK) return ret; } if ((ret = hd_videoproc_open(HD_VIDEOPROC_IN(MAX_BITSTREAM_NUM, 0), HD_VIDEOPROC_OUT(MAX_BITSTREAM_NUM, 0), \\&p_playback_info->video_proc[MAX_BITSTREAM_NUM])) != HD_OK) { return ret; } if ((ret = hd_videoenc_open(HD_VIDEOENC_0_IN_0, HD_VIDEOENC_0_OUT_0, \\&p_playback_info->video_enc)) != HD_OK) { return ret; } if ((ret = hd_videoout_open(0, HD_VIDEOOUT_0_CTRL, \\&p_playback_info->video_out_ctrl)) != HD_OK) //open this for device control return ret; 4. Set the decoder configure and parameters. The max_mem (the buffer name is disp_dec_in_ddr0) is allocated from the HD_COMMON_MEM_DISP_DEC_IN_POOL. Only two data_pool are valid for the decoder, so data_pool[2\\~3].mode must set to disable. The first data_pool (the buffer name is disp_dec_out_ddr0) is allocated from the HD_COMMON_MEM_DISP_DEC_OUT_POOL, the counts/max_counts should not be larger than \u201cYUV Buffer count\u201d in the \u201cdecode\u201d sheet of DVR_xch.xls. The second data_pool (the buffer name is disp_dec_out_ratio_ddr0) is allocated from the HD_COMMON_MEM_DISP_DEC_OUT_RATIO_POOL, the counts/max_counts should not be larger than \u201cYUV Buffer count\u201d in the \u201cdecode\u201d sheet of DVR_xch.xls. While enable data_pool[1].mode, the decoder will output two different sizes of the frame, one is original size, the other is 1/4 of the original size (the decode ratio frame must set to 0.25 in the \u201cdecode\u201d sheet of DVR_xch.xls.). The small size frame is used for the multi-grid display on LCD to reduce the VPE scaling bandwidth. dec_config.max_mem.dim.w = ALIGN_CEIL(playback_info.video_pattern[i].img_width); dec_config.max_mem.dim.h = ALIGN_CEIL(playback_info.video_pattern[i].img_height); dec_config.max_mem.frame_rate = playback_info.video_pattern[i].frame_rate; dec_config.max_mem.bs_counts = 8; dec_config.max_mem.codec_type = HD_CODEC_TYPE_H265; dec_config.max_mem.max_ref_num = 1; dec_config.data_pool[0].mode = HD_VIDEODEC_POOL_ENABLE; dec_config.data_pool[0].ddr_id = 0; dec_config.data_pool[0].counts = HD_VIDEODEC_SET_COUNT(3, 0); dec_config.data_pool[0].max_counts = HD_VIDEODEC_SET_COUNT(3, 0); dec_config.data_pool[1].mode = HD_VIDEODEC_POOL_ENABLE; dec_config.data_pool[1].ddr_id = 0; dec_config.data_pool[1].counts = HD_VIDEODEC_SET_COUNT(3, 0); dec_config.data_pool[1].max_counts = HD_VIDEODEC_SET_COUNT(3, 0); dec_config.data_pool[2].mode = HD_VIDEODEC_POOL_DISABLE; dec_config.data_pool[3].mode = HD_VIDEODEC_POOL_DISABLE; ret = hd_videodec_set(playback_info.video_dec[i], HD_VIDEODEC_PARAM_PATH_CONFIG, \\&dec_config); 5. Set the video process configure and parameters. //use HD_VIDEOPROC_PARAM_DEV_CONFIG to set the memory pool configure. vpe_config.data_pool[0].mode = HD_VIDEOPROC_POOL_ENABLE; vpe_config.data_pool[0].ddr_id = 0; vpe_config.data_pool[0].counts = HD_VIDEOPROC_SET_COUNT(3, 0); vpe_config.data_pool[0].max_counts = HD_VIDEOPROC_SET_COUNT(3, 0); vpe_config.data_pool[1].mode = HD_VIDEOPROC_POOL_DISABLE; vpe_config.data_pool[2].mode = HD_VIDEOPROC_POOL_DISABLE; vpe_config.data_pool[3].mode = HD_VIDEOPROC_POOL_DISABLE; ret = hd_videoproc_set(playback_info.video_proc[i], HD_VIDEOPROC_PARAM_DEV_CONFIG, \\&vpe_config); //use HD_VIDEOPROC_PARAM_OUT to set the position, dimension, background dimension\u2026 proc_out.rect.x = 0; proc_out.rect.y = 0; proc_out.rect.w = playback_info.lcd_syscaps.input_dim.w; proc_out.rect.h = playback_info.lcd_syscaps.input_dim.h; proc_out.bg.w = playback_info.lcd_syscaps.input_dim.w; proc_out.bg.h = playback_info.lcd_syscaps.input_dim.h; proc_out.pxlfmt = fb_fmt.fmt; proc_out.dir = HD_VIDEO_DIR_NONE; ret = hd_videoproc_set(playback_info.video_proc[i], HD_VIDEOPROC_PARAM_OUT, \\&proc_out); 6. Set the parameters of the video out module. //use HD_VIDEOOUT_PARAM_IN_WIN_ATTR to set the position, dimension, and visible. win.rect.x = 0; win.rect.y = 0; win.rect.w = playback_info.lcd_syscaps.input_dim.w; win.rect.h = playback_info.lcd_syscaps.input_dim.h; win.visible = 1; ret = hd_videoout_set(playback_info.video_out[i], HD_VIDEOOUT_PARAM_IN_WIN_ATTR, \\&win); 7. Set the encoder parameters. //use HD_VIDEOENC_PARAM_IN to set the input dimension and the pixel format. ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_IN, \\&video_in_param); //use HD_VIDEOENC_PARAM_OUT_ENC_PARAM to set the parameters of the codec. ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_OUT_ENC_PARAM, \\&enc_param); //use HD_VIDEOENC_PARAM_OUT_RATE_CONTROL to set the parameters of the rate control. ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_OUT_RATE_CONTROL, \\&rc_param); 8. Bind the video decoder, the video process and the video out modules, and then the video stream will flow from the decoder to the video out. for (i = 0; i \\< MAX_BITSTREAM_NUM; i++) { if ((ret = hd_videodec_bind(HD_VIDEODEC_OUT(0, i), HD_VIDEOPROC_IN(i, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_bind(HD_VIDEOPROC_OUT(i, 0), HD_VIDEOOUT_IN(0, i))) != HD_OK) { return ret; } } 9. Start the video decoder, the video process and the video out modules. if ((ret = hd_videodec_start_list(playback_info.video_dec, MAX_BITSTREAM_NUM)) != HD_OK) { return ret; } if ((ret = hd_videoproc_start_list(playback_info.video_proc, MAX_BITSTREAM_NUM)) != HD_OK) { return ret; } if ((ret = hd_videoout_start_list(playback_info.video_out, MAX_BITSTREAM_NUM)) != HD_OK) { return ret; } 10. Create a thread to read the h.265 bitstream files, and then uses hd_videodec_send_list() to send the bitstream to the decode module. The YUV output from the decode module will flow to the video out module via the video process module. static void *playback_thread(void *arg) { \u2026 while (1) { \u2026 fread(data[ch], 1, length, bs_fd[ch]); video_bs[ch].path_id = playback_info->video_dec[ch]; video_bs[ch].user_bs.p_bs_buf = data[ch]; video_bs[ch].user_bs.bs_buf_size = length; \u2026 hd_videodec_send_list(video_bs, MAX_BITSTREAM_NUM, 1000); \u2026 } \u2026 } 11. If you press \u2018y\u2019 key, it will toggle single window and 2x2 grid windows by changing the parameters of the video process and the video out modules. 12. If you press \u2018p\u2019 key, it will snapshot one JPEG file. This sample will demo how to use the push/pull APIs to scale and encode a single frame. Compare with the binding mode, this single mode must prepare the input/output buffer of the modules first. HD_RESULT pull_decout_and_scale_jpg(VIDEO_PLAYBACK playback_info, int enc_num) { \u2026 // Pull out the output buffer of the decoder module ret = hd_videodec_pull_out_buf(dec_path_id, \\&out_buffer, 500); \u2026 // prepare the input buffer of the video process for scaling scale_in_va = (UINT32)hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_NONCACHE, scale_in_pa, scale_in_blk_size); \u2026 // set the crop input parameters of the video process ret = hd_videoproc_set(proc_path_id, HD_VIDEOPROC_PARAM_IN_CROP, (void *)&crop); \u2026 // set the output parameters of the video process ret = hd_videoproc_set(proc_path_id, HD_VIDEOPROC_PARAM_OUT, (void *)&out); \u2026 // Push the decode output buffer into the video process module scale_out_va = (UINT32)hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_NONCACHE, scale_out_pa, scale_out_blk_size); scale_in_buffer.phy_addr[0] = scale_in_pa; scale_out_buffer.phy_addr[0] = scale_out_pa; ret = hd_videoproc_push_in_buf(proc_path_id, \\&scale_in_buffer, \\&scale_out_buffer, 500); \u2026 // Pull out the output buffer of the video process module ret = hd_videoproc_pull_out_buf(proc_path_id, \\&scale_out_buffer, 500); \u2026 // Push the video process output buffer into the encode module ret = hd_videoenc_push_in_buf(videoenc_path_id, \\&enc_in_buffer.frame, &(bs_out_buffer.bs), 500); \u2026 // pull out the output buffer of the encode module ret = hd_videoenc_pull_out_buf(videoenc_path_id, \\&video_bitstream, 500); // save to the JPEG file fwrite(bs_out_buffer.va, 1, video_bitstream.video_pack[0].size, bs_file); \u2026 } 13. Wait the key press \u2018q\u2019 to exit the thread. 14. Stop the video decoder, the video process and the video out modules. if ((ret = hd_videodec_stop_list(playback_info.video_dec, MAX_BITSTREAM_NUM)) != HD_OK) { return ret; } if ((ret = hd_videoproc_stop_list(playback_info.video_proc, MAX_BITSTREAM_NUM)) != HD_OK) { return ret; } if ((ret = hd_videoout_stop_list(playback_info.video_out, MAX_BITSTREAM_NUM)) != HD_OK) { return ret; } 15. Unbind the video decoder, the video process and the video out modules. for (i = 0; i \\< MAX_BITSTREAM_NUM; i++) { if ((ret = hd_videodec_unbind(HD_VIDEODEC_OUT(0, i))) != HD_OK) { return ret; } if ((ret = hd_videoproc_unbind(HD_VIDEOPROC_OUT(i, 0))) != HD_OK) { return ret; } } 16. Close the video decoder, the video process, the video out and the video encoder modules. for (i = 0; i \\< MAX_BITSTREAM_NUM; i++) { if ((ret = hd_videodec_close(p_playback_info.video_dec[i])) != HD_OK) { return ret; } if ((ret = hd_videoproc_close(p_playback_info.video_proc[i])) != HD_OK) { return ret; } if ((ret = hd_videoout_close(p_playback_info.video_out[i])) != HD_OK) { return ret; } } if ((ret = hd_videoproc_close(p_playback_info.video_proc[MAX_BITSTREAM_NUM])) != HD_OK) { return ret; } if ((ret = hd_videoenc_close(p_playback_info.video_enc)) != HD_OK) { return ret; } if ((ret = hd_videoout_close(p_playback_info.video_out_ctrl)) != HD_OK) { return ret; } 17. Un-initiate the video decoder, the video process, the video out and the video encoder modules. if ((ret = hd_videodec_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoproc_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoout_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoenc_uninit()) != HD_OK) { return ret; } 18. Un-initiate the HDAL. ret = hd_common_uninit();","title":"5.2.3 Playback"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#524-display-to-encode","text":"The stream flow of the sample code \u201c display_to_encode.c \u201d: root@NVTEVM:\\~\\$ cat /proc/videograph/graph entity (jobs) pool name (done buffers/max buffers) ----------------------------------------------------------- vcap0_0_4_0 (2) (disp0_cap_out_ddr0, \u2013, \u2013, \u2013) (1/4) ->kflow_vpe_0_0_0 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) ->*kflow_osg_0_0_0 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/0) ->lcd0vg_0_0_0 (2) ->kflow_vpe_0_0_4 (0) (enc_scl_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->*kflow_osg_0_0_10 (0)(enc_scl_out_ddr0, \u2013, \u2013, \u2013) (0/0) ->h26xenc_0_0_0 (0) (enc_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->dataout_0_0_0 (1) vcap0_0_6_0 (3) (disp0_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->kflow_vpe_0_0_1 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) vcap0_0_0_0 (3) (disp0_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->kflow_vpe_0_0_2 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) vcap0_0_2_0 (3) (disp0_cap_out_ddr0, \u2013, \u2013, \u2013) (0/4) ->kflow_vpe_0_0_3 (0) (disp0_in_ddr0, \u2013, \u2013, \u2013) (0/3) Sample code flow: 1. Initiate the HDAL. ret = hd_common_init(1); //the parameter is reserved for the future. 2. Initiate the capture, the video process, the video out and the video encoder modules. if ((ret = hd_videocap_init()) != HD_OK) { return ret; } if ((ret = hd_videoproc_init()) != HD_OK) { return ret; } if ((ret = hd_videoout_init()) != HD_OK) { return ret; } if ((ret = hd_videoenc_init()) != HD_OK) { return ret; } 3. Open the capture, the video process, the video out and the video encoder modules. 0 \\~ ( MAX_BITSTREAM_NUM \u2013 1) modules are used for capturing the video frames and display on LCD, and MAX_BITSTREAM_NUM modules are used for encoding the video out to be as h.265 file. for (i = 0; i \\< MAX_VI_NU; i++) { if((ret = hd_videocap_open(HD_VIDEOCAP_IN(i, 0), HD_VIDEOCAP_OUT(i, 0), \\&p_disp_to_enc->video_cap[i])) != HD_OK) return ret; if((ret = hd_videoproc_open(HD_VIDEOPROC_IN(i, 0), HD_VIDEOPROC_OUT(i, 0), \\&p_disp_to_enc->video_proc[i])) != HD_OK) return ret; if((ret = hd_videoout_open(HD_VIDEOOUT_IN(p_disp_to_enc->lcd_devid, i), HD_VIDEOOUT_OUT(p_disp_to_enc->lcd_devid, 0), \\&p_disp_to_enc->video_out[i])) != HD_OK) return ret; } if ((ret = hd_videoproc_open(HD_VIDEOPROC_IN(i, 0), HD_VIDEOPROC_OUT(i, 0), \\&p_disp_to_enc->vpe_path[0])) != HD_OK) { return ret; } if ((ret = hd_videoenc_open(HD_VIDEOENC_IN(0, 0), HD_VIDEOENC_OUT(0, 0), \\&p_disp_to_enc->enc_path[0])) != HD_OK) { return ret; } if ((ret = hd_videoout_open(0, HD_VIDEOOUT_CTRL(p_disp_to_enc->lcd_devid), \\&p_disp_to_enc->video_out_ctrl)) != HD_OK) //open this for device control return ret; 4. Set the capture configure and parameters. //use HD_VIDEOCAP_PARAM_PATH_CONFIG to set the memory pool configure. cap_config.data_pool[0].mode = HD_VIDEOCAP_POOL_ENABLE; cap_config.data_pool[0].ddr_id = SAMPLE_VCAP_DDR_ID; cap_config.data_pool[0].counts = HD_VIDEOCAP_SET_COUNT(4, 0); cap_config.data_pool[0].max_counts = HD_VIDEOCAP_SET_COUNT(4, 0); cap_config.data_pool[1].mode = HD_VIDEOCAP_POOL_DISABLE; cap_config.data_pool[2].mode = HD_VIDEOCAP_POOL_DISABLE; cap_config.data_pool[3].mode = HD_VIDEOCAP_POOL_DISABLE; ret = hd_videocap_set(cap_path_id, HD_VIDEOCAP_PARAM_PATH_CONFIG, \\&cap_config); //use HD_VIDEOCAP_PARAM_OUT to set the output dimension and the pixel format. ret = hd_videocap_set(cap_path_id, HD_VIDEOCAP_PARAM_OUT, \\&cap_out); 5. Set the video process configure and parameters. //use HD_VIDEOPROC_PARAM_DEV_CONFIG to set the memory pool configure. vpe_config.data_pool[0].mode = HD_VIDEOPROC_POOL_ENABLE; vpe_config.data_pool[0].ddr_id = 0; vpe_config.data_pool[0].counts = HD_VIDEOPROC_SET_COUNT(3, 0); vpe_config.data_pool[0].max_counts = HD_VIDEOPROC_SET_COUNT(3, 0); vpe_config.data_pool[1].mode = HD_VIDEOPROC_POOL_DISABLE; vpe_config.data_pool[2].mode = HD_VIDEOPROC_POOL_DISABLE; vpe_config.data_pool[3].mode = HD_VIDEOPROC_POOL_DISABLE; ret = hd_videoproc_set(p_disp_to_enc->video_proc[i], HD_VIDEOPROC_PARAM_DEV_CONFIG, \\&vpe_config); //use HD_VIDEOPROC_PARAM_OUT to set the position, dimension, background dimension\u2026 ret = hd_videoproc_set(playback_info.video_proc[i], HD_VIDEOPROC_PARAM_OUT, \\&proc_out); 6. Set the parameters of the video out module. //use HD_VIDEOOUT_PARAM_IN_WIN_ATTR to set the position, dimension, and visible. win.rect.x = (i % 2) * (p_disp_to_enc->lcd_syscaps.input_dim.w / 2); win.rect.y = (i / 2) * (p_disp_to_enc->lcd_syscaps.input_dim.h / 2); win.rect.w = (p_disp_to_enc->lcd_syscaps.input_dim.w / 2); win.rect.h = (p_disp_to_enc->lcd_syscaps.input_dim.h / 2); win.visible = 1; ret = hd_videoout_set(p_disp_to_enc->video_out[i], HD_VIDEOOUT_PARAM_IN_WIN_ATTR, \\&win); 7. Set the encoder parameters. //use HD_VIDEOENC_PARAM_IN to set the input dimension and the pixel format. ret = hd_videoenc_set(p_disp_to_enc->enc_path[0], HD_VIDEOENC_PARAM_IN, \\&video_in_param); //use HD_VIDEOENC_PARAM_OUT_ENC_PARAM to set the parameters of the codec. ret = hd_videoenc_set(p_disp_to_enc->enc_path[0], HD_VIDEOENC_PARAM_OUT_ENC_PARAM, \\&enc_param); //use HD_VIDEOENC_PARAM_OUT_RATE_CONTROL to set the parameters of the rate control. ret = hd_videoenc_set(p_disp_to_enc->enc_path[0], HD_VIDEOENC_PARAM_OUT_RATE_CONTROL, \\&rc_param); 8. First, bind the capture, the video process and the video out modules, and then the video stream will flow from the capture to the video out. Second, bind the video out, the video process and the video encoder modules, and then the video stream will flow from the video out to the video encoder module. for (i = 0; i \\< MAX_VI_NU; i++) { if ((ret = hd_videocap_bind(HD_VIDEOCAP_OUT(i, 0), HD_VIDEOPROC_IN(i, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_bind(HD_VIDEOPROC_OUT(i, 0), HD_VIDEOOUT_IN(p_disp_to_enc->lcd_devid, i))) != HD_OK) { return ret; } } //connect liveview to encode if ((ret = hd_videoout_bind(HD_VIDEOOUT_OUT(p_disp_to_enc->lcd_devid, 0), HD_VIDEOPROC_IN(i, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_bind(HD_VIDEOPROC_OUT(i, 0), HD_VIDEOENC_IN(0, 0))) != HD_OK) { return ret; } 9. Start the capture, the video process, the video out and the video encoder modules. if ((ret = hd_videocap_start_list(p_disp_to_enc->video_cap, MAX_VI_NU)) != HD_OK) { return ret; } if ((ret = hd_videoproc_start_list(p_disp_to_enc->video_proc, MAX_VI_NU)) != HD_OK) { return ret; } if ((ret = hd_videoout_start_list(p_disp_to_enc->video_out, MAX_VI_NU)) != HD_OK) { return ret; } if ((ret = hd_videoproc_start_list(p_disp_to_enc->vpe_path, 1)) != HD_OK) { return ret; } if ((ret = hd_videoenc_start_list(p_disp_to_enc->enc_path, 1)) != HD_OK) { return ret; } 10. Create a thread to encode the stream from the video output. The main procedure in this thread is using the hd_videoenc_poll_list() API to check the stream is ready or not. If the stream is ready, use hd_videoenc_recv_list() API to receive it. static void *encode_thread(void *arg) { \u2026 while (p_disp_to_enc->enc_exit == 0) { //check bitstream status before receiving ret = hd_videoenc_poll_list(poll_list, MAX_BITSTREAM_NUM, 500); \u2026 if ((ret = hd_videoenc_recv_list(recv_list, MAX_BITSTREAM_NUM)) \\< 0) { printf(\u201cError return value %d\\n\u201d, ret); } else { for (i = 0; i \\< MAX_BITSTREAM_NUM; i++) { //Write the receive the encoded bitstreams to file } } } \u2026 } 11. Wait the key press \u2018q\u2019 to exit the thread. 12. Stop the capture, the video process, the video out and the video encoder modules. if ((ret = hd_videocap_stop_list(p_disp_to_enc->video_cap, MAX_VI_NU)) != HD_OK) { return ret; } if ((ret = hd_videoproc_stop_list(p_disp_to_enc->video_proc, MAX_VI_NU)) != HD_OK) { return ret; } if ((ret = hd_videoout_stop_list(p_disp_to_enc->video_out, MAX_VI_NU)) != HD_OK) { return ret; } if ((ret = hd_videoproc_stop_list(p_disp_to_enc->vpe_path, 1)) != HD_OK) { return ret; } if ((ret = hd_videoenc_stop_list(p_disp_to_enc->enc_path, 1)) != HD_OK) { return ret; } 13. Unbind the capture and the encoder modules. for (i = 0; i \\< MAX_VI_NU; i++) { if ((ret = hd_videocap_unbind(HD_VIDEOCAP_OUT(i, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_unbind(HD_VIDEOPROC_OUT(i, 0))) != HD_OK) { return ret; } } if ((ret = hd_videoout_unbind(HD_VIDEOOUT_OUT(p_disp_to_enc->lcd_devid, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_unbind(HD_VIDEOPROC_OUT(i, 0))) != HD_OK) { return ret; } 14. Close the capture, the video process, the video out and the video encoder modules. for (i = 0; i \\< MAX_VI_NU; i++) { if ((ret = hd_videocap_close(p_disp_to_enc->video_cap[i])) != HD_OK) { return ret; } if ((ret = hd_videoproc_close(p_disp_to_enc->video_proc[i])) != HD_OK) { return ret; } if ((ret = hd_videoout_close(p_disp_to_enc->video_out[i])) != HD_OK) { return ret; } } if ((ret = hd_videoproc_close(p_disp_to_enc->vpe_path[0])) != HD_OK) { return ret; } if ((ret = hd_videoenc_close(p_disp_to_enc->enc_path[0])) != HD_OK) { return ret; } if ((ret = hd_videoout_close(p_disp_to_enc->video_out_ctrl)) != HD_OK) { return ret; } 15. Un-initiate the capture, the video process, the video out and the video encoder modules. if ((ret = hd_videocap_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoproc_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoout_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoenc_uninit()) != HD_OK) { return ret; } 16. Un-initiate the HDAL. ret = hd_common_uninit();","title":"5.2.4 Display to Encode"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#6-appendix","text":"","title":"6 Appendix"},{"location":"Software/NT9833x_DVR_NVR_SDK_Quick_Start.html#61-video-format","text":"The following table lists the available video formats for the video path and HDAL APIs. Path/APIs Available Video Format (HD_VIDEO_PXLFMT_XXX) VCAP_OUT YUV422_ONE, YUV420 VCAP_OUT (compress mode) YUV420_NVX3, YUV422_NVX3 VOUT_IN YUV420, YUV422_ONE VOUT_IN (compress mode) YUV420_NVX3, YUV422_NVX3 VPE_IN YUV420, YUV422_ONE VPE_IN (compress mode) YUV420_NVX3, YUV420_NVX4 VPE_OUT YUV420, YUV422_ONE VPE_OUT (compress mode) YUV420_NVX3 VENC_IN (JPEG) YUV420 VENC_IN (JPEG) (compress mode) YUV420_NVX3 VENC_IN (H.265) YUV420 VENC_IN (H.265) (compress mode) YUV420_NVX3 VENC_IN (H.264) YUV420 VENC_IN (H.264) (compress mode) YUV420_NVX3 VENC OSG ARGB1555 VDEC_OUT (JPEG) YUV420 VDEC_OUT (H.265) YUV420_NVX4, YUV420_NVX3 (ratio) VDEC_OUT (H.264) YUV420_NVX4, YUV420_NVX3 (ratio) OSG IN ARGB1555, ARGB8888 OSG OUT YUV420, YUV422_NVX3 hd_gfx_xxx() APIs ARGB1555, ARGB8888, YUV422_ONE, YUV420 HD_VIDEOPROC_PARAM_PATTERN_IMG YUV422_ONE HD_VIDEOENC_PARAM_IN_STAMP_IMG ARGB1555, ARGB8888 HD_VIDEOOUT_PARAM_OUT_STAMP_IMG ARGB1555, ARGB8888 HD_VIDEOOUT_PARAM_CLEAR_WIN YUV422_ONE","title":"6.1 Video Format"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html","text":"1 IVE Introduction \u00b6 1.1 API List \u00b6 \uf06c NVT_IVE_Filter : General filter function \uf06c NVT_IVE_Median : 3x3 Median filter function \uf06c NVT_IVE_Min : 3x3 Min filter function \uf06c NVT_IVE_Max : 3x3 Max filter function \uf06c NVT_IVE_Sobel : 5x5 Sobel filter function \uf06c NVT_IVE_Thresh : Image thresholding function \uf06c NVT_IVE_Dilate : Image dilate function \uf06c NVT_IVE_Erode : Image erode function \uf06c NVT_IVE_Integ : Integral image function \uf06c NVT_IVE_Canny : Canny edge function \uf06c NVT_IVE_CSC : Color Space Conversion (CSC) function \uf06c NVT_IVE_Histo : Histogram function \uf06c NVT_IVE_NCC : Normalized Cross Correlation (NCC) function 2 Flow \u00b6 Using LibIVE, main flow as following flow chart \uf06c vendor_ive_init : Before running task, this function will open engine clock. Only need to execute this function once, do not execute repeatly. \uf06c vendor_ive_uninit : After running task, this function will close engine clock. Only need to execute this function once, do not execute repeatly. 3 API \u00b6 3.1 NVT_IVE_Filter \u00b6 \u3010Description\u3011 Applying 7x7 general filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Filter (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst, IVE_FILTER_CTRL_S* pstFltCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstFltCtrl General filter control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~16383x8191 pstDst U8C1 4 byte Same as pstSrc IVE_FILTER_CTRL_S Parameter Data Type Description u8Mask[10] UINT8 General filter Mask, range : 0\\~15 \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c Filter index number as following Figure 2.21 Figure 2.21 u8Mask[0]\\~ u8Mask[9] corresponds to index 0\\~9 \uf06c For image border pixels, mirror padding is applied in general filter process. \u3010Sample\u3011 hdal\\samples\\alg_ive_filter\\alg_ive_filter.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Filter is 532 , estimated by a sample (image resolution 516x376). 3.2 NVT_IVE_Median \u00b6 \u3010Description\u3011 Applying 3x3 Median filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Median (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~16383x8191 pstDst U8C1 4 byte Same as pstSrc \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c For image border pixels, mirror padding is applied in median filter process. \u3010Sample\u3011 hdal\\samples\\alg_ive_median\\alg_ive_median.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Median is 540 , estimated by sample (image resolution 516x376). 3.3 NVT_IVE_Min \u00b6 \u3010Description\u3011 Applying 3x3 Min filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Min (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~16383x8191 pstDst U8C1 4 byte Same as pstSrc \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c For image border pixels, mirror padding is applied in min filter process. \u3010Sample\u3011 hdal\\samples\\alg_ive_min\\alg_ive_min.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Min is 536 , estimated by sample (image resolution 516x376). 3.4 NVT_IVE_Max \u00b6 \u3010Description\u3011 Applying 3x3 Max filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Max (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~16383x8191 pstDst U8C1 4 byte Same as pstSrc \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c For image border pixels, mirror padding is applied in max filter process. \u3010Sample\u3011 hdal\\samples\\alg_ive_max\\alg_ive_max.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Max is 541 , estimated by sample (image resolution 516x376). 3.5 NVT_IVE_Sobel \u00b6 \u3010Description\u3011 Applying 5x5 Sobel filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Sobel (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst, IVE_SOBEL_CTRL_S* pstSobelCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output gradient x/y packed image pointer Output pstSobelCtrl Edge filter parameter pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~16383x8191 pstDst S16C1 4 byte 16x16\\~16383x8191 IVE_SOBEL_CTRL_S Parameter Data Type Description s8Mask[25] S8 Edge filter Mask, range : -15\\~15 \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c User can set s8Mask for calculating gradient x, and the library will transpose and flip the mask for calculating gradient y. The mask index is shown as below: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \uf06c User can set pstDst format as S16C1. If user set as S16C1, the output will be signed 8 bit gradient x/y packed format(gradient x signed 8bit + gradient y signed 8bit per pixel). \u3010Sample\u3011 hdal\\samples\\alg_ive_sobel\\alg_ive_sobel.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Sobel is 556 , estimated by sample (image resolution 516x376). 3.6 NVT_IVE_Thresh \u00b6 \u3010Description\u3011 NVT_IVE_Thresh applies two user-defined thresholds to partition an input image into a tenary image. \u3010Function\u3011 INT32 NVT_IVE_Thresh (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst, IVE_THRESH_CTRL_S* pstThrCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstThrCtrl Thresholding control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 64x64\\~1920x1080 pstDst U8C1 4 byte Same as pstSrc IVE_THRESH_CTRL_S Parameter Data type Description u8LutThresh[15] U8 15 threshold levels: 0-255 (strictly increasing) \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c NVT_IVE_Thresh partitions image pixels into a 4bits image by LutThresh. The value of each output pixel could be 0-15. Each output pixel (U8C1) is the packed format by two neighbor pixel (LSB 4bit represent odd pixel, MSB 4bit represent even pixel). \uf06c Packed output format is shown as: \u3010Sample\u3011 hdal\\samples\\alg_ive_thresh\\alg_ive_thresh.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Thresh is 500 , estimated by sample (image resolution 316x316). 3.7 NVT_IVE_Dilate \u00b6 \u3010Description\u3011 Image dilation uses a 5x5 structural element to expand the shapes contained in input image. \u3010Function\u3011 INT32 NVT_IVE_Dilate (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst, IVE_MORPH_CTRL_S* pstDilateCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstDilateCtrl Dilation control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~16383x8191 pstDst U8C1 4 byte Same as pstSrc IVE_MORPH_CTRL_S Parameter Data Type Description u8Mask[24] U8 Structural element coefficients \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c The coefficients of structural element must be 0 or 1. \uf06c The 5x5 structural element is described by array u8Mask which contains 24 coefficients and the corresponding position in 2D space is Dilation uses a specified structural element to slide whole image and the process can be described as below for each image pixel p in input image I in { max = I in( p ) for(i=0; i\\<24; i++) { if(mask(i)==1 && I in ( q (i)) > max) // q (i) is the corresponding pixel of coefficient i // max = I in ( q (i)) } I out ( p ) = max } \uf06c For image border pixels, mirror padding is applied in dilation process. \u3010Sample\u3011 hdal\\samples\\alg_ive_dilate\\alg_ive_dilate.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Dilate is 346 , estimated by sample (image resolution 316x316). 3.8 NVT_IVE_Erode \u00b6 \u3010Description\u3011 Image erosion uses a 5x5 structural element to reduce the shapes contained in input image. \u3010Function\u3011 INT32 NVT_IVE_Erode (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst, IVE_MORPH_CTRL_S* pstErodeCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image Input pstDst Output image Output pstErodeCtrl Erosion control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~16383x8191 pstDst U8C1 4 byte Same as pstSrc IVE_MORPH_CTRL_S Parameter Data Type Description u8Mask[24] U8 Structural element coefficients \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c The coefficients of structural element must be 0 or 1. \uf06c The 5x5 structural element is described by array u8Mask which contains 24 coefficients and the corresponding position in 2D space is Erosion uses a specified structural element to slide whole image and the process can be described as below for each image pixel p in input image I in { min = I in( p ) for(i=0; i\\<24; i++) { if(mask(i)==1 && I in ( q (i)) \\< min) // q (i) is the corresponding pixel of coefficient i // min = I in ( q (i)) } I out ( p ) = min } \uf06c For image border pixels, mirror padding is applied in erosion process. \u3010Sample\u3011 hdal\\samples\\alg_ive_erode\\alg_ive_erode.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Erode is 352 , estimated by sample (image resolution 316x316). 3.9 NVT_IVE_Integ \u00b6 \u3010Description\u3011 This function calculates the sum of values in a rectangular subset of a grid: \u3010Function\u3011 INT32 NVT_IVE_Integ (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst, IVE_INTEG_CTRL_S *pstIntegCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstIntegCtrl Integral control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~1920x8191 pstDst U32C1 4 byte Same as pstSrc IVE_INTEG_CTRL_S Parameter Data Type Description enInFormat LIB_IVE_INTEGRAL_IN_FMT 0: 1 channel 1: 2 channel packed enOutFormat LIB_IVE_INTEGRAL_OUT_FMT 0: sum \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 The input format supports 1 channel 8 bit / 2 channel 8 bit packed. The output format supports integral sum (32bit). \u3010Sample\u3011 Sample code : samples\\alg_ive_integral\\alg_ive_integral.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Integral is 694 , estimated by sample (image resolution 316x316). 3.10 NVT_IVE_Canny \u00b6 \u3010Description\u3011 NVT_IVE_Canny extract edges in a gray scale image by following steps \uf06c Image smoothing \uf06c Image gradient and gradient magnitude calculation \uf06c Non-maximun suppression \u3010Function\u3011 INT32 NVT_IVE_Canny (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst, IVE_CANNY_CTRL_S* pstCannyCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstCannyCtrl Edge detection control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~16383x8191 pstDst U8C1 4 byte Same as pstSrc \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c The edge detection process uses a 7x7 kernel to smooth input image. The smoothing kernel is described by an array with 10 elements, s8Mask , and the corresponding position in 2D space is The valid value range of s8Mask is [-15, 15]. \u3010Sample\u3011 hdal\\samples\\alg_ive_canny\\alg_ive_canny.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Canny is 367 , estimated by sample (image resolution 316x316). 3.11 NVT_IVE_CSC \u00b6 \u3010Description\u3011 NVT_IVE_CSC can do color space conversion from YUV to RGB or HSV or LAB. \u3010Function\u3011 INT32 NVT_IVE_CSC (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst, IVE_CSC_CTRL_S* pstCscCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstCscCtrl CSC control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~4096x8191 pstDst U8C1 4 byte Same as pstSrc IVE_CSC_CTRL_S Parameter Data Type Description enCSCMode LIB_IVE_CSC_MODE 0: YUV2RGB 1: YUV2HSV 2: YUV2LAB enOutFmt LIB_IVE_CSC_OUT_FMT 0: PLANAR 1: PACKED enLabFmt LIB_IVE_CSC_LAB_FMT 0: D65 1: D50 enRgbFmt LIB_IVE_CSC_RGB_FMT 0: BT601 1: BT709 2: JPG encoder \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c Only support YUV420SP(NV12)/YVU420SP(NV21)/YUV422 input YUV420SP(NV12): YVU420SP(NV21): YUV422 support UYVY\u3001YUYV\u3001VYUY\u3001YVYU 4 types. \uf06c Output format PLANAR/ PACKED as following figure PLANAR: pstDst->u32Stride = width PACKED: pstDst->u32Stride = 3*width \uf06c YUV2RGB : YUV->RGB ->Gamma Correction YUV2HSV : YUV ->RGB ->Gamma correction ->HSV YUV2LAB : YUV ->RGB ->Gamma correction ->LAB enRgbFmt should be set for all enCSCMode. \u3010Sample\u3011 hdal\\samples\\alg_ive_csc\\alg_ive_csc.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Canny is 569 , estimated by sample (image resolution 512x376). 3.12 NVT_IVE_Histo \u00b6 \u3010Description\u3011 NVT_IVE_Histo can calculate histogram for input image. \u3010Function\u3011 INT32 NVT_IVE_Histo (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output histogram result pointer Output Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 64x64\\~1920x1080 pstDst U8C1 4 byte 1024 byte \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c Histogram output size = 256(bin) x 4(byte) = 1024(byte) \u3010Sample\u3011 hdal\\samples\\alg_ive_histo\\alg_ive_histo.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Histo is 644 , estimated by a sample (image resolution 512x376). 3.13 NVT_IVE_NCC \u00b6 \u3010Description\u3011 NVT_IVE_NCC can calculate normalized cross correlation. The formula is shown below: \u3010Function\u3011 INT32 NVT_IVE_NCC (IVE_SRC_IMAGE_S* pstSrc1, IVE_SRC_IMAGE_S* pstSrc2, IVE_NCC_INFO_S* pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc1 Input image pointer Input pstSrc2 Input image pointer Input pstDst Ouput NCC result pointer Output Parameter Data type Alignment Resolution pstSrc1 U8C1 4 byte 32x32\\~1920x1080 pstSrc2 U8C1 4 byte Same as pstSrc1 pstDst Data structure - - IVE_NCC_INFO_S Parameter Data Type Description u64Numerator UINT64 NCC numerator u64QuadSum1 UINT64 NCC quad sum from pstSrc1 u64QuadSum2 UINT64 NCC quad sum from pstSrc2 \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c After trigger NVT_IVE_NCC, calculation result is stored in pstDst. \u3010Sample\u3011 hdal\\samples\\alg_ive_ncc\\alg_ive_ncc.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_NCC is 537 , estimated by a sample (image resolution 512x376). 4 Error Code \u00b6 Return value Description LIB_IVE_OK Execute success LIB_IVE_ERR_PARAM Lib IVE param setting failure LIB_IVE_ERR_INIT IVE hardware init failure LIB_IVE_ERR_LOCK IVE hardware lock failure LIB_IVE_ERR_SET IVE hardware set param failure LIB_IVE_ERR_GET IVE hardware get param failure LIB_IVE_ERR_TRIG IVE hardware trigger failure LIB_IVE_ERR_UNLOCK IVE hardware unlock failure LIB_IVE_ERR_UNINIT IVE hardware uninit failure 5 Revision History \u00b6 Revision Date Author Changes 1.0 2022/5/9 Ethan Wang First Version. 1.1 2022/8/2 Ethan Wang 1. Add initialized & uninitialized IVE\u2019s function. 2. Update execution time of each function.","title":"IVE User Guide"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#1-ive-introduction","text":"","title":"1 IVE Introduction"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#11-api-list","text":"\uf06c NVT_IVE_Filter : General filter function \uf06c NVT_IVE_Median : 3x3 Median filter function \uf06c NVT_IVE_Min : 3x3 Min filter function \uf06c NVT_IVE_Max : 3x3 Max filter function \uf06c NVT_IVE_Sobel : 5x5 Sobel filter function \uf06c NVT_IVE_Thresh : Image thresholding function \uf06c NVT_IVE_Dilate : Image dilate function \uf06c NVT_IVE_Erode : Image erode function \uf06c NVT_IVE_Integ : Integral image function \uf06c NVT_IVE_Canny : Canny edge function \uf06c NVT_IVE_CSC : Color Space Conversion (CSC) function \uf06c NVT_IVE_Histo : Histogram function \uf06c NVT_IVE_NCC : Normalized Cross Correlation (NCC) function","title":"1.1 API List"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#2-flow","text":"Using LibIVE, main flow as following flow chart \uf06c vendor_ive_init : Before running task, this function will open engine clock. Only need to execute this function once, do not execute repeatly. \uf06c vendor_ive_uninit : After running task, this function will close engine clock. Only need to execute this function once, do not execute repeatly.","title":"2 Flow"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#3-api","text":"","title":"3 API"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#31-nvt_ive_filter","text":"\u3010Description\u3011 Applying 7x7 general filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Filter (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst, IVE_FILTER_CTRL_S* pstFltCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstFltCtrl General filter control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~16383x8191 pstDst U8C1 4 byte Same as pstSrc IVE_FILTER_CTRL_S Parameter Data Type Description u8Mask[10] UINT8 General filter Mask, range : 0\\~15 \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c Filter index number as following Figure 2.21 Figure 2.21 u8Mask[0]\\~ u8Mask[9] corresponds to index 0\\~9 \uf06c For image border pixels, mirror padding is applied in general filter process. \u3010Sample\u3011 hdal\\samples\\alg_ive_filter\\alg_ive_filter.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Filter is 532 , estimated by a sample (image resolution 516x376).","title":"3.1 NVT_IVE_Filter"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#32-nvt_ive_median","text":"\u3010Description\u3011 Applying 3x3 Median filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Median (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~16383x8191 pstDst U8C1 4 byte Same as pstSrc \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c For image border pixels, mirror padding is applied in median filter process. \u3010Sample\u3011 hdal\\samples\\alg_ive_median\\alg_ive_median.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Median is 540 , estimated by sample (image resolution 516x376).","title":"3.2 NVT_IVE_Median"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#33-nvt_ive_min","text":"\u3010Description\u3011 Applying 3x3 Min filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Min (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~16383x8191 pstDst U8C1 4 byte Same as pstSrc \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c For image border pixels, mirror padding is applied in min filter process. \u3010Sample\u3011 hdal\\samples\\alg_ive_min\\alg_ive_min.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Min is 536 , estimated by sample (image resolution 516x376).","title":"3.3 NVT_IVE_Min"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#34-nvt_ive_max","text":"\u3010Description\u3011 Applying 3x3 Max filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Max (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~16383x8191 pstDst U8C1 4 byte Same as pstSrc \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c For image border pixels, mirror padding is applied in max filter process. \u3010Sample\u3011 hdal\\samples\\alg_ive_max\\alg_ive_max.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Max is 541 , estimated by sample (image resolution 516x376).","title":"3.4 NVT_IVE_Max"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#35-nvt_ive_sobel","text":"\u3010Description\u3011 Applying 5x5 Sobel filter to input image. \u3010Function\u3011 INT32 NVT_IVE_Sobel (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst, IVE_SOBEL_CTRL_S* pstSobelCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output gradient x/y packed image pointer Output pstSobelCtrl Edge filter parameter pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~16383x8191 pstDst S16C1 4 byte 16x16\\~16383x8191 IVE_SOBEL_CTRL_S Parameter Data Type Description s8Mask[25] S8 Edge filter Mask, range : -15\\~15 \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c User can set s8Mask for calculating gradient x, and the library will transpose and flip the mask for calculating gradient y. The mask index is shown as below: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \uf06c User can set pstDst format as S16C1. If user set as S16C1, the output will be signed 8 bit gradient x/y packed format(gradient x signed 8bit + gradient y signed 8bit per pixel). \u3010Sample\u3011 hdal\\samples\\alg_ive_sobel\\alg_ive_sobel.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Sobel is 556 , estimated by sample (image resolution 516x376).","title":"3.5 NVT_IVE_Sobel"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#36-nvt_ive_thresh","text":"\u3010Description\u3011 NVT_IVE_Thresh applies two user-defined thresholds to partition an input image into a tenary image. \u3010Function\u3011 INT32 NVT_IVE_Thresh (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst, IVE_THRESH_CTRL_S* pstThrCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstThrCtrl Thresholding control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 64x64\\~1920x1080 pstDst U8C1 4 byte Same as pstSrc IVE_THRESH_CTRL_S Parameter Data type Description u8LutThresh[15] U8 15 threshold levels: 0-255 (strictly increasing) \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c NVT_IVE_Thresh partitions image pixels into a 4bits image by LutThresh. The value of each output pixel could be 0-15. Each output pixel (U8C1) is the packed format by two neighbor pixel (LSB 4bit represent odd pixel, MSB 4bit represent even pixel). \uf06c Packed output format is shown as: \u3010Sample\u3011 hdal\\samples\\alg_ive_thresh\\alg_ive_thresh.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Thresh is 500 , estimated by sample (image resolution 316x316).","title":"3.6 NVT_IVE_Thresh"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#37-nvt_ive_dilate","text":"\u3010Description\u3011 Image dilation uses a 5x5 structural element to expand the shapes contained in input image. \u3010Function\u3011 INT32 NVT_IVE_Dilate (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst, IVE_MORPH_CTRL_S* pstDilateCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstDilateCtrl Dilation control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~16383x8191 pstDst U8C1 4 byte Same as pstSrc IVE_MORPH_CTRL_S Parameter Data Type Description u8Mask[24] U8 Structural element coefficients \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c The coefficients of structural element must be 0 or 1. \uf06c The 5x5 structural element is described by array u8Mask which contains 24 coefficients and the corresponding position in 2D space is Dilation uses a specified structural element to slide whole image and the process can be described as below for each image pixel p in input image I in { max = I in( p ) for(i=0; i\\<24; i++) { if(mask(i)==1 && I in ( q (i)) > max) // q (i) is the corresponding pixel of coefficient i // max = I in ( q (i)) } I out ( p ) = max } \uf06c For image border pixels, mirror padding is applied in dilation process. \u3010Sample\u3011 hdal\\samples\\alg_ive_dilate\\alg_ive_dilate.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Dilate is 346 , estimated by sample (image resolution 316x316).","title":"3.7 NVT_IVE_Dilate"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#38-nvt_ive_erode","text":"\u3010Description\u3011 Image erosion uses a 5x5 structural element to reduce the shapes contained in input image. \u3010Function\u3011 INT32 NVT_IVE_Erode (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst, IVE_MORPH_CTRL_S* pstErodeCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image Input pstDst Output image Output pstErodeCtrl Erosion control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~16383x8191 pstDst U8C1 4 byte Same as pstSrc IVE_MORPH_CTRL_S Parameter Data Type Description u8Mask[24] U8 Structural element coefficients \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c The coefficients of structural element must be 0 or 1. \uf06c The 5x5 structural element is described by array u8Mask which contains 24 coefficients and the corresponding position in 2D space is Erosion uses a specified structural element to slide whole image and the process can be described as below for each image pixel p in input image I in { min = I in( p ) for(i=0; i\\<24; i++) { if(mask(i)==1 && I in ( q (i)) \\< min) // q (i) is the corresponding pixel of coefficient i // min = I in ( q (i)) } I out ( p ) = min } \uf06c For image border pixels, mirror padding is applied in erosion process. \u3010Sample\u3011 hdal\\samples\\alg_ive_erode\\alg_ive_erode.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Erode is 352 , estimated by sample (image resolution 316x316).","title":"3.8 NVT_IVE_Erode"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#39-nvt_ive_integ","text":"\u3010Description\u3011 This function calculates the sum of values in a rectangular subset of a grid: \u3010Function\u3011 INT32 NVT_IVE_Integ (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst, IVE_INTEG_CTRL_S *pstIntegCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstIntegCtrl Integral control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~1920x8191 pstDst U32C1 4 byte Same as pstSrc IVE_INTEG_CTRL_S Parameter Data Type Description enInFormat LIB_IVE_INTEGRAL_IN_FMT 0: 1 channel 1: 2 channel packed enOutFormat LIB_IVE_INTEGRAL_OUT_FMT 0: sum \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 The input format supports 1 channel 8 bit / 2 channel 8 bit packed. The output format supports integral sum (32bit). \u3010Sample\u3011 Sample code : samples\\alg_ive_integral\\alg_ive_integral.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Integral is 694 , estimated by sample (image resolution 316x316).","title":"3.9 NVT_IVE_Integ"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#310-nvt_ive_canny","text":"\u3010Description\u3011 NVT_IVE_Canny extract edges in a gray scale image by following steps \uf06c Image smoothing \uf06c Image gradient and gradient magnitude calculation \uf06c Non-maximun suppression \u3010Function\u3011 INT32 NVT_IVE_Canny (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst, IVE_CANNY_CTRL_S* pstCannyCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstCannyCtrl Edge detection control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~16383x8191 pstDst U8C1 4 byte Same as pstSrc \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c The edge detection process uses a 7x7 kernel to smooth input image. The smoothing kernel is described by an array with 10 elements, s8Mask , and the corresponding position in 2D space is The valid value range of s8Mask is [-15, 15]. \u3010Sample\u3011 hdal\\samples\\alg_ive_canny\\alg_ive_canny.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Canny is 367 , estimated by sample (image resolution 316x316).","title":"3.10 NVT_IVE_Canny"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#311-nvt_ive_csc","text":"\u3010Description\u3011 NVT_IVE_CSC can do color space conversion from YUV to RGB or HSV or LAB. \u3010Function\u3011 INT32 NVT_IVE_CSC (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst, IVE_CSC_CTRL_S* pstCscCtrl) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output image pointer Output pstCscCtrl CSC control pointer Input Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 16x16\\~4096x8191 pstDst U8C1 4 byte Same as pstSrc IVE_CSC_CTRL_S Parameter Data Type Description enCSCMode LIB_IVE_CSC_MODE 0: YUV2RGB 1: YUV2HSV 2: YUV2LAB enOutFmt LIB_IVE_CSC_OUT_FMT 0: PLANAR 1: PACKED enLabFmt LIB_IVE_CSC_LAB_FMT 0: D65 1: D50 enRgbFmt LIB_IVE_CSC_RGB_FMT 0: BT601 1: BT709 2: JPG encoder \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c Only support YUV420SP(NV12)/YVU420SP(NV21)/YUV422 input YUV420SP(NV12): YVU420SP(NV21): YUV422 support UYVY\u3001YUYV\u3001VYUY\u3001YVYU 4 types. \uf06c Output format PLANAR/ PACKED as following figure PLANAR: pstDst->u32Stride = width PACKED: pstDst->u32Stride = 3*width \uf06c YUV2RGB : YUV->RGB ->Gamma Correction YUV2HSV : YUV ->RGB ->Gamma correction ->HSV YUV2LAB : YUV ->RGB ->Gamma correction ->LAB enRgbFmt should be set for all enCSCMode. \u3010Sample\u3011 hdal\\samples\\alg_ive_csc\\alg_ive_csc.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Canny is 569 , estimated by sample (image resolution 512x376).","title":"3.11 NVT_IVE_CSC"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#312-nvt_ive_histo","text":"\u3010Description\u3011 NVT_IVE_Histo can calculate histogram for input image. \u3010Function\u3011 INT32 NVT_IVE_Histo (IVE_SRC_IMAGE_S* pstSrc, IVE_DST_IMAGE_S* pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc Input image pointer Input pstDst Output histogram result pointer Output Parameter Data type Alignment Resolution pstSrc U8C1 4 byte 64x64\\~1920x1080 pstDst U8C1 4 byte 1024 byte \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c Histogram output size = 256(bin) x 4(byte) = 1024(byte) \u3010Sample\u3011 hdal\\samples\\alg_ive_histo\\alg_ive_histo.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_Histo is 644 , estimated by a sample (image resolution 512x376).","title":"3.12 NVT_IVE_Histo"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#313-nvt_ive_ncc","text":"\u3010Description\u3011 NVT_IVE_NCC can calculate normalized cross correlation. The formula is shown below: \u3010Function\u3011 INT32 NVT_IVE_NCC (IVE_SRC_IMAGE_S* pstSrc1, IVE_SRC_IMAGE_S* pstSrc2, IVE_NCC_INFO_S* pstDst) \u3010Parameter\u3011 Parameter Description Input/Output pstSrc1 Input image pointer Input pstSrc2 Input image pointer Input pstDst Ouput NCC result pointer Output Parameter Data type Alignment Resolution pstSrc1 U8C1 4 byte 32x32\\~1920x1080 pstSrc2 U8C1 4 byte Same as pstSrc1 pstDst Data structure - - IVE_NCC_INFO_S Parameter Data Type Description u64Numerator UINT64 NCC numerator u64QuadSum1 UINT64 NCC quad sum from pstSrc1 u64QuadSum2 UINT64 NCC quad sum from pstSrc2 \u3010Return Value\u3011 Return Value Description 0 Success Other values Failure. See section \u201cError Code\u201d for details \u3010Requirement\u3011 Header file: libive.h Library file: libvendor_cv.a \u3010Notice\u3011 \uf06c After trigger NVT_IVE_NCC, calculation result is stored in pstDst. \u3010Sample\u3011 hdal\\samples\\alg_ive_ncc\\alg_ive_ncc.c \u3010Efficiency\u3011 \uf06c The execution time is proportional to the resolution of an image. \uf06c The execution time of NVT_IVE_NCC is 537 , estimated by a sample (image resolution 512x376).","title":"3.13 NVT_IVE_NCC"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#4-error-code","text":"Return value Description LIB_IVE_OK Execute success LIB_IVE_ERR_PARAM Lib IVE param setting failure LIB_IVE_ERR_INIT IVE hardware init failure LIB_IVE_ERR_LOCK IVE hardware lock failure LIB_IVE_ERR_SET IVE hardware set param failure LIB_IVE_ERR_GET IVE hardware get param failure LIB_IVE_ERR_TRIG IVE hardware trigger failure LIB_IVE_ERR_UNLOCK IVE hardware unlock failure LIB_IVE_ERR_UNINIT IVE hardware uninit failure","title":"4 Error Code"},{"location":"Software/CVAI/NT9833X_IVE_User_Guide_en.html#5-revision-history","text":"Revision Date Author Changes 1.0 2022/5/9 Ethan Wang First Version. 1.1 2022/8/2 Ethan Wang 1. Add initialized & uninitialized IVE\u2019s function. 2. Update execution time of each function.","title":"5 Revision History"},{"location":"Software/CVAI/NT9833X_MD_Tuning_Guide_en.html","text":"1 Ten Sets of MD Parameters \u00b6 1.1 Overview \u00b6 We provide 10 sets of parameters of MD model for different sensitive degree (1\\~10, and 10 means the most sensitive parameters set). MD with a more sensitive parameter set can produce results with a lower miss rate and higher false alarm. 1.2 Scene Test \u00b6 The MD performance is evaluated using video tests and real-world tests. \uf06c Video test \uf06f Indoor Shadow remove = 1 Shadow remove = 0 \uf06f Stable moving scene \uf06f Outdoor \uf06f Dramatic AE changes scene \uf06c Real-world tests \uf06f Un-moving object. (e.g. a statue in the room) \uf06f Repetitively change of scenarios. (e.g. two images are played alternately every 15 seconds) \uf06f Progressive change of light in the scene. \uf06f Objects which keep moving in the scene. 1.3 Test Result \u00b6 sensitive ALPHA TB SIGMA Shadow remove 10 32 11 7 0 9 65 11 7 0 8 164 11 7 0 7 262 11 7 0 6 320 11 7 1 5 320 16 7 1 4 320 25 7 1 3 640 25 7 1 2 1200 11 7 1 1 1200 25 7 1 DEFAULT TBG = 29490 ONE_MIN_ALPHA = 32768-ALPHA INIT_WEIGHT=7 MODEL_UPDATE =0 TG=9 PRUNE=ALPHA*1.6 Shadow remove = 0 LUMA_DIFF_THRES =0 TEXT_DIFF_THRES=0 TEXT_THRES=50 TEXT_RATIO_THRES=127 Shadow remove = 1 LUMA_DIFF_THRES =30 TEXT_DIFF_THRES=50 TEXT_THRES=50 TEXT_RATIO_THRES=50 1.4 Tuning Suggestion \u00b6 \uf06c In the case of dramatic light change or moving shadow, a higher ALPHA value is suggested to reduce the false alarm. However, the side effect is that a slowly moving object might be detected as background. \uf06c In the case of dark shadow, a higher TB value is suggested. The side effect is that the detected foreground of object might be broken. \uf06c If the result of motion detection is not stable, we suggest to adjust TG to get a more stable result. 1.5 Scene Suggestion \u00b6 \uf06c MD is not suitable for the moment when turning on or turning off the light. The results of MD should be skipped at this moment for about 10 seconds. \uf06c MD should be used with a fixed-camera which captures a stable scene. Once camera moves, MD might need more time to get a stable background model. \uf06c The size of a detected moving object should be larger than 1 micro-block (MB) 2 Revision History \u00b6 Revision Date Author Changes 0.1 2021/06/30 Sophia First formal version 0.2 2021/07/02 Sophia Update document format and description","title":"MD Tuning Guide"},{"location":"Software/CVAI/NT9833X_MD_Tuning_Guide_en.html#1-ten-sets-of-md-parameters","text":"","title":"1 Ten Sets of MD Parameters"},{"location":"Software/CVAI/NT9833X_MD_Tuning_Guide_en.html#11-overview","text":"We provide 10 sets of parameters of MD model for different sensitive degree (1\\~10, and 10 means the most sensitive parameters set). MD with a more sensitive parameter set can produce results with a lower miss rate and higher false alarm.","title":"1.1 Overview"},{"location":"Software/CVAI/NT9833X_MD_Tuning_Guide_en.html#12-scene-test","text":"The MD performance is evaluated using video tests and real-world tests. \uf06c Video test \uf06f Indoor Shadow remove = 1 Shadow remove = 0 \uf06f Stable moving scene \uf06f Outdoor \uf06f Dramatic AE changes scene \uf06c Real-world tests \uf06f Un-moving object. (e.g. a statue in the room) \uf06f Repetitively change of scenarios. (e.g. two images are played alternately every 15 seconds) \uf06f Progressive change of light in the scene. \uf06f Objects which keep moving in the scene.","title":"1.2 Scene Test"},{"location":"Software/CVAI/NT9833X_MD_Tuning_Guide_en.html#13-test-result","text":"sensitive ALPHA TB SIGMA Shadow remove 10 32 11 7 0 9 65 11 7 0 8 164 11 7 0 7 262 11 7 0 6 320 11 7 1 5 320 16 7 1 4 320 25 7 1 3 640 25 7 1 2 1200 11 7 1 1 1200 25 7 1 DEFAULT TBG = 29490 ONE_MIN_ALPHA = 32768-ALPHA INIT_WEIGHT=7 MODEL_UPDATE =0 TG=9 PRUNE=ALPHA*1.6 Shadow remove = 0 LUMA_DIFF_THRES =0 TEXT_DIFF_THRES=0 TEXT_THRES=50 TEXT_RATIO_THRES=127 Shadow remove = 1 LUMA_DIFF_THRES =30 TEXT_DIFF_THRES=50 TEXT_THRES=50 TEXT_RATIO_THRES=50","title":"1.3 Test Result"},{"location":"Software/CVAI/NT9833X_MD_Tuning_Guide_en.html#14-tuning-suggestion","text":"\uf06c In the case of dramatic light change or moving shadow, a higher ALPHA value is suggested to reduce the false alarm. However, the side effect is that a slowly moving object might be detected as background. \uf06c In the case of dark shadow, a higher TB value is suggested. The side effect is that the detected foreground of object might be broken. \uf06c If the result of motion detection is not stable, we suggest to adjust TG to get a more stable result.","title":"1.4 Tuning Suggestion"},{"location":"Software/CVAI/NT9833X_MD_Tuning_Guide_en.html#15-scene-suggestion","text":"\uf06c MD is not suitable for the moment when turning on or turning off the light. The results of MD should be skipped at this moment for about 10 seconds. \uf06c MD should be used with a fixed-camera which captures a stable scene. Once camera moves, MD might need more time to get a stable background model. \uf06c The size of a detected moving object should be larger than 1 micro-block (MB)","title":"1.5 Scene Suggestion"},{"location":"Software/CVAI/NT9833X_MD_Tuning_Guide_en.html#2-revision-history","text":"Revision Date Author Changes 0.1 2021/06/30 Sophia First formal version 0.2 2021/07/02 Sophia Update document format and description","title":"2 Revision History"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html","text":"1 Introduction \u00b6 1.1 Overview \u00b6 The motion detection supports applications including global motion detection, sub-region motion detection, motion object detection and tamper detection. \uf06c Global motion detection By using a fixed camera, global motion detection issues alarm if the area of moving objects is larger than the user-defined threshold. Figure 1 Global motion detection \uf06c Sub-region motion detection By using a fixed camera, this function issues a sub-region motion alarm if the area of moving objects in the user-defined regions is larger than the user-defined threshold. Figure 2 Sub-region motion alarm \uf06c Motion objects detection By using a fixed camera, it detects moving objects if their areas are larger than a user-defined threshold. It also reports the sizes and coordinates of detected moving objects. Figure 3 Motion objects detection \uf06c Tamper detection By using a fixed camera, it issues a tamper alarm if the occlusion area is larger than a user-defined area threshold. Figure 4: Tamper Detection 1.2 Motion detection steps \u00b6 The steps of motion detection functions are Step. 1: Generating a initial background model by using the first few frames. Step. 2: Micro block (MB) map is used in motion detection. The size of each MB can be 32x32 or 16x16. The algorithm determines a MB as a motion block if the variance of blocks is higher than a predefined threshold. Step. 3: Updating the background model by using current frame information. Figure 5. The flowchart of MD algoritm 1.3 Process Flow \u00b6 Figure 6. The process flow of MD 1.4 Parameters \u00b6 MD has two major parameter types, as listed below \uf06c The parameters of vendor MD are used to control MD hardware. \uf06c The parameters of libmd are used to control MD software application. \uf06c Please notice that the parameters of vendor MD should be set before setting the parameters of libmd. 1.4.1 Parameters of vendor MD \u00b6 \uf06c VENDOR_MD_CTRL: trigger setting of MD hardware Parameter Range Comment Value engine_enabled 0, 1 HW trigger setting 0: close 1: open \uf06c VENDOR_MD_MDT_INFO: size information of MD hardware Parameter Range Comment Value phy_width 32\\~3840 Sensor resolution (width) \u2013 phy_height 16\\~2160 Sensor resolution (height) \u2013 phy_mb_x_size 16, 32 The x-size of micro-block (MB) for HW Set 32 when the phy_height is bigger than 1088. Set 16 when the phy_height is smaller than or equal to 1088. phy_mb_y_size 16, 32 The y-size of MB for HW Same value of phy_mb_x_size. phy_mb_x_num The number of MB in the MB-map at x-direction phy_width/ phy_mb_x_size phy_mb_y_num The number of MB in the MB-map at y-direction phy_height/ phy_mb_y_size \uf06c VENDOR_MD_MDT_PARAM_IDX: index of MD background model parameters id Comment VENDOR_MD_MDT_PARAM_RST Background model reset VENDOR_MD_MDT_PARAM_TYPE The method to construct background model VENDOR_MD_MDT_PARAM_TIME_PERIOD update time of background model (only for MD2) VENDOR_MD_MDT_PARAM_TBG Weight threshold of background model VENDOR_MD_MDT_PARAM_LVL_ALPHA Learning rate for the fitting background model VENDOR_MD_MDT_PARAM_LVL_ONE_MIN_ALPHA Learning rate for the nun-fitting background model VENDOR_MD_MDT_PARAM_LVL_INIT_WEIGHT Initial weight of background model VENDOR_MD_MDT_PARAM_LVL_MODEL_UPDATE Update constraint of background model VENDOR_MD_MDT_PARAM_LVL_TB Threshold of foreground detection VENDOR_MD_MDT_PARAM_LVL_SIGMA Variance threshold of background model VENDOR_MD_MDT_PARAM_LVL_TG Threshold of background model update VENDOR_MD_MDT_PARAM_LVL_PRUNE Threshold to decrease weight for nun-fitting background model VENDOR_MD_MDT_PARAM_LVL_LUMA_DIFF_THRES Luminance variance threshold at refine stage (only for MD1) VENDOR_MD_MDT_PARAM_LVL_TEXT_DIFF_THRES Texture variance threshold at refine stage (only for MD1) VENDOR_MD_MDT_PARAM_LVL_TEXT_THRES Texture strength threshold at refine stage (only for MD1) VENDOR_MD_MDT_PARAM_LVL_TEXT_RATIO_THRES Texture coverage ratio threshold at refine stage (only for MD1) VENDOR_MD_MDT_PARAM_LVL_GM_MD2_THRES Background threshold (only for MD2) \uf06c VENDOR_MD_MDT_PARAM: parameters of MD background model Parameter Comment out_id Path id level Choose the selective model id VENDOR_MD_MDT_PARAM_IDX value Parameter value \uf06c Value range of the VENDOR_MD_MDT_PARAM VENDOR_MD_MDT_PARAM_IDX Range Comment Value VENDOR_MD_MDT_PARAM_RST 0, 1 Reset MD background model 0: no reset 1: reset VENDOR_MD_MDT_PARAM_TYPE 0, 1 MD method type 0: MD1 (HW) (learning-based) 1: MD2 (HW) difference-based) VENDOR_MD_MDT_PARAM_TIME_PERIOD - Background update frame threshold (only for MD2) 10 VENDOR_MD_MDT_PARAM_TBG 1\\~32767 Background model weight threshold Suggest not to modify the value. 29490 VENDOR_MD_MDT_PARAM_LVL_ALPHA 1\\~32767 Background learning rate threshold when input fits model. Please set higher value when AE change obviously to avoid false alarm. 32 VENDOR_MD_MDT_PARAM_LVL_ONE_MIN_ALPHA 1\\~32767 Background learning rate threshold when input doesn\u2019t fit model. 32736 VENDOR_MD_MDT_PARAM_LVL_INIT_WEIGHT 1\\~32767 Background model initial weight 32 VENDOR_MD_MDT_PARAM_LVL_MODEL_UPDATE 0, 1 Background model constraint update Suggest not to modify the value. 0 VENDOR_MD_MDT_PARAM_LVL_TB 1\\~31 Background model fitting threshold. The MD is more sensitive when the value is lower. 25 VENDOR_MD_MDT_PARAM_LVL_SIGMA 1\\~31 Background model variance threshold. Set larger value to avoid false alarm when background luminance changes large. Please set the value lower when the MD result of detected object is broken. 25 VENDOR_MD_MDT_PARAM_LVL_TG 1\\~31 Background model count threshold. Suggest not to modify the value. 9 VENDOR_MD_MDT_PARAM_LVL_PRUNE 1\\~32767 Weight decrease threshold for un-fitting model 51 VENDOR_MD_MDT_PARAM_LVL_LUMA_DIFF_THRES 0\\~255 Luminance variance threshold at refine stage (only for MD1) 0 VENDOR_MD_MDT_PARAM_LVL_TEXT_DIFF_THRES 0\\~255 Texture variance threshold at refine stage (only for MD1) 0 VENDOR_MD_MDT_PARAM_LVL_TEXT_THRES 0\\~255 Texture strength threshold at refine stage (only for MD1) 0 VENDOR_MD_MDT_PARAM_LVL_TEXT_RATIO_THRES 0\\~127 Texture coverage ratio threshold at refine stage (only for MD1) 127 VENDOR_MD_MDT_PARAM_LVL_GM_MD2_THRES 0\\~255 Background threshold (only for MD2) 10 \uf06c VENDOR_MD_MDT_MB_LEVEL: region setting of the background model Parameter Range Comment x 0\\~max_width x position of the left upper corner of the region (physical plane, Unit: pixel) y 0\\~max_height y position of the left upper corner of the region (physical plane, Unit: pixel) width 1\\~max_width width of the left upper corner of the region (physical plane, Unit: pixel) height 1\\~max_height height of the left upper corner of the region (physical plane, Unit: pixel) level 0\\~3 The selective background model of the region \uf06c VENDOR_MD_TDT_PARAM_IDX: index of the tamper detection parameters id Comment VENDOR_MD_TDT_PARAM_TYPE Tamper detection method type VENDOR_MD_TDT_PARAM_EDGE_TEX_THRES Texture strength threshold VENDOR_MD_TDT_PARAM_EDGE_WIN_THRES Coverage of low texture strength threshold VENDOR_MD_TDT_PARAM_AVG_TEX_THRES Luminance strength threshold VENDOR_MD_TDT_PARAM_AVG_WIN_THRES Coverage of low luminance strength threshold \uf06c VENDOR_MD_MDT_PARAM: tamper detection parameters Parameter Comment out_id Path id id VENDOR_MD_TDT_PARAM_IDX value Parameter value \uf06c Value range of the tamper detection parameters VENDOR_MD_TDT_PARAM_IDX Range Comment Default VENDOR_MD_TDT_PARAM_TYPE 0, 1 Tamper detection method 0: edge-based 1: intensity based VENDOR_MD_TDT_PARAM_EDGE_TEX_THRES 0\\~255 Texture strength threshold 25 VENDOR_MD_TDT_PARAM_EDGE_WIN_THRES 0\\~127 Coverage of low texture strength threshold 100 VENDOR_MD_TDT_PARAM_AVG_TEX_THRES 0\\~255 Luminance strength threshold 65 VENDOR_MD_TDT_PARAM_AVG_WIN_THRES 0\\~127 Coverage of low luminance strength threshold 100 \uf06c VENDOR_BUFFER : buffer information structure Parameter Comment paddr Physical address size Buffer size ddr_id DDR_IDX \uf06c VENDOR_MD_BUFFER: buffer information of MD hardware Parameter Comment mb_x_num_max Maximum width of the MB number(Unit: MB number) mb_y_num_max Maximum height of the MB number(Unit: MB number) sta MD HW statistics value buffer event MD HWmotion bitmap buffer level MD HW selective background model buffer \uf06c VENDOR_MD_PARAM_ID: index of vendor_md function id Comment VENDOR_MD_CTRL_PARAM MD HW control structure VENDOR_MD_MOTION_DETECT_INFO MD HW process size unit structure VENDOR_MD_MOTION_DETECT_PARAM MD HW background model parameter structure VENDOR_MD_MOTION_DETECT_MB_LEVEL MD HW background model selective model structure VENDOR_MD_MOTION_DETECT_BUFFER MD HW buffer structure VENDOR_MD_TAMPER_DETECT_PARAM MD HW tamper parameter structure VENDOR_MD_RESULT_INFO MD HW result structure VENDOR_MD_REASSIGN_BUFFERS MD reassign buffer API. When max MB num is larger than (1920/16, 1080/16) or want to shrink MD buffer size. Note: hdal default pool buffer size for MD is (120,67) and 8 channel. If you use reassign buffer, you should change the hdal default pool buffer size. 1.4.2 Parameters of libmd \u00b6 \uf06c LIB_MD_AP_ENABLE: trigger setting of MD application: Parameter Range Comment globel_md_alarm_detect_en 0, 1 Global motion alarm enable subregion_md_alarm_detect_en 0, 1 Sub-region motion alarm enable md_obj_detect_en 0, 1 Objects detection enable md_postprocess_en 0, 1 Motionbitmap postprocess enable \uf06c LIB_MD_EVT_INFO: results of motion detection Parameter Comment p_evt_map MD HW event bimap buffer evt_sz MD HW event bimap buffer size timestamp MD event timestamp \uf06c LIB_MD_MDT_INFO: size setting information of libmd Parameter Range Comment Default md_enabled 0, 1 Libmd enable vendor_md engine_enabled should be enable firstly vp_width 1\\~3840 User plane width suggest to set as sensor setting vp_height 1\\~2160 User plane height suggest to set as sensor setting vp_mb_x_size 16, 32 Width of MB size in the user plane suggest to set the same value of phy_mb_x_size vp_mb_y_size 16, 32 Height of MB size in the user plane suggest to set the same value of phy_mb_y_size vp_mb_x_num - Width of MB number in the user plane vp_width / vp_mb_x_size vp_mb_y_num - Height of MB number in the user plane vp_height / vp_mb_y_size phy_mb_x_size 16, 32 HW width of MB size set the same as vendor_md phy_mb_y_size 16, 32 HW height of MB size set the same as vendor_md phy_mb_x_num Sensor_width/ phy_mb_x_size set the same as vendor_md phy_mb_y_num Sensor_height/ phy_mb_y_size set the same as vendor_md \uf06c LIB_MD_AP_POSTPROCESS: post-process type of libmd event Parameter Range Comment Default evt_postprocess_type 0\\~7 Motion event postprocess 0: no 1: one erosion + two dilation 2: two dilation + one erosion 3: two dilation 4: one dilation 5: one erosion 6: one dilation + one erosion 7: one erosion + one dilation \uf06c LIB_MD_AP_GLOBAL_MOTION_ALARM: parameters of global motion alarm detection Parameter Range Comment motion_alarm_th 0\\~100 Global motion detection alarm area coverage ratio threshold (%). MD is more sensitive when the value is lower. ref_cell_en 0, 1 The detection result will reference p_cell_map or not. When the value is 1, the global motion alarm/ sub-region motion alarm/ object detection result will reference the p_cell_map. p_cell_map 0, 1 The detection result will reference the buffer when the ref_cell_en=1. cell_map_sz vp_mb_x_num* vp_mb_y_num The buffer size of the p_cell_map \uf06c LIB_MD_AP_SUBREGION: parameters of specified sub-region structure Parameter Range Comment enabled 0, 1 Sub-region motion detection alarm enable x_start 0\\~mb_w_num-1 x position of the left upper corner of the region (virtual plane\uff0cUnit: macro block) y_start 0\\~mb_h_num-1 y position of the left upper corner of the region (virtual plane\uff0cUnit: macro block) x_end 0\\~mb_w_num-1 x position of the right under corner of the region (virtual plane\uff0cUnit: macro block) y_end 0\\~mb_h_num-1 y position of the right under corner of the region (virtual plane\uff0cUnit: macro block) alarm_th 0\\~100 Sub-region motion detection alarm area coverage ratio threshold (%). MD is more sensitive when the value is lower. \uf06c LIB_MD_AP_SUBREGION_MOTION_ALARM: parameters of sub-region motion alarm detection Parameter Range Comment sub_region_num 0\\~4 Specified sub-region number sub_region - Specified sub-region structure \uf06c LIB_MD_AP_OBJ: size setting of minmum motion object Parameter Range Comment object_size - Minimum size of detected moing objects (Unit: macro block) \uf06c LIB_MD_AP_OBJ_INFO: information of motion objects Parameter Range Comment start_x 0\\~ vp_width x position of the left upper corner of the motion object (virtual plane\uff0cUnit:pixel) start_y 0\\~vp_height y position of the left upper corner of the motion object (virtual plane\uff0cUnit:pixel) end_x 0\\~ vp_width x position of the right under corner of the motion object (virtual plane\uff0cUnit: macro block) end_y 0\\~vp_height y position of the right under corner of the motion object (virtual plane\uff0cUnit: macro block) label 0\\~128 Motion obect index \uf06c LIB_MD_MDT_RESULT_INFO: results information of the libmd Parameter Range Comment Value global_motion_alarm 0, 1 Global motion detection alarm 0: no alarm 1: alarm global_motion_alarm_num 0\\~ vp_mb_x_num* vp_mb_y_num Motion MB number sub_motion_alarm 0, 1 Sub-region motion detection alarm 0: no alarm 1: alarm obj_num 0\\~128 Motion object number obj - Motion object structure vp_evt_info - Motion detection event map in the user plane \uf06c LIB_MD_PARAM_ID: index of libmd function Parameter Comment LIB_MD_MOTION_DETECT_INFO Libmd set virtual/physical plane evt bitmap addr. Physical plane should be set the same as vendor_md. Physical evt bitmap address is vendor_md output result motion bitmap address. evt bitmap addr\u70bavendor_md output result Libmd all detection application enable port LIB_MD_AP_ENABLE_PARAM Libmd postprocess enable LIB_MD_AP_POSTPROCESS_PARAM Libmd global motion detection enable LIB_MD_AP_GLOBAL_MOTION_ALARM_PARAM Libmd sub-region motion detection enable LIB_MD_AP_SUBREGION_MOTION_ALARM_PARAM Libmd motion object detection enable LIB_MD_AP_OBJ_PARAM Libmd result information Note: The MD model can lean the stable change of scene, such as river or twinkle light. If the user want to detect this kind of events, the parameters can be set as following: \uf06c Model parameters \uf06f tg=3 \uf06f tb=19 \uf06f alpha = 1024 \uf06c Refine process \uf06f lum_diff_th=75 \uf06f tex_diff_th=50 \uf06f tex_ratio_th=50 1.5 Initilization of MD \u00b6 \uf06c Vendor MD The buffer of vender MD and HW internal parametesrs should be set by the API as following: HD_RESULT md_init(void); \uf06c Libmd The buffer of libmd and software parametesrs should be set by the API as following: HD_RESULT motion_set_ap_param(UINT32 path_id); HD_RESULT lib_md_init(HD_PATH_ID path_id); // libmd buffer setting shoule be set after HW MD size setting which set through motion_set_ap_param. 1.6 Parameters Setting of MD \u00b6 \uf06c Vendor MD Vendor MD parameters should be set by the following API. ret = vendor_md_set(video_cap[ch], VENDOR_MD_CTRL_PARAM, \\&md_cfg); The content of VENDOR_MD_PARAM_ID is list in the section1.4.1. \uf06c Libmd The parameters of libmd should be set by the following API. ret = lib_md_set(path_id, LIB_MD_AP_ENABLE_PARAM, \\&mdt_lib_param[idx].mdt_enable); The content of LIB_MD_PARAM_ID is list in the section1.4.2. 1.7 Execution of MD \u00b6 1.7.1 vendor MD \u00b6 Vendor MD application should be set by the following API. // buffer and parameters intial setting HD_RESULT md_init(void); // create md_thread static void *md_thread(void *arg); //set and get vendor md API ret = vendor_md_get(path_id, VENDOR_MD_MOTION_DETECT_INFO, &mdt_info); ret = vendor_md_set(path_id, VENDOR_MD_RESULT_INFO, &result_info); ret = vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info); 1.7.2 libmd \u00b6 libmd application should be set by the following API. // buffer and parameters intial setting HD_RESULT motion_set_ap_param(UINT32 path_id); HD_RESULT lib_md_init(HD_PATH_ID path_id); // create md_thread static void *md_thread(void *arg); //set and get libmd API ret = vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info); //libmd process should use vendor_md result as input vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info) ret = lib_md_set(path_id, LIB_MD_MOTION_DETECT_INFO, &lib_md_info); ret = lib_md_get(path_id, LIB_MD_RESULT_INFO, &lib_md_rst); 1.8 Requirement of MD \u00b6 \uf06c MD funtions only be applied by CPU and HW. 1.9 Limitation of MD \u00b6 \uf06c MD shoud be used in the fixed-camera. If camera has been moved, MD function might output a false alarm event. \uf06c MD function might output a false alarm event because of the zoom in/out of camera or the adjustment of auto white balance. \uf06c The size of moving object should be larger than 1 micro-block (MB) 1.10 Test Flow of MD \u00b6 \uf06c Check MD use in the fixed-camera scene \uf06c Check MD event bitmap to check MD flow \uf06c MD should be used after 3 frames to create initial background. 2 Output \u00b6 2.1 Get Output Results of MD \u00b6 \uf06c vendor MD Vendor MD result should be set/got by the following API. ret = vendor_md_set(path_id, VENDOR_MD_RESULT_INFO, &result_info); ret = vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info); The structure of MD hardware result lists as following. typedef struct _VENDOR_MD_MDT_RESULT_INFO { UINT8 *p_evt_map; ///< motion detection bitmap, size is evt_sz UINT32 evt_sz; ///< phy_mb_x_num*phy_mb_y_num MB UINT8 tp_result; ///< tamper alarm UINT32 timestamp; } VENDOR_MD_MDT_RESULT_INFO; \uf06c libmd libmd result should be set/got by the following API. vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info) ret = lib_md_set(path_id, LIB_MD_MOTION_DETECT_INFO, &lib_md_info); ret = lib_md_get(path_id, LIB_MD_RESULT_INFO, &lib_md_rst); libmd result structure lists as following. typedef struct _LIB_MD_MDT_RESULT_INFO { UINT8 global_motion_alarm; ///< global motion alarm UINT32 global_motion_alarm_num; ///< global motion alarm num UINT32 sub_motion_alarm[LIB_MD_MAX_SUB_REGION_NUM]; ///< sub-region motion alarm UINT32 obj_num; ///< detect object number (max=128) LIB_MD_AP_OBJ_INFO obj[LIB_MD_MAX_OBJ_NUM]; ///< detect object info LIB_MD_EVT_INFO vp_evt_info; } LIB_MD_MDT_RESULT_INFO; typedef struct _LIB_MD_EVT_INFO { UINT8 *p_evt_map; ///< motion detection bitmap, size is evt_sz UINT32 evt_sz; ///< mb_x_num*mb_y_num MB UINT32 timestamp; } LIB_MD_EVT_INFO; typedef struct _LIB_MD_AP_OBJ_INFO { UINT32 start_x; ///< obj rectangle left upper x position (virtual pixel) UINT32 start_y; ///< obj rectangle left upper y position (virtual pixel) UINT32 end_x; ///< obj rectangle right down x position (virtual pixel) UINT32 end_y; ///< obj rectangle right down y position (virtual pixel) UINT32 label; ///< obj label } LIB_MD_AP_OBJ_INFO; 2.2 Print Output Results of MD \u00b6 \uf06c Output Result of Global Motion Detection UART will print the results as following when motion area in the whole scene is larger than user-defined threshold. > global motion alarm on ch(specified channel). \uf06c Output Result of Sub-region Motion Detection UART will print the results as following when the motion area in one or more sub-regions is larger than user-defined threshold. > sub_region[specified region index] motion alarm on ch(specified channel). \uf06c Output Result of Motion Object Detection UART will print the results as following when motion objects area are larger than minimum object user-defined threshold. > obj num:Motion object number and obj[object index]: start_xy=[left upper corner position of motion object], end_xy = [right under corner position of motion object], label = object label. \uf06c Output Result of Tamper Detection UART will print the results as following when occlusion area is larger than user-defined threshold. > tamper_result:1 on ch(specified channel). 2.3 Limitation MD Hardware \u00b6 \uf06c Maximum sensor resolution is 3840x2160. \uf06c Maximum MB number of MD hardware are (mb_x_num, mb_y_num) = (256, 128) and minimum MB number of MD hardware are (mb_x_num, mb_y_num) = (2, 1). \uf06c In the Vcap flow, MD doesn\u2019t support the scale function. 2.4 Requirement of MD System \u00b6 \uf06c The efficiency of MD function is associated with system loading. The ouput result of MD may be delayed when system is overloading. 2.5 Tuning of MD Parameters \u00b6 \uf06c In the scene with the shortly changing of light, such as AE adjustment or turn-on and turn-off the light, please set the value of alpha higher. The side effect is that moving slowly object might be detected as background. \uf06c Please set tb to be higher for shadow. The side effect is that the detected forground of moving obeject might be broken. In this case, please also set \u201csigma\u201d to be lower to fix the broken forground issue. \uf06c The distance between moving object and camera should be farer than 30 cm. If the moving objects is too close to the camera, there might cause the false alarm of shadow. \uf06c Please set lower tb when foreground luminance is similar background. However, the side effect is that the false alarm of shadow may be increase. \uf06c Please see section 1.5 when you need to detect stable motion case. \uf06c The MD function doesn\u2019t support night view with IR-cut. In this case, there might be similar between background and foreground. \uf06c There is no motion event when MD is creating intial background model. Also, MD will need longer time to create initial backgroung model if there are some moving objects in the initial scene. \uf06c The size of moving object should be larger than 1 MB. 3 Q&A \u00b6 (1) How to check vendor MD version? Ans: echo md > /proc/hdal/flow Execute AP cat /proc/hdal/flow (2) How to set the md sensitive? Ans: I. Use vendor_md_set API (the details describe in the 1.6 section and the section 1.4.1. II. Tuning Guide document provide the tuning parameter suggestion. If any more question, please provide the video and parameters. (3) How to solve sensor resolution change error? Ans: If you want to chage sensor reolution, please vendor_md_unint & vendor_md_int at fisrt and you might see liveview_with_md_ctrl.c or liveview_with_md_resolution.c (4) How to check sensor interlace case? Ans: MD is field input. If input is interlace, please set the half of the sensor input height. You can see interlace case through command as following cat /proc/vcap316/vcap0/vg_info. (5) Check AD mode (960H and 720) case Ans: I. Check AD output is full frame. II. MD input size is the same as the AD output size. phy_width andphy_height should be calculate by AD output (might not be the size of sensor). The size setting check by /proc/vcap316/vcap0/vg_info and vcap md (detal describe in question 6 ). (6) If any setting question of the vendor_md flow, please provide the log of vendor_md flow by the following command. Ans: echo md > /proc/hdal/flow Execute AP cat /proc/hdal/flow (7) How to check vcap md setting Ans: echo vcap_ch > /proc/vcap316/vcap0/vcap0.CHIP/md/event (vcap_ch and CHIP according to vg_info) cat /proc/vcap316/vcap0/vcap0. CHIP /md/region cat /proc/vcap316/vcap0/vcap0. CHIP /md/param (8) How to solve the mb num >(120,67)? Ans: I. modify hdal excel buffer size setting II. open reassign_buffer (9) How to use the level setting ? Ans: Each MB can be setted different level. Each level is mapping the set of background model. In nomal scene, all scene use the same level. In the scene which include both indoor and outdoor, you can set two level of the scene. (10) Where is the tamper sample code? Ans: tamper sample code is liveview_with_md.c. 4 Revision History \u00b6 Revision Date Author Changes 0.1 2021/06/30 Sophia First formal version 0.2 2021/07/02 Sophia Update document format and description 0.3 2022/06/24 Hunter Modify the description of mb size and some wrong information.","title":"MD User Guide"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#1-introduction","text":"","title":"1 Introduction"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#11-overview","text":"The motion detection supports applications including global motion detection, sub-region motion detection, motion object detection and tamper detection. \uf06c Global motion detection By using a fixed camera, global motion detection issues alarm if the area of moving objects is larger than the user-defined threshold. Figure 1 Global motion detection \uf06c Sub-region motion detection By using a fixed camera, this function issues a sub-region motion alarm if the area of moving objects in the user-defined regions is larger than the user-defined threshold. Figure 2 Sub-region motion alarm \uf06c Motion objects detection By using a fixed camera, it detects moving objects if their areas are larger than a user-defined threshold. It also reports the sizes and coordinates of detected moving objects. Figure 3 Motion objects detection \uf06c Tamper detection By using a fixed camera, it issues a tamper alarm if the occlusion area is larger than a user-defined area threshold. Figure 4: Tamper Detection","title":"1.1 Overview"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#12-motion-detection-steps","text":"The steps of motion detection functions are Step. 1: Generating a initial background model by using the first few frames. Step. 2: Micro block (MB) map is used in motion detection. The size of each MB can be 32x32 or 16x16. The algorithm determines a MB as a motion block if the variance of blocks is higher than a predefined threshold. Step. 3: Updating the background model by using current frame information. Figure 5. The flowchart of MD algoritm","title":"1.2 Motion detection steps"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#13-process-flow","text":"Figure 6. The process flow of MD","title":"1.3 Process Flow"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#14-parameters","text":"MD has two major parameter types, as listed below \uf06c The parameters of vendor MD are used to control MD hardware. \uf06c The parameters of libmd are used to control MD software application. \uf06c Please notice that the parameters of vendor MD should be set before setting the parameters of libmd.","title":"1.4 Parameters"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#141-parameters-of-vendor-md","text":"\uf06c VENDOR_MD_CTRL: trigger setting of MD hardware Parameter Range Comment Value engine_enabled 0, 1 HW trigger setting 0: close 1: open \uf06c VENDOR_MD_MDT_INFO: size information of MD hardware Parameter Range Comment Value phy_width 32\\~3840 Sensor resolution (width) \u2013 phy_height 16\\~2160 Sensor resolution (height) \u2013 phy_mb_x_size 16, 32 The x-size of micro-block (MB) for HW Set 32 when the phy_height is bigger than 1088. Set 16 when the phy_height is smaller than or equal to 1088. phy_mb_y_size 16, 32 The y-size of MB for HW Same value of phy_mb_x_size. phy_mb_x_num The number of MB in the MB-map at x-direction phy_width/ phy_mb_x_size phy_mb_y_num The number of MB in the MB-map at y-direction phy_height/ phy_mb_y_size \uf06c VENDOR_MD_MDT_PARAM_IDX: index of MD background model parameters id Comment VENDOR_MD_MDT_PARAM_RST Background model reset VENDOR_MD_MDT_PARAM_TYPE The method to construct background model VENDOR_MD_MDT_PARAM_TIME_PERIOD update time of background model (only for MD2) VENDOR_MD_MDT_PARAM_TBG Weight threshold of background model VENDOR_MD_MDT_PARAM_LVL_ALPHA Learning rate for the fitting background model VENDOR_MD_MDT_PARAM_LVL_ONE_MIN_ALPHA Learning rate for the nun-fitting background model VENDOR_MD_MDT_PARAM_LVL_INIT_WEIGHT Initial weight of background model VENDOR_MD_MDT_PARAM_LVL_MODEL_UPDATE Update constraint of background model VENDOR_MD_MDT_PARAM_LVL_TB Threshold of foreground detection VENDOR_MD_MDT_PARAM_LVL_SIGMA Variance threshold of background model VENDOR_MD_MDT_PARAM_LVL_TG Threshold of background model update VENDOR_MD_MDT_PARAM_LVL_PRUNE Threshold to decrease weight for nun-fitting background model VENDOR_MD_MDT_PARAM_LVL_LUMA_DIFF_THRES Luminance variance threshold at refine stage (only for MD1) VENDOR_MD_MDT_PARAM_LVL_TEXT_DIFF_THRES Texture variance threshold at refine stage (only for MD1) VENDOR_MD_MDT_PARAM_LVL_TEXT_THRES Texture strength threshold at refine stage (only for MD1) VENDOR_MD_MDT_PARAM_LVL_TEXT_RATIO_THRES Texture coverage ratio threshold at refine stage (only for MD1) VENDOR_MD_MDT_PARAM_LVL_GM_MD2_THRES Background threshold (only for MD2) \uf06c VENDOR_MD_MDT_PARAM: parameters of MD background model Parameter Comment out_id Path id level Choose the selective model id VENDOR_MD_MDT_PARAM_IDX value Parameter value \uf06c Value range of the VENDOR_MD_MDT_PARAM VENDOR_MD_MDT_PARAM_IDX Range Comment Value VENDOR_MD_MDT_PARAM_RST 0, 1 Reset MD background model 0: no reset 1: reset VENDOR_MD_MDT_PARAM_TYPE 0, 1 MD method type 0: MD1 (HW) (learning-based) 1: MD2 (HW) difference-based) VENDOR_MD_MDT_PARAM_TIME_PERIOD - Background update frame threshold (only for MD2) 10 VENDOR_MD_MDT_PARAM_TBG 1\\~32767 Background model weight threshold Suggest not to modify the value. 29490 VENDOR_MD_MDT_PARAM_LVL_ALPHA 1\\~32767 Background learning rate threshold when input fits model. Please set higher value when AE change obviously to avoid false alarm. 32 VENDOR_MD_MDT_PARAM_LVL_ONE_MIN_ALPHA 1\\~32767 Background learning rate threshold when input doesn\u2019t fit model. 32736 VENDOR_MD_MDT_PARAM_LVL_INIT_WEIGHT 1\\~32767 Background model initial weight 32 VENDOR_MD_MDT_PARAM_LVL_MODEL_UPDATE 0, 1 Background model constraint update Suggest not to modify the value. 0 VENDOR_MD_MDT_PARAM_LVL_TB 1\\~31 Background model fitting threshold. The MD is more sensitive when the value is lower. 25 VENDOR_MD_MDT_PARAM_LVL_SIGMA 1\\~31 Background model variance threshold. Set larger value to avoid false alarm when background luminance changes large. Please set the value lower when the MD result of detected object is broken. 25 VENDOR_MD_MDT_PARAM_LVL_TG 1\\~31 Background model count threshold. Suggest not to modify the value. 9 VENDOR_MD_MDT_PARAM_LVL_PRUNE 1\\~32767 Weight decrease threshold for un-fitting model 51 VENDOR_MD_MDT_PARAM_LVL_LUMA_DIFF_THRES 0\\~255 Luminance variance threshold at refine stage (only for MD1) 0 VENDOR_MD_MDT_PARAM_LVL_TEXT_DIFF_THRES 0\\~255 Texture variance threshold at refine stage (only for MD1) 0 VENDOR_MD_MDT_PARAM_LVL_TEXT_THRES 0\\~255 Texture strength threshold at refine stage (only for MD1) 0 VENDOR_MD_MDT_PARAM_LVL_TEXT_RATIO_THRES 0\\~127 Texture coverage ratio threshold at refine stage (only for MD1) 127 VENDOR_MD_MDT_PARAM_LVL_GM_MD2_THRES 0\\~255 Background threshold (only for MD2) 10 \uf06c VENDOR_MD_MDT_MB_LEVEL: region setting of the background model Parameter Range Comment x 0\\~max_width x position of the left upper corner of the region (physical plane, Unit: pixel) y 0\\~max_height y position of the left upper corner of the region (physical plane, Unit: pixel) width 1\\~max_width width of the left upper corner of the region (physical plane, Unit: pixel) height 1\\~max_height height of the left upper corner of the region (physical plane, Unit: pixel) level 0\\~3 The selective background model of the region \uf06c VENDOR_MD_TDT_PARAM_IDX: index of the tamper detection parameters id Comment VENDOR_MD_TDT_PARAM_TYPE Tamper detection method type VENDOR_MD_TDT_PARAM_EDGE_TEX_THRES Texture strength threshold VENDOR_MD_TDT_PARAM_EDGE_WIN_THRES Coverage of low texture strength threshold VENDOR_MD_TDT_PARAM_AVG_TEX_THRES Luminance strength threshold VENDOR_MD_TDT_PARAM_AVG_WIN_THRES Coverage of low luminance strength threshold \uf06c VENDOR_MD_MDT_PARAM: tamper detection parameters Parameter Comment out_id Path id id VENDOR_MD_TDT_PARAM_IDX value Parameter value \uf06c Value range of the tamper detection parameters VENDOR_MD_TDT_PARAM_IDX Range Comment Default VENDOR_MD_TDT_PARAM_TYPE 0, 1 Tamper detection method 0: edge-based 1: intensity based VENDOR_MD_TDT_PARAM_EDGE_TEX_THRES 0\\~255 Texture strength threshold 25 VENDOR_MD_TDT_PARAM_EDGE_WIN_THRES 0\\~127 Coverage of low texture strength threshold 100 VENDOR_MD_TDT_PARAM_AVG_TEX_THRES 0\\~255 Luminance strength threshold 65 VENDOR_MD_TDT_PARAM_AVG_WIN_THRES 0\\~127 Coverage of low luminance strength threshold 100 \uf06c VENDOR_BUFFER : buffer information structure Parameter Comment paddr Physical address size Buffer size ddr_id DDR_IDX \uf06c VENDOR_MD_BUFFER: buffer information of MD hardware Parameter Comment mb_x_num_max Maximum width of the MB number(Unit: MB number) mb_y_num_max Maximum height of the MB number(Unit: MB number) sta MD HW statistics value buffer event MD HWmotion bitmap buffer level MD HW selective background model buffer \uf06c VENDOR_MD_PARAM_ID: index of vendor_md function id Comment VENDOR_MD_CTRL_PARAM MD HW control structure VENDOR_MD_MOTION_DETECT_INFO MD HW process size unit structure VENDOR_MD_MOTION_DETECT_PARAM MD HW background model parameter structure VENDOR_MD_MOTION_DETECT_MB_LEVEL MD HW background model selective model structure VENDOR_MD_MOTION_DETECT_BUFFER MD HW buffer structure VENDOR_MD_TAMPER_DETECT_PARAM MD HW tamper parameter structure VENDOR_MD_RESULT_INFO MD HW result structure VENDOR_MD_REASSIGN_BUFFERS MD reassign buffer API. When max MB num is larger than (1920/16, 1080/16) or want to shrink MD buffer size. Note: hdal default pool buffer size for MD is (120,67) and 8 channel. If you use reassign buffer, you should change the hdal default pool buffer size.","title":"1.4.1 Parameters of vendor MD"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#142-parameters-of-libmd","text":"\uf06c LIB_MD_AP_ENABLE: trigger setting of MD application: Parameter Range Comment globel_md_alarm_detect_en 0, 1 Global motion alarm enable subregion_md_alarm_detect_en 0, 1 Sub-region motion alarm enable md_obj_detect_en 0, 1 Objects detection enable md_postprocess_en 0, 1 Motionbitmap postprocess enable \uf06c LIB_MD_EVT_INFO: results of motion detection Parameter Comment p_evt_map MD HW event bimap buffer evt_sz MD HW event bimap buffer size timestamp MD event timestamp \uf06c LIB_MD_MDT_INFO: size setting information of libmd Parameter Range Comment Default md_enabled 0, 1 Libmd enable vendor_md engine_enabled should be enable firstly vp_width 1\\~3840 User plane width suggest to set as sensor setting vp_height 1\\~2160 User plane height suggest to set as sensor setting vp_mb_x_size 16, 32 Width of MB size in the user plane suggest to set the same value of phy_mb_x_size vp_mb_y_size 16, 32 Height of MB size in the user plane suggest to set the same value of phy_mb_y_size vp_mb_x_num - Width of MB number in the user plane vp_width / vp_mb_x_size vp_mb_y_num - Height of MB number in the user plane vp_height / vp_mb_y_size phy_mb_x_size 16, 32 HW width of MB size set the same as vendor_md phy_mb_y_size 16, 32 HW height of MB size set the same as vendor_md phy_mb_x_num Sensor_width/ phy_mb_x_size set the same as vendor_md phy_mb_y_num Sensor_height/ phy_mb_y_size set the same as vendor_md \uf06c LIB_MD_AP_POSTPROCESS: post-process type of libmd event Parameter Range Comment Default evt_postprocess_type 0\\~7 Motion event postprocess 0: no 1: one erosion + two dilation 2: two dilation + one erosion 3: two dilation 4: one dilation 5: one erosion 6: one dilation + one erosion 7: one erosion + one dilation \uf06c LIB_MD_AP_GLOBAL_MOTION_ALARM: parameters of global motion alarm detection Parameter Range Comment motion_alarm_th 0\\~100 Global motion detection alarm area coverage ratio threshold (%). MD is more sensitive when the value is lower. ref_cell_en 0, 1 The detection result will reference p_cell_map or not. When the value is 1, the global motion alarm/ sub-region motion alarm/ object detection result will reference the p_cell_map. p_cell_map 0, 1 The detection result will reference the buffer when the ref_cell_en=1. cell_map_sz vp_mb_x_num* vp_mb_y_num The buffer size of the p_cell_map \uf06c LIB_MD_AP_SUBREGION: parameters of specified sub-region structure Parameter Range Comment enabled 0, 1 Sub-region motion detection alarm enable x_start 0\\~mb_w_num-1 x position of the left upper corner of the region (virtual plane\uff0cUnit: macro block) y_start 0\\~mb_h_num-1 y position of the left upper corner of the region (virtual plane\uff0cUnit: macro block) x_end 0\\~mb_w_num-1 x position of the right under corner of the region (virtual plane\uff0cUnit: macro block) y_end 0\\~mb_h_num-1 y position of the right under corner of the region (virtual plane\uff0cUnit: macro block) alarm_th 0\\~100 Sub-region motion detection alarm area coverage ratio threshold (%). MD is more sensitive when the value is lower. \uf06c LIB_MD_AP_SUBREGION_MOTION_ALARM: parameters of sub-region motion alarm detection Parameter Range Comment sub_region_num 0\\~4 Specified sub-region number sub_region - Specified sub-region structure \uf06c LIB_MD_AP_OBJ: size setting of minmum motion object Parameter Range Comment object_size - Minimum size of detected moing objects (Unit: macro block) \uf06c LIB_MD_AP_OBJ_INFO: information of motion objects Parameter Range Comment start_x 0\\~ vp_width x position of the left upper corner of the motion object (virtual plane\uff0cUnit:pixel) start_y 0\\~vp_height y position of the left upper corner of the motion object (virtual plane\uff0cUnit:pixel) end_x 0\\~ vp_width x position of the right under corner of the motion object (virtual plane\uff0cUnit: macro block) end_y 0\\~vp_height y position of the right under corner of the motion object (virtual plane\uff0cUnit: macro block) label 0\\~128 Motion obect index \uf06c LIB_MD_MDT_RESULT_INFO: results information of the libmd Parameter Range Comment Value global_motion_alarm 0, 1 Global motion detection alarm 0: no alarm 1: alarm global_motion_alarm_num 0\\~ vp_mb_x_num* vp_mb_y_num Motion MB number sub_motion_alarm 0, 1 Sub-region motion detection alarm 0: no alarm 1: alarm obj_num 0\\~128 Motion object number obj - Motion object structure vp_evt_info - Motion detection event map in the user plane \uf06c LIB_MD_PARAM_ID: index of libmd function Parameter Comment LIB_MD_MOTION_DETECT_INFO Libmd set virtual/physical plane evt bitmap addr. Physical plane should be set the same as vendor_md. Physical evt bitmap address is vendor_md output result motion bitmap address. evt bitmap addr\u70bavendor_md output result Libmd all detection application enable port LIB_MD_AP_ENABLE_PARAM Libmd postprocess enable LIB_MD_AP_POSTPROCESS_PARAM Libmd global motion detection enable LIB_MD_AP_GLOBAL_MOTION_ALARM_PARAM Libmd sub-region motion detection enable LIB_MD_AP_SUBREGION_MOTION_ALARM_PARAM Libmd motion object detection enable LIB_MD_AP_OBJ_PARAM Libmd result information Note: The MD model can lean the stable change of scene, such as river or twinkle light. If the user want to detect this kind of events, the parameters can be set as following: \uf06c Model parameters \uf06f tg=3 \uf06f tb=19 \uf06f alpha = 1024 \uf06c Refine process \uf06f lum_diff_th=75 \uf06f tex_diff_th=50 \uf06f tex_ratio_th=50","title":"1.4.2 Parameters of libmd"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#15-initilization-of-md","text":"\uf06c Vendor MD The buffer of vender MD and HW internal parametesrs should be set by the API as following: HD_RESULT md_init(void); \uf06c Libmd The buffer of libmd and software parametesrs should be set by the API as following: HD_RESULT motion_set_ap_param(UINT32 path_id); HD_RESULT lib_md_init(HD_PATH_ID path_id); // libmd buffer setting shoule be set after HW MD size setting which set through motion_set_ap_param.","title":"1.5 Initilization of MD"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#16-parameters-setting-of-md","text":"\uf06c Vendor MD Vendor MD parameters should be set by the following API. ret = vendor_md_set(video_cap[ch], VENDOR_MD_CTRL_PARAM, \\&md_cfg); The content of VENDOR_MD_PARAM_ID is list in the section1.4.1. \uf06c Libmd The parameters of libmd should be set by the following API. ret = lib_md_set(path_id, LIB_MD_AP_ENABLE_PARAM, \\&mdt_lib_param[idx].mdt_enable); The content of LIB_MD_PARAM_ID is list in the section1.4.2.","title":"1.6 Parameters Setting of MD"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#17-execution-of-md","text":"","title":"1.7 Execution of MD"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#171-vendor-md","text":"Vendor MD application should be set by the following API. // buffer and parameters intial setting HD_RESULT md_init(void); // create md_thread static void *md_thread(void *arg); //set and get vendor md API ret = vendor_md_get(path_id, VENDOR_MD_MOTION_DETECT_INFO, &mdt_info); ret = vendor_md_set(path_id, VENDOR_MD_RESULT_INFO, &result_info); ret = vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info);","title":"1.7.1 vendor MD"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#172-libmd","text":"libmd application should be set by the following API. // buffer and parameters intial setting HD_RESULT motion_set_ap_param(UINT32 path_id); HD_RESULT lib_md_init(HD_PATH_ID path_id); // create md_thread static void *md_thread(void *arg); //set and get libmd API ret = vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info); //libmd process should use vendor_md result as input vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info) ret = lib_md_set(path_id, LIB_MD_MOTION_DETECT_INFO, &lib_md_info); ret = lib_md_get(path_id, LIB_MD_RESULT_INFO, &lib_md_rst);","title":"1.7.2 libmd"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#18-requirement-of-md","text":"\uf06c MD funtions only be applied by CPU and HW.","title":"1.8 Requirement of MD"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#19-limitation-of-md","text":"\uf06c MD shoud be used in the fixed-camera. If camera has been moved, MD function might output a false alarm event. \uf06c MD function might output a false alarm event because of the zoom in/out of camera or the adjustment of auto white balance. \uf06c The size of moving object should be larger than 1 micro-block (MB)","title":"1.9 Limitation of MD"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#110-test-flow-of-md","text":"\uf06c Check MD use in the fixed-camera scene \uf06c Check MD event bitmap to check MD flow \uf06c MD should be used after 3 frames to create initial background.","title":"1.10 Test Flow of MD"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#2-output","text":"","title":"2 Output"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#21-get-output-results-of-md","text":"\uf06c vendor MD Vendor MD result should be set/got by the following API. ret = vendor_md_set(path_id, VENDOR_MD_RESULT_INFO, &result_info); ret = vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info); The structure of MD hardware result lists as following. typedef struct _VENDOR_MD_MDT_RESULT_INFO { UINT8 *p_evt_map; ///< motion detection bitmap, size is evt_sz UINT32 evt_sz; ///< phy_mb_x_num*phy_mb_y_num MB UINT8 tp_result; ///< tamper alarm UINT32 timestamp; } VENDOR_MD_MDT_RESULT_INFO; \uf06c libmd libmd result should be set/got by the following API. vendor_md_get(path_id, VENDOR_MD_RESULT_INFO, &result_info) ret = lib_md_set(path_id, LIB_MD_MOTION_DETECT_INFO, &lib_md_info); ret = lib_md_get(path_id, LIB_MD_RESULT_INFO, &lib_md_rst); libmd result structure lists as following. typedef struct _LIB_MD_MDT_RESULT_INFO { UINT8 global_motion_alarm; ///< global motion alarm UINT32 global_motion_alarm_num; ///< global motion alarm num UINT32 sub_motion_alarm[LIB_MD_MAX_SUB_REGION_NUM]; ///< sub-region motion alarm UINT32 obj_num; ///< detect object number (max=128) LIB_MD_AP_OBJ_INFO obj[LIB_MD_MAX_OBJ_NUM]; ///< detect object info LIB_MD_EVT_INFO vp_evt_info; } LIB_MD_MDT_RESULT_INFO; typedef struct _LIB_MD_EVT_INFO { UINT8 *p_evt_map; ///< motion detection bitmap, size is evt_sz UINT32 evt_sz; ///< mb_x_num*mb_y_num MB UINT32 timestamp; } LIB_MD_EVT_INFO; typedef struct _LIB_MD_AP_OBJ_INFO { UINT32 start_x; ///< obj rectangle left upper x position (virtual pixel) UINT32 start_y; ///< obj rectangle left upper y position (virtual pixel) UINT32 end_x; ///< obj rectangle right down x position (virtual pixel) UINT32 end_y; ///< obj rectangle right down y position (virtual pixel) UINT32 label; ///< obj label } LIB_MD_AP_OBJ_INFO;","title":"2.1 Get Output Results of MD"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#22-print-output-results-of-md","text":"\uf06c Output Result of Global Motion Detection UART will print the results as following when motion area in the whole scene is larger than user-defined threshold. > global motion alarm on ch(specified channel). \uf06c Output Result of Sub-region Motion Detection UART will print the results as following when the motion area in one or more sub-regions is larger than user-defined threshold. > sub_region[specified region index] motion alarm on ch(specified channel). \uf06c Output Result of Motion Object Detection UART will print the results as following when motion objects area are larger than minimum object user-defined threshold. > obj num:Motion object number and obj[object index]: start_xy=[left upper corner position of motion object], end_xy = [right under corner position of motion object], label = object label. \uf06c Output Result of Tamper Detection UART will print the results as following when occlusion area is larger than user-defined threshold. > tamper_result:1 on ch(specified channel).","title":"2.2 Print Output Results of MD"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#23-limitation-md-hardware","text":"\uf06c Maximum sensor resolution is 3840x2160. \uf06c Maximum MB number of MD hardware are (mb_x_num, mb_y_num) = (256, 128) and minimum MB number of MD hardware are (mb_x_num, mb_y_num) = (2, 1). \uf06c In the Vcap flow, MD doesn\u2019t support the scale function.","title":"2.3 Limitation MD Hardware"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#24-requirement-of-md-system","text":"\uf06c The efficiency of MD function is associated with system loading. The ouput result of MD may be delayed when system is overloading.","title":"2.4 Requirement of MD System"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#25-tuning-of-md-parameters","text":"\uf06c In the scene with the shortly changing of light, such as AE adjustment or turn-on and turn-off the light, please set the value of alpha higher. The side effect is that moving slowly object might be detected as background. \uf06c Please set tb to be higher for shadow. The side effect is that the detected forground of moving obeject might be broken. In this case, please also set \u201csigma\u201d to be lower to fix the broken forground issue. \uf06c The distance between moving object and camera should be farer than 30 cm. If the moving objects is too close to the camera, there might cause the false alarm of shadow. \uf06c Please set lower tb when foreground luminance is similar background. However, the side effect is that the false alarm of shadow may be increase. \uf06c Please see section 1.5 when you need to detect stable motion case. \uf06c The MD function doesn\u2019t support night view with IR-cut. In this case, there might be similar between background and foreground. \uf06c There is no motion event when MD is creating intial background model. Also, MD will need longer time to create initial backgroung model if there are some moving objects in the initial scene. \uf06c The size of moving object should be larger than 1 MB.","title":"2.5 Tuning of MD Parameters"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#3-qa","text":"(1) How to check vendor MD version? Ans: echo md > /proc/hdal/flow Execute AP cat /proc/hdal/flow (2) How to set the md sensitive? Ans: I. Use vendor_md_set API (the details describe in the 1.6 section and the section 1.4.1. II. Tuning Guide document provide the tuning parameter suggestion. If any more question, please provide the video and parameters. (3) How to solve sensor resolution change error? Ans: If you want to chage sensor reolution, please vendor_md_unint & vendor_md_int at fisrt and you might see liveview_with_md_ctrl.c or liveview_with_md_resolution.c (4) How to check sensor interlace case? Ans: MD is field input. If input is interlace, please set the half of the sensor input height. You can see interlace case through command as following cat /proc/vcap316/vcap0/vg_info. (5) Check AD mode (960H and 720) case Ans: I. Check AD output is full frame. II. MD input size is the same as the AD output size. phy_width andphy_height should be calculate by AD output (might not be the size of sensor). The size setting check by /proc/vcap316/vcap0/vg_info and vcap md (detal describe in question 6 ). (6) If any setting question of the vendor_md flow, please provide the log of vendor_md flow by the following command. Ans: echo md > /proc/hdal/flow Execute AP cat /proc/hdal/flow (7) How to check vcap md setting Ans: echo vcap_ch > /proc/vcap316/vcap0/vcap0.CHIP/md/event (vcap_ch and CHIP according to vg_info) cat /proc/vcap316/vcap0/vcap0. CHIP /md/region cat /proc/vcap316/vcap0/vcap0. CHIP /md/param (8) How to solve the mb num >(120,67)? Ans: I. modify hdal excel buffer size setting II. open reassign_buffer (9) How to use the level setting ? Ans: Each MB can be setted different level. Each level is mapping the set of background model. In nomal scene, all scene use the same level. In the scene which include both indoor and outdoor, you can set two level of the scene. (10) Where is the tamper sample code? Ans: tamper sample code is liveview_with_md.c.","title":"3 Q&amp;A"},{"location":"Software/CVAI/NT9833X_MD_User_Guide_en.html#4-revision-history","text":"Revision Date Author Changes 0.1 2021/06/30 Sophia First formal version 0.2 2021/07/02 Sophia Update document format and description 0.3 2022/06/24 Hunter Modify the description of mb size and some wrong information.","title":"4 Revision History"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html","text":"System Control \u00b6 1.1 Parameter Description \u00b6 Parameter Range Def Description ch_fd Video graph use ch_fd to represent the connected video engine of each channel. User can fine tune parameter of each video engine by setting ch_fd. 1.2 Setting Interface \u00b6 1.2.1 Proc \u00b6 Proc command designates the desired camera to be fine tuned by camera channel\u2019s fd. \uf06c /proc/videograph/di/ch_fd \u00b6 [Description] Read or write the current camera channel, and it only needs to set once, the following parameters will work on this channel. The following proc command will list all ch_fd of the current video engine. [Command] Write : proc command Target Parameter echo [fd] > /proc/videograph/di/ch_fd Fw Internal Pointer Read : cat /proc/videograph/di/ch_fd 2 GMM \u00b6 The motion detection module in DI module is not used for motion detection alarm; instead, it provides the motion detection information to DI algorithm to increase the interpolation accuracy of transforming interlace image to progressive image. 2.1.1 Parameter Description \u00b6 Table 31 MD Parameter List Parameter Range Def Description gmm_alpha 0\\~32767 32 Update speed of background model( fit model). gmm_one_min_alpha 0\\~32767 32736 Update speed of background model(non-fit model). Recommend value = 2\\^15- gmm_alpha gmm_init_val 0\\~255 7 The restart learining weighting of the background model. gmm_tb 0\\~15 9 Evaluate the similar level with the current background model to decide whether it is foreground. gmm_sigma 0\\~31 11 The standard deviation for the newly generated model. It will influence the model tolerance. gmm_tg 0\\~15 9 Threshold for evaluating whether the model need to be updated. gmm_prune -217 \\~ 217-1 -8207 prune = -(alpha * CT)*8191/256; weight attenuation value CT \u2013 complexity reduction prior, this is related to number of samples. CT = 8 \uf06c Advance description: \u00b6 \uf06c gmm_alpha \uff1aupdate speed of background model If \u201cgmm_alpha\u201d set too large, it will easily to misjudge the motion object to background. For de-interlace application, it will result in fractured image. If \u201cgmm_alpha\u201d set too small, it will easily to misjudge tiny light/shadow change to motion object. For de-interlace application, it will result in blur image. For indoor(without light/shadow change) scene, the recommend value is 32. For other scenes with light/shadow change, it is recommend to properly increase this value(not larger than 327). For outdoor scene, due to the influence of light/shadow change need to be excluded, the recommend value is between 327\\~1200. \uf06c gmm_sigma \uff1aThe standard deviation of model. The parameter \u201cgmm_tb\u201d and \u201cgmm_sigma\u201d are used to decide the static model together. The larger the \u201cgmm_sigma\u201d, the more easily to be determined as static object. \uf06c gmm_tb \uff1a\u201cgmm_sigma\u201d and \u201cgmm_tb\u201d will influence the completion of motion detection. If the detected motion block of motion object is fractured(not continuous), it is recommend to properly increase \u201c gmm_tb\u201d. \uf06c gmm_purne\uff1a The smaller(more negative) \u201cgmm_purne\u201d, the quicker learning speed of new model. However, for small motion, it will more easily to be misjudged to background. And it will also influence the motion detection sensitivity(the same as \u201cgmm_alpha\u201d), it is recommend to adopt default value, and using \u201cgmm_alpha\u201d to fine tune sensitivity. 2.2 Setting Interface \u00b6 2.2.1 Proc \u00b6 \uf06c /proc/videograph/di/gmm/dump_info \u00b6 [Description] Read all GMM parameters of the current camera channel. [Command] Write : Not Support Read : cat /proc/videograph/di/gmm/dump_info Output: \uf06c /proc/videograph/di/gmm/enable \u00b6 [Description] Read or witer the GMM enable status of the current camera channel. [Command] Write : proc command Target Parameter echo [enable 0 \\~ 1] > /proc/videograph/di/gmm/enable gmm_en Read : cat /proc/videograph/di/gmm/enable Output: \uf06c /proc/videograph/di/gmm/alpha \u00b6 [Description] Read or write the GMM/alpha parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [alpha 0 \\~ 32767] > /proc/videograph/di/gmm/alpha gmm_alpha Read : cat /proc/videograph/di/gmm/alpha Output: \uf06c /proc/videograph/di/gmm/one_alpha \u00b6 [Description] Read or write the GMM parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [alpha 0 \\~ 32767] > /proc/videograph/di/gmm/one_alpha gmm_one_min_alpha Read : cat /proc/videograph/di/gmm/one_alpha Output: \uf06c /proc/videograph/di/gmm/init_val \u00b6 [Description] Read or write the GMM parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [value 0 \\~ 255] > /proc/videograph/di/init_val gmm_init_val Read : cat /proc/videograph/di/gmm/init_val Output: \uf06c /proc/videograph/di/gmm/tb \u00b6 [Description] Read or write the GMM/gmm_tb parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [tb 0 \\~ 15] > /proc/videograph/di/gmm/tb gmm_tb Read : cat /proc/videograph/di/gmm/tb Output: \uf06c /proc/videograph/di/gmm/sigma \u00b6 [Description] Read or write the GMM/sigma parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [sigma 0\\~31] > /proc/videograph/di/gmm/sigma gmm_sigma Read : cat /proc/videograph/di/gmm/sigma Output: \uf06c /proc/videograph/di/gmm/tg \u00b6 [Description] Read or write the GMM/gmm_tg parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [tg 0 \\~ 15] > /proc/videograph/di/gmm/tg gmm_tg Read : cat /proc/videograph/di/gmm/tg Output: \uf06c /proc/videograph/di/gmm/prune \u00b6 [Description] Read or write the GMM/gmm_prune parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [prune -131072 \\~ 131071 ] > /proc/videograph/di/gmm/prune gmm_prune Read : cat /proc/videograph/di/gmm/prune Output: 3 TMNR \u00b6 This is temporal noise reduction module(abbreviation is TMNR). Although this function is temporal noise reduction, its major purpose is to increase the interpolation accuracy of transforming interlace image to progressive image. If user need to enhance the temporal denoise strength of video, it is recommend to use TMNR in VPE. Please note that the concept and parameter of DI/TMNR and VPE/TMNR is totally different. 3.1 Parameter Description \u00b6 Table 41 TMNR Parameter List Parameter Range Def Description tmnr_en 0\\~1 1 TMNR ON tmnr_learn_en 0\\~1 1 Enable internal TMNR library for automatically calculating noise level y_var 0\\~64 20 Luma pixel 3DNR strength cb_var 0\\~64 12 Cb pixel 3DNR strength Please refer to advance description. cr_var 0\\~64 12 Cr pixel 3DNR strength Please refer to advance description k 1\\~8 3 Adjust the threshold for determining motion object. Please refer to advance description. auto_k 0\\~1 0 Enable function for firmware automatically fine tune K. auto_k_hi 2\\~5 5 Automatically fine tune the upper limit of K. auto_k_lo 1\\~3 2 Automatically fine tune the lower limit of K. trade_thres 0\\~128 64 The blending weight of external var and internal var. suppress_strength 2\\~64 24 The maximum NR mask strength of static point. nf 1\\~6 5 The normalized parameter of variance of internal calculation. The larger the \u201cnf\u201d, the smaller the NR strength calculated by internal. var_offset 0\\~15 2 The maximum variance difference of neighbor block. motion_var 1\\~20 8 The variance of motion block. This value influence the temporal noise reduction strength of motion block. The recommend value is Y_var / 3. motion_th_mult 1\\~100 3 The threshold for determining whether it is motion block. The smaller the value, the more easily to be determined as motion block. The recommend value is 2\\~3. tmnr_fcs_en 0\\~1 0 Enable temporal false color suppression function. Please refer to advance description. tmnr_fcs_th 0\\~255 16 Threshold for determining temporal false color. tmnr_fcs_weight 0\\~16 8 Strength of temporal false color suppression. dpr_en 0\\~1 0 TMNR temporal DPC ON/OFF dpr_motion_th 0\\~255 64 Threshold for determining whether it is temporal defect pixel. The smaller the \u201cdpr_motion_th\u201d, the more easily to be determined as temporal defect pixel. dpr_cnt_th 0\\~15 1 Threshold for determing temporal defect pixel, if the number of surrounding defect pixel is smaller than \u201cdpr_cnt_th\u201d, it is determined as defect pixel. The larger the value, the more easily to be determined as temporal defect pixel. The default value is 1, representing only deals with single defect pixel. dpr_mode 0\\~1 0 The defect mode of TMNR temporal defect pixel. 0: Temporal defect mode 1: Spatial defect mode \uf06c Advance description\uff1a \u00b6 \uf06c y_var, cb_var, cr_var: Noise Level set by external. The noise level set by external and calculate by internal will be blended by \u201ctrade_threshold\u201d, and the blended noise level is the noise base to determine whether it is motion object. This parameter can also be considered as 3DNR strength. \uf06c k : The parameter to adjust threshold for determining motion object. The recommend value is 2\\~3. The larger the k, the more easily to be determined as static object, the noise is more stable, but it might have ghost. On the contrary, the smaller the k, the more easily to be determined as motion object, but the noise is more obvious. If \u201cauto_k\u201d is enabled, this parameter is invalid. \uf06c auto_k, auto_k_lo, auto_k_hi : When noise is badly serious, this function could accelerate the speed to become noise stable. If enable this function, the firmware will automatically calculate \u201ck\u201d, the calculated \u201ck\u201d will be smaller than auto_k_hi and larger than auto_k_lo. It is recommend to enable \u201cauto_k\u201d, set \u201cauto_k_hi\u201d = 5 and \u201cauto_k_low\u201d = 2. \uf06c motion_var : The noise level of motion object. The larger the \u201cmotion_var\u201d, the less noise of motion object, but it might have ghost. The recommend value is y_var/3, it should not larger than 20, and the default value is 5. \uf06c motion_th_mult : Threshold for determining whether it is motion object. The smaller the \u201cmotion_th_mult\u201d, the more easily to be determined as motion object. The recommend value is 2-3. \uf06c tmnr_fcs_en : TMNR enable high frequency false color suppression funcrtion ON/OFF. Normally, it is recommend to set OFF, if camera has false color, then enable it. The false color phenomenon is as follows: FCS off FCS on \uf06c tmnr_fcs_th : Threshold for determining whether it is high frequency false color, the default value is 10. \uf06c tmnr_fcs_weight: The strength of FCS. The larger the \u201ctmnr_fcs_weight\u201d, the stronger strength of FCS, but it might have color ghost. It is recommend smaller than 8 to avoid having color ghost. 3.2 Setting Interface \u00b6 3.2.1 Proc \u00b6 \uf06c /proc/videograph/di/tmnr/dump_info \u00b6 [Description] Read all TMNR parameters of the current camera channel. [Command] Write : Not Support Read : cat /proc/videograph/di/tmnr/dump_info Output: \uf06c /proc/videograph/di/tmnr/enable \u00b6 [Description] Read or write the TMNR/tmnr_en parameters of the current camera channel. [Command] Write : proc command Target Parameter echo [enable 0 \\~ 2] > /proc/videograph/di/tmnr/enable tmnr_en 0: TMNR enabled by HDAL 1: TMNR enable 2: TMNR disable Read : cat /proc/videograph/di/tmnr/enable Output: \uf06c /proc/videograph/di/tmnr/tmnr_learn_en \u00b6 [Description] Read or write the TMNR/tmnr_learn_en parameter of the current camera channel. [Description] Write : proc command Target Parameter echo [tmnr_learn_en 0\\~1] > /proc/videograph/di/tmnr/tmnr_learn_en tmnr_learn_en Read : cat /proc/videograph/di/tmnr/tmnr_learn_en Output: \uf06c /proc/videograph/di/tmnr/var \u00b6 [Description] Read or write the TMNR/y, cb, cr var parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [y_var 0\\~64] [cb_var 0\\~64] [cr_var 0\\~64] > /proc/videograph/di/tmnr/var y_var, cb_var, cr_var Read : cat /proc/videograph/di/tmnr/var Output: \uf06c /proc/videograph/di/tmnr/k \u00b6 [Description] Read or write the TMNR/k parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [k 1\\~8] > /proc/videograph/di/tmnr/k k Read : cat /proc/videograph/di/tmnr/k Output: \uf06c /proc/videograph/di/tmnr/auto_k \u00b6 [Description] Read or write the TMNR/auto_k related parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [auto_k 0 \\~ 1] [k_hi 1\\~8] [k_lo 1\\~8]> /proc/videograph/di/tmnr/auto_k auto_k, k_hi, k_lo Read : cat /proc/videograph/di/tmnr/auto_k Output: \uf06c /proc/videograph/di/tmnr/trade_th \u00b6 [Description] Read or write the TMNR/trade_threshold parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [th 0 \\~ 128] > /proc/videograph/di/tmnr/trade_th trade_threshold Read : cat /proc/videograph/di/tmnr/trade_th Output: \uf06c /proc/videograph/di/tmnr/supp_str \u00b6 [Description] Read or write the TMNR/suppress_strength parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [str 2\\~64] > /proc/videograph/di/tmnr/supp_str suppress_strength Read : cat /proc/videograph/di/tmnr/supp_str Output: \uf06c /proc/videograph/di/tmnr/nf \u00b6 [Description] Read or write the TMNR/NF (Normalize Factor) parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [nf 1 \\~ 6] > /proc/videograph/di/tmnr/nf nf Read : cat /proc/videograph/di/tmnr/nf Output: \uf06c /proc/videograph/di/tmnr/var_offset \u00b6 [Description] Read or write the TMNR/var_offset parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [var_offset 0\\~15] > /proc/videograph/di/tmnr/var_offset var_offset Read : cat /proc/videograph/di/tmnr/var_offset Output: \uf06c /proc/videograph/di/tmnr/motion_var \u00b6 [Description] Read or write the TMNR/motion_var parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [motion_var 1 \\~ 20] > /proc/videograph/di/tmnr/motion_var motion_var Read : cat /proc/videograph/di/tmnr/motion_var Output: \uf06c /proc/videograph/di/tmnr/motion_th_mult \u00b6 [Description] Read or write the TMNR/motion_th_mult parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [motion_th_mult 0\\~128] > /proc/videograph/di/tmnr/motion_th_mult motion_th_mult Read : cat /proc/videograph/di/tmnr / motion_th_mult Output: \uf06c /proc/videograph/di/tmnr/tmnr_fcs \u00b6 [Description] Read or write the TMNR/FCS related parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [enable 0\\~1] [fcs_th 0\\~255] [fcs_weight 0\\~16] > /proc/videograph/di/tmnr/tmnr_fcs tmnr_fcs_en, tmnr_fcs_th, tmnr_fcs_weight Read : cat /proc/videograph/di/tmnr / tmnr_fcs Output: \uf06c /proc/videograph/di/tmnr/dpr \u00b6 [Description] Read or writer the TMNR/DPR related parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [dpr_en 0\\~1] [motion_th 0\\~255] [cnt_th 0\\~16] [dpr_mode 0\\~1] > /proc/videograph/di/tmnr/dpr dpr_en, dpr_motion_th, dpr_cnt_th, dpr_mode Read : cat /proc/videograph/di/tmnr/dpr Output: 4 De-Interlace (DI) \u00b6 The dynamic de-interlace method is to detect where is the motion object in the image and where is the static object in the image. For static block in the image using field de-interlace to get the completely resolution in vertical direction, and for motion block in the image using single field de-interlace to avoid sawtooth and ghost phenomenon. The following are common abnormal phenomenons which caused by de-interlace, it needs to adjust parameter to get the best image performance. Table 51 sawtooth phenomen caused by motion object misjudge to static object Table 52 resolution decreased phenomenon caused by static object misjudge to motion object 4.1 Parameter Description \u00b6 (The blue text is the part of the parameter difference between this module and the 9831x series, please pay special attention) Table 53 DI Parameter List Parameter Range Def Description top_motion_en 0\\~1 1 Enable the motion detection of top field. bot_motion_en 0\\~1 1 Enable the motion detection of bottom field. auto_th_en 0\\~1 1 Based on Y to automatically generate \u201cmd_th\u201d. If this function is enabled, the parameter \u201cmd_th\u201d is invalid. strong_md_en 0\\~1 1 Enable \u201cstrong_md\u201d function. If \u201cmd\u201d is larger than \u201cstrong_md_th\u201d, it is determined as motion block, no matter the motion block is continuous or not. mmb_en 0\\~1 1 Enable motion macro block(mmb) determine mechanism. Single mb is motion does not mean it is necessary mmb, it needs to be determined with other mb. smb_en 0\\~1 1 Enable static macro block(smb) determine mechanism. (The pixel in smb still has possibility to be motion) emb_en 0\\~1 1 Enable extend macro block(emb) determine mechanism, the smb will further perform emb to avoid fratured image. lmb_en 0\\~1 1 Enable line macro block(lmb) determine mechanism. (mb is texture in line form) pmmb_en 0\\~1 1 Enable pmmb detection, \u201ctm_di\u201d must be enable. corner_detect_en 0\\~1 1 Determine whether it is corner pixel, if it is corner pixel, replace the pixel with average of the upper pixel and lower pixel. di_gmm_motion_en 0\\~1 1 Reference gmm\u2019s motion result. Motion = (DI motion || GMM motion) all_motion 0\\~1 0 Debug mode. Set all image as motion. all_static 0\\~1 0 Debug mode, set all image as static. strong_edge 0\\~255 40 Threshold for determining strong edge. strong_md_th 0\\~255 40 Threshold for determining strong motion. if (pixel diff > strong_md_th) => motion md_th 0\\~255 10 Threshold for determining whether pixel is motion. line_admit 0\\~15 4 Threshold for determining whether it is line pixel. If number of continuous similar point is larger than line_admit, it is determined as line pixel. lmb_th 0\\~255 6 Threshold for determining whether it is line mb. If line pixel in mb is larger than \u201clmb_th\u201d, it is determined as line mb. mmb_th 0\\~255 16 Threshold for determining whether it is mmb. If larger than \u201cmmb_th\u201d, it is motion. smb_th 0\\~255 4 Threshold for determining whether it is smb. If larger than \u201csmb_th\u201d, it is static. emb_th 0\\~255 8 Threshold for determining whether it is emb. If larger than \u201cemb_th\u201d, it is extend mb. ela_h_th 0\\~255 60 The break point of edge strength weighting map. Please refer to advance description. ela_l_th 0\\~255 20 The break point of edge strength weighting map. Please refer to advance description. mmb_scene_change_en 0\\~1 1 Enable the scene change detection of mmb. When it is determined as scene changed, the algorithm will set all image as motion status to avoid fratured image. mmb_scene_change_th 0\\~2\\^16-1 1080 Threshold for determining whether it is scene changed. When the number of mmb is larger than this threshold, it is determined as scene changed. ch0_row1_status_ctrl 0\\~3 0 Control with special treatment for first row in even field 2\u2019b00 : Automatic processing by DI. 2\u2019b01: Same as process that DI handle a still object 2\u2019b10: Same as process that DI handle a motion object 2\u2019b11: Fill it with black. ch1_row1_status_ctrl 0\\~3 0 Control with special treatment for first row in odd field 2\u2019b00 : Automatic processing by DI. 2\u2019b01: Same as process that DI handle a still object 2\u2019b10: Same as process that DI handle a motion object 2\u2019b11: Fill it with black. ch0_last_row_status_ctrl 0\\~3 0 Control with special treatment for last row in even field 2\u2019b00 : Automatic processing by DI. 2\u2019b01: Same as process that DI handle a still object 2\u2019b10: Same as process that DI handle a motion object 2\u2019b11: Fill it with black. ch1_last_row_status_ctrl 0\\~3 0 Control with special treatment for last row in odd field 2\u2019b00 : Automatic processing by DI. 2\u2019b01: Same as process that DI handle a still object 2\u2019b10: Same as process that DI handle a motion object 2\u2019b11: Fill it with black. \uf06c Advance desciption \u00b6 \uf06c lmb_admit : When horizontal line in static object appears as broken line(uncontinuous line) or has uneven phenomenon, it is recommend to properly decrease this value. \uf06c lmb_th : When horizontal line in static object appears as broken line(uncontinuous line) or has uneven phenomenon, it is recommend to properly decrease this value. This value should larger or equal to \u201cline_admin\u201d. \uf06c mmb_th : When the edge of motion object easily has broken phenomenon, it might be the motion object edge be determined as static, properly decrease this value could improve this phenomenon. \uf06c emb_th : When the motion small object(such as falling beans or high frequency thin line) has broken phenomenon, properly decrease this value could improve this phenomenon, increase the sensitivity of small object. \uf06c smb _th : When static text(thin line) or trademark have discontinuous line or uneven phenomenon(caused by static point misjudge to motion point, and adopt interpolation result), properly decrease this value can let it more easily to be determined as static object. \uf06c ela_h_th, ela_l_th: Based on Edge strength to decide use directional interpolation or average interpolation. The relationship please refer the following figure. Normally, it is recommend to use default value. 4.2 Setting Interface \u00b6 4.2.1 Proc \u00b6 \uf06c /proc/videograph/di/di/dump_info \u00b6 [Description] Read all DIE parameters of the current camera channel. [Command] Write : Not Support Read : cat /proc/videograph/di/di/dump_info Output: \uf06c /proc/videograph/di/di/motion_en \u00b6 [Description] Read or write the DI/top_motion_en, bot_motion_en parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [top_motion_en 0\\~1] [bot_motion_en 0\\~1] > /proc/videograph/di/di/motion_en top_motion_en, bot_motion_en Read : cat /proc/videograph/di/di/motion_en Output: \uf06c /proc/videograph/di/di/md_th \u00b6 [Description] Read or write the DIE/md_th parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [auto_th_en 0 \\~ 1] [md_th 0\\~255]> /proc/videograph/di/di/md_th auto_md_en, md_th \u203b When \u201cauto_md_en\u201d is 1, \u201cmd_th\u201d is not working. Read : cat /proc/videograph/di/di/md_th Output: \uf06c /proc/videograph/di/di/strong_md \u00b6 [Description] Read or write the DI/strong_md related parameters of the current channel. [Command] Write : proc command Target Parameter echo [strong_md_en 0 \\~ 1] [strong_md_th 0\\~255]> /proc/videograph/di/di/strong_md strong_md_en, strong_md_th Read : cat /proc/videograph/di/di/strong_md Output: \uf06c /proc/videograph/di/di/strong_edge \u00b6 [Description] Read or write the DI/strong_edge parameter of the cuurent camera channel. [Command] Write : proc command Target Parameter echo [strong_edge 0\\~255]> /proc/videograph/di/di/strong_edge strong_edge Read : cat /proc/videograph/di/di/strong_edge Output: \uf06c /proc/videograph/di/di/corner_detect_en \u00b6 [Description] Read or write the DI/corner_detect_en parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [corner_det_en 0\\~1]> /proc/videograph/di/di/corner_det_en corner_detect_en Read : cat /proc/videograph/di/di/corner_det_en Output: \uf06c /proc/videograph/di/di/line_admit \u00b6 [Description] Read or write the DI/line_admit parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [line_admit 0\\~15]> /proc/videograph/di/di/line_admit line_admit Read : cat /proc/videograph/di/di/line_admit Output: \uf06c /proc/videograph/di/di/all_motion_static \u00b6 [Description] Read or write the DI/all_motion, all_static parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [all_motion 0\\~1] [all_static 0\\~1] > /proc/videograph/di/di/all_motion_static all_motion, all_static \u203bShould not be both set to 1. Read : cat /proc/videograph/di/di/all_motion_static Output: \uf06c /proc/videograph/di/di/di_gmm_motion_en \u00b6 [Description] Read or write the DI/di_gmm_motion_en of the current camera channel. [Command] Write : proc command Target Parameter echo [enable 0\\~1] > /proc/videograph/di/di/di_gmm_motion_en di_gmm_motion_en Read : cat /proc/videograph/di/di/di_gmm_motion_en Output: \uf06c /proc/videograph/di/di/mmb_param \u00b6 [Description] Read or write the DI/mmb related parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [mmb_en 0\\~1] [pmmb_en 0\\~1] [mmb_th 0\\~255] > /proc/videograph/di/di/mmb_param mmb_en, pmmb_en,(mmb_en should be 1) mmb_th Read : cat /proc/videograph/di/di/mmb_param Output: \uf06c /proc/videograph/di/di/mmb_scene_change \u00b6 [Description] Read or write the DI/mmb scene change related parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [scene_change_en 0\\~1] [scene_change_th 0\\~65535] > /proc/videograph/di/di/mmb_scene_change mmb_scene_change_en, mmb_scene_change_th Read : cat /proc/videograph/di/di/mmb_scene_change Output: \uf06c /proc/videograph/di/di/smb_param \u00b6 [Description] Read or write the DI/smb related parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [smb_en 0\\~1] [smb_th 0\\~255] > /proc/videograph/di/di/smb_param smb_en, smb_th Read : cat /proc/videograph/di/di/smb_param Output: \uf06c /proc/videograph/di/di/emb_param \u00b6 [Description] Read or write the DI/emb related parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [emb_en 0\\~1] [emb_th 0\\~255] > /proc/videograph/di/di/emb_param emb_en, smb_th Read : cat /proc/videograph/di/di/emb_param Output: \uf06c /proc/videograph/di/di/lmb_param \u00b6 [Description] Read or write the DIE/lmb related parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [lmb_en 0\\~1] [lmb_th 0\\~255] > /proc/videograph/di/di/lmb_param lmb_en, lmb_th Read : cat /proc/videograph/di/di/lmb_param Output: \uf06c /proc/videograph/di/di/ela_th \u00b6 [Description] Read or write the DIE/ela_h_th, ela_l_th related parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [ela_hi 0\\~255] [ela_lo 0\\~255] > /proc/videograph/di/di/ela_th ela_h_th, ela_l_th Read : cat /proc/videograph/di/di/ela_th Output: \uf06c /proc/videograph/di/di/row_status_ctrl \u00b6 [\u63cf\u8ff0] Read or write the DEI/row1_status_ctrl, last_row_status_ctrl related parameter of the current camera channel. [\u8a9e\u6cd5] Write : proc command \u76ee\u6a19\u53c3\u6578 echo [ch0_row1_status_ctrl 0\\~3] [ch1_row1_status_ctrl 0\\~3] [ch0_last_row_status_ctrl 0\\~3] [ch1_last_row_status_ctrl 0\\~3] > /proc/videograph/di/di/row_status_ctrl ch0_row1_status_ctrl, ch1_row1_status_ctrl, ch0_last_row_status_ctrl, ch1_last_row_status_ctrl, Read : cat /proc/videograph/di/di/row_status_ctrl Output: 5 Revision History \u00b6 Version Date Advisor Description 0.1.0 2021/01/20 Allen Hsu First version.","title":"DI Tuning Guide"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#system-control","text":"","title":"System Control"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#11-parameter-description","text":"Parameter Range Def Description ch_fd Video graph use ch_fd to represent the connected video engine of each channel. User can fine tune parameter of each video engine by setting ch_fd.","title":"1.1 Parameter Description"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#12-setting-interface","text":"","title":"1.2 Setting Interface"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#121-proc","text":"Proc command designates the desired camera to be fine tuned by camera channel\u2019s fd.","title":"1.2.1 Proc"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdich_fd","text":"[Description] Read or write the current camera channel, and it only needs to set once, the following parameters will work on this channel. The following proc command will list all ch_fd of the current video engine. [Command] Write : proc command Target Parameter echo [fd] > /proc/videograph/di/ch_fd Fw Internal Pointer Read : cat /proc/videograph/di/ch_fd","title":"\uf06c /proc/videograph/di/ch_fd"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#2-gmm","text":"The motion detection module in DI module is not used for motion detection alarm; instead, it provides the motion detection information to DI algorithm to increase the interpolation accuracy of transforming interlace image to progressive image.","title":"2 GMM"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#211-parameter-description","text":"Table 31 MD Parameter List Parameter Range Def Description gmm_alpha 0\\~32767 32 Update speed of background model( fit model). gmm_one_min_alpha 0\\~32767 32736 Update speed of background model(non-fit model). Recommend value = 2\\^15- gmm_alpha gmm_init_val 0\\~255 7 The restart learining weighting of the background model. gmm_tb 0\\~15 9 Evaluate the similar level with the current background model to decide whether it is foreground. gmm_sigma 0\\~31 11 The standard deviation for the newly generated model. It will influence the model tolerance. gmm_tg 0\\~15 9 Threshold for evaluating whether the model need to be updated. gmm_prune -217 \\~ 217-1 -8207 prune = -(alpha * CT)*8191/256; weight attenuation value CT \u2013 complexity reduction prior, this is related to number of samples. CT = 8","title":"2.1.1 Parameter Description"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#advance-description","text":"\uf06c gmm_alpha \uff1aupdate speed of background model If \u201cgmm_alpha\u201d set too large, it will easily to misjudge the motion object to background. For de-interlace application, it will result in fractured image. If \u201cgmm_alpha\u201d set too small, it will easily to misjudge tiny light/shadow change to motion object. For de-interlace application, it will result in blur image. For indoor(without light/shadow change) scene, the recommend value is 32. For other scenes with light/shadow change, it is recommend to properly increase this value(not larger than 327). For outdoor scene, due to the influence of light/shadow change need to be excluded, the recommend value is between 327\\~1200. \uf06c gmm_sigma \uff1aThe standard deviation of model. The parameter \u201cgmm_tb\u201d and \u201cgmm_sigma\u201d are used to decide the static model together. The larger the \u201cgmm_sigma\u201d, the more easily to be determined as static object. \uf06c gmm_tb \uff1a\u201cgmm_sigma\u201d and \u201cgmm_tb\u201d will influence the completion of motion detection. If the detected motion block of motion object is fractured(not continuous), it is recommend to properly increase \u201c gmm_tb\u201d. \uf06c gmm_purne\uff1a The smaller(more negative) \u201cgmm_purne\u201d, the quicker learning speed of new model. However, for small motion, it will more easily to be misjudged to background. And it will also influence the motion detection sensitivity(the same as \u201cgmm_alpha\u201d), it is recommend to adopt default value, and using \u201cgmm_alpha\u201d to fine tune sensitivity.","title":"\uf06c Advance description:"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#22-setting-interface","text":"","title":"2.2 Setting Interface"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#221-proc","text":"","title":"2.2.1 Proc"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdigmmdump_info","text":"[Description] Read all GMM parameters of the current camera channel. [Command] Write : Not Support Read : cat /proc/videograph/di/gmm/dump_info Output:","title":"\uf06c /proc/videograph/di/gmm/dump_info"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdigmmenable","text":"[Description] Read or witer the GMM enable status of the current camera channel. [Command] Write : proc command Target Parameter echo [enable 0 \\~ 1] > /proc/videograph/di/gmm/enable gmm_en Read : cat /proc/videograph/di/gmm/enable Output:","title":"\uf06c /proc/videograph/di/gmm/enable"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdigmmalpha","text":"[Description] Read or write the GMM/alpha parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [alpha 0 \\~ 32767] > /proc/videograph/di/gmm/alpha gmm_alpha Read : cat /proc/videograph/di/gmm/alpha Output:","title":"\uf06c /proc/videograph/di/gmm/alpha"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdigmmone_alpha","text":"[Description] Read or write the GMM parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [alpha 0 \\~ 32767] > /proc/videograph/di/gmm/one_alpha gmm_one_min_alpha Read : cat /proc/videograph/di/gmm/one_alpha Output:","title":"\uf06c /proc/videograph/di/gmm/one_alpha"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdigmminit_val","text":"[Description] Read or write the GMM parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [value 0 \\~ 255] > /proc/videograph/di/init_val gmm_init_val Read : cat /proc/videograph/di/gmm/init_val Output:","title":"\uf06c /proc/videograph/di/gmm/init_val"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdigmmtb","text":"[Description] Read or write the GMM/gmm_tb parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [tb 0 \\~ 15] > /proc/videograph/di/gmm/tb gmm_tb Read : cat /proc/videograph/di/gmm/tb Output:","title":"\uf06c /proc/videograph/di/gmm/tb"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdigmmsigma","text":"[Description] Read or write the GMM/sigma parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [sigma 0\\~31] > /proc/videograph/di/gmm/sigma gmm_sigma Read : cat /proc/videograph/di/gmm/sigma Output:","title":"\uf06c /proc/videograph/di/gmm/sigma"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdigmmtg","text":"[Description] Read or write the GMM/gmm_tg parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [tg 0 \\~ 15] > /proc/videograph/di/gmm/tg gmm_tg Read : cat /proc/videograph/di/gmm/tg Output:","title":"\uf06c /proc/videograph/di/gmm/tg"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdigmmprune","text":"[Description] Read or write the GMM/gmm_prune parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [prune -131072 \\~ 131071 ] > /proc/videograph/di/gmm/prune gmm_prune Read : cat /proc/videograph/di/gmm/prune Output:","title":"\uf06c /proc/videograph/di/gmm/prune"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#3-tmnr","text":"This is temporal noise reduction module(abbreviation is TMNR). Although this function is temporal noise reduction, its major purpose is to increase the interpolation accuracy of transforming interlace image to progressive image. If user need to enhance the temporal denoise strength of video, it is recommend to use TMNR in VPE. Please note that the concept and parameter of DI/TMNR and VPE/TMNR is totally different.","title":"3 TMNR"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#31-parameter-description","text":"Table 41 TMNR Parameter List Parameter Range Def Description tmnr_en 0\\~1 1 TMNR ON tmnr_learn_en 0\\~1 1 Enable internal TMNR library for automatically calculating noise level y_var 0\\~64 20 Luma pixel 3DNR strength cb_var 0\\~64 12 Cb pixel 3DNR strength Please refer to advance description. cr_var 0\\~64 12 Cr pixel 3DNR strength Please refer to advance description k 1\\~8 3 Adjust the threshold for determining motion object. Please refer to advance description. auto_k 0\\~1 0 Enable function for firmware automatically fine tune K. auto_k_hi 2\\~5 5 Automatically fine tune the upper limit of K. auto_k_lo 1\\~3 2 Automatically fine tune the lower limit of K. trade_thres 0\\~128 64 The blending weight of external var and internal var. suppress_strength 2\\~64 24 The maximum NR mask strength of static point. nf 1\\~6 5 The normalized parameter of variance of internal calculation. The larger the \u201cnf\u201d, the smaller the NR strength calculated by internal. var_offset 0\\~15 2 The maximum variance difference of neighbor block. motion_var 1\\~20 8 The variance of motion block. This value influence the temporal noise reduction strength of motion block. The recommend value is Y_var / 3. motion_th_mult 1\\~100 3 The threshold for determining whether it is motion block. The smaller the value, the more easily to be determined as motion block. The recommend value is 2\\~3. tmnr_fcs_en 0\\~1 0 Enable temporal false color suppression function. Please refer to advance description. tmnr_fcs_th 0\\~255 16 Threshold for determining temporal false color. tmnr_fcs_weight 0\\~16 8 Strength of temporal false color suppression. dpr_en 0\\~1 0 TMNR temporal DPC ON/OFF dpr_motion_th 0\\~255 64 Threshold for determining whether it is temporal defect pixel. The smaller the \u201cdpr_motion_th\u201d, the more easily to be determined as temporal defect pixel. dpr_cnt_th 0\\~15 1 Threshold for determing temporal defect pixel, if the number of surrounding defect pixel is smaller than \u201cdpr_cnt_th\u201d, it is determined as defect pixel. The larger the value, the more easily to be determined as temporal defect pixel. The default value is 1, representing only deals with single defect pixel. dpr_mode 0\\~1 0 The defect mode of TMNR temporal defect pixel. 0: Temporal defect mode 1: Spatial defect mode","title":"3.1 Parameter Description"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#advance-description_1","text":"\uf06c y_var, cb_var, cr_var: Noise Level set by external. The noise level set by external and calculate by internal will be blended by \u201ctrade_threshold\u201d, and the blended noise level is the noise base to determine whether it is motion object. This parameter can also be considered as 3DNR strength. \uf06c k : The parameter to adjust threshold for determining motion object. The recommend value is 2\\~3. The larger the k, the more easily to be determined as static object, the noise is more stable, but it might have ghost. On the contrary, the smaller the k, the more easily to be determined as motion object, but the noise is more obvious. If \u201cauto_k\u201d is enabled, this parameter is invalid. \uf06c auto_k, auto_k_lo, auto_k_hi : When noise is badly serious, this function could accelerate the speed to become noise stable. If enable this function, the firmware will automatically calculate \u201ck\u201d, the calculated \u201ck\u201d will be smaller than auto_k_hi and larger than auto_k_lo. It is recommend to enable \u201cauto_k\u201d, set \u201cauto_k_hi\u201d = 5 and \u201cauto_k_low\u201d = 2. \uf06c motion_var : The noise level of motion object. The larger the \u201cmotion_var\u201d, the less noise of motion object, but it might have ghost. The recommend value is y_var/3, it should not larger than 20, and the default value is 5. \uf06c motion_th_mult : Threshold for determining whether it is motion object. The smaller the \u201cmotion_th_mult\u201d, the more easily to be determined as motion object. The recommend value is 2-3. \uf06c tmnr_fcs_en : TMNR enable high frequency false color suppression funcrtion ON/OFF. Normally, it is recommend to set OFF, if camera has false color, then enable it. The false color phenomenon is as follows: FCS off FCS on \uf06c tmnr_fcs_th : Threshold for determining whether it is high frequency false color, the default value is 10. \uf06c tmnr_fcs_weight: The strength of FCS. The larger the \u201ctmnr_fcs_weight\u201d, the stronger strength of FCS, but it might have color ghost. It is recommend smaller than 8 to avoid having color ghost.","title":"\uf06c Advance description\uff1a"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#32-setting-interface","text":"","title":"3.2 Setting Interface"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#321-proc","text":"","title":"3.2.1 Proc"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographditmnrdump_info","text":"[Description] Read all TMNR parameters of the current camera channel. [Command] Write : Not Support Read : cat /proc/videograph/di/tmnr/dump_info Output:","title":"\uf06c /proc/videograph/di/tmnr/dump_info"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographditmnrenable","text":"[Description] Read or write the TMNR/tmnr_en parameters of the current camera channel. [Command] Write : proc command Target Parameter echo [enable 0 \\~ 2] > /proc/videograph/di/tmnr/enable tmnr_en 0: TMNR enabled by HDAL 1: TMNR enable 2: TMNR disable Read : cat /proc/videograph/di/tmnr/enable Output:","title":"\uf06c /proc/videograph/di/tmnr/enable"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographditmnrtmnr_learn_en","text":"[Description] Read or write the TMNR/tmnr_learn_en parameter of the current camera channel. [Description] Write : proc command Target Parameter echo [tmnr_learn_en 0\\~1] > /proc/videograph/di/tmnr/tmnr_learn_en tmnr_learn_en Read : cat /proc/videograph/di/tmnr/tmnr_learn_en Output:","title":"\uf06c /proc/videograph/di/tmnr/tmnr_learn_en"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographditmnrvar","text":"[Description] Read or write the TMNR/y, cb, cr var parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [y_var 0\\~64] [cb_var 0\\~64] [cr_var 0\\~64] > /proc/videograph/di/tmnr/var y_var, cb_var, cr_var Read : cat /proc/videograph/di/tmnr/var Output:","title":"\uf06c /proc/videograph/di/tmnr/var"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographditmnrk","text":"[Description] Read or write the TMNR/k parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [k 1\\~8] > /proc/videograph/di/tmnr/k k Read : cat /proc/videograph/di/tmnr/k Output:","title":"\uf06c /proc/videograph/di/tmnr/k"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographditmnrauto_k","text":"[Description] Read or write the TMNR/auto_k related parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [auto_k 0 \\~ 1] [k_hi 1\\~8] [k_lo 1\\~8]> /proc/videograph/di/tmnr/auto_k auto_k, k_hi, k_lo Read : cat /proc/videograph/di/tmnr/auto_k Output:","title":"\uf06c /proc/videograph/di/tmnr/auto_k"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographditmnrtrade_th","text":"[Description] Read or write the TMNR/trade_threshold parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [th 0 \\~ 128] > /proc/videograph/di/tmnr/trade_th trade_threshold Read : cat /proc/videograph/di/tmnr/trade_th Output:","title":"\uf06c /proc/videograph/di/tmnr/trade_th"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographditmnrsupp_str","text":"[Description] Read or write the TMNR/suppress_strength parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [str 2\\~64] > /proc/videograph/di/tmnr/supp_str suppress_strength Read : cat /proc/videograph/di/tmnr/supp_str Output:","title":"\uf06c /proc/videograph/di/tmnr/supp_str"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographditmnrnf","text":"[Description] Read or write the TMNR/NF (Normalize Factor) parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [nf 1 \\~ 6] > /proc/videograph/di/tmnr/nf nf Read : cat /proc/videograph/di/tmnr/nf Output:","title":"\uf06c /proc/videograph/di/tmnr/nf"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographditmnrvar_offset","text":"[Description] Read or write the TMNR/var_offset parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [var_offset 0\\~15] > /proc/videograph/di/tmnr/var_offset var_offset Read : cat /proc/videograph/di/tmnr/var_offset Output:","title":"\uf06c /proc/videograph/di/tmnr/var_offset"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographditmnrmotion_var","text":"[Description] Read or write the TMNR/motion_var parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [motion_var 1 \\~ 20] > /proc/videograph/di/tmnr/motion_var motion_var Read : cat /proc/videograph/di/tmnr/motion_var Output:","title":"\uf06c /proc/videograph/di/tmnr/motion_var"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographditmnrmotion_th_mult","text":"[Description] Read or write the TMNR/motion_th_mult parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [motion_th_mult 0\\~128] > /proc/videograph/di/tmnr/motion_th_mult motion_th_mult Read : cat /proc/videograph/di/tmnr / motion_th_mult Output:","title":"\uf06c /proc/videograph/di/tmnr/motion_th_mult"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographditmnrtmnr_fcs","text":"[Description] Read or write the TMNR/FCS related parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [enable 0\\~1] [fcs_th 0\\~255] [fcs_weight 0\\~16] > /proc/videograph/di/tmnr/tmnr_fcs tmnr_fcs_en, tmnr_fcs_th, tmnr_fcs_weight Read : cat /proc/videograph/di/tmnr / tmnr_fcs Output:","title":"\uf06c /proc/videograph/di/tmnr/tmnr_fcs"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographditmnrdpr","text":"[Description] Read or writer the TMNR/DPR related parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [dpr_en 0\\~1] [motion_th 0\\~255] [cnt_th 0\\~16] [dpr_mode 0\\~1] > /proc/videograph/di/tmnr/dpr dpr_en, dpr_motion_th, dpr_cnt_th, dpr_mode Read : cat /proc/videograph/di/tmnr/dpr Output:","title":"\uf06c /proc/videograph/di/tmnr/dpr"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#4-de-interlace-di","text":"The dynamic de-interlace method is to detect where is the motion object in the image and where is the static object in the image. For static block in the image using field de-interlace to get the completely resolution in vertical direction, and for motion block in the image using single field de-interlace to avoid sawtooth and ghost phenomenon. The following are common abnormal phenomenons which caused by de-interlace, it needs to adjust parameter to get the best image performance. Table 51 sawtooth phenomen caused by motion object misjudge to static object Table 52 resolution decreased phenomenon caused by static object misjudge to motion object","title":"4 De-Interlace (DI)"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#41-parameter-description","text":"(The blue text is the part of the parameter difference between this module and the 9831x series, please pay special attention) Table 53 DI Parameter List Parameter Range Def Description top_motion_en 0\\~1 1 Enable the motion detection of top field. bot_motion_en 0\\~1 1 Enable the motion detection of bottom field. auto_th_en 0\\~1 1 Based on Y to automatically generate \u201cmd_th\u201d. If this function is enabled, the parameter \u201cmd_th\u201d is invalid. strong_md_en 0\\~1 1 Enable \u201cstrong_md\u201d function. If \u201cmd\u201d is larger than \u201cstrong_md_th\u201d, it is determined as motion block, no matter the motion block is continuous or not. mmb_en 0\\~1 1 Enable motion macro block(mmb) determine mechanism. Single mb is motion does not mean it is necessary mmb, it needs to be determined with other mb. smb_en 0\\~1 1 Enable static macro block(smb) determine mechanism. (The pixel in smb still has possibility to be motion) emb_en 0\\~1 1 Enable extend macro block(emb) determine mechanism, the smb will further perform emb to avoid fratured image. lmb_en 0\\~1 1 Enable line macro block(lmb) determine mechanism. (mb is texture in line form) pmmb_en 0\\~1 1 Enable pmmb detection, \u201ctm_di\u201d must be enable. corner_detect_en 0\\~1 1 Determine whether it is corner pixel, if it is corner pixel, replace the pixel with average of the upper pixel and lower pixel. di_gmm_motion_en 0\\~1 1 Reference gmm\u2019s motion result. Motion = (DI motion || GMM motion) all_motion 0\\~1 0 Debug mode. Set all image as motion. all_static 0\\~1 0 Debug mode, set all image as static. strong_edge 0\\~255 40 Threshold for determining strong edge. strong_md_th 0\\~255 40 Threshold for determining strong motion. if (pixel diff > strong_md_th) => motion md_th 0\\~255 10 Threshold for determining whether pixel is motion. line_admit 0\\~15 4 Threshold for determining whether it is line pixel. If number of continuous similar point is larger than line_admit, it is determined as line pixel. lmb_th 0\\~255 6 Threshold for determining whether it is line mb. If line pixel in mb is larger than \u201clmb_th\u201d, it is determined as line mb. mmb_th 0\\~255 16 Threshold for determining whether it is mmb. If larger than \u201cmmb_th\u201d, it is motion. smb_th 0\\~255 4 Threshold for determining whether it is smb. If larger than \u201csmb_th\u201d, it is static. emb_th 0\\~255 8 Threshold for determining whether it is emb. If larger than \u201cemb_th\u201d, it is extend mb. ela_h_th 0\\~255 60 The break point of edge strength weighting map. Please refer to advance description. ela_l_th 0\\~255 20 The break point of edge strength weighting map. Please refer to advance description. mmb_scene_change_en 0\\~1 1 Enable the scene change detection of mmb. When it is determined as scene changed, the algorithm will set all image as motion status to avoid fratured image. mmb_scene_change_th 0\\~2\\^16-1 1080 Threshold for determining whether it is scene changed. When the number of mmb is larger than this threshold, it is determined as scene changed. ch0_row1_status_ctrl 0\\~3 0 Control with special treatment for first row in even field 2\u2019b00 : Automatic processing by DI. 2\u2019b01: Same as process that DI handle a still object 2\u2019b10: Same as process that DI handle a motion object 2\u2019b11: Fill it with black. ch1_row1_status_ctrl 0\\~3 0 Control with special treatment for first row in odd field 2\u2019b00 : Automatic processing by DI. 2\u2019b01: Same as process that DI handle a still object 2\u2019b10: Same as process that DI handle a motion object 2\u2019b11: Fill it with black. ch0_last_row_status_ctrl 0\\~3 0 Control with special treatment for last row in even field 2\u2019b00 : Automatic processing by DI. 2\u2019b01: Same as process that DI handle a still object 2\u2019b10: Same as process that DI handle a motion object 2\u2019b11: Fill it with black. ch1_last_row_status_ctrl 0\\~3 0 Control with special treatment for last row in odd field 2\u2019b00 : Automatic processing by DI. 2\u2019b01: Same as process that DI handle a still object 2\u2019b10: Same as process that DI handle a motion object 2\u2019b11: Fill it with black.","title":"4.1 Parameter Description"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#advance-desciption","text":"\uf06c lmb_admit : When horizontal line in static object appears as broken line(uncontinuous line) or has uneven phenomenon, it is recommend to properly decrease this value. \uf06c lmb_th : When horizontal line in static object appears as broken line(uncontinuous line) or has uneven phenomenon, it is recommend to properly decrease this value. This value should larger or equal to \u201cline_admin\u201d. \uf06c mmb_th : When the edge of motion object easily has broken phenomenon, it might be the motion object edge be determined as static, properly decrease this value could improve this phenomenon. \uf06c emb_th : When the motion small object(such as falling beans or high frequency thin line) has broken phenomenon, properly decrease this value could improve this phenomenon, increase the sensitivity of small object. \uf06c smb _th : When static text(thin line) or trademark have discontinuous line or uneven phenomenon(caused by static point misjudge to motion point, and adopt interpolation result), properly decrease this value can let it more easily to be determined as static object. \uf06c ela_h_th, ela_l_th: Based on Edge strength to decide use directional interpolation or average interpolation. The relationship please refer the following figure. Normally, it is recommend to use default value.","title":"\uf06c Advance desciption"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#42-setting-interface","text":"","title":"4.2 Setting Interface"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#421-proc","text":"","title":"4.2.1 Proc"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdididump_info","text":"[Description] Read all DIE parameters of the current camera channel. [Command] Write : Not Support Read : cat /proc/videograph/di/di/dump_info Output:","title":"\uf06c /proc/videograph/di/di/dump_info"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdidimotion_en","text":"[Description] Read or write the DI/top_motion_en, bot_motion_en parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [top_motion_en 0\\~1] [bot_motion_en 0\\~1] > /proc/videograph/di/di/motion_en top_motion_en, bot_motion_en Read : cat /proc/videograph/di/di/motion_en Output:","title":"\uf06c /proc/videograph/di/di/motion_en"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdidimd_th","text":"[Description] Read or write the DIE/md_th parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [auto_th_en 0 \\~ 1] [md_th 0\\~255]> /proc/videograph/di/di/md_th auto_md_en, md_th \u203b When \u201cauto_md_en\u201d is 1, \u201cmd_th\u201d is not working. Read : cat /proc/videograph/di/di/md_th Output:","title":"\uf06c /proc/videograph/di/di/md_th"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdidistrong_md","text":"[Description] Read or write the DI/strong_md related parameters of the current channel. [Command] Write : proc command Target Parameter echo [strong_md_en 0 \\~ 1] [strong_md_th 0\\~255]> /proc/videograph/di/di/strong_md strong_md_en, strong_md_th Read : cat /proc/videograph/di/di/strong_md Output:","title":"\uf06c /proc/videograph/di/di/strong_md"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdidistrong_edge","text":"[Description] Read or write the DI/strong_edge parameter of the cuurent camera channel. [Command] Write : proc command Target Parameter echo [strong_edge 0\\~255]> /proc/videograph/di/di/strong_edge strong_edge Read : cat /proc/videograph/di/di/strong_edge Output:","title":"\uf06c /proc/videograph/di/di/strong_edge"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdidicorner_detect_en","text":"[Description] Read or write the DI/corner_detect_en parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [corner_det_en 0\\~1]> /proc/videograph/di/di/corner_det_en corner_detect_en Read : cat /proc/videograph/di/di/corner_det_en Output:","title":"\uf06c /proc/videograph/di/di/corner_detect_en"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdidiline_admit","text":"[Description] Read or write the DI/line_admit parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [line_admit 0\\~15]> /proc/videograph/di/di/line_admit line_admit Read : cat /proc/videograph/di/di/line_admit Output:","title":"\uf06c /proc/videograph/di/di/line_admit"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdidiall_motion_static","text":"[Description] Read or write the DI/all_motion, all_static parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [all_motion 0\\~1] [all_static 0\\~1] > /proc/videograph/di/di/all_motion_static all_motion, all_static \u203bShould not be both set to 1. Read : cat /proc/videograph/di/di/all_motion_static Output:","title":"\uf06c /proc/videograph/di/di/all_motion_static"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdididi_gmm_motion_en","text":"[Description] Read or write the DI/di_gmm_motion_en of the current camera channel. [Command] Write : proc command Target Parameter echo [enable 0\\~1] > /proc/videograph/di/di/di_gmm_motion_en di_gmm_motion_en Read : cat /proc/videograph/di/di/di_gmm_motion_en Output:","title":"\uf06c /proc/videograph/di/di/di_gmm_motion_en"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdidimmb_param","text":"[Description] Read or write the DI/mmb related parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [mmb_en 0\\~1] [pmmb_en 0\\~1] [mmb_th 0\\~255] > /proc/videograph/di/di/mmb_param mmb_en, pmmb_en,(mmb_en should be 1) mmb_th Read : cat /proc/videograph/di/di/mmb_param Output:","title":"\uf06c /proc/videograph/di/di/mmb_param"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdidimmb_scene_change","text":"[Description] Read or write the DI/mmb scene change related parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [scene_change_en 0\\~1] [scene_change_th 0\\~65535] > /proc/videograph/di/di/mmb_scene_change mmb_scene_change_en, mmb_scene_change_th Read : cat /proc/videograph/di/di/mmb_scene_change Output:","title":"\uf06c /proc/videograph/di/di/mmb_scene_change"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdidismb_param","text":"[Description] Read or write the DI/smb related parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [smb_en 0\\~1] [smb_th 0\\~255] > /proc/videograph/di/di/smb_param smb_en, smb_th Read : cat /proc/videograph/di/di/smb_param Output:","title":"\uf06c /proc/videograph/di/di/smb_param"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdidiemb_param","text":"[Description] Read or write the DI/emb related parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [emb_en 0\\~1] [emb_th 0\\~255] > /proc/videograph/di/di/emb_param emb_en, smb_th Read : cat /proc/videograph/di/di/emb_param Output:","title":"\uf06c /proc/videograph/di/di/emb_param"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdidilmb_param","text":"[Description] Read or write the DIE/lmb related parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [lmb_en 0\\~1] [lmb_th 0\\~255] > /proc/videograph/di/di/lmb_param lmb_en, lmb_th Read : cat /proc/videograph/di/di/lmb_param Output:","title":"\uf06c /proc/videograph/di/di/lmb_param"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdidiela_th","text":"[Description] Read or write the DIE/ela_h_th, ela_l_th related parameter of the current camera channel. [Command] Write : proc command Target Parameter echo [ela_hi 0\\~255] [ela_lo 0\\~255] > /proc/videograph/di/di/ela_th ela_h_th, ela_l_th Read : cat /proc/videograph/di/di/ela_th Output:","title":"\uf06c /proc/videograph/di/di/ela_th"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#procvideographdidirow_status_ctrl","text":"[\u63cf\u8ff0] Read or write the DEI/row1_status_ctrl, last_row_status_ctrl related parameter of the current camera channel. [\u8a9e\u6cd5] Write : proc command \u76ee\u6a19\u53c3\u6578 echo [ch0_row1_status_ctrl 0\\~3] [ch1_row1_status_ctrl 0\\~3] [ch0_last_row_status_ctrl 0\\~3] [ch1_last_row_status_ctrl 0\\~3] > /proc/videograph/di/di/row_status_ctrl ch0_row1_status_ctrl, ch1_row1_status_ctrl, ch0_last_row_status_ctrl, ch1_last_row_status_ctrl, Read : cat /proc/videograph/di/di/row_status_ctrl Output:","title":"\uf06c /proc/videograph/di/di/row_status_ctrl"},{"location":"Software/ISP/NT9833x_DI_Tuning_Guide_en.html#5-revision-history","text":"Version Date Advisor Description 0.1.0 2021/01/20 Allen Hsu First version.","title":"5 Revision History"},{"location":"Software/ISP/NT9833x_LCD_IQ_Tuning_Guide_en.html","text":"1 Overview \u00b6 LCD310 is the LCD controller of NT9833x. The following image processing modules are insided. \uf06c Y Gamma \uf06c YUV Adjustment \uf06c Local Contrast Enhance \uf06c Sharpen \u00b6 2 IQ Tuning Guide \u00b6 2.1 Y Gamma \u00b6 This feature is tone mapping and can be used to adjust the contrast, brightness and dynamic range of the image. 2.1.1 Parameters \u00b6 LCD310 Y Gamma divides the Y channel range from the darkest to the brightest and is equally divided into 16 blocks. Each block can be divided into up to 8 sub-blocks. The total number of all blocks must not exceed 32. Parameter Range Def Description gm_en 0\\~1 1 enable Y gamma blk_idx[16] 0\\~31 0 Block first index blk_split[16] 0\\~3 0 Block[x], Sub-block split 00 : no split. 01 : split to 2 sub-blocks 10 : split to 4 sub-blocks 11 : split to 8-blocks Y_gm[32] 0\\~4095 Gamma table \uf06c gm_en: Y gamma enable/disable \uf06c blk_idx: Sub-block index in each macro block. Corresponds to the index of the gamma table. \uf06c blk_split: Each block is divided into sub-blocks. Ex. 1 \uff1a Block0 is divided into 8 sub-block Block1 is divided into 8 sub-block Block2 is divided into 8 sub-block Block3 is divided into 8 sub-block Total Block no: 8 + 8 + 2 + 2 + 12(Block4\\~15) = 32 The parameter settings are as follows\uff1a blk_idx[16] = {0, 8, 16, 18, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31}; blk_split[16] = {3, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; Y_gm[32] = {32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 480, 512, 640, 768, 896, 1024, 1280, 1536, 1792, 2048, 2304, 2560, 2816, 3072, 3328, 3584, 3840, 4095}; Ex. 2 \uff1a Block0 is divided into 4 sub-block Block1 is divided into 4 sub-block Block14 is divided into 4 sub-block Block15 is divided into 4 sub-block Total block no: 4 + 4 + 12(Block2\\~13) + 4 + 4 = 28 //\u203bnot necessary to equal to 32 The parameter settings are as follows\uff1a blk_idx[16] = {0, 4, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 24}; blk_split[16] = {2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2}; Y_gm[32] = {64, 128, 192, 256,320, 384, 448, 512, 768, 1024, 1280, 1536, 1792, 2048, 2304, 2560, 2816, 3072, 3328, 3584, 3648, 3712, 3776, 3840, 3904, 3968, 4032, 4095, 4095, 4095, 4095, 4095}; \u203bThe last for value will be dummy. 2.1.2 Tuning Interface \u00b6 Proc Command: \u00b6 echo 0 1 0 \u201c0x300,0x108,0x10a,0xc,0xd,0xe,0xf,0x10,0x11,0x12,0x13,0x14,0x15,0x116,0x218,0x21c\u201d > ygamma echo 0 1 1 \u201c80,128,176,224,256,304,336,368,528,688,832,1008,1344,1680,2016,2336\u201d > ygamma echo 0 1 2 \u201c2640,2912,3152,3376,3552,3712,3776,3840,3872,3904,3936,3968,4000,4032,4064,4080\u201d > ygamma 2.2 YUV Adjustment \u00b6 This function includes adjustments for brightness, contrast, hue, saturation, etc., as follows: \uf06c Brightness: \uf06e Setting Interface\uff1a proc Read : cat /proc/flcd310/brightness Write: echo \\<plane 0> \\<brightness -127\\~127> > brightness Parameter Description plane Image plane. Fixed to be 0 (Video plane) brightness Brightness value. The larger value corressponds to brighter image. \uf06e Result\uff1a Brightness = 0 Brightness = 25 Brightness = -25 \uf06c Contrast: Map the image Y channel to adjust the image contrast. \uf06e Setting Interface\uff1a /proc/flcd310/contrast Read: cat /proc/flcd310/contrast Write: echo \\<plane 0\\~0> \\<contrast_ratio 0\\~255> \\<contrast_mode 0\\~2> > /proc/flcd310/contrast Parameter Description plane Image plane. Fixed to be 0 (Video plane) contrast_ratio Default = 128, The lager value corressponds to higher contrast. contrast_mode Mapping mode, explained as following: contrast_mode mapping mode (contrast=150) Feature 0 \uf06c No loss of shadow details, loss of highlight detail \uf06c Overall brightness may increase. 1 \uf06c Dark details and highlight details are likely to be loss. \uf06c Overall brightness will not be changed. 2 \uf06c No loss of detail in the highlights, details of the shadows and possible loss. \uf06c The overall brightness may be dimmed. \uf06e Result\uff1a contrast = 170 Contrast = 80 \uf06c Hue: LCD310 divides the color picture into six blocks, which can adjust the hue and saturation for specific color blocks. Index 0 \\~ 5 respectively: Magenta, Red, Yellow, Green, Cyan, Blue. \uf06e Setting Interface: /proc/flcd310/hue Read: cat /proc/flcd310/hue Write: echo \\<plane 0\\~0> \\<hue_sat state 0/1> \\<hue0 -45\\~45> \\<hue1 -45\\~45> \\<hue2 -45\\~45> \\<hue3 -45\\~45> \\<hue4 -45\\~45> \\<hue5 -45\\~45> > /proc/flcd310/hue Parameter Description plane Image plane. Fixed to be 0 (Video plane) hue_sat state 1: enable, 0: diable hue saturation hue0\\~5 They are the rotation adjustment values of the following 6 large hue blocks. The preset value of 0 means no adjustment, and the positive/negative values are respectively inverse/clockwise rotation of the hue block. Magenta, Red, Yellow, Green, Cyan, Blue \uf06c Saturation: Adjust the saturation of the picture. LCD310 divides the color picture into six blocks, which can adjust the hue and saturation for specific color blocks. Index 0 \\~ 5 respectively: Magenta, Red, Yellow, Green, Cyan, Blue. \uf06e Setting Interface\uff1a /proc/flcd310/hue_sat Read: cat /proc/flcd310/hue_sat Write: echo \\<plane 0\\~0> \\<hue_sat state 0/1> \\<hue_sat0> \\<hue_sat1> \\<hue_sat2> \\<hue_sat3> \\<hue_sat4> \\<hue_sat5> > /proc/flcd310/hue_sat Parameter Description plane Image plane. Fixed to be 0 (Video plane) hue_sat state 1: enable, 0: diable hue saturation hue_sat0\\~5 The saturation adjustment values of the following six color. Set to 128 to indicate no adjustment. The larger the value, the higher the saturation. Magenta, Red, Yellow, Green, Cyan, Blue \uf06e Result\uff1a hue_sat = 64 hue_sat = 128 hue_sat=164 2.3 Local Contrast Enhance \u00b6 This feature enhances regional contrast. Setting Interface\uff1a /proc/flcd310/ce Read: cat /proc/flcd310/ce Write: echo \\<plane 0\\~0> \\<ce_state 0/1> \\<strength 0\\~1023> > /proc/flcd310/ ce Parameter Description plane Image plane. Fixed to be 0 (Video plane) ce_state 1: enable, 0: diable strength The strength of local contrast enhancement. \uf06e Result\uff1a strength = 0 strength = 30 2.4 Sharpen \u00b6 This function is an edge enhancement function that enhances the sharpness of the picture. Two-level sharpness enhancement core for reinforcement of thin and thick edges \uf06e Setting Interface: /proc/flcd310/sharpness Read: cat /proc/flcd310/sharpness Write: echo \\<plane 0> \\<enable 0/1> \\<hpf0_5x5_gain 0\\~1024> \\<hpf1_5x5_gain 0\\~1024> > /proc/flcd310/sharpness Parameter Description plane Image plane. Fixed to be 0 (Video plane) enable 1: enable, 0: diable hpf0_5x5_gain Enhance strength of thick edge. hpf1_5x5_gain Enhance strength of thin edge. \uf06e Result\uff1a Thin edge enhancement Thick edge enhancement Revision Historys \u00b6 Revision Date Author Changes 0.1.0 2021/01/20 Allen Hsu First version.","title":"LCD IQ Tuning Guide"},{"location":"Software/ISP/NT9833x_LCD_IQ_Tuning_Guide_en.html#1-overview","text":"LCD310 is the LCD controller of NT9833x. The following image processing modules are insided. \uf06c Y Gamma \uf06c YUV Adjustment \uf06c Local Contrast Enhance \uf06c Sharpen","title":"1 Overview"},{"location":"Software/ISP/NT9833x_LCD_IQ_Tuning_Guide_en.html#_1","text":"","title":""},{"location":"Software/ISP/NT9833x_LCD_IQ_Tuning_Guide_en.html#2-iq-tuning-guide","text":"","title":"2 IQ Tuning Guide"},{"location":"Software/ISP/NT9833x_LCD_IQ_Tuning_Guide_en.html#21-y-gamma","text":"This feature is tone mapping and can be used to adjust the contrast, brightness and dynamic range of the image.","title":"2.1 Y Gamma"},{"location":"Software/ISP/NT9833x_LCD_IQ_Tuning_Guide_en.html#211-parameters","text":"LCD310 Y Gamma divides the Y channel range from the darkest to the brightest and is equally divided into 16 blocks. Each block can be divided into up to 8 sub-blocks. The total number of all blocks must not exceed 32. Parameter Range Def Description gm_en 0\\~1 1 enable Y gamma blk_idx[16] 0\\~31 0 Block first index blk_split[16] 0\\~3 0 Block[x], Sub-block split 00 : no split. 01 : split to 2 sub-blocks 10 : split to 4 sub-blocks 11 : split to 8-blocks Y_gm[32] 0\\~4095 Gamma table \uf06c gm_en: Y gamma enable/disable \uf06c blk_idx: Sub-block index in each macro block. Corresponds to the index of the gamma table. \uf06c blk_split: Each block is divided into sub-blocks. Ex. 1 \uff1a Block0 is divided into 8 sub-block Block1 is divided into 8 sub-block Block2 is divided into 8 sub-block Block3 is divided into 8 sub-block Total Block no: 8 + 8 + 2 + 2 + 12(Block4\\~15) = 32 The parameter settings are as follows\uff1a blk_idx[16] = {0, 8, 16, 18, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31}; blk_split[16] = {3, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; Y_gm[32] = {32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 480, 512, 640, 768, 896, 1024, 1280, 1536, 1792, 2048, 2304, 2560, 2816, 3072, 3328, 3584, 3840, 4095}; Ex. 2 \uff1a Block0 is divided into 4 sub-block Block1 is divided into 4 sub-block Block14 is divided into 4 sub-block Block15 is divided into 4 sub-block Total block no: 4 + 4 + 12(Block2\\~13) + 4 + 4 = 28 //\u203bnot necessary to equal to 32 The parameter settings are as follows\uff1a blk_idx[16] = {0, 4, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 24}; blk_split[16] = {2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2}; Y_gm[32] = {64, 128, 192, 256,320, 384, 448, 512, 768, 1024, 1280, 1536, 1792, 2048, 2304, 2560, 2816, 3072, 3328, 3584, 3648, 3712, 3776, 3840, 3904, 3968, 4032, 4095, 4095, 4095, 4095, 4095}; \u203bThe last for value will be dummy.","title":"2.1.1 Parameters"},{"location":"Software/ISP/NT9833x_LCD_IQ_Tuning_Guide_en.html#212-tuning-interface","text":"","title":"2.1.2 Tuning Interface"},{"location":"Software/ISP/NT9833x_LCD_IQ_Tuning_Guide_en.html#proc-command","text":"echo 0 1 0 \u201c0x300,0x108,0x10a,0xc,0xd,0xe,0xf,0x10,0x11,0x12,0x13,0x14,0x15,0x116,0x218,0x21c\u201d > ygamma echo 0 1 1 \u201c80,128,176,224,256,304,336,368,528,688,832,1008,1344,1680,2016,2336\u201d > ygamma echo 0 1 2 \u201c2640,2912,3152,3376,3552,3712,3776,3840,3872,3904,3936,3968,4000,4032,4064,4080\u201d > ygamma","title":"Proc Command:"},{"location":"Software/ISP/NT9833x_LCD_IQ_Tuning_Guide_en.html#22-yuv-adjustment","text":"This function includes adjustments for brightness, contrast, hue, saturation, etc., as follows: \uf06c Brightness: \uf06e Setting Interface\uff1a proc Read : cat /proc/flcd310/brightness Write: echo \\<plane 0> \\<brightness -127\\~127> > brightness Parameter Description plane Image plane. Fixed to be 0 (Video plane) brightness Brightness value. The larger value corressponds to brighter image. \uf06e Result\uff1a Brightness = 0 Brightness = 25 Brightness = -25 \uf06c Contrast: Map the image Y channel to adjust the image contrast. \uf06e Setting Interface\uff1a /proc/flcd310/contrast Read: cat /proc/flcd310/contrast Write: echo \\<plane 0\\~0> \\<contrast_ratio 0\\~255> \\<contrast_mode 0\\~2> > /proc/flcd310/contrast Parameter Description plane Image plane. Fixed to be 0 (Video plane) contrast_ratio Default = 128, The lager value corressponds to higher contrast. contrast_mode Mapping mode, explained as following: contrast_mode mapping mode (contrast=150) Feature 0 \uf06c No loss of shadow details, loss of highlight detail \uf06c Overall brightness may increase. 1 \uf06c Dark details and highlight details are likely to be loss. \uf06c Overall brightness will not be changed. 2 \uf06c No loss of detail in the highlights, details of the shadows and possible loss. \uf06c The overall brightness may be dimmed. \uf06e Result\uff1a contrast = 170 Contrast = 80 \uf06c Hue: LCD310 divides the color picture into six blocks, which can adjust the hue and saturation for specific color blocks. Index 0 \\~ 5 respectively: Magenta, Red, Yellow, Green, Cyan, Blue. \uf06e Setting Interface: /proc/flcd310/hue Read: cat /proc/flcd310/hue Write: echo \\<plane 0\\~0> \\<hue_sat state 0/1> \\<hue0 -45\\~45> \\<hue1 -45\\~45> \\<hue2 -45\\~45> \\<hue3 -45\\~45> \\<hue4 -45\\~45> \\<hue5 -45\\~45> > /proc/flcd310/hue Parameter Description plane Image plane. Fixed to be 0 (Video plane) hue_sat state 1: enable, 0: diable hue saturation hue0\\~5 They are the rotation adjustment values of the following 6 large hue blocks. The preset value of 0 means no adjustment, and the positive/negative values are respectively inverse/clockwise rotation of the hue block. Magenta, Red, Yellow, Green, Cyan, Blue \uf06c Saturation: Adjust the saturation of the picture. LCD310 divides the color picture into six blocks, which can adjust the hue and saturation for specific color blocks. Index 0 \\~ 5 respectively: Magenta, Red, Yellow, Green, Cyan, Blue. \uf06e Setting Interface\uff1a /proc/flcd310/hue_sat Read: cat /proc/flcd310/hue_sat Write: echo \\<plane 0\\~0> \\<hue_sat state 0/1> \\<hue_sat0> \\<hue_sat1> \\<hue_sat2> \\<hue_sat3> \\<hue_sat4> \\<hue_sat5> > /proc/flcd310/hue_sat Parameter Description plane Image plane. Fixed to be 0 (Video plane) hue_sat state 1: enable, 0: diable hue saturation hue_sat0\\~5 The saturation adjustment values of the following six color. Set to 128 to indicate no adjustment. The larger the value, the higher the saturation. Magenta, Red, Yellow, Green, Cyan, Blue \uf06e Result\uff1a hue_sat = 64 hue_sat = 128 hue_sat=164","title":"2.2 YUV Adjustment"},{"location":"Software/ISP/NT9833x_LCD_IQ_Tuning_Guide_en.html#23-local-contrast-enhance","text":"This feature enhances regional contrast. Setting Interface\uff1a /proc/flcd310/ce Read: cat /proc/flcd310/ce Write: echo \\<plane 0\\~0> \\<ce_state 0/1> \\<strength 0\\~1023> > /proc/flcd310/ ce Parameter Description plane Image plane. Fixed to be 0 (Video plane) ce_state 1: enable, 0: diable strength The strength of local contrast enhancement. \uf06e Result\uff1a strength = 0 strength = 30","title":"2.3 Local Contrast Enhance"},{"location":"Software/ISP/NT9833x_LCD_IQ_Tuning_Guide_en.html#24-sharpen","text":"This function is an edge enhancement function that enhances the sharpness of the picture. Two-level sharpness enhancement core for reinforcement of thin and thick edges \uf06e Setting Interface: /proc/flcd310/sharpness Read: cat /proc/flcd310/sharpness Write: echo \\<plane 0> \\<enable 0/1> \\<hpf0_5x5_gain 0\\~1024> \\<hpf1_5x5_gain 0\\~1024> > /proc/flcd310/sharpness Parameter Description plane Image plane. Fixed to be 0 (Video plane) enable 1: enable, 0: diable hpf0_5x5_gain Enhance strength of thick edge. hpf1_5x5_gain Enhance strength of thin edge. \uf06e Result\uff1a Thin edge enhancement Thick edge enhancement","title":"2.4 Sharpen"},{"location":"Software/ISP/NT9833x_LCD_IQ_Tuning_Guide_en.html#revision-historys","text":"Revision Date Author Changes 0.1.0 2021/01/20 Allen Hsu First version.","title":"Revision Historys"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html","text":"1 Overview \u00b6 Figure 11 NT9833x Video Flow VPE is an independent image processing engine in YUV domain, and it performs some pre-processing process before LCD display or encoder to improve the image quality. The related modules are as follows: \uf06c Spatial Noise Reduction Module(SPNR, using MRNR method) \uf06c Tempoarl Noise Reduction Module(TMNR) \uf06c Sharpen Module(SHP) \uf06c Scaling Module(SCA) \u203b The 9833x series has removed DCE and DCTG. \u203b In the following description, the area shown in blue is the same module as the 9831x series but the parameters are different. Please pay special attention) Figure 12 VPE Image Processing Flow 2 System Control \u00b6 The processing sequence of Sharpen, SPNR(using MRNR method) and TMNR is changeable, and user can change the processing sequence depends on different camera charateristic to achieve the best image quality. 2.1 Parameter Description \u00b6 Parameter Range Def Description ch_fd Video graph use ch_fd to represent the connected video engine of each channel. User can fine tune parameter of each video engine by setting ch_fd. pipe_mode 0\\~5 0 Set module processing sequence. 0 : MRNR -> TMNR -> Sharpen 1 : MRNR-> Sharpen -> TMNR 2 : Sharpen -> MRNR -> TMNR 3 : SHP->TMNR->MRNR 4 : TMNR->MRNR->SHP 5 : TMNR->SHP->MRNR 2.2 Setting Interface \u00b6 2.2.1 Proc \u00b6 \uf06c /proc/videograph/vpe/ch_fd \u00b6 [Description] Read or write the current camera channel, and it only needs to set once, the following SHP, MRNR, TMNR parameters will work on this channel. The following proc command will list all ch_fd of the current video engine: [Command] Write : proc command Target Parameter echo [fd ] > /proc/videograph/vpe/ch_fd Fw Internal Pointer Read : cat /proc/videograph/vpe/ch_fd \uf06c /proc/videograph/vpe/pipe_mode \u00b6 [Description] Read or write the executing sequence of SHP, MRNR and TMNR. [Command] Write : proc command Target Parameter echo [pipe_mode ] > /proc/videograph/vpe/pipe_mode src_ppo_idx mrnr_ppi_idx mrnr_ppo_idx tmnr_ppi_idx tmnr_ppo_idx shp_ppi_idx shp_ppo_idx sca_ppi_idx Read : cat /proc/videograph/vpe/pipe_mode 3 Spatial Noise Reduction \u00b6 This is spatial noise reduction module(abbreviation is \u201cSPNR\u201d). It will divide the image into high frequency part and middle frequency part, performing noise reduction process respectively, then combine together to achieve the purpose of noise reduction and retain detail. 3.1 Overview \u00b6 Major processing flow is as follows : Figure 31 The SPNR processing flow. Major processing flow : 1. Divide the input image into high frequency image and middle frequency image. 2. Determine and label whether the processing pixel is on the edge. 3. Perform edge smooth process on high frequency image and middle frequency image, respectively. 4. Perform flat region noise reduction process on middle frequency image. 5. Use high/middle frequency image which had performed noise reduction process to reconstruct image. 3.2 Parameter Description \u00b6 (The blue text is the part of the parameter difference between this module and the 9831x series, please pay special attention) Table 31 SPNR Parameter List Parameter Range Def Description t_y_edge_detection [2][8] 0\\~1023 161,322,483,447, 419,320,195,130, 108,215,308,272, 246,185,125,100 Y threshold for determining whether the current processing pixel is on the edge. It has eight thresholds mapping to pixel brightness from dark to bright, respectively. [0][0\\~7] is the threshold from dark to bright for high frequency image. [1][0\\~7] is the threshold from dark to bright for middle frequency image. t_cb_edge_detection 0\\~1023 0,249 Cb threshold for determining whether the current processing pixel is on the edge. Only works in middle frequency image. t_cr_edge_detection [2] 0\\~1023 0,249 Cr threshold for determining whether the current processing pixel is on the edge. Only works in middle frequency image. t_y_edge_smoothing[2][8] 0\\~255 66,132,161,149, 140,107,80,53, 44,88,103,91, 82,62,51,41 Y threshold for determining whether it will perform smooth process. It has eight thresholds mapping to pixel brightness from dark to bright, respectively. [0][0\\~7] is the threshold from dark to bright for high frequency image. [1][0\\~7] is the threshold from dark to bright for middle frequency image. t_cb_edge_smoothing [2] 0\\~255 0,153 Cb threshold for determining whether it will perform smooth process. Only works in middle frequency image. t_cr_edge_smoothing [2] 0\\~255 0,153 Cr threshold for determining whether it will perform smooth process. Only works in middle frequency image. nr_strength_y[2] 0\\~15 {0, 0} The denoise strength of spatial domain on Y channel. [0] is denoise strength for high frequency image. [1] is denoise strength for middle frequency image. nr_strength_c 0\\~15 {0, 10} The denoise strength of spatial domain on Cb/Cr channel. Only works in middle frequency image. Advance description : \uf06c edge_smoothing : When SPNR performs smooth process, it will calculate weighting sum of neighbor pixels along the edge direction, if the difference between the neighbor pixel and center pixel is larger than threshold, this neighbor pixel will not be used in the smooth process. The smooth process of Y/Cb/Cr are the same. 3.3 Setting Interface \u00b6 3.3.1 Proc \u00b6 \uf06c /proc/videograph/vpe/mrnr/dump_info \u00b6 [Description] Read all SPNR(using MRNR method) parameters of the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/mrnr/dump_info Output: \uf06c /proc/videograph/vpe/mrnr/mrnr_en \u00b6 [Description] Read or write the MRNR enable status of the current camera channel. [Command] Write : proc command Target Parameter echo [mrnr_en (0\\~1)] > /proc/videograph/vpe/mrnr/mrnr_en mrnr_en Read : cat /proc/videograph/vpe/mrnr/mrnr_en Output: \uf06c /proc/videograph/vpe/mrnr/t_xx_edge_det \u00b6 [Description] Read or write edge_detection parameters. [Command] Write : proc command Target Parameter echo [t_y_edge_det[0][0] \u2026..[0][7]] > /proc/videograph/vpe/mrnr/ t_y_edge_det_1 t_y_edge_detection[0\\~7] echo [t_y_edge_det[1][0] \u2026..[1][7]] > /proc/videograph/vpe/mrnr/ t_y_edge_det_2 t_y_edge_detection[8\\~15] echo [t_cb_edge_det] > /proc/videograph/vpe/mrnr/ t_cb_edge_det t_cb_edge_detection[0\\~1] echo [t_cr_edge_det] > /proc/videograph/vpe/mrnr/ t_cr_edge_det t_cr_edge_detection[0\\~1] Read : cat /proc/videograph/vpe/mrnr/ t_y_edge_det_1 cat /proc/videograph/vpe/mrnr/ t_y_edge_det_2 cat /proc/videograph/vpe/mrnr/ t_cb_edge_det_1 cat /proc/videograph/vpe/mrnr/ t_cr_edge_det_1 Output : ![\u6587\u5b57\u65b9\u584a: Command : echo [t_y_edge_det[0][0] \u2026\u2026.. [0][7] > /proc/videograph/vpe/mrnr/ t_y_edge_det_1 echo [t_y_edge_det[1][0] \u2026\u2026.. [0][7] > /proc/videograph/vpe/mrnr/ t_y_edge_det_2 echo [t_cb_edge_det > /proc/videograph/vpe/mrnr/ t_cb_edge_det echo t_cr_edge_det > /proc/videograph/vpe/mrnr/ t_cr_edge_det =============================================================== t_y_edge_det1 = t_y_edge_detection [0] [0] \u2026\u2026\u2026\u2026\u2026.[0][7] t_y_edge_det2 = t_y_edge_detection [1] [0]\u2026\u2026\u2026\u2026\u2026.. [0][7] t_cb_edge_det = t_cb_edge_detection t_cr_edge_det = t_cb_edge_detection \uf06c /proc/videograph/vpe/mrnr/t_xx_edge_smooth \u00b6 [Description] Read or write edge_smoothing parameters. [Command] Write : proc command Target Parameter echo [t_y_edge_smooth[0][0]] \u2026\u2026..[t_y_edge_smooth [0][7]] > /proc/videograph/vpe/mrnr/ t_y_edge_smooth_1 t_y_edge_ smoothing[0\\~7] echo [t_y_edge_smooth[1][0] \u2026\u2026.. [t_y_edge_smooth[1] [7]] > /proc/videograph/vpe/mrnr/t_y_edge_smooth_2 t_y_edge_ smoothing[8\\~16] echo [t_cb_edge_smooth] > /proc/videograph/vpe/mrnr/ t_cb_edge_smooth t_cb_edge_smoothing[0\\~1] echo [t_cr_edge_smooth] > /proc/videograph/vpe/mrnr/ t_cr_edge_smooth t_cr_edge_ smoothing[0\\~1] Read : cat /proc/videograph/vpe/mrnr/t_y_edge_smooth_1 cat /proc/videograph/vpe/mrnr/t_y_edge_smooth_2 cat /proc/videograph/vpe/mrnr/t_cb_edge_smooth cat /proc/videograph/vpe/mrnr/t_cr_edge_smooth Output : \uf06c /proc/videograph/vpe/mrnr/nr_strength \u00b6 [Description] Read or write nr_strength parameters on Y/C channel. [Command] Write : proc command Target Parameter echo [strength_y[0]] [strength_y [1]] [strength_c] > /proc/videograph/vpe/mrnr/nr_strength nr_strength_y[0\\~1], nr_strength_c Read : cat /proc/videograph/vpe/mrnr/ nr_strength Output : ![\u6587\u5b57\u65b9\u584a: Command : echo [strength_y[0]] [strength_y [1]] [strength_c]] > /proc/videograph/vpe/mrnr/nr_strength =============================================================== nr_strength_y = nr_strength_y[0], strength_y [1] nr_strength_c= nr_strength_c ](nvt_media/65bb53da5aaa5c2ba62dcae67f96ccb2.png) 3.3.2 Vendor API \u00b6 [Description] Get and set the 2DNR parameters corresponding to current path_id. [Command] Get\uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_DN_2D, VENDOR_VIDEO_PARAM_MRNR *p_param); Set\uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_DN_2D, VENDOR_VIDEO_PARAM_MRNR *p_param); [Definition] 4 Temporal Noise Reduction (TMNR) \u00b6 This is temporal noise reduction module(abbreviation is \u201cTMNR\u201d). The major function is to eliminate temporal noise in the image. 4.1 Overview \u00b6 The concept of TMNR algorithm is to determine whether the pixel status is static(MotionLevel=0) or motion(MotionLevel=2) by Motion Detect module. The static region perform 3DNR to reduce the temporal noise, and the motion region will not perform 3DNR to prevent from having ghost, instead, it will perform 2DNR to reduce noise. The transition region between static region and motion region will combine the result of 2DNR and 3DNR by weighting. 4.2 Parameter description \u00b6 (The blue text is the part of the parameter difference between this module and the 9831x series, please pay special attention) Table 41 TMNR Parameter List Parameter Range Default Description tmnr_en 0\\~1 1 TMNR ON/OFF luma_dn_en 0\\~1 1 Y channel TMNR ON/OFF chroma_dn_en 0\\~1 1 Cb/Cr channel TMNR ON/OFF tmnr_fcs_en 0\\~1 0 Temporal de-false color function ON/OFF It only works when \u201cchroma_dn_en\u201d is set to 1. Please refer to advance description. nr_str_y_3d 0\\~32 8 Y channel temporal NR strength nr_str_y_2d 0\\~32 16 Y channel spatial NR strength of motion object nr_str _c_3d 0\\~32 16 Cb/Cr channel temporal NR strength nr_str _c_2d 0\\~32 16 Cb/Cr channel spatial NR strength of motion object blur_str_y 0\\~2 1 Y image blurred strength 0: No blur 1: low-strength blur 2: high-strength blur \u203bIt is recommend to set enable, if the executing sequence of 3DNR is after Sharpness; otherwise, it is recommend to set disable. For DVR/NVR application, due to in most case the front-end camera had perfomed sharpen process, it is recommend to set 1. center_wzero_y_2d_en 0\\~1 1 Set to enable represents when performing the 2DNR, the weighting of center point is 0. It will increase NR strength, but might lose detail. Due to 2DNR only works on motion region, the detail loss is not obvious, it is recommend to fix enable. center_wzero_y_3d_en 0\\~1 1 Set to enable represents when performing 3DNR, the weighting of center point is 0. It is recommend to fix enable. small_vibrat_supp_y_en 0\\~1 0 Y channel small vibration suppresiioon ON/OFF. This function will enhance suppression on small vibration noise to make the image more stable. However, it also causes slower ghost removal. It is recommend to enable at normal luminance, and disable at dark luminance. avoid_residue_th_y 1\\~4 2 Upper threshold for Y channel small noise putting back. If err_compensate = 0, bigger this value will cause smaller temporal noise. On the other hand, if err_compensate = 1, bigger this value will cause bigger temporal noise. avoid_residue_th_c 1\\~4 1 Upper threshold for Vb/Cr channel small noise putting back. If err_compensate = 0, bigger this value will cause smaller temporal noise. On the other hand, if err_compensate = 1, bigger this value will cause bigger temporal noise. display_motion_map_en 0\\~1 0 Debug mode. Show motion detection result on the image to assist to judge the correctness of motion detect parameters. Please refer to advance description. motion_map_channel 0\\~4 0 Select debug signal channel. 0: Y channel 1: Cb channel 2: Cr channel 3: temporal de-false color Cb channel 4: temporal de-false color Cr channel y_base[8] 0\\~16320 {146,147,107,110,102,104,104,104} y_base[0]-[7] are NoiseSAD mapping to pixel brightness from dark to bright. When performing 2DNR, the internal algorithm will automatically fine tune strength based on y_base. The larger the y_base, the stronger strength of 2DNR of motion object. It is recommend to increase y_base as sensor gain increases. motion_level_th_y_k1 0\\~32 8 Threshold (motion_level_th_y_k1*Y_NOISE) for determining transition region on Y channel. Y_NOISE please refer to advance description. motion_level_th_y_k2 0\\~32 8 Threshold (motion_level_th_y_k2*Y_NOISE) for determining motion region on Y channel. K2 must larger or equal to K1. y_coefa[8] 0\\~48 {0,0,0,0,0,0,0,0} The slope of NoiseSAD from flat region to detail region on Y channel. y_coefa[0]-[7] mapping to pixel brightness from dark to bright. y_coefb[8] 0\\~16320 {27,27,20,12,7,10,10,10} NoiseSAD of flat region on Y channel. y_coefb[0]-[7] mapping to pixel brightness from dark to bright. y_std[8] 0\\~16320 {20,70,70,70,70,50,28,18} The standard deviation of NoiseSAD on Y channel. y_std[0]-[7] mapping to pixel brightness from dark to bright. motion_level_th_c_k1 0\\~32 8 Threshold for determining transition region on Cb/Cr channel. motion_level_th_c_k2 0\\~32 8 Threshold for determining motion region on Cb/Cr channel, K2 must larger or equal to K1. cb_mean[8] 0\\~6375 {33,33,34,32,29,28,28,28} The NoiseSAD mean value on Cb channel. cb_mean[0]-[7] mapping to pixel brightness from dark to bright. cb_std[8] 0\\~6375 {10,9,10,10,9,9,9,9} The standard deviation of NoiseSAD on Cb channel. cb_std[0]-[7] mapping to pixel brightness from dark to bright. cr_mean[8] 0\\~6375 {23,23,25,23,20,20,21,21} The NoiseSAD mean value on Cr channel. cr_mean[0]-[7] mapping to pixel brightness from dark to bright. cr_std[8] 0\\~6375 {7,7,8,7,7,77,7} The standard deviation of NoiseSAD on Cr channel. cr_std[0]-[7] mapping to pixel brightness from dark to bright. lut_y_3d_1_Th[4] 0\\~127 {11,33,55,77} Lut of Y channel 3D_1 filter Please refer to advance description. lut_y _3d_2_Th[4] 0\\~127 {40,14,7,3} Lut of Y channel 3D_2 filter Please refer to advance description. lut_y_2d_Th[4] 0\\~127 {11,33,55,77} Lut of Y channel 2D filter Please refer to advance description. lut_c_3d_Th[4] 0\\~127 {37,19,11,7} Lut of Cb/Cr channel 3D filter Please refer to advance description. lut_c_2d_Th[4] 0\\~127 {11,33,55,77} Lut of Cb/Cr channel 2D filter Please refer to advance description. tmnr_fcs_str 0\\~15 4 The strength of temporal de-false color function. tmnr_fcs_th 0\\~255 32 Threshold for the difference between the previous frame and the current frame to determine whether it is false color. dithering_en 0\\~1 1 Dithering enable. This function can be used to eliminate slight power noise or flicker phenomenon. dithering_bit_y 0\\~3 2 Y channel random bit number. The higher the value, the stronger the ability to eliminate the power noiser and filcker phenomenon, but the picture may appear larger fine noise. dithering_bit_u 0\\~3 1 U channel random bit number. The higher the value, the stronger the ability to eliminate the power noiser and filcker phenomenon, but the picture may appear larger fine noise. dithering_bit_v 0\\~3 1 V channel random bit number. The higher the value, the stronger the ability to eliminate the power noiser and filcker phenomenon, but the picture may appear larger fine noise. err_compensate 0\\~1 1 YC Compression error compensation. 0: Antiflicker mode. (Larger anti-flicker effect) 1: Compensation mode. (Data Compression Error Compensation) Advance Description: \uf06c tmnr_fcs_en: Temporal de-false color ON/OFF. This function will eliminate color-flash phenomenon in high frequency region. FCS off FCS on \uf06c display_motion_map_en: \u3002 Motion region will label with red color, static region will label with black color, and transition region will label with white color. Original image Motion Map \uf06c Y_NOISE: Block SAD is the summation of pixel difference between the previous frame and current frame at the same location. If the Block SAD is larger than K2*NoiseSAD_STD(NoiseSAD_STD is the input parameter), it determines as motion region. If the Block SAD is smaller than K1*NoiseSAD_STD, it determines as static region. If the Block SAD is larger than K1*NoiseSAD_STD and smaller than K2*NoiseSAD_STD, it determines as transition region. As follows : \uf06c Cb_NOISE, Cr_NOISE: Different from Y channel, the NoiseSAD of Cb/Cr channel has no relationship with detail. Therefore, it has no slope parameter. \uf06c lut_Y_3d_1_Th: Weighting Lut for stage 1 3DNR on Y channel, the x-axis is delta difference of neighbor pixel, the y-axis is weighting. As the following figure, the larger the difference, the smaller the weighting. The smaller the difference, the larger the weighting. Then, based on each weighting to perform weighting sum. \uf06c lut_Y_3d_2_Th: Weighting Lut for Stage 2 3DNR on Y channel, the x-axis is difference of the reference point between the previous frame and current frame, the y-axis is weighting. As the following figure, those with smaller difference might be static region, and set smaller weighting, the output will close to the reference frame. On the contrast, those with larger difference might be motion region, and set larger weighting, the output will close to the current frame. \uf06c lut_Y_2d_Th: Weighting Lut of neighbor pixel for 2DNR on Y channel, the x-axis is difference, the y-axis is weighting. As the following figure, the larger the difference, the smaller the weighting. The smaller the difference, the larger the weighting. Then, based on each weighting to perform weighting sum. \uf06c lut_c_3d_Th: Suppression Level Lut for 3DNR on Cb/Cr channel, the x-axis is the difference of the reference point between the previous frame and current frame, the y-axis is the suppression level. The concept is the same with \u201c LUT_Y_3d_2_Th \u201d. \uf06c lut_c_2d_Th: Weighting Lut of neighbor pixel for 2DNR on Cb/Cr channel, the x-axis is difference, the y-axis is weighting. The concept is the same with \u201c lut_Y_2d_Th \u201d. 4.3 Setting Interface \u00b6 4.3.1 Proc \u00b6 \uf06c /proc/videograph/vpe/tmnr/dump_info \u00b6 [Description] Read all parameters of the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/tmnr/dump_info Output : \uf06c /proc/videograph/vpe/tmnr/ch_en_status \u00b6 [Description] Read or write the enable status of the current channel. [Command] Write : proc command Target Parameter echo [luma_en] [chroma_en] [fcs_en] > /proc/videograph/vpe/tmnr/ch_en_status luma_dn_en chroma_dn_en tmnr_fcs_en Read : cat /proc/videograph/vpe/tmnr/ch_en_status Output : \uf06c /proc/videograph/vpe/tmnr/nr_strength \u00b6 [Description] Read or write the TMNR strength of the current channel. [Command] Write : proc command Target Parameter echo [y_3d_str] [y_2d_str] [c_3d_str] [c_2d_str] > /proc/videograph/vpe/tmnr/nr_strength nr_str_y_3d, nr_str_y_2d nr_str_c_3d, nr_str_c_2d Read : cat /proc/videograph/vpe/tmnr/nr_strength Output : \uf06c /proc/videograph/vpe/tmnr/y_base \u00b6 [Description] Read or write the base noise level of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_base0] [y_base1]\u2026\u2026\u2026[y_base7] > /proc/videograph/vpe/tmnr/y_base y_base[0]\\~[7] Read : cat /proc/videograph/vpe/tmnr/y_base Output : \uf06c /proc/videograph/vpe/tmnr/motion_level_th \u00b6 [Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_k1] [y_k2] [c_k1] [c_k2] > /proc/videograph/vpe/tmnr/motion_level_th motion_level_th_y_k1 motion_level_th_y_k2 motion_level_th_c_k1 motion_level_th_c_k2 Read : cat /proc/videograph/vpe/tmnr/motion_level_th Output : \uf06c /proc/videograph/vpe/tmnr/y_coeffa \u00b6 [Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_coeffa0] [y_coeffa1]\u2026\u2026\u2026[y_coeffa7] > /proc/videograph/vpe/tmnr/y_coeffa y_coeffa[0]\\~[7] Read : cat /proc/videograph/vpe/tmnr/y_coeffa Output : \uf06c /proc/videograph/vpe/tmnr/y_coeffb \u00b6 [Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_coeffb0] [y_coeffb1]\u2026\u2026\u2026[y_coeffb7] > /proc/videograph/vpe/tmnr/y_coeffb y_coeffb[0]\\~[7] Read : cat /proc/videograph/vpe/tmnr/y_coeffb Output : \uf06c /proc/videograph/vpe/tmnr/y_std \u00b6 [Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_std0] [y_std1]\u2026\u2026\u2026[y_std7] > /proc/videograph/vpe/tmnr/y_std y_std[0]\\~[7] Read : cat /proc/videograph/vpe/tmnr/y_std Output : \uf06c /proc/videograph/vpe/tmnr/cb_mean \u00b6 [Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [cb_mean0] [cb_mean1]\u2026\u2026\u2026[cb_mean 7] > /proc/videograph/vpe/tmnr/cb_mean cb_mean[0]\\~[7] Read : cat /proc/videograph/vpe/tmnr/cb_mean Output : \uf06c /proc/videograph/vpe/tmnr/cb_std \u00b6 [Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [cb_std0] [cb_std1]\u2026\u2026\u2026[cb_std7] > /proc/videograph/vpe/tmnr/cb_std cb_std[0]\\~[7] Read : cat /proc/videograph/vpe/tmnr/cb_std Output : \uf06c /proc/videograph/vpe/tmnr/cr_mean \u00b6 [Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [cr_mean0] [cr_mean1]\u2026\u2026\u2026[cr_std7] > /proc/videograph/vpe/tmnr/cr_mean cr_std[0]\\~[7] Read : cat /proc/videograph/vpe/tmnr/cr_mean Output : \uf06c /proc/videograph/vpe/tmnr/cr_std \u00b6 [Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [cr_std0] [cr_std1]\u2026\u2026\u2026[cr_std7] ] > /proc/videograph/vpe/tmnr/cr_std cr_std[0]\\~[7] Read : cat /proc/videograph/vpe/tmnr/cr_std Output : \uf06c /proc/videograph/vpe/tmnr/lut_y_3d_1_th \u00b6 [Description] Read or write the 3D noise reduction parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_y_3d_1_th lut_y_3d_1_th[0]\\~[3] Read : cat /proc/videograph/vpe/tmnr/lut_y_3d_1_th Output : \uf06c /proc/videograph/vpe/tmnr/lut_y_3d_2_th \u00b6 [Description] Read or write the 3D noise reduction parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_y_3d_2_th lut_y_3d_2_th[0]\\~[3] Read : cat /proc/videograph/vpe/tmnr/lut_y_3d_2_th Output : \uf06c /proc/videograph/vpe/tmnr/lut_y_2d_th \u00b6 [Description] Read or write the 2D noise reduction parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_y_2d_th lut_y_2d_th[0]\\~[3] Read : cat /proc/videograph/vpe/tmnr/lut_y_2d_th Output : \uf06c /proc/videograph/vpe/tmnr/lut_c_3d_th \u00b6 [Description] Read or write the 3D noise reduction parameters of 3DNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_c_3d_th lut_c_3d_th[0]\\~[3] Read : cat /proc/videograph/vpe/tmnr/lut_c_3d_th Output : \uf06c /proc/videograph/vpe/tmnr/lut_c_2d_th \u00b6 [Description] Read or write the 2D noise reduction parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_c_2d_th lut_c_2d_th[0]\\~[3] Read : cat /proc/videograph/vpe/tmnr/lut_c_2d_th Output : \uf06c /proc/videograph/vpe/tmnr/fcs_str \u00b6 [Description] Read or write the false color suppression strength of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [fcs_str (0\\~15) ] > /proc/videograph/vpe/tmnr/fcs_str tmnr_fcs_str Read : cat /proc/videograph/vpe/tmnr/fcs_str Output : \uf06c /proc/videograph/vpe/tmnr/fcs_th \u00b6 [Description] Read or write the threshold for determining whether it is false color of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [fcs_th (0\\~255) ] > /proc/videograph/vpe/tmnr/fcs_th tmnr_fcs_th Read : cat /proc/videograph/vpe/tmnr/fcs_th Output : \uf06c /proc/videograph/vpe/tmnr/motion_map \u00b6 [Description] Read or write the motion map of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [map_en (0\\~1)] > [map_idx] > /proc/videograph/vpe/tmnr/motion_map map_en: 0: display_motion_map_en = 0 1: display_motion_map_en = 1 map_idx : 0: motion_map_channel=Y 1: motion_map_channel=Cb 2: motion_map_channel=Cr 3: motion_map_channel=FCS_Cb 4: motion_map_channel=FCS_Cr display_motion_map_en, motion_map_channel Read : cat /proc/videograph/vpe/tmnr/motion_map Output : \uf06c /proc/videograph/vpe/tmnr/diff_blur_str \u00b6 [Description] Read or write the Diff. image blur strength of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [str (0\\~2)] > /proc/videograph/vpe/tmnr/diff_blur_str str: blur strength 0 \\~2 blur_str_y Read : cat /proc/videograph/vpe/tmnr/diff_blur_str Output : \uf06c /proc/videograph/vpe/tmnr/avoid_residue_th \u00b6 [Description] Read or write the Diff. image blur strength of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [avoid_residue_th_y (1\\~4)] [avoid_residue_th_c (1\\~4)] > /proc/videograph/vpe/tmnr/avoid_residue_th avoid_residue_th_y, avoid_residue_th_c Read : cat /proc/videograph/vpe/tmnr/avoid_residue_th Output : \uf06c /proc/videograph/vpe/tmnr/dithering \u00b6 [Description] Read or write the dithering relative parameters of the current channel. [Command] Write : proc command Target Parameter echo [dithering_en (0\\~1)] [dithering_bit_y (0\\~7)] [dithering_bit_u (0\\~7)] [dithering_bit_v (0\\~7)] > /proc/videograph/vpe/tmnr/dithering dithering_en dithering_bit_y dithering_bit_u dithering_bit_v Read : cat /proc/videograph/vpe/tmnr/ dithering Output : \uf06c /proc/videograph/vpe/tmnr/err_compensate \u00b6 [Description] Read or write the err_compensate parameter of the current channel. [Command] Write : proc command Target Parameter echo [err_compensate (0\\~1)] > /proc/videograph/vpe/tmnr/err_compensate err_compensate Read : cat /proc/videograph/vpe/tmnr/err_compensate Output : 4.3.2 Vendor API \u00b6 [Description] Get and set the TMNR parameters corresponding to current path_id. [Command] Get\uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_TMNR_CTRL, VENDOR_VIDEO_PARAM_TMNR_EXT *p_param); Set\uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_DN_2D, VENDOR_VIDEO_PARAM_TMNR_EXT *p_param); [Definition] 5 Sharpen (SHP) \u00b6 This is texture enhancement module. 5.1 Overview \u00b6 This algorithm adopts inverse gamma information and after gamma information to perform texture enhancement, respectively, to improve the enhancement strength not smooth problem of the bright/dark region. Besides, it adopts 3x3 and 5x5 filter to enhance thin edge and thick edge, repectively, to take care of the detail and contrast of image. Calculating \u201cEdge Weight\u201d to determine this is detail region or flat region(thinner edge) and automatically adjusting weighting of detail enhancement result and flat region enhancement result to take care of texture enhancement and avoid noise enhancement. The \u201cHalo clip\u201d is used to control the overshootong phenomenon caused by edge enhancement. The major flow please refer to the following figure: Parameter Description Table 51 SHP Parameter List Parameter Range Def Description sharpen_en 0\\~1 0 Edge enhance ON/OFF edge_weight_src_sel 0\\~1 0 Select the image source to calculate \u201cEdge Weight \u201d. 0: after gamma, 1: inverse gamma. Please refer to description. edge_weight_th 0\\~255 2 Threshold for calculating \u201cEdge Weight\u201d, those smaller than threshold will be considered as flat region, and the output all adopt flat region enhancement result. edge_weight_gain 0\\~255 175 Adjust the weighting of detail enhancement result and flat region(thin edge) enhancement result. Based on the setting of \u201cnoise_level+noise_curve\u201d to adjust EdgeWeight for different pixel brightness. The larger the Edge Weight, the larger weighting of detail enhancement result, repersenting the edge enhance is more stronger(more noise). In the contrast, the smaller the edge weight, the larger weighting of flat region enhancement result, representing the edge enhancement is less stronger. noise_level 0\\~255 25 Please refer to advance description. noise_curve[17] 0\\~255 {50, 50, 50, 48, 47, 44, 39, 38, 37, 36, 35, 35, 35, 35, 35, 35, 35} Please refer to advance description. blend_inv_gamma 0\\~128 64 The blending weight of inverse gamma edge enhancement result and after gamma edge enhancement result. This parameter is equal to adjust the ratio of edge enhancement between bright region and dark region, let the edge enhancement level of bright region and dark region is more even. The larger the value, the stronger strength of bright region enhancement, but the weaker strength of dark region enhancement. edge_sharp_str1 0\\~255 25 Adjust the strength of thin edge enhancement edge_sharp_str2 0\\~255 10 Adjust the strength of thick edge enhancement flat_sharp_str 0\\~255 0 Adjust the strength of flat region(thin detail) enhancement. coring_th 0\\~255 0 Threshold for determing whether to perform enhancement. For those edge value smaller than threshold, they will not perform edge enhancement to avoid enhancing noise. bright_halo_clip 0\\~128 32 Remove bright halo edge caused by edge enhancement. The smaller the \u201cbright_halo_clip\u201d, the less bright halo edge, but the sharpness might be decreased. dark_halo_clip 0\\~128 96 Remove dark halo edge caused by edge enhancement. The smaller the \u201cdark_halo_clip\u201d, the less dark halo edge, but the sharpness might be decreased. Advance description \uf06c noise_level, noise_curve[17]: noise_level = noise_level + NoiseofPixel, wherein the NoiseofPixel is the y-axis of noise_curve. The noise_curve may depend on the pixel brightness to set the noise size, respectively. Normally, human eyes are less sensitive to the noise in high bright region; thus, it can set small value to increase the edge enhancement strength to enhance detail. It is recommend to use the following default value. If user want to adjust the noise size at all Y range(0-255), it just needs to adjust noise_level. Noise Default value: edge_weight_src_sel =0 noise_curve[17] ={50,50,50,48,47,44,39,38,37,36,35,35,35,35,35,35,35} \uf0f0 More strengthen on detail in bright region to avoid enhancing noise. edge_weight_src_sel =1 noise_curve[17] = {0, 38, 46, 51, 54, 57, 59, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62} \uf0f0 More strengthen on detail in dark region to enhance thin detail, but the noise in dark region will be enhanced, either. 5.2 Setting Interface \u00b6 5.2.1 Proc \u00b6 \uf06c /proc/videograph/vpe/sharpen/dump_info \u00b6 [Description] Read all Sharpen parameters of the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/sharpen/dump_info \uf06c /proc/videograph/vpe/sharpen/sharp_en \u00b6 [Description] Read or write the enable status of the cuurent channel. [Command] Write : proc command Target Parameter echo [ sharp_en (0\\~1) ] > /proc/videograph/vpe/sharpen/sharp_en sharpen_en Read : cat /proc/videograph/vpe/sharpen/shp_en Output : \uf06c /proc/videograph/vpe/sharpen/edge_weight_src_sel \u00b6 [Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [src_sel (0 \\~ 1) ] > /proc/videograph/vpe/sharpen/edge_weight_src_sel edge_weight_src_sel Read : cat /proc/videograph/vpe/sharpen/edge_weight_src_sel Output : \uf06c /proc/videograph/vpe/sharpen/edge_weigt_gain \u00b6 [Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [gain (0\\~255) ] > /proc/videograph/vpe/sharpen/edge_weight_gain edge_weight_gain Read : cat /proc/videograph/vpe/sharpen/edge_weight_gain Output : \uf06c /proc/videograph/vpe/sharpen/edge_weight_th \u00b6 [Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [th (0\\~255) ] > /proc/videograph/vpe/sharpen/edge_weight_th edge_weight_th Read : cat /proc/videograph/vpe/sharpen/edge_weight_th Output : \uf06c /proc/videograph/vpe/sharpen/blend_inv_gamma \u00b6 [Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [th (0\\~128) ] > /proc/videograph/vpe/sharpen/blend_inv_gamma blend_inv_gamma Read : cat /proc/videograph/vpe/sharpen/blend_inv_gamma Output : ![\u6587\u5b57\u65b9\u584a: Command : echo th (0\\~128) > /proc/videograph/vpe/sharpen/blend_inv_gamma =============================================================== blend_inv_gamma = blend_inv_gamma \uf06c /proc/videograph/vpe/sharpen/edge_sharp_str \u00b6 [Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [str1 (0\\~255)] [str2 (0\\~255)] > /proc/videograph/vpe/sharpen/edge_sharp_str edge_sharp_str1 edge_sharp_str2 Read : cat /proc/videograph/vpe/sharpen/edge_sharp_str Output : \uf06c /proc/videograph/vpe/sharpen/flat_sharp_str \u00b6 [Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [str (0\\~255)] > /proc/videograph/vpe/sharpen/flat_sharp_str flat_sharp_str Read : cat /proc/videograph/vpe/sharpen/flat_sharp_str Output : \uf06c /proc/videograph/vpe/sharpen/coring_th \u00b6 [Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [coring_th (0\\~255)] > /proc/videograph/vpe/sharpen/coring_th coring_th Read : cat /proc/videograph/vpe/sharpen/coring_th Output : \uf06c /proc/videograph/vpe/sharpen/halo_clip \u00b6 [Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [bright_clip (0\\~128)] [dark_clip(0\\~128)] > /proc/videograph/vpe/sharpen/halo_clip bright_halo_clip drak_halo_clip Read : cat /proc/videograph/vpe/sharpen/halo_clip Output : \uf06c /proc/videograph/vpe/sharpen/noise_curve \u00b6 [Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [noise_curve[0] (0\\~255)]\u2026. [noise_curve [16] (0\\~255)] > /proc/videograph/vpe/sharpen/noise_curve noise_curve[17] Read : cat /proc/videograph/vpe/sharpen/noise_curve Output : 5.2.2 Vendor API \u00b6 [Description] Get and set the sharpen parameters corresponding to current path_id. [Command] Get\uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_SHARP, VENDOR_VIDEO_PARAM_SHARP *p_param); Set\uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_SHARP, VENDOR_VIDEO_PARAM_SHARP *p_param); [\u5b9a\u7fa9] 6 Edge Smoothing (ES) \u00b6 This module is edge smoothing. The main function is to eliminate aliasing in the picture to improve the smoothness of the picture. 6.1 Overview \u00b6 The characteristics of this algorithm are to effectively smooth the edges of the input image, correct the jaggedness in the edge area of the input image, and avoid the Sharpen module to enhance the degree of jaggedness in the image edge again. The algorithm divides the input image into edge area and detail area, calculates the direction of the edge on the edge area, and then performs LPF convolution adaptively along the edge direction to smooth the edge of the image. The Edge Mask can be adjusted to avoid high-frequency areas being blurred due to smoothing. Please refer to the following figure for the main process: 6.2 Parameter Description \u00b6 Table 61 ES Parameter List Parameter Range Def Description edge_smooth_en 0\\~1 0 Edge smooth enable edge_smooth_y_edeng_th_lo 0\\~255 10 Adjust the strength threshold of detail areas in the picture Please refer to the advanced instructions edge_smooth_y_edeng_th_hi 0\\~255 70 Adjust the strength threshold of the edge area in the picture Please refer to the advanced instructions edge_smooth_y_ew_lo 0\\~255 2 Adjust the smoothing strength weight of detail areas in the picture Please refer to the advanced instructions edge_smooth_y_ew_hi 0\\~255 32 Adjust the suppression threshold for the smoothing of high-frequency areas in the picture. The larger the value, the easier it is to determine and smooth the high-frequency area. Therefore, the larger the value, the smoother the high-frequency area, and the smaller the value, the clearer the high-frequency area edge_smooth_y_edi_th 0\\~63 31 Suppresses the strength of smoothing in the high-frequency region. The larger the value, the stronger the smoothing in the high-frequency region. edge_smooth_y_ds_str 0\\~7 5 Adjust the strength of the smoothing filter in the picture. The larger the value, the stronger the smoothing degree. Advance description: \uf06c edge_smooth_y_edeng_th_lo, edge_smooth_y_edeng_th_hi, edge_smooth_y_ew_lo, edge_smooth_y_ew_hi: The strength of edge smooth is controlled by the edge energy intensity of the input image, where edge_smooth_y_edeng_th_hi and edge_smooth_y_edeng_th_lo are the ranges that set the edge area and the detail area, and edge_smooth_y_ew_hi and edge_smooth_y_ew_lo set the smoothness strength of the edge area and detail area. The larger the number, the stronger of the smoothness. The relationship between the edge area and the detail area is a continuous linear change, and the corresponding relationship is shown in the following figure: 6.3 Setting Interface \u00b6 6.3.1 Proc \u00b6 \uf06c /proc/videograph/vpe/es/param \u00b6 [Description] Read all edge smoothing parameters of the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/es/param \uf06c /proc/videograph/vpe/es/edge_smooth_en \u00b6 [Description] Set the edge smooth switch of the current camera channel. [Command] Write : proc command Target Parameter echo [edge_smooth_en (0\\~1)] > /proc/videograph/vpe/es/edge_smooth_en edge_smooth_en \uf06c /proc/videograph/vpe/es/edge_smooth_out_sel \u00b6 [Description] Set the edge smooth debugging switch of the current camera channel. [Command] Write : proc command Target Parameter echo [edge_smooth_out_sel (0\\~1)] > /proc/videograph/vpe/es/edge_smooth_out_sel edge_smooth_out_sel Read : cat /proc/videograph/vpe/es/edge_smooth_out_sel Output : \uf06c /proc/videograph/vpe/es/edge_smooth_th \u00b6 [Description] Set the edge smooth related threshold of the current camera channel. [Command] Write : proc command Target Parameter echo [y_edeng_th_lo (0\\~255)] [y_edeng_th_hi (0\\~255)] [y_ew_lo (0\\~255)] [y_ew_hi (0\\~255)] > /proc/videograph/vpe/es/edge_smooth_th edge_smooth_y_edeng_th_l edge_smooth_y_edeng_th_hi edge_smooth_y_ew_lo edge_smooth_y_ew_hi Read : cat /proc/videograph/vpe/es/edge_smooth_th Output : \uf06c /proc/videograph/vpe/es/edge_smooth_y_edi_th \u00b6 [Description] Set the edge smooth mask related parameters of the current camera channel. [Command] Write : proc command Target Parameter echo [edge_smooth_y_edi_th (0\\~63)] > /proc/videograph/vpe/es/edge_smooth_y_edi_th edge_smooth_y_edi_th Read : cat /proc/videograph/vpe/es/edge_smooth_y_edi_th Output : \uf06c /proc/videograph/vpe/es/edge_smooth_y_ds_str \u00b6 [Description] Sets the filter strength of the edge smooth of the current camera channel. [Command] Write : proc command Target Parameter echo [edge_smooth_y_ds_str (0\\~7)] > /proc/videograph/vpe/es/edge_smooth_y_ds_str edge_smooth_y_ds_str Read : cat /proc/videograph/vpe/es/edge_smooth_y_ds_str Output : 6.3.2 Vendor API \u00b6 [Description] Get and set the edge smooth parameters corresponding to current path_id. [Command] Get\uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_EDGE_SMOOTH, VENDOR_VIDEO_PARAM_SHARP *p_param); Set\uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_EDGE_SMOOTH, VENDOR_VIDEO_PARAM_SHARP *p_param); [Definition] 7 Scaling (SCA) \u00b6 Inupt/Output low pass filter process with different resolution. The recommend maximum scaling down ratio is 8, and the recommend maximum scaling up ratio is 8. 7.1 Overview \u00b6 This is image scaling module, the major concept is interpolation and smooth process. 7.2 Parameter Description \u00b6 Table 71 SCA Parameter List Parameter Range Def Description sca_y_luma_algo_en 0\\~3 0 Algorithm select for vertical luma scaler. 0: judge by HW algorithm 1: select the nearest point on the left side 2: select the left side point and perform low pass filter process 3: the same as option 0 It is recommend to set 0. sca_x_luma_algo_en 0\\~3 0 Algorithm select for horizontal luma scaler. 0: judge by HW algorithm 1: select the nearest point on the left side 2: select the left side point and perform low pass filter process 3: the same as option 0 It is recommend to set 0. sca_y_chroma_algo_en 0\\~3 0 Algorithm select for vertical chroma scaler. 0: judge by HW algorithm 1: select the nearest point on the left side 2: bilinear interpolation 3: average It is recommend to set 0. sca_x_chroma_algo_en 0\\~3 0 Algorithm select for horizontal chroma scaler. 0: judge by HW algorithm 1: select the nearest point on the left side 2: bilinear interpolation 3: average It is recommend to set 0. sca_map_sel 0\\~1 0 Select scaler source mapping format. 0: without 0.5 pixel distance shift(start from the 0th pixel of image image) 1: with 0.5 pixel distance shift(start from the 0.5th pixel of image image) If set to 1, when the size of input image and output image is the same or the size is multiple of 2, the scaling performance of output image will similar to perform low pass filter. It is recommend to set 0. sca_ceffH_0\\~3 -128\\~127 [0, 0, 0, 64] LPF coefficient in horizontal direction. Please refer to advance description. \u203bThe software limit range is between -128\\~127, to reduce memory usage. sca_ceffv_0\\~3 -128\\~127 [0, 0, 0, 64] LPF coefficient in vertical direction. Please refer to advance description. \u203bThe software limit range is between -128\\~127, to reduce memory usage. des_drt 0, 2,3 0 YUV domain transform 0: bypass 2: PC level to TV level (Y: 16\\~235 / C:16\\~240) 3: TV level to PC level (Y: 0\\~235 C:0\\~255) 255: decide by job parameter of AP rather than driver (default value is 255, other settings are used for debug) Advance description: \uf06c sca_ceffH_0\\~3, sca_ceffV_0\\~3: LPF coefficients in horizontal direction and vertical direction. User can adjust LPF coefficients to fine tune sawtooth phenomenon in oblique line caused by scaling. Table 72 Scaler Low pass filter default parameter list Scaling Ratio (R) HCoef0 HCoef1 HCoef2 HCoef3 VCoef0 VCoef1 VCoef2 VCoef3 \u2267 1x 0 0 0 64 0 0 0 64 1 \\< R \u2266 1.25x 0 0 3 58 0 0 3 58 1.25 \\< R \u2266 1.5x 0 0 7 50 0 0 7 50 1.5 \\< R \u2266 1.75x 0 0 11 42 0 0 11 42 1.75 \\< R \u2266 2x 0 1 13 36 0 1 13 36 2 \\< R \u2266 2.25x 0 1 15 32 0 1 15 32 2.25 \\< R \u2266 2.5x 0 2 15 30 0 2 15 30 2.5 \\< R \u2266 2.75x 0 3 15 28 0 3 15 28 2.75 \\< R \u2266 3x 0 4 15 26 0 4 15 26 3 \\< R \u2266 3.25x 1 4 15 24 1 4 15 24 3.25 \\< R \u2266 3.5x 1 5 15 22 1 5 15 22 3.5 \\< R \u2266 3.75x 2 7 14 18 2 7 14 18 3.75 \\< R \u2266 4x 3 8 13 16 3 8 13 16 4 \\< R \u2266 5x 4 8 13 14 4 8 13 14 5 \\< R \u2266 6x 4 9 12 14 4 9 12 14 6x \\< R \u2266 7x 6 9 11 12 6 9 11 12 7x \\< R 6 9 11 12 6 9 11 12 7.3 Setting Interface \u00b6 7.3.1 Proc \u00b6 \uf06c /proc/videograph/vpe/sca/param \u00b6 [Description] Read all SCA parameters of the cuurent scaling ratio [Command] Write : Not support. Read : cat /proc/videograph/vpe/sca/param \uf06c /proc/videograph/vpe/sca/ctrl_param \u00b6 [Description] Set SCA controlling parameter for specific ratio. [Command] Write : proc command Target Parameter echo [sca_luma_algo (0\\~3)] [sca_chroma_algo (0\\~3)] [sca_map_sel (0\\~1)] > /proc/videograph/vpe/sca/ctrl_param index: Target ratio The command \u201csca_luma_algo\u201d set parameters \u201csca_y_luma_algo_en\u201d and \u201csca_x_luma_algo_en\u201d at the same time. The command \u201csca_chroma_algo\u201d set parameters \u201csca_y_chroma_algo_en\u201d and \u201csca_x_chroma_algo_en\u201d at the same time. The command \u201csca_map_sel\u201d set \u201csca_map_sel\u201d parameter. Read : Not support \uf06c /proc/videograph/vpe/sca/lpf_param \u00b6 [Description] Set SCA low pass filter parameter for specific ratio. [Command] Write : proc command Target Parameter echo [index (0\\~16)] [coeffH[0]] [coeffH[1]] [coeffH[2]] ]coeffH[3]] [coeffV[0]] [coeffV[1]] [coeffV[2]] [coeffV[3]] (-128 \\~ 127) > /proc/videograph/vpe/sca/lpf_param index: Target ratio coeffH : sca_ceffH[4] coeffV: sca_ceffV[4] \u203bThe software limit range is between -128\\~127, to reduce memory usage. Read : Not support \uf06c /proc/videograph/vpe/sca/yuv_range \u00b6 [Description] Read or write YUV range of SCA at each one of the channel. \u203bParameter can be set by put job of AP depends on channel requests, it is not recommend to be set by this proc command or ioctl to avoid conflicts. This command is used for debugging. [Command] Write : proc command Target Parameter echo [fd range] > /proc/videograph/vpe/sca /yuv_range yuv_range: 0, 2, 3, 255 (disable) \u203bdisable represent AP directly control parameters des_drt Read : cat /proc/videograph/vpe/sca/yuv_range Output : 7.3.2 Vendor API \u00b6 [Description] Get and set the scaling parameters corresponding to current path_id. [Command] Get\uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_SCA, VENDOR_VIDEO_PARAM_SCA_SET *p_param); Set\uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_SCA, VENDOR_VIDEO_PARAM_SCA_SET *p_param); [Definition] typedef struct _VENDOR_VIDEO_PARMA_SCA_CTRL { INT32 sca_ceffH[4]; ///\\< LPF coefficient in horizontal direction INT32 sca_ceffV[4]; ///\\< LPF coefficient in vertical direction } VENDOR_VIDEO_PARMA_SCA_CTRL; typedef struct _VENDOR_VIDEO_PARAM_SCA_SET { UINT8 sca_y_luma_algo_en; ///\\< Algorithm select for vertical luma scaler UINT8 sca_x_luma_algo_en; ///\\< Algorithm select for horizontal luma scaler UINT8 sca_y_chroma_algo_en; ///\\< Algorithm select for vertical chroma scaler UINT8 sca_x_chroma_algo_en; ///\\< Algorithm select for horizontal chroma scaler UINT8 sca_map_sel; ///\\< Scaler source mapping format select VENDOR_VIDEO_PARMA_SCA_CTRL sca_1000x_param; ///\\< scaling parameter for scaling ratio 1.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_1250x_param; ///\\< scaling parameter for scaling ratio 1.25x VENDOR_VIDEO_PARMA_SCA_CTRL sca_1500x_param; ///\\< scaling parameter for scaling ratio 1.50x VENDOR_VIDEO_PARMA_SCA_CTRL sca_1750x_param; ///\\< scaling parameter for scaling ratio 1.75x VENDOR_VIDEO_PARMA_SCA_CTRL sca_2000x_param; ///\\< scaling parameter for scaling ratio 2.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_2250x_param; ///\\< scaling parameter for scaling ratio 2.25x VENDOR_VIDEO_PARMA_SCA_CTRL sca_2500x_param; ///\\< scaling parameter for scaling ratio 2.50x VENDOR_VIDEO_PARMA_SCA_CTRL sca_2750x_param; ///\\< scaling parameter for scaling ratio 2.75x VENDOR_VIDEO_PARMA_SCA_CTRL sca_3000x_param; ///\\< scaling parameter for scaling ratio 3.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_3250x_param; ///\\< scaling parameter for scaling ratio 3.25x VENDOR_VIDEO_PARMA_SCA_CTRL sca_3500x_param; ///\\< scaling parameter for scaling ratio 3.50x VENDOR_VIDEO_PARMA_SCA_CTRL sca_3750x_param; ///\\< scaling parameter for scaling ratio 3.75x VENDOR_VIDEO_PARMA_SCA_CTRL sca_4000x_param; ///\\< scaling parameter for scaling ratio 4.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_5000x_param; ///\\< scaling parameter for scaling ratio 5.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_6000x_param; ///\\< scaling parameter for scaling ratio 6.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_7000x_param; ///\\< scaling parameter for scaling ratio 7.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_8000x_param; ///\\< scaling parameter for scaling ratio 8.00x } VENDOR_VIDEO_PARAM_SCA_SET; 8 Distortion Correction Engine (DCE) \u00b6 8.1 Overview \u00b6 This is lens distortion calibration module, it can perform calibration on wide-angle lens and fish-eye lens. 8.2 DCE Parameter Description \u00b6 Table 81 DCE Parameter List Parameter Range Def Description dce_mode 0\\~1 0 Select distortion function 0: GDC lens calibration 1: 2DLUT self-define XY coordinate distortion lut2d_sz 0\\~5 0 Size selection of 2D look-up table. The larger the size, the more precision to describe distortion. 0: 9x9 3: 65x65 4: 129x129 5: 257x257 lsb_rand 0\\~1 0 LSB 2 bit random generation for internal 10 bit->8 bit image. 0: fixed fill 0 1: random generate 0\\~3 fovbound 0\\~1 0 FOV boundary process method selection. When the distortion result can not fill the total output image, select different way to proceed the exceed range. 0: Replace out of boundary pixels with duplicate nearest pixel 1: Replace out of boundary pixels with bound pixels boundy 0\\~1023 0 Bound value for Y component(u8.2) boundu 0\\~1023 0 Bound value for U component(u8.2) boundv 0\\~1023 0 Bound value for V component(u8.2) cent_x_s 213-1 0 Define lens center of x-axis. It is recommend to set width/2. cent_y_s 213-1 0 Define lens center of y-axis. It is recommend to set height/2. xdist 0\\~4095 0 X input distance factor, for oval shape modeling. It is recommend to set 4095, which is suitable for most situation. ydist 0\\~4095 0 Y input distance factor, for oval shape modeling. It is recommend to set 4095, which is suitable for most situation. geo_lut 0\\~65535 0 The GEO deformation gain table, a total of 65 points, indicates the magnification of each pixel in the image at a different distance from the deformation center (magnification = 65535 * input radius / output radius), the gainbase is 65535, please refer to Note 2 for the gain table example. Value range\uff1a[0, 65535]\u3002 normfact 0\\~255 128 Radius normalization factor. Normfact = 1 \\<\\< (normbit + 7) / R2 normbit 0\\~31 31 Radius normalization shift bit. R2 = (width/2)2+(height/2)2 The total bit number of R2 is normbit. Example: 9602+5402 = 1213200 (21 bits) fovgain 0\\~4095 0 Adjust the scaling ratio of the final distortion coordinate to preserve FOV. Scale down factor for FOV preservation. Due to it will effect the calibration performance, it is recommend to set 1024. hfact 0 \\~ 224 -1 0 Horizontal scaling factor for 2DLut scaling up(u0.24). ((2DLUT horizontal pixel number \u2013 1) \\<\\< 24) / (width \u2013 1) vfact 0 \\~ 224 -1 0 Vertical scaling factor for 2DLut scaling up(u0.24). ((2DLUT vertical pixel number \u2013 1) \\<\\< 24) / (height \u2013 1) xofs_i 0\\~127 0 2DLut x offset, integer part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. xofs_f 0\\~224-1 0 2DLut x offset, fraction part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. yofs_i 0\\~127 0 2DLut y offset, integer part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. yofs_f 0\\~224-1 0 2DLut y offset, fraction part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. [Note 1] Adjust geo_fov_gain, the left side is 1024, the right side is 1320, you can observe the increase in the field of view on the right side. [Note 2] The example of the GEO deformation gain table, from left to right, corresponds to the deformation amount from the center of the image to the edge. This parameter group indicates that the larger the deformation amount toward the edge is. This example is a barrel deformation correction. R is the distance from the center of the image to each point. This distance can be understood as the radius of the circle. Ri represents the radius of each point of the input (before correction) image. Ro represents the radius of each point of the output (corrected) image. RoMax represents the longest distance from the center of the output image to the four corners. If the center of the image falls at 1/2 of the width and height, the four corners are all equal, and they are the longest distances. 8.3 Setting Interface \u00b6 8.3.1 Proc \u00b6 \uf06c /proc/videograph/vpe/dce/dump_info \u00b6 [Description] Read all DCE parameters at the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/dce/dump_info dce_en = 0 dce_mode = 1 lut2d_sz = 3 lut2d_vaddr = 0x0000000000000000 lut2d_paddr = 0x0 lsb_rand = 0 fovbound = 1 boundy = 512 boundu = 512 boundv = 512 cent_x_s = 720 cent_y_s = 720 xdist = 4095 ydist = 4095 normfact = 0 normbit = 0 fovgain = 1024 hfact = 745654 vfact = 745654 xofs_i = 0 xofs_f = 0 yofs_i = 0 yofs_f = 0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 \uf06c /proc/videograph/vpe/dce/ch_en \u00b6 [Description] Read or write the enable status of the current channel. [Command] Write : proc command Target Parameter echo [ dc_en 0\\~1 ] > /proc/videograph/vpe/dce/ch_en dc_en Read : cat /proc/videograph/vpe/dce/ch_en Output : dc_en = 0 8.3.2 Vendor API \u00b6 [Description] Get and set the dce parameters corresponding to current path_id. [Command] Get\uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEOPROC_DEWARP_INFO, VENDOR_DEWARP_INFO *p_param); Set\uff1a HD_RESULT c(HD_PATH_ID path_id, VENDOR_ VENDOR_VIDEOPROC_DEWARP_INFO, VENDOR_DEWARP_INFO *p_param); [Define] typedef struct _VENDOR_DEWARP_CTRL { BOOL dc_enable; BOOL dctg_enable; } VENDOR_DEWARP_CTRL; typedef enum _VENDOR_DEWARP_MODE { VENDOR_DEWARP_DEWARP_MODE_GDC = 0, VENDOR_DEWARP_DEWARP_MODE_2DLUT = 1, ENUM_DUMMY4WORD(VENDOR_DEWARP_DEWARP_MODE) } VENDOR_DEWARP_MODE; typedef struct _VENDOR_DEWARP_DGC_PARM { INT32 cent_x_s; ///\\< Lens center of x axis (signed) INT32 cent_y_s; ///\\< Lens center of y axis (signed) UINT32 lens_r; ///\\< Radius of Lens UINT32 xdist; ///\\< X input distance factor, for oval shape modeling UINT32 ydist; ///\\< Y input distance factor, for oval shape modeling UINT8 normfact; ///\\< Radius normalization factor (u1.7) UINT8 normbit; ///\\< Radius normalization shift bit UINT16 geo_lut[VENDOR_GEO_LUT_X]; ///\\< GDC look-up table } VENDOR_DEWARP_DGC_PARM; typedef struct _VENDOR_DEWARP_2DLUT_PARM { UINT8 lut2d_sz; ///\\< Size selection of 2D look-up table, 0:9x9, 3:65x65 UINT32 hfact; ///\\< Horizontal scaling factor for 2DLut scaling up (u0.24) UINT32 vfact; ///\\< Vertical scaling factor for 2DLut scaling up (u0.24) UINT8 xofs_i; ///\\< 2DLUT x offset, integer part UINT32 xofs_f; ///\\< 2DLUT x offset, fraction part UINT8 yofs_i; ///\\< 2DLUT y offset, integer part UINT32 yofs_f; ///\\< 2DLUT xy offset, fraction part } VENDOR_DEWARP_2DLUT_PARM; typedef struct _VENDOR_DEWARP_FOV_PARM { UINT8 fovbound; ///\\< FOV boundary process method selection UINT16 boundy; ///\\< Bound value for Y component (u8.2) UINT16 boundu; ///\\< Bound value for U component (u8.2) UINT16 boundv; ///\\< Bound value for V component (u8.2) UINT16 fovgain; ///\\< Scale down factor for FOV preservation (u2.10) } VENDOR_DEWARP_FOV_PARM; typedef struct _VENDOR_DEWARP_INFO { VENDOR_DEWARP_MODE mode; VENDOR_DEWARP_DGC_PARM dgc; VENDOR_DEWARP_2DLUT_PARM lut2d; VENDOR_DEWARP_FOV_PARM fov; } VENDOR_DEWARP_INFO; typedef struct _VENDOR_DEWARP_2DLUT_TABLE { UINT32 tbl[VENDOR_GEO_LUT]; } VENDOR_DEWARP_2DLUT_TABLE; 9 DC Table Generator(DCTG) \u00b6 9.1 Overview \u00b6 For perspective projection application, in order to increase the convenience of usage, DCTG module let user to set the desired angle and size with an instinct way to generate DCTG parameters automatically. Whenever this function is enabled, manual set DCE 2D-LUT function will be invalid. [Note] When using DCTG function, user needs to set two parameters enable, one is dc_enable, the other is dctg_en. Please refer to the following description: The \u201ctheta\u201d is the top/bottom angle. The \u201cphi\u201d is the rotate angle. The \u201crot_y\u201d is the rotate offset of (x, z) plane towards Y-axis. The \u201crot_z\u201d is the rotate offset of (x, y) plane towards Z-axis. Generate LUT: Define the rotate angle of FOV by phi_st/phi_ed, and then rotate to FOV location by rot_y. Define the top/bottom angle of FOV by theta_st/theta_ed, and then rotate to FOV location by rot_z. 9.2 Parameter Description \u00b6 Table 91 DCTG parameter list Parameter Range Def Description dctg_en 0-1 0 DCTG ON/OFF mount_type 0\\~1 0 Camera mount type. 0: Ceiling mount 1: Floor mount lut2d_sz 0, 3 3 Select size of 2D look-up table, this parameter must the same with DCE parameter. 0: 9x9 3: 65x65 lens_r 0\\~215-1 0 Valid radius of fish-eye lens, the unit is pixel. Please refer to advance description. lens_x_st 0\\~214-1 0 The start x position of fish-eye lens at the source image, the unit is pixel. lens_y_st 0\\~214-1 0 The start y position of fish-eye lens at the source image, the unit is pixel. theta_st -180 \\~ 180 (-*pi \\~ *pi) 0 FOV theta start radian. theta_ed -180 \\~ 180 (-*pi \\~ *pi) 0 FOV theta end radian. theta_end > theta_st: normal image theta_end \\< theta_st: flip image phi_st -360 \\~ 360 (-2*pi \\~ 2*pi) 0 OV phi start radian. phi_ed -360 \\~ 360 (-2*pi \\~ 2*pi) 0 FOV phi end radian. (-2*pi \\~ 2*pi) phi_end > theta_st: normal image phi_end \\< theta_st: flip image rot_z -360 \\~ 360 (-2*pi \\~ 2*pi) 0 Z-axis rotate radian rot_y -360 \\~ 360 (-2*pi \\~ 2*pi) 0 Y-zxis rotate radian. Advance description: \uf06c lens_r: The valid radius of fish-eye device. \uf06c lens_x_st : The start x position of fish-eye lens at the source image, the unit is pixel. \uf06c lens_y_st : The start y position of fish-eye lens at the source image, the unit is pixel. 9.3 Setting Interface \u00b6 9.3.1 Proc \u00b6 \uf06c /proc/videograph/vpe/dctg/dump_info \u00b6 [Description] Read all dctg parameters of the current channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/dctg/dump_info fd(0x00000000) dctg_en = 0 mount_type = 1 lut2d_sz = 3 lens_r = 540 lens_x_st = 0(0) lens_y_st = 0(0) theta_st = 45(51471) theda_ed = 90(102943) phi_st = -40(-45753) phi_ed = 40(45752) rot_z = 0 rot_y = 0 \uf06c /proc/videograph/vpe/dctg/ch_en \u00b6 [Description] Set dctg enable. [Command] Write : proc command Target Parameter echo [dctg_en] > /proc/videograph/vpe/dctg/ch_en dctg_en: dctg enable Read : cat /proc/videograph/vpe/dctg/ch_en Output : dctg_en = 1 \uf06c /proc/videograph/vpe/dctg/phi \u00b6 [Description] Set FOV phi start radian [Command] Write : proc command Target Parameter echo [st] [ed] > /proc/videograph/vpe/dctg/phi st: FOV phi start radian ed : FOV phi end radian \u203bangle range: -360 \\~ 360 Read : cat /proc/videograph/vpe/dctg/phi Output : echo \\<st> \\<ed> (range -360\\~360) phi_st degree= -40 phi_ed degree = 40 \uf06c /proc/videograph/vpe/dctg/rot \u00b6 [Description] Set Z-axis and Y-zxis rotate radian. [Command] Write : proc command Target Parameter echo [z] [y] > /prc/videograph/vpe/dctg/rot z: Z-axis rotate radian. y: Y-zxis rotate radian \u203bangle range: -360 \\~ 360 Read : cat /proc/videograph/vpe/dctg/rot Output : echo \\<z> \\<y> (range -360\\~360) rot_z degree = 0 rot_y degree = 0 \uf06c /proc/videograph/vpe/dctg/theta \u00b6 [Description] Set FOV theta start radian. [Command] Write : proc command \u76ee\u6a19\u53c3\u6578 echo [st] [ed] > /prc/videograph/vpe/dctg/theta st: FOV theta start radian. ed : FOV theta end radian \u203bangle range: -180 \\~ 180 Read : cat /proc/videograph/vpe/dctg/theta Output : echo \\<st> \\<ed> (range -180\\~180) theta_st degree = 45 theda_ed degree = 90 9.3.2 Vendor API \u00b6 [Description] Get and set the dctg parameters corresponding to current path_id. [Command] Get\uff1a HD_RESULT vendor_videoproc_get(HD_PATH_ID path_id, VENDOR_VIDEOPROC_DEWARP_DCTG_INFO, VENDOR_DEWARP_DCTG_INFO *p_param); Set\uff1a HD_RESULT vendor_videoproc_set(HD_PATH_ID path_id, VENDOR_VIDEOPROC_DEWARP_DCTG_INFO, VENDOR_DEWARP_DCTG_INFO *p_param); [Define] typedef struct _VENDOR_DEWARP_CTRL { BOOL dc_enable; BOOL dctg_enable; } VENDOR_DEWARP_CTRL; typedef struct _VENDOR_DEWARP_DCTG_INFO { VENDOR_DEWARP_DCTG_MODE mode; VENDOR_DEWARP_DCTG_LENS_PARM lens; VENDOR_DEWARP_DCTG_FOV_PARM fov; } VENDOR_DEWARP_DCTG_INFO; typedef enum _VENDOR_DEWARP_DCTG_MODE { VENDOR_DEWARP_DCTG_MODE_90 = 0, VENDOR_DEWARP_DCTG_MODE_360 = 1, ENUM_DUMMY4WORD(VENDOR_DEWARP_DCTG_MODE) } VENDOR_DEWARP_DCTG_MODE; typedef struct _VENDOR_DEWARP_DCTG_LENS_PARM { UINT8 mount_type; ///\\< Camera mount type. 0:Ceiling mount, 1:Floor mount UINT8 lut2d_sz; ///\\< Size selection of 2D look-up table, 0:9x9, 3:65x65, should the same with DCE setting. UINT32 lens_r; ///\\< Radius of Lens UINT32 lens_x_st; ///\\< Lens start x position at a source image UINT32 lens_y_st; ///\\< Lens start y position at a source image } VENDOR_DEWARP_DCTG_LENS_PARM; typedef struct _VENDOR_DEWARP_DCTG_FOV_PARM { INT32 theta_st; ///\\< FOV theta start radian (s4.16) Range: -*pi \\~ *pi INT32 theta_ed; ///\\< FOV theta end radian (s4.16) Range: -*pi \\~ *pi INT32 phi_st; ///\\< FOV phi start radian (s4.16) Range: -2*pi \\~ 2*pi INT32 phi_ed; ///\\< FOV phi end radian (s4.16) Range: -2*pi \\~ 2*pi INT32 rot_z; ///\\< Z-axis rotate radian (s4.16) Range: -2*pi \\~ 2*pi INT32 rot_y; ///\\< Y-axis rotate radian (s4.16) Range: -2*pi \\~ 2*pi } VENDOR_DEWARP_DCTG_FOV_PARM; 10 Revise History \u00b6 Version Date Advisor Description 0.1.00 2021/01/20 Allen Hsu First version. 0.2.00 2021/3/26 Allen Hsu Add description of Vendor command. 0.3.00 2022/4/11 Mina Wang Add description for dce and dctg","title":"VPE IQ Tuning Guide"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#1-overview","text":"Figure 11 NT9833x Video Flow VPE is an independent image processing engine in YUV domain, and it performs some pre-processing process before LCD display or encoder to improve the image quality. The related modules are as follows: \uf06c Spatial Noise Reduction Module(SPNR, using MRNR method) \uf06c Tempoarl Noise Reduction Module(TMNR) \uf06c Sharpen Module(SHP) \uf06c Scaling Module(SCA) \u203b The 9833x series has removed DCE and DCTG. \u203b In the following description, the area shown in blue is the same module as the 9831x series but the parameters are different. Please pay special attention) Figure 12 VPE Image Processing Flow","title":"1 Overview"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#2-system-control","text":"The processing sequence of Sharpen, SPNR(using MRNR method) and TMNR is changeable, and user can change the processing sequence depends on different camera charateristic to achieve the best image quality.","title":"2 System Control"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#21-parameter-description","text":"Parameter Range Def Description ch_fd Video graph use ch_fd to represent the connected video engine of each channel. User can fine tune parameter of each video engine by setting ch_fd. pipe_mode 0\\~5 0 Set module processing sequence. 0 : MRNR -> TMNR -> Sharpen 1 : MRNR-> Sharpen -> TMNR 2 : Sharpen -> MRNR -> TMNR 3 : SHP->TMNR->MRNR 4 : TMNR->MRNR->SHP 5 : TMNR->SHP->MRNR","title":"2.1 Parameter Description"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#22-setting-interface","text":"","title":"2.2 Setting Interface"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#221-proc","text":"","title":"2.2.1 Proc"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpech_fd","text":"[Description] Read or write the current camera channel, and it only needs to set once, the following SHP, MRNR, TMNR parameters will work on this channel. The following proc command will list all ch_fd of the current video engine: [Command] Write : proc command Target Parameter echo [fd ] > /proc/videograph/vpe/ch_fd Fw Internal Pointer Read : cat /proc/videograph/vpe/ch_fd","title":"\uf06c /proc/videograph/vpe/ch_fd"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpepipe_mode","text":"[Description] Read or write the executing sequence of SHP, MRNR and TMNR. [Command] Write : proc command Target Parameter echo [pipe_mode ] > /proc/videograph/vpe/pipe_mode src_ppo_idx mrnr_ppi_idx mrnr_ppo_idx tmnr_ppi_idx tmnr_ppo_idx shp_ppi_idx shp_ppo_idx sca_ppi_idx Read : cat /proc/videograph/vpe/pipe_mode","title":"\uf06c /proc/videograph/vpe/pipe_mode"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#3-spatial-noise-reduction","text":"This is spatial noise reduction module(abbreviation is \u201cSPNR\u201d). It will divide the image into high frequency part and middle frequency part, performing noise reduction process respectively, then combine together to achieve the purpose of noise reduction and retain detail.","title":"3 Spatial Noise Reduction"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#31-overview","text":"Major processing flow is as follows : Figure 31 The SPNR processing flow. Major processing flow : 1. Divide the input image into high frequency image and middle frequency image. 2. Determine and label whether the processing pixel is on the edge. 3. Perform edge smooth process on high frequency image and middle frequency image, respectively. 4. Perform flat region noise reduction process on middle frequency image. 5. Use high/middle frequency image which had performed noise reduction process to reconstruct image.","title":"3.1 Overview"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#32-parameter-description","text":"(The blue text is the part of the parameter difference between this module and the 9831x series, please pay special attention) Table 31 SPNR Parameter List Parameter Range Def Description t_y_edge_detection [2][8] 0\\~1023 161,322,483,447, 419,320,195,130, 108,215,308,272, 246,185,125,100 Y threshold for determining whether the current processing pixel is on the edge. It has eight thresholds mapping to pixel brightness from dark to bright, respectively. [0][0\\~7] is the threshold from dark to bright for high frequency image. [1][0\\~7] is the threshold from dark to bright for middle frequency image. t_cb_edge_detection 0\\~1023 0,249 Cb threshold for determining whether the current processing pixel is on the edge. Only works in middle frequency image. t_cr_edge_detection [2] 0\\~1023 0,249 Cr threshold for determining whether the current processing pixel is on the edge. Only works in middle frequency image. t_y_edge_smoothing[2][8] 0\\~255 66,132,161,149, 140,107,80,53, 44,88,103,91, 82,62,51,41 Y threshold for determining whether it will perform smooth process. It has eight thresholds mapping to pixel brightness from dark to bright, respectively. [0][0\\~7] is the threshold from dark to bright for high frequency image. [1][0\\~7] is the threshold from dark to bright for middle frequency image. t_cb_edge_smoothing [2] 0\\~255 0,153 Cb threshold for determining whether it will perform smooth process. Only works in middle frequency image. t_cr_edge_smoothing [2] 0\\~255 0,153 Cr threshold for determining whether it will perform smooth process. Only works in middle frequency image. nr_strength_y[2] 0\\~15 {0, 0} The denoise strength of spatial domain on Y channel. [0] is denoise strength for high frequency image. [1] is denoise strength for middle frequency image. nr_strength_c 0\\~15 {0, 10} The denoise strength of spatial domain on Cb/Cr channel. Only works in middle frequency image. Advance description : \uf06c edge_smoothing : When SPNR performs smooth process, it will calculate weighting sum of neighbor pixels along the edge direction, if the difference between the neighbor pixel and center pixel is larger than threshold, this neighbor pixel will not be used in the smooth process. The smooth process of Y/Cb/Cr are the same.","title":"3.2 Parameter Description"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#33-setting-interface","text":"","title":"3.3 Setting Interface"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#331-proc","text":"","title":"3.3.1 Proc"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpemrnrdump_info","text":"[Description] Read all SPNR(using MRNR method) parameters of the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/mrnr/dump_info Output:","title":"\uf06c /proc/videograph/vpe/mrnr/dump_info"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpemrnrmrnr_en","text":"[Description] Read or write the MRNR enable status of the current camera channel. [Command] Write : proc command Target Parameter echo [mrnr_en (0\\~1)] > /proc/videograph/vpe/mrnr/mrnr_en mrnr_en Read : cat /proc/videograph/vpe/mrnr/mrnr_en Output:","title":"\uf06c /proc/videograph/vpe/mrnr/mrnr_en"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpemrnrt_xx_edge_det","text":"[Description] Read or write edge_detection parameters. [Command] Write : proc command Target Parameter echo [t_y_edge_det[0][0] \u2026..[0][7]] > /proc/videograph/vpe/mrnr/ t_y_edge_det_1 t_y_edge_detection[0\\~7] echo [t_y_edge_det[1][0] \u2026..[1][7]] > /proc/videograph/vpe/mrnr/ t_y_edge_det_2 t_y_edge_detection[8\\~15] echo [t_cb_edge_det] > /proc/videograph/vpe/mrnr/ t_cb_edge_det t_cb_edge_detection[0\\~1] echo [t_cr_edge_det] > /proc/videograph/vpe/mrnr/ t_cr_edge_det t_cr_edge_detection[0\\~1] Read : cat /proc/videograph/vpe/mrnr/ t_y_edge_det_1 cat /proc/videograph/vpe/mrnr/ t_y_edge_det_2 cat /proc/videograph/vpe/mrnr/ t_cb_edge_det_1 cat /proc/videograph/vpe/mrnr/ t_cr_edge_det_1 Output : ![\u6587\u5b57\u65b9\u584a: Command : echo [t_y_edge_det[0][0] \u2026\u2026.. [0][7] > /proc/videograph/vpe/mrnr/ t_y_edge_det_1 echo [t_y_edge_det[1][0] \u2026\u2026.. [0][7] > /proc/videograph/vpe/mrnr/ t_y_edge_det_2 echo [t_cb_edge_det > /proc/videograph/vpe/mrnr/ t_cb_edge_det echo t_cr_edge_det > /proc/videograph/vpe/mrnr/ t_cr_edge_det =============================================================== t_y_edge_det1 = t_y_edge_detection [0] [0] \u2026\u2026\u2026\u2026\u2026.[0][7] t_y_edge_det2 = t_y_edge_detection [1] [0]\u2026\u2026\u2026\u2026\u2026.. [0][7] t_cb_edge_det = t_cb_edge_detection t_cr_edge_det = t_cb_edge_detection","title":"\uf06c /proc/videograph/vpe/mrnr/t_xx_edge_det"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpemrnrt_xx_edge_smooth","text":"[Description] Read or write edge_smoothing parameters. [Command] Write : proc command Target Parameter echo [t_y_edge_smooth[0][0]] \u2026\u2026..[t_y_edge_smooth [0][7]] > /proc/videograph/vpe/mrnr/ t_y_edge_smooth_1 t_y_edge_ smoothing[0\\~7] echo [t_y_edge_smooth[1][0] \u2026\u2026.. [t_y_edge_smooth[1] [7]] > /proc/videograph/vpe/mrnr/t_y_edge_smooth_2 t_y_edge_ smoothing[8\\~16] echo [t_cb_edge_smooth] > /proc/videograph/vpe/mrnr/ t_cb_edge_smooth t_cb_edge_smoothing[0\\~1] echo [t_cr_edge_smooth] > /proc/videograph/vpe/mrnr/ t_cr_edge_smooth t_cr_edge_ smoothing[0\\~1] Read : cat /proc/videograph/vpe/mrnr/t_y_edge_smooth_1 cat /proc/videograph/vpe/mrnr/t_y_edge_smooth_2 cat /proc/videograph/vpe/mrnr/t_cb_edge_smooth cat /proc/videograph/vpe/mrnr/t_cr_edge_smooth Output :","title":"\uf06c /proc/videograph/vpe/mrnr/t_xx_edge_smooth"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpemrnrnr_strength","text":"[Description] Read or write nr_strength parameters on Y/C channel. [Command] Write : proc command Target Parameter echo [strength_y[0]] [strength_y [1]] [strength_c] > /proc/videograph/vpe/mrnr/nr_strength nr_strength_y[0\\~1], nr_strength_c Read : cat /proc/videograph/vpe/mrnr/ nr_strength Output : ![\u6587\u5b57\u65b9\u584a: Command : echo [strength_y[0]] [strength_y [1]] [strength_c]] > /proc/videograph/vpe/mrnr/nr_strength =============================================================== nr_strength_y = nr_strength_y[0], strength_y [1] nr_strength_c= nr_strength_c ](nvt_media/65bb53da5aaa5c2ba62dcae67f96ccb2.png)","title":"\uf06c /proc/videograph/vpe/mrnr/nr_strength"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#332-vendor-api","text":"[Description] Get and set the 2DNR parameters corresponding to current path_id. [Command] Get\uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_DN_2D, VENDOR_VIDEO_PARAM_MRNR *p_param); Set\uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_DN_2D, VENDOR_VIDEO_PARAM_MRNR *p_param); [Definition]","title":"3.3.2 Vendor API"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#4-temporal-noise-reduction-tmnr","text":"This is temporal noise reduction module(abbreviation is \u201cTMNR\u201d). The major function is to eliminate temporal noise in the image.","title":"4 Temporal Noise Reduction (TMNR)"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#41-overview","text":"The concept of TMNR algorithm is to determine whether the pixel status is static(MotionLevel=0) or motion(MotionLevel=2) by Motion Detect module. The static region perform 3DNR to reduce the temporal noise, and the motion region will not perform 3DNR to prevent from having ghost, instead, it will perform 2DNR to reduce noise. The transition region between static region and motion region will combine the result of 2DNR and 3DNR by weighting.","title":"4.1 Overview"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#42-parameter-description","text":"(The blue text is the part of the parameter difference between this module and the 9831x series, please pay special attention) Table 41 TMNR Parameter List Parameter Range Default Description tmnr_en 0\\~1 1 TMNR ON/OFF luma_dn_en 0\\~1 1 Y channel TMNR ON/OFF chroma_dn_en 0\\~1 1 Cb/Cr channel TMNR ON/OFF tmnr_fcs_en 0\\~1 0 Temporal de-false color function ON/OFF It only works when \u201cchroma_dn_en\u201d is set to 1. Please refer to advance description. nr_str_y_3d 0\\~32 8 Y channel temporal NR strength nr_str_y_2d 0\\~32 16 Y channel spatial NR strength of motion object nr_str _c_3d 0\\~32 16 Cb/Cr channel temporal NR strength nr_str _c_2d 0\\~32 16 Cb/Cr channel spatial NR strength of motion object blur_str_y 0\\~2 1 Y image blurred strength 0: No blur 1: low-strength blur 2: high-strength blur \u203bIt is recommend to set enable, if the executing sequence of 3DNR is after Sharpness; otherwise, it is recommend to set disable. For DVR/NVR application, due to in most case the front-end camera had perfomed sharpen process, it is recommend to set 1. center_wzero_y_2d_en 0\\~1 1 Set to enable represents when performing the 2DNR, the weighting of center point is 0. It will increase NR strength, but might lose detail. Due to 2DNR only works on motion region, the detail loss is not obvious, it is recommend to fix enable. center_wzero_y_3d_en 0\\~1 1 Set to enable represents when performing 3DNR, the weighting of center point is 0. It is recommend to fix enable. small_vibrat_supp_y_en 0\\~1 0 Y channel small vibration suppresiioon ON/OFF. This function will enhance suppression on small vibration noise to make the image more stable. However, it also causes slower ghost removal. It is recommend to enable at normal luminance, and disable at dark luminance. avoid_residue_th_y 1\\~4 2 Upper threshold for Y channel small noise putting back. If err_compensate = 0, bigger this value will cause smaller temporal noise. On the other hand, if err_compensate = 1, bigger this value will cause bigger temporal noise. avoid_residue_th_c 1\\~4 1 Upper threshold for Vb/Cr channel small noise putting back. If err_compensate = 0, bigger this value will cause smaller temporal noise. On the other hand, if err_compensate = 1, bigger this value will cause bigger temporal noise. display_motion_map_en 0\\~1 0 Debug mode. Show motion detection result on the image to assist to judge the correctness of motion detect parameters. Please refer to advance description. motion_map_channel 0\\~4 0 Select debug signal channel. 0: Y channel 1: Cb channel 2: Cr channel 3: temporal de-false color Cb channel 4: temporal de-false color Cr channel y_base[8] 0\\~16320 {146,147,107,110,102,104,104,104} y_base[0]-[7] are NoiseSAD mapping to pixel brightness from dark to bright. When performing 2DNR, the internal algorithm will automatically fine tune strength based on y_base. The larger the y_base, the stronger strength of 2DNR of motion object. It is recommend to increase y_base as sensor gain increases. motion_level_th_y_k1 0\\~32 8 Threshold (motion_level_th_y_k1*Y_NOISE) for determining transition region on Y channel. Y_NOISE please refer to advance description. motion_level_th_y_k2 0\\~32 8 Threshold (motion_level_th_y_k2*Y_NOISE) for determining motion region on Y channel. K2 must larger or equal to K1. y_coefa[8] 0\\~48 {0,0,0,0,0,0,0,0} The slope of NoiseSAD from flat region to detail region on Y channel. y_coefa[0]-[7] mapping to pixel brightness from dark to bright. y_coefb[8] 0\\~16320 {27,27,20,12,7,10,10,10} NoiseSAD of flat region on Y channel. y_coefb[0]-[7] mapping to pixel brightness from dark to bright. y_std[8] 0\\~16320 {20,70,70,70,70,50,28,18} The standard deviation of NoiseSAD on Y channel. y_std[0]-[7] mapping to pixel brightness from dark to bright. motion_level_th_c_k1 0\\~32 8 Threshold for determining transition region on Cb/Cr channel. motion_level_th_c_k2 0\\~32 8 Threshold for determining motion region on Cb/Cr channel, K2 must larger or equal to K1. cb_mean[8] 0\\~6375 {33,33,34,32,29,28,28,28} The NoiseSAD mean value on Cb channel. cb_mean[0]-[7] mapping to pixel brightness from dark to bright. cb_std[8] 0\\~6375 {10,9,10,10,9,9,9,9} The standard deviation of NoiseSAD on Cb channel. cb_std[0]-[7] mapping to pixel brightness from dark to bright. cr_mean[8] 0\\~6375 {23,23,25,23,20,20,21,21} The NoiseSAD mean value on Cr channel. cr_mean[0]-[7] mapping to pixel brightness from dark to bright. cr_std[8] 0\\~6375 {7,7,8,7,7,77,7} The standard deviation of NoiseSAD on Cr channel. cr_std[0]-[7] mapping to pixel brightness from dark to bright. lut_y_3d_1_Th[4] 0\\~127 {11,33,55,77} Lut of Y channel 3D_1 filter Please refer to advance description. lut_y _3d_2_Th[4] 0\\~127 {40,14,7,3} Lut of Y channel 3D_2 filter Please refer to advance description. lut_y_2d_Th[4] 0\\~127 {11,33,55,77} Lut of Y channel 2D filter Please refer to advance description. lut_c_3d_Th[4] 0\\~127 {37,19,11,7} Lut of Cb/Cr channel 3D filter Please refer to advance description. lut_c_2d_Th[4] 0\\~127 {11,33,55,77} Lut of Cb/Cr channel 2D filter Please refer to advance description. tmnr_fcs_str 0\\~15 4 The strength of temporal de-false color function. tmnr_fcs_th 0\\~255 32 Threshold for the difference between the previous frame and the current frame to determine whether it is false color. dithering_en 0\\~1 1 Dithering enable. This function can be used to eliminate slight power noise or flicker phenomenon. dithering_bit_y 0\\~3 2 Y channel random bit number. The higher the value, the stronger the ability to eliminate the power noiser and filcker phenomenon, but the picture may appear larger fine noise. dithering_bit_u 0\\~3 1 U channel random bit number. The higher the value, the stronger the ability to eliminate the power noiser and filcker phenomenon, but the picture may appear larger fine noise. dithering_bit_v 0\\~3 1 V channel random bit number. The higher the value, the stronger the ability to eliminate the power noiser and filcker phenomenon, but the picture may appear larger fine noise. err_compensate 0\\~1 1 YC Compression error compensation. 0: Antiflicker mode. (Larger anti-flicker effect) 1: Compensation mode. (Data Compression Error Compensation) Advance Description: \uf06c tmnr_fcs_en: Temporal de-false color ON/OFF. This function will eliminate color-flash phenomenon in high frequency region. FCS off FCS on \uf06c display_motion_map_en: \u3002 Motion region will label with red color, static region will label with black color, and transition region will label with white color. Original image Motion Map \uf06c Y_NOISE: Block SAD is the summation of pixel difference between the previous frame and current frame at the same location. If the Block SAD is larger than K2*NoiseSAD_STD(NoiseSAD_STD is the input parameter), it determines as motion region. If the Block SAD is smaller than K1*NoiseSAD_STD, it determines as static region. If the Block SAD is larger than K1*NoiseSAD_STD and smaller than K2*NoiseSAD_STD, it determines as transition region. As follows : \uf06c Cb_NOISE, Cr_NOISE: Different from Y channel, the NoiseSAD of Cb/Cr channel has no relationship with detail. Therefore, it has no slope parameter. \uf06c lut_Y_3d_1_Th: Weighting Lut for stage 1 3DNR on Y channel, the x-axis is delta difference of neighbor pixel, the y-axis is weighting. As the following figure, the larger the difference, the smaller the weighting. The smaller the difference, the larger the weighting. Then, based on each weighting to perform weighting sum. \uf06c lut_Y_3d_2_Th: Weighting Lut for Stage 2 3DNR on Y channel, the x-axis is difference of the reference point between the previous frame and current frame, the y-axis is weighting. As the following figure, those with smaller difference might be static region, and set smaller weighting, the output will close to the reference frame. On the contrast, those with larger difference might be motion region, and set larger weighting, the output will close to the current frame. \uf06c lut_Y_2d_Th: Weighting Lut of neighbor pixel for 2DNR on Y channel, the x-axis is difference, the y-axis is weighting. As the following figure, the larger the difference, the smaller the weighting. The smaller the difference, the larger the weighting. Then, based on each weighting to perform weighting sum. \uf06c lut_c_3d_Th: Suppression Level Lut for 3DNR on Cb/Cr channel, the x-axis is the difference of the reference point between the previous frame and current frame, the y-axis is the suppression level. The concept is the same with \u201c LUT_Y_3d_2_Th \u201d. \uf06c lut_c_2d_Th: Weighting Lut of neighbor pixel for 2DNR on Cb/Cr channel, the x-axis is difference, the y-axis is weighting. The concept is the same with \u201c lut_Y_2d_Th \u201d.","title":"4.2 Parameter description"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#43-setting-interface","text":"","title":"4.3 Setting Interface"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#431-proc","text":"","title":"4.3.1 Proc"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrdump_info","text":"[Description] Read all parameters of the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/tmnr/dump_info Output :","title":"\uf06c /proc/videograph/vpe/tmnr/dump_info"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrch_en_status","text":"[Description] Read or write the enable status of the current channel. [Command] Write : proc command Target Parameter echo [luma_en] [chroma_en] [fcs_en] > /proc/videograph/vpe/tmnr/ch_en_status luma_dn_en chroma_dn_en tmnr_fcs_en Read : cat /proc/videograph/vpe/tmnr/ch_en_status Output :","title":"\uf06c /proc/videograph/vpe/tmnr/ch_en_status"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrnr_strength","text":"[Description] Read or write the TMNR strength of the current channel. [Command] Write : proc command Target Parameter echo [y_3d_str] [y_2d_str] [c_3d_str] [c_2d_str] > /proc/videograph/vpe/tmnr/nr_strength nr_str_y_3d, nr_str_y_2d nr_str_c_3d, nr_str_c_2d Read : cat /proc/videograph/vpe/tmnr/nr_strength Output :","title":"\uf06c /proc/videograph/vpe/tmnr/nr_strength"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnry_base","text":"[Description] Read or write the base noise level of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_base0] [y_base1]\u2026\u2026\u2026[y_base7] > /proc/videograph/vpe/tmnr/y_base y_base[0]\\~[7] Read : cat /proc/videograph/vpe/tmnr/y_base Output :","title":"\uf06c /proc/videograph/vpe/tmnr/y_base"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrmotion_level_th","text":"[Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_k1] [y_k2] [c_k1] [c_k2] > /proc/videograph/vpe/tmnr/motion_level_th motion_level_th_y_k1 motion_level_th_y_k2 motion_level_th_c_k1 motion_level_th_c_k2 Read : cat /proc/videograph/vpe/tmnr/motion_level_th Output :","title":"\uf06c /proc/videograph/vpe/tmnr/motion_level_th"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnry_coeffa","text":"[Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_coeffa0] [y_coeffa1]\u2026\u2026\u2026[y_coeffa7] > /proc/videograph/vpe/tmnr/y_coeffa y_coeffa[0]\\~[7] Read : cat /proc/videograph/vpe/tmnr/y_coeffa Output :","title":"\uf06c /proc/videograph/vpe/tmnr/y_coeffa"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnry_coeffb","text":"[Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_coeffb0] [y_coeffb1]\u2026\u2026\u2026[y_coeffb7] > /proc/videograph/vpe/tmnr/y_coeffb y_coeffb[0]\\~[7] Read : cat /proc/videograph/vpe/tmnr/y_coeffb Output :","title":"\uf06c /proc/videograph/vpe/tmnr/y_coeffb"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnry_std","text":"[Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [y_std0] [y_std1]\u2026\u2026\u2026[y_std7] > /proc/videograph/vpe/tmnr/y_std y_std[0]\\~[7] Read : cat /proc/videograph/vpe/tmnr/y_std Output :","title":"\uf06c /proc/videograph/vpe/tmnr/y_std"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrcb_mean","text":"[Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [cb_mean0] [cb_mean1]\u2026\u2026\u2026[cb_mean 7] > /proc/videograph/vpe/tmnr/cb_mean cb_mean[0]\\~[7] Read : cat /proc/videograph/vpe/tmnr/cb_mean Output :","title":"\uf06c /proc/videograph/vpe/tmnr/cb_mean"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrcb_std","text":"[Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [cb_std0] [cb_std1]\u2026\u2026\u2026[cb_std7] > /proc/videograph/vpe/tmnr/cb_std cb_std[0]\\~[7] Read : cat /proc/videograph/vpe/tmnr/cb_std Output :","title":"\uf06c /proc/videograph/vpe/tmnr/cb_std"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrcr_mean","text":"[Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [cr_mean0] [cr_mean1]\u2026\u2026\u2026[cr_std7] > /proc/videograph/vpe/tmnr/cr_mean cr_std[0]\\~[7] Read : cat /proc/videograph/vpe/tmnr/cr_mean Output :","title":"\uf06c /proc/videograph/vpe/tmnr/cr_mean"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrcr_std","text":"[Description] Read or write the noise model parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [cr_std0] [cr_std1]\u2026\u2026\u2026[cr_std7] ] > /proc/videograph/vpe/tmnr/cr_std cr_std[0]\\~[7] Read : cat /proc/videograph/vpe/tmnr/cr_std Output :","title":"\uf06c /proc/videograph/vpe/tmnr/cr_std"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrlut_y_3d_1_th","text":"[Description] Read or write the 3D noise reduction parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_y_3d_1_th lut_y_3d_1_th[0]\\~[3] Read : cat /proc/videograph/vpe/tmnr/lut_y_3d_1_th Output :","title":"\uf06c /proc/videograph/vpe/tmnr/lut_y_3d_1_th"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrlut_y_3d_2_th","text":"[Description] Read or write the 3D noise reduction parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_y_3d_2_th lut_y_3d_2_th[0]\\~[3] Read : cat /proc/videograph/vpe/tmnr/lut_y_3d_2_th Output :","title":"\uf06c /proc/videograph/vpe/tmnr/lut_y_3d_2_th"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrlut_y_2d_th","text":"[Description] Read or write the 2D noise reduction parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_y_2d_th lut_y_2d_th[0]\\~[3] Read : cat /proc/videograph/vpe/tmnr/lut_y_2d_th Output :","title":"\uf06c /proc/videograph/vpe/tmnr/lut_y_2d_th"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrlut_c_3d_th","text":"[Description] Read or write the 3D noise reduction parameters of 3DNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_c_3d_th lut_c_3d_th[0]\\~[3] Read : cat /proc/videograph/vpe/tmnr/lut_c_3d_th Output :","title":"\uf06c /proc/videograph/vpe/tmnr/lut_c_3d_th"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrlut_c_2d_th","text":"[Description] Read or write the 2D noise reduction parameters of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [th0] [th1] [th2] [th3] > /proc/videograph/vpe/tmnr/lut_c_2d_th lut_c_2d_th[0]\\~[3] Read : cat /proc/videograph/vpe/tmnr/lut_c_2d_th Output :","title":"\uf06c /proc/videograph/vpe/tmnr/lut_c_2d_th"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrfcs_str","text":"[Description] Read or write the false color suppression strength of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [fcs_str (0\\~15) ] > /proc/videograph/vpe/tmnr/fcs_str tmnr_fcs_str Read : cat /proc/videograph/vpe/tmnr/fcs_str Output :","title":"\uf06c /proc/videograph/vpe/tmnr/fcs_str"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrfcs_th","text":"[Description] Read or write the threshold for determining whether it is false color of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [fcs_th (0\\~255) ] > /proc/videograph/vpe/tmnr/fcs_th tmnr_fcs_th Read : cat /proc/videograph/vpe/tmnr/fcs_th Output :","title":"\uf06c /proc/videograph/vpe/tmnr/fcs_th"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrmotion_map","text":"[Description] Read or write the motion map of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [map_en (0\\~1)] > [map_idx] > /proc/videograph/vpe/tmnr/motion_map map_en: 0: display_motion_map_en = 0 1: display_motion_map_en = 1 map_idx : 0: motion_map_channel=Y 1: motion_map_channel=Cb 2: motion_map_channel=Cr 3: motion_map_channel=FCS_Cb 4: motion_map_channel=FCS_Cr display_motion_map_en, motion_map_channel Read : cat /proc/videograph/vpe/tmnr/motion_map Output :","title":"\uf06c /proc/videograph/vpe/tmnr/motion_map"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrdiff_blur_str","text":"[Description] Read or write the Diff. image blur strength of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [str (0\\~2)] > /proc/videograph/vpe/tmnr/diff_blur_str str: blur strength 0 \\~2 blur_str_y Read : cat /proc/videograph/vpe/tmnr/diff_blur_str Output :","title":"\uf06c /proc/videograph/vpe/tmnr/diff_blur_str"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnravoid_residue_th","text":"[Description] Read or write the Diff. image blur strength of TMNR of the current channel. [Command] Write : proc command Target Parameter echo [avoid_residue_th_y (1\\~4)] [avoid_residue_th_c (1\\~4)] > /proc/videograph/vpe/tmnr/avoid_residue_th avoid_residue_th_y, avoid_residue_th_c Read : cat /proc/videograph/vpe/tmnr/avoid_residue_th Output :","title":"\uf06c /proc/videograph/vpe/tmnr/avoid_residue_th"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrdithering","text":"[Description] Read or write the dithering relative parameters of the current channel. [Command] Write : proc command Target Parameter echo [dithering_en (0\\~1)] [dithering_bit_y (0\\~7)] [dithering_bit_u (0\\~7)] [dithering_bit_v (0\\~7)] > /proc/videograph/vpe/tmnr/dithering dithering_en dithering_bit_y dithering_bit_u dithering_bit_v Read : cat /proc/videograph/vpe/tmnr/ dithering Output :","title":"\uf06c /proc/videograph/vpe/tmnr/dithering"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpetmnrerr_compensate","text":"[Description] Read or write the err_compensate parameter of the current channel. [Command] Write : proc command Target Parameter echo [err_compensate (0\\~1)] > /proc/videograph/vpe/tmnr/err_compensate err_compensate Read : cat /proc/videograph/vpe/tmnr/err_compensate Output :","title":"\uf06c /proc/videograph/vpe/tmnr/err_compensate"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#432-vendor-api","text":"[Description] Get and set the TMNR parameters corresponding to current path_id. [Command] Get\uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_TMNR_CTRL, VENDOR_VIDEO_PARAM_TMNR_EXT *p_param); Set\uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_DN_2D, VENDOR_VIDEO_PARAM_TMNR_EXT *p_param); [Definition]","title":"4.3.2 Vendor API"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#5-sharpen-shp","text":"This is texture enhancement module.","title":"5 Sharpen (SHP)"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#51-overview","text":"This algorithm adopts inverse gamma information and after gamma information to perform texture enhancement, respectively, to improve the enhancement strength not smooth problem of the bright/dark region. Besides, it adopts 3x3 and 5x5 filter to enhance thin edge and thick edge, repectively, to take care of the detail and contrast of image. Calculating \u201cEdge Weight\u201d to determine this is detail region or flat region(thinner edge) and automatically adjusting weighting of detail enhancement result and flat region enhancement result to take care of texture enhancement and avoid noise enhancement. The \u201cHalo clip\u201d is used to control the overshootong phenomenon caused by edge enhancement. The major flow please refer to the following figure: Parameter Description Table 51 SHP Parameter List Parameter Range Def Description sharpen_en 0\\~1 0 Edge enhance ON/OFF edge_weight_src_sel 0\\~1 0 Select the image source to calculate \u201cEdge Weight \u201d. 0: after gamma, 1: inverse gamma. Please refer to description. edge_weight_th 0\\~255 2 Threshold for calculating \u201cEdge Weight\u201d, those smaller than threshold will be considered as flat region, and the output all adopt flat region enhancement result. edge_weight_gain 0\\~255 175 Adjust the weighting of detail enhancement result and flat region(thin edge) enhancement result. Based on the setting of \u201cnoise_level+noise_curve\u201d to adjust EdgeWeight for different pixel brightness. The larger the Edge Weight, the larger weighting of detail enhancement result, repersenting the edge enhance is more stronger(more noise). In the contrast, the smaller the edge weight, the larger weighting of flat region enhancement result, representing the edge enhancement is less stronger. noise_level 0\\~255 25 Please refer to advance description. noise_curve[17] 0\\~255 {50, 50, 50, 48, 47, 44, 39, 38, 37, 36, 35, 35, 35, 35, 35, 35, 35} Please refer to advance description. blend_inv_gamma 0\\~128 64 The blending weight of inverse gamma edge enhancement result and after gamma edge enhancement result. This parameter is equal to adjust the ratio of edge enhancement between bright region and dark region, let the edge enhancement level of bright region and dark region is more even. The larger the value, the stronger strength of bright region enhancement, but the weaker strength of dark region enhancement. edge_sharp_str1 0\\~255 25 Adjust the strength of thin edge enhancement edge_sharp_str2 0\\~255 10 Adjust the strength of thick edge enhancement flat_sharp_str 0\\~255 0 Adjust the strength of flat region(thin detail) enhancement. coring_th 0\\~255 0 Threshold for determing whether to perform enhancement. For those edge value smaller than threshold, they will not perform edge enhancement to avoid enhancing noise. bright_halo_clip 0\\~128 32 Remove bright halo edge caused by edge enhancement. The smaller the \u201cbright_halo_clip\u201d, the less bright halo edge, but the sharpness might be decreased. dark_halo_clip 0\\~128 96 Remove dark halo edge caused by edge enhancement. The smaller the \u201cdark_halo_clip\u201d, the less dark halo edge, but the sharpness might be decreased. Advance description \uf06c noise_level, noise_curve[17]: noise_level = noise_level + NoiseofPixel, wherein the NoiseofPixel is the y-axis of noise_curve. The noise_curve may depend on the pixel brightness to set the noise size, respectively. Normally, human eyes are less sensitive to the noise in high bright region; thus, it can set small value to increase the edge enhancement strength to enhance detail. It is recommend to use the following default value. If user want to adjust the noise size at all Y range(0-255), it just needs to adjust noise_level. Noise Default value: edge_weight_src_sel =0 noise_curve[17] ={50,50,50,48,47,44,39,38,37,36,35,35,35,35,35,35,35} \uf0f0 More strengthen on detail in bright region to avoid enhancing noise. edge_weight_src_sel =1 noise_curve[17] = {0, 38, 46, 51, 54, 57, 59, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62} \uf0f0 More strengthen on detail in dark region to enhance thin detail, but the noise in dark region will be enhanced, either.","title":"5.1 Overview"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#52-setting-interface","text":"","title":"5.2 Setting Interface"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#521-proc","text":"","title":"5.2.1 Proc"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpesharpendump_info","text":"[Description] Read all Sharpen parameters of the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/sharpen/dump_info","title":"\uf06c /proc/videograph/vpe/sharpen/dump_info"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpesharpensharp_en","text":"[Description] Read or write the enable status of the cuurent channel. [Command] Write : proc command Target Parameter echo [ sharp_en (0\\~1) ] > /proc/videograph/vpe/sharpen/sharp_en sharpen_en Read : cat /proc/videograph/vpe/sharpen/shp_en Output :","title":"\uf06c /proc/videograph/vpe/sharpen/sharp_en"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpesharpenedge_weight_src_sel","text":"[Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [src_sel (0 \\~ 1) ] > /proc/videograph/vpe/sharpen/edge_weight_src_sel edge_weight_src_sel Read : cat /proc/videograph/vpe/sharpen/edge_weight_src_sel Output :","title":"\uf06c /proc/videograph/vpe/sharpen/edge_weight_src_sel"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpesharpenedge_weigt_gain","text":"[Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [gain (0\\~255) ] > /proc/videograph/vpe/sharpen/edge_weight_gain edge_weight_gain Read : cat /proc/videograph/vpe/sharpen/edge_weight_gain Output :","title":"\uf06c /proc/videograph/vpe/sharpen/edge_weigt_gain"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpesharpenedge_weight_th","text":"[Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [th (0\\~255) ] > /proc/videograph/vpe/sharpen/edge_weight_th edge_weight_th Read : cat /proc/videograph/vpe/sharpen/edge_weight_th Output :","title":"\uf06c /proc/videograph/vpe/sharpen/edge_weight_th"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpesharpenblend_inv_gamma","text":"[Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [th (0\\~128) ] > /proc/videograph/vpe/sharpen/blend_inv_gamma blend_inv_gamma Read : cat /proc/videograph/vpe/sharpen/blend_inv_gamma Output : ![\u6587\u5b57\u65b9\u584a: Command : echo th (0\\~128) > /proc/videograph/vpe/sharpen/blend_inv_gamma =============================================================== blend_inv_gamma = blend_inv_gamma","title":"\uf06c /proc/videograph/vpe/sharpen/blend_inv_gamma"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpesharpenedge_sharp_str","text":"[Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [str1 (0\\~255)] [str2 (0\\~255)] > /proc/videograph/vpe/sharpen/edge_sharp_str edge_sharp_str1 edge_sharp_str2 Read : cat /proc/videograph/vpe/sharpen/edge_sharp_str Output :","title":"\uf06c /proc/videograph/vpe/sharpen/edge_sharp_str"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpesharpenflat_sharp_str","text":"[Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [str (0\\~255)] > /proc/videograph/vpe/sharpen/flat_sharp_str flat_sharp_str Read : cat /proc/videograph/vpe/sharpen/flat_sharp_str Output :","title":"\uf06c /proc/videograph/vpe/sharpen/flat_sharp_str"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpesharpencoring_th","text":"[Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [coring_th (0\\~255)] > /proc/videograph/vpe/sharpen/coring_th coring_th Read : cat /proc/videograph/vpe/sharpen/coring_th Output :","title":"\uf06c /proc/videograph/vpe/sharpen/coring_th"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpesharpenhalo_clip","text":"[Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [bright_clip (0\\~128)] [dark_clip(0\\~128)] > /proc/videograph/vpe/sharpen/halo_clip bright_halo_clip drak_halo_clip Read : cat /proc/videograph/vpe/sharpen/halo_clip Output :","title":"\uf06c /proc/videograph/vpe/sharpen/halo_clip"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpesharpennoise_curve","text":"[Description] Read or write the sharpen parameter of the current channel. [Command] Write : proc command Target Parameter echo [noise_curve[0] (0\\~255)]\u2026. [noise_curve [16] (0\\~255)] > /proc/videograph/vpe/sharpen/noise_curve noise_curve[17] Read : cat /proc/videograph/vpe/sharpen/noise_curve Output :","title":"\uf06c /proc/videograph/vpe/sharpen/noise_curve"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#522-vendor-api","text":"[Description] Get and set the sharpen parameters corresponding to current path_id. [Command] Get\uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_SHARP, VENDOR_VIDEO_PARAM_SHARP *p_param); Set\uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_SHARP, VENDOR_VIDEO_PARAM_SHARP *p_param); [\u5b9a\u7fa9]","title":"5.2.2 Vendor API"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#6-edge-smoothing-es","text":"This module is edge smoothing. The main function is to eliminate aliasing in the picture to improve the smoothness of the picture.","title":"6 Edge Smoothing (ES)"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#61-overview","text":"The characteristics of this algorithm are to effectively smooth the edges of the input image, correct the jaggedness in the edge area of the input image, and avoid the Sharpen module to enhance the degree of jaggedness in the image edge again. The algorithm divides the input image into edge area and detail area, calculates the direction of the edge on the edge area, and then performs LPF convolution adaptively along the edge direction to smooth the edge of the image. The Edge Mask can be adjusted to avoid high-frequency areas being blurred due to smoothing. Please refer to the following figure for the main process:","title":"6.1 Overview"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#62-parameter-description","text":"Table 61 ES Parameter List Parameter Range Def Description edge_smooth_en 0\\~1 0 Edge smooth enable edge_smooth_y_edeng_th_lo 0\\~255 10 Adjust the strength threshold of detail areas in the picture Please refer to the advanced instructions edge_smooth_y_edeng_th_hi 0\\~255 70 Adjust the strength threshold of the edge area in the picture Please refer to the advanced instructions edge_smooth_y_ew_lo 0\\~255 2 Adjust the smoothing strength weight of detail areas in the picture Please refer to the advanced instructions edge_smooth_y_ew_hi 0\\~255 32 Adjust the suppression threshold for the smoothing of high-frequency areas in the picture. The larger the value, the easier it is to determine and smooth the high-frequency area. Therefore, the larger the value, the smoother the high-frequency area, and the smaller the value, the clearer the high-frequency area edge_smooth_y_edi_th 0\\~63 31 Suppresses the strength of smoothing in the high-frequency region. The larger the value, the stronger the smoothing in the high-frequency region. edge_smooth_y_ds_str 0\\~7 5 Adjust the strength of the smoothing filter in the picture. The larger the value, the stronger the smoothing degree. Advance description: \uf06c edge_smooth_y_edeng_th_lo, edge_smooth_y_edeng_th_hi, edge_smooth_y_ew_lo, edge_smooth_y_ew_hi: The strength of edge smooth is controlled by the edge energy intensity of the input image, where edge_smooth_y_edeng_th_hi and edge_smooth_y_edeng_th_lo are the ranges that set the edge area and the detail area, and edge_smooth_y_ew_hi and edge_smooth_y_ew_lo set the smoothness strength of the edge area and detail area. The larger the number, the stronger of the smoothness. The relationship between the edge area and the detail area is a continuous linear change, and the corresponding relationship is shown in the following figure:","title":"6.2 Parameter Description"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#63-setting-interface","text":"","title":"6.3 Setting Interface"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#631-proc","text":"","title":"6.3.1 Proc"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpeesparam","text":"[Description] Read all edge smoothing parameters of the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/es/param","title":"\uf06c /proc/videograph/vpe/es/param"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpeesedge_smooth_en","text":"[Description] Set the edge smooth switch of the current camera channel. [Command] Write : proc command Target Parameter echo [edge_smooth_en (0\\~1)] > /proc/videograph/vpe/es/edge_smooth_en edge_smooth_en","title":"\uf06c /proc/videograph/vpe/es/edge_smooth_en"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpeesedge_smooth_out_sel","text":"[Description] Set the edge smooth debugging switch of the current camera channel. [Command] Write : proc command Target Parameter echo [edge_smooth_out_sel (0\\~1)] > /proc/videograph/vpe/es/edge_smooth_out_sel edge_smooth_out_sel Read : cat /proc/videograph/vpe/es/edge_smooth_out_sel Output :","title":"\uf06c /proc/videograph/vpe/es/edge_smooth_out_sel"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpeesedge_smooth_th","text":"[Description] Set the edge smooth related threshold of the current camera channel. [Command] Write : proc command Target Parameter echo [y_edeng_th_lo (0\\~255)] [y_edeng_th_hi (0\\~255)] [y_ew_lo (0\\~255)] [y_ew_hi (0\\~255)] > /proc/videograph/vpe/es/edge_smooth_th edge_smooth_y_edeng_th_l edge_smooth_y_edeng_th_hi edge_smooth_y_ew_lo edge_smooth_y_ew_hi Read : cat /proc/videograph/vpe/es/edge_smooth_th Output :","title":"\uf06c /proc/videograph/vpe/es/edge_smooth_th"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpeesedge_smooth_y_edi_th","text":"[Description] Set the edge smooth mask related parameters of the current camera channel. [Command] Write : proc command Target Parameter echo [edge_smooth_y_edi_th (0\\~63)] > /proc/videograph/vpe/es/edge_smooth_y_edi_th edge_smooth_y_edi_th Read : cat /proc/videograph/vpe/es/edge_smooth_y_edi_th Output :","title":"\uf06c /proc/videograph/vpe/es/edge_smooth_y_edi_th"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpeesedge_smooth_y_ds_str","text":"[Description] Sets the filter strength of the edge smooth of the current camera channel. [Command] Write : proc command Target Parameter echo [edge_smooth_y_ds_str (0\\~7)] > /proc/videograph/vpe/es/edge_smooth_y_ds_str edge_smooth_y_ds_str Read : cat /proc/videograph/vpe/es/edge_smooth_y_ds_str Output :","title":"\uf06c /proc/videograph/vpe/es/edge_smooth_y_ds_str"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#632-vendor-api","text":"[Description] Get and set the edge smooth parameters corresponding to current path_id. [Command] Get\uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_EDGE_SMOOTH, VENDOR_VIDEO_PARAM_SHARP *p_param); Set\uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_EDGE_SMOOTH, VENDOR_VIDEO_PARAM_SHARP *p_param); [Definition]","title":"6.3.2 Vendor API"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#7-scaling-sca","text":"Inupt/Output low pass filter process with different resolution. The recommend maximum scaling down ratio is 8, and the recommend maximum scaling up ratio is 8.","title":"7 Scaling (SCA)"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#71-overview","text":"This is image scaling module, the major concept is interpolation and smooth process.","title":"7.1 Overview"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#72-parameter-description","text":"Table 71 SCA Parameter List Parameter Range Def Description sca_y_luma_algo_en 0\\~3 0 Algorithm select for vertical luma scaler. 0: judge by HW algorithm 1: select the nearest point on the left side 2: select the left side point and perform low pass filter process 3: the same as option 0 It is recommend to set 0. sca_x_luma_algo_en 0\\~3 0 Algorithm select for horizontal luma scaler. 0: judge by HW algorithm 1: select the nearest point on the left side 2: select the left side point and perform low pass filter process 3: the same as option 0 It is recommend to set 0. sca_y_chroma_algo_en 0\\~3 0 Algorithm select for vertical chroma scaler. 0: judge by HW algorithm 1: select the nearest point on the left side 2: bilinear interpolation 3: average It is recommend to set 0. sca_x_chroma_algo_en 0\\~3 0 Algorithm select for horizontal chroma scaler. 0: judge by HW algorithm 1: select the nearest point on the left side 2: bilinear interpolation 3: average It is recommend to set 0. sca_map_sel 0\\~1 0 Select scaler source mapping format. 0: without 0.5 pixel distance shift(start from the 0th pixel of image image) 1: with 0.5 pixel distance shift(start from the 0.5th pixel of image image) If set to 1, when the size of input image and output image is the same or the size is multiple of 2, the scaling performance of output image will similar to perform low pass filter. It is recommend to set 0. sca_ceffH_0\\~3 -128\\~127 [0, 0, 0, 64] LPF coefficient in horizontal direction. Please refer to advance description. \u203bThe software limit range is between -128\\~127, to reduce memory usage. sca_ceffv_0\\~3 -128\\~127 [0, 0, 0, 64] LPF coefficient in vertical direction. Please refer to advance description. \u203bThe software limit range is between -128\\~127, to reduce memory usage. des_drt 0, 2,3 0 YUV domain transform 0: bypass 2: PC level to TV level (Y: 16\\~235 / C:16\\~240) 3: TV level to PC level (Y: 0\\~235 C:0\\~255) 255: decide by job parameter of AP rather than driver (default value is 255, other settings are used for debug) Advance description: \uf06c sca_ceffH_0\\~3, sca_ceffV_0\\~3: LPF coefficients in horizontal direction and vertical direction. User can adjust LPF coefficients to fine tune sawtooth phenomenon in oblique line caused by scaling. Table 72 Scaler Low pass filter default parameter list Scaling Ratio (R) HCoef0 HCoef1 HCoef2 HCoef3 VCoef0 VCoef1 VCoef2 VCoef3 \u2267 1x 0 0 0 64 0 0 0 64 1 \\< R \u2266 1.25x 0 0 3 58 0 0 3 58 1.25 \\< R \u2266 1.5x 0 0 7 50 0 0 7 50 1.5 \\< R \u2266 1.75x 0 0 11 42 0 0 11 42 1.75 \\< R \u2266 2x 0 1 13 36 0 1 13 36 2 \\< R \u2266 2.25x 0 1 15 32 0 1 15 32 2.25 \\< R \u2266 2.5x 0 2 15 30 0 2 15 30 2.5 \\< R \u2266 2.75x 0 3 15 28 0 3 15 28 2.75 \\< R \u2266 3x 0 4 15 26 0 4 15 26 3 \\< R \u2266 3.25x 1 4 15 24 1 4 15 24 3.25 \\< R \u2266 3.5x 1 5 15 22 1 5 15 22 3.5 \\< R \u2266 3.75x 2 7 14 18 2 7 14 18 3.75 \\< R \u2266 4x 3 8 13 16 3 8 13 16 4 \\< R \u2266 5x 4 8 13 14 4 8 13 14 5 \\< R \u2266 6x 4 9 12 14 4 9 12 14 6x \\< R \u2266 7x 6 9 11 12 6 9 11 12 7x \\< R 6 9 11 12 6 9 11 12","title":"7.2 Parameter Description"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#73-setting-interface","text":"","title":"7.3 Setting Interface"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#731-proc","text":"","title":"7.3.1 Proc"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpescaparam","text":"[Description] Read all SCA parameters of the cuurent scaling ratio [Command] Write : Not support. Read : cat /proc/videograph/vpe/sca/param","title":"\uf06c /proc/videograph/vpe/sca/param"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpescactrl_param","text":"[Description] Set SCA controlling parameter for specific ratio. [Command] Write : proc command Target Parameter echo [sca_luma_algo (0\\~3)] [sca_chroma_algo (0\\~3)] [sca_map_sel (0\\~1)] > /proc/videograph/vpe/sca/ctrl_param index: Target ratio The command \u201csca_luma_algo\u201d set parameters \u201csca_y_luma_algo_en\u201d and \u201csca_x_luma_algo_en\u201d at the same time. The command \u201csca_chroma_algo\u201d set parameters \u201csca_y_chroma_algo_en\u201d and \u201csca_x_chroma_algo_en\u201d at the same time. The command \u201csca_map_sel\u201d set \u201csca_map_sel\u201d parameter. Read : Not support","title":"\uf06c /proc/videograph/vpe/sca/ctrl_param"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpescalpf_param","text":"[Description] Set SCA low pass filter parameter for specific ratio. [Command] Write : proc command Target Parameter echo [index (0\\~16)] [coeffH[0]] [coeffH[1]] [coeffH[2]] ]coeffH[3]] [coeffV[0]] [coeffV[1]] [coeffV[2]] [coeffV[3]] (-128 \\~ 127) > /proc/videograph/vpe/sca/lpf_param index: Target ratio coeffH : sca_ceffH[4] coeffV: sca_ceffV[4] \u203bThe software limit range is between -128\\~127, to reduce memory usage. Read : Not support","title":"\uf06c /proc/videograph/vpe/sca/lpf_param"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpescayuv_range","text":"[Description] Read or write YUV range of SCA at each one of the channel. \u203bParameter can be set by put job of AP depends on channel requests, it is not recommend to be set by this proc command or ioctl to avoid conflicts. This command is used for debugging. [Command] Write : proc command Target Parameter echo [fd range] > /proc/videograph/vpe/sca /yuv_range yuv_range: 0, 2, 3, 255 (disable) \u203bdisable represent AP directly control parameters des_drt Read : cat /proc/videograph/vpe/sca/yuv_range Output :","title":"\uf06c /proc/videograph/vpe/sca/yuv_range"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#732-vendor-api","text":"[Description] Get and set the scaling parameters corresponding to current path_id. [Command] Get\uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEO_SCA, VENDOR_VIDEO_PARAM_SCA_SET *p_param); Set\uff1a HD_RESULT vendor_video_set(HD_PATH_ID path_id, VENDOR_VIDEO_SCA, VENDOR_VIDEO_PARAM_SCA_SET *p_param); [Definition] typedef struct _VENDOR_VIDEO_PARMA_SCA_CTRL { INT32 sca_ceffH[4]; ///\\< LPF coefficient in horizontal direction INT32 sca_ceffV[4]; ///\\< LPF coefficient in vertical direction } VENDOR_VIDEO_PARMA_SCA_CTRL; typedef struct _VENDOR_VIDEO_PARAM_SCA_SET { UINT8 sca_y_luma_algo_en; ///\\< Algorithm select for vertical luma scaler UINT8 sca_x_luma_algo_en; ///\\< Algorithm select for horizontal luma scaler UINT8 sca_y_chroma_algo_en; ///\\< Algorithm select for vertical chroma scaler UINT8 sca_x_chroma_algo_en; ///\\< Algorithm select for horizontal chroma scaler UINT8 sca_map_sel; ///\\< Scaler source mapping format select VENDOR_VIDEO_PARMA_SCA_CTRL sca_1000x_param; ///\\< scaling parameter for scaling ratio 1.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_1250x_param; ///\\< scaling parameter for scaling ratio 1.25x VENDOR_VIDEO_PARMA_SCA_CTRL sca_1500x_param; ///\\< scaling parameter for scaling ratio 1.50x VENDOR_VIDEO_PARMA_SCA_CTRL sca_1750x_param; ///\\< scaling parameter for scaling ratio 1.75x VENDOR_VIDEO_PARMA_SCA_CTRL sca_2000x_param; ///\\< scaling parameter for scaling ratio 2.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_2250x_param; ///\\< scaling parameter for scaling ratio 2.25x VENDOR_VIDEO_PARMA_SCA_CTRL sca_2500x_param; ///\\< scaling parameter for scaling ratio 2.50x VENDOR_VIDEO_PARMA_SCA_CTRL sca_2750x_param; ///\\< scaling parameter for scaling ratio 2.75x VENDOR_VIDEO_PARMA_SCA_CTRL sca_3000x_param; ///\\< scaling parameter for scaling ratio 3.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_3250x_param; ///\\< scaling parameter for scaling ratio 3.25x VENDOR_VIDEO_PARMA_SCA_CTRL sca_3500x_param; ///\\< scaling parameter for scaling ratio 3.50x VENDOR_VIDEO_PARMA_SCA_CTRL sca_3750x_param; ///\\< scaling parameter for scaling ratio 3.75x VENDOR_VIDEO_PARMA_SCA_CTRL sca_4000x_param; ///\\< scaling parameter for scaling ratio 4.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_5000x_param; ///\\< scaling parameter for scaling ratio 5.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_6000x_param; ///\\< scaling parameter for scaling ratio 6.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_7000x_param; ///\\< scaling parameter for scaling ratio 7.00x VENDOR_VIDEO_PARMA_SCA_CTRL sca_8000x_param; ///\\< scaling parameter for scaling ratio 8.00x } VENDOR_VIDEO_PARAM_SCA_SET;","title":"7.3.2 Vendor API"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#8-distortion-correction-engine-dce","text":"","title":"8 Distortion Correction Engine (DCE)"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#81-overview","text":"This is lens distortion calibration module, it can perform calibration on wide-angle lens and fish-eye lens.","title":"8.1 Overview"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#82-dce-parameter-description","text":"Table 81 DCE Parameter List Parameter Range Def Description dce_mode 0\\~1 0 Select distortion function 0: GDC lens calibration 1: 2DLUT self-define XY coordinate distortion lut2d_sz 0\\~5 0 Size selection of 2D look-up table. The larger the size, the more precision to describe distortion. 0: 9x9 3: 65x65 4: 129x129 5: 257x257 lsb_rand 0\\~1 0 LSB 2 bit random generation for internal 10 bit->8 bit image. 0: fixed fill 0 1: random generate 0\\~3 fovbound 0\\~1 0 FOV boundary process method selection. When the distortion result can not fill the total output image, select different way to proceed the exceed range. 0: Replace out of boundary pixels with duplicate nearest pixel 1: Replace out of boundary pixels with bound pixels boundy 0\\~1023 0 Bound value for Y component(u8.2) boundu 0\\~1023 0 Bound value for U component(u8.2) boundv 0\\~1023 0 Bound value for V component(u8.2) cent_x_s 213-1 0 Define lens center of x-axis. It is recommend to set width/2. cent_y_s 213-1 0 Define lens center of y-axis. It is recommend to set height/2. xdist 0\\~4095 0 X input distance factor, for oval shape modeling. It is recommend to set 4095, which is suitable for most situation. ydist 0\\~4095 0 Y input distance factor, for oval shape modeling. It is recommend to set 4095, which is suitable for most situation. geo_lut 0\\~65535 0 The GEO deformation gain table, a total of 65 points, indicates the magnification of each pixel in the image at a different distance from the deformation center (magnification = 65535 * input radius / output radius), the gainbase is 65535, please refer to Note 2 for the gain table example. Value range\uff1a[0, 65535]\u3002 normfact 0\\~255 128 Radius normalization factor. Normfact = 1 \\<\\< (normbit + 7) / R2 normbit 0\\~31 31 Radius normalization shift bit. R2 = (width/2)2+(height/2)2 The total bit number of R2 is normbit. Example: 9602+5402 = 1213200 (21 bits) fovgain 0\\~4095 0 Adjust the scaling ratio of the final distortion coordinate to preserve FOV. Scale down factor for FOV preservation. Due to it will effect the calibration performance, it is recommend to set 1024. hfact 0 \\~ 224 -1 0 Horizontal scaling factor for 2DLut scaling up(u0.24). ((2DLUT horizontal pixel number \u2013 1) \\<\\< 24) / (width \u2013 1) vfact 0 \\~ 224 -1 0 Vertical scaling factor for 2DLut scaling up(u0.24). ((2DLUT vertical pixel number \u2013 1) \\<\\< 24) / (height \u2013 1) xofs_i 0\\~127 0 2DLut x offset, integer part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. xofs_f 0\\~224-1 0 2DLut x offset, fraction part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. yofs_i 0\\~127 0 2DLut y offset, integer part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. yofs_f 0\\~224-1 0 2DLut y offset, fraction part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. [Note 1] Adjust geo_fov_gain, the left side is 1024, the right side is 1320, you can observe the increase in the field of view on the right side. [Note 2] The example of the GEO deformation gain table, from left to right, corresponds to the deformation amount from the center of the image to the edge. This parameter group indicates that the larger the deformation amount toward the edge is. This example is a barrel deformation correction. R is the distance from the center of the image to each point. This distance can be understood as the radius of the circle. Ri represents the radius of each point of the input (before correction) image. Ro represents the radius of each point of the output (corrected) image. RoMax represents the longest distance from the center of the output image to the four corners. If the center of the image falls at 1/2 of the width and height, the four corners are all equal, and they are the longest distances.","title":"8.2 DCE Parameter Description"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#83-setting-interface","text":"","title":"8.3 Setting Interface"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#831-proc","text":"","title":"8.3.1 Proc"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpedcedump_info","text":"[Description] Read all DCE parameters at the current camera channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/dce/dump_info dce_en = 0 dce_mode = 1 lut2d_sz = 3 lut2d_vaddr = 0x0000000000000000 lut2d_paddr = 0x0 lsb_rand = 0 fovbound = 1 boundy = 512 boundu = 512 boundv = 512 cent_x_s = 720 cent_y_s = 720 xdist = 4095 ydist = 4095 normfact = 0 normbit = 0 fovgain = 1024 hfact = 745654 vfact = 745654 xofs_i = 0 xofs_f = 0 yofs_i = 0 yofs_f = 0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0 geo_lut[i]=0","title":"\uf06c /proc/videograph/vpe/dce/dump_info"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpedcech_en","text":"[Description] Read or write the enable status of the current channel. [Command] Write : proc command Target Parameter echo [ dc_en 0\\~1 ] > /proc/videograph/vpe/dce/ch_en dc_en Read : cat /proc/videograph/vpe/dce/ch_en Output : dc_en = 0","title":"\uf06c /proc/videograph/vpe/dce/ch_en"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#832-vendor-api","text":"[Description] Get and set the dce parameters corresponding to current path_id. [Command] Get\uff1a HD_RESULT vendor_video_get(HD_PATH_ID path_id, VENDOR_VIDEOPROC_DEWARP_INFO, VENDOR_DEWARP_INFO *p_param); Set\uff1a HD_RESULT c(HD_PATH_ID path_id, VENDOR_ VENDOR_VIDEOPROC_DEWARP_INFO, VENDOR_DEWARP_INFO *p_param); [Define] typedef struct _VENDOR_DEWARP_CTRL { BOOL dc_enable; BOOL dctg_enable; } VENDOR_DEWARP_CTRL; typedef enum _VENDOR_DEWARP_MODE { VENDOR_DEWARP_DEWARP_MODE_GDC = 0, VENDOR_DEWARP_DEWARP_MODE_2DLUT = 1, ENUM_DUMMY4WORD(VENDOR_DEWARP_DEWARP_MODE) } VENDOR_DEWARP_MODE; typedef struct _VENDOR_DEWARP_DGC_PARM { INT32 cent_x_s; ///\\< Lens center of x axis (signed) INT32 cent_y_s; ///\\< Lens center of y axis (signed) UINT32 lens_r; ///\\< Radius of Lens UINT32 xdist; ///\\< X input distance factor, for oval shape modeling UINT32 ydist; ///\\< Y input distance factor, for oval shape modeling UINT8 normfact; ///\\< Radius normalization factor (u1.7) UINT8 normbit; ///\\< Radius normalization shift bit UINT16 geo_lut[VENDOR_GEO_LUT_X]; ///\\< GDC look-up table } VENDOR_DEWARP_DGC_PARM; typedef struct _VENDOR_DEWARP_2DLUT_PARM { UINT8 lut2d_sz; ///\\< Size selection of 2D look-up table, 0:9x9, 3:65x65 UINT32 hfact; ///\\< Horizontal scaling factor for 2DLut scaling up (u0.24) UINT32 vfact; ///\\< Vertical scaling factor for 2DLut scaling up (u0.24) UINT8 xofs_i; ///\\< 2DLUT x offset, integer part UINT32 xofs_f; ///\\< 2DLUT x offset, fraction part UINT8 yofs_i; ///\\< 2DLUT y offset, integer part UINT32 yofs_f; ///\\< 2DLUT xy offset, fraction part } VENDOR_DEWARP_2DLUT_PARM; typedef struct _VENDOR_DEWARP_FOV_PARM { UINT8 fovbound; ///\\< FOV boundary process method selection UINT16 boundy; ///\\< Bound value for Y component (u8.2) UINT16 boundu; ///\\< Bound value for U component (u8.2) UINT16 boundv; ///\\< Bound value for V component (u8.2) UINT16 fovgain; ///\\< Scale down factor for FOV preservation (u2.10) } VENDOR_DEWARP_FOV_PARM; typedef struct _VENDOR_DEWARP_INFO { VENDOR_DEWARP_MODE mode; VENDOR_DEWARP_DGC_PARM dgc; VENDOR_DEWARP_2DLUT_PARM lut2d; VENDOR_DEWARP_FOV_PARM fov; } VENDOR_DEWARP_INFO; typedef struct _VENDOR_DEWARP_2DLUT_TABLE { UINT32 tbl[VENDOR_GEO_LUT]; } VENDOR_DEWARP_2DLUT_TABLE;","title":"8.3.2 Vendor API"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#9-dc-table-generatordctg","text":"","title":"9 DC Table Generator(DCTG)"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#91-overview","text":"For perspective projection application, in order to increase the convenience of usage, DCTG module let user to set the desired angle and size with an instinct way to generate DCTG parameters automatically. Whenever this function is enabled, manual set DCE 2D-LUT function will be invalid. [Note] When using DCTG function, user needs to set two parameters enable, one is dc_enable, the other is dctg_en. Please refer to the following description: The \u201ctheta\u201d is the top/bottom angle. The \u201cphi\u201d is the rotate angle. The \u201crot_y\u201d is the rotate offset of (x, z) plane towards Y-axis. The \u201crot_z\u201d is the rotate offset of (x, y) plane towards Z-axis. Generate LUT: Define the rotate angle of FOV by phi_st/phi_ed, and then rotate to FOV location by rot_y. Define the top/bottom angle of FOV by theta_st/theta_ed, and then rotate to FOV location by rot_z.","title":"9.1 Overview"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#92-parameter-description","text":"Table 91 DCTG parameter list Parameter Range Def Description dctg_en 0-1 0 DCTG ON/OFF mount_type 0\\~1 0 Camera mount type. 0: Ceiling mount 1: Floor mount lut2d_sz 0, 3 3 Select size of 2D look-up table, this parameter must the same with DCE parameter. 0: 9x9 3: 65x65 lens_r 0\\~215-1 0 Valid radius of fish-eye lens, the unit is pixel. Please refer to advance description. lens_x_st 0\\~214-1 0 The start x position of fish-eye lens at the source image, the unit is pixel. lens_y_st 0\\~214-1 0 The start y position of fish-eye lens at the source image, the unit is pixel. theta_st -180 \\~ 180 (-*pi \\~ *pi) 0 FOV theta start radian. theta_ed -180 \\~ 180 (-*pi \\~ *pi) 0 FOV theta end radian. theta_end > theta_st: normal image theta_end \\< theta_st: flip image phi_st -360 \\~ 360 (-2*pi \\~ 2*pi) 0 OV phi start radian. phi_ed -360 \\~ 360 (-2*pi \\~ 2*pi) 0 FOV phi end radian. (-2*pi \\~ 2*pi) phi_end > theta_st: normal image phi_end \\< theta_st: flip image rot_z -360 \\~ 360 (-2*pi \\~ 2*pi) 0 Z-axis rotate radian rot_y -360 \\~ 360 (-2*pi \\~ 2*pi) 0 Y-zxis rotate radian. Advance description: \uf06c lens_r: The valid radius of fish-eye device. \uf06c lens_x_st : The start x position of fish-eye lens at the source image, the unit is pixel. \uf06c lens_y_st : The start y position of fish-eye lens at the source image, the unit is pixel.","title":"9.2 Parameter Description"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#93-setting-interface","text":"","title":"9.3 Setting Interface"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#931-proc","text":"","title":"9.3.1 Proc"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpedctgdump_info","text":"[Description] Read all dctg parameters of the current channel. [Command] Write : Not support. Read : cat /proc/videograph/vpe/dctg/dump_info fd(0x00000000) dctg_en = 0 mount_type = 1 lut2d_sz = 3 lens_r = 540 lens_x_st = 0(0) lens_y_st = 0(0) theta_st = 45(51471) theda_ed = 90(102943) phi_st = -40(-45753) phi_ed = 40(45752) rot_z = 0 rot_y = 0","title":"\uf06c /proc/videograph/vpe/dctg/dump_info"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpedctgch_en","text":"[Description] Set dctg enable. [Command] Write : proc command Target Parameter echo [dctg_en] > /proc/videograph/vpe/dctg/ch_en dctg_en: dctg enable Read : cat /proc/videograph/vpe/dctg/ch_en Output : dctg_en = 1","title":"\uf06c /proc/videograph/vpe/dctg/ch_en"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpedctgphi","text":"[Description] Set FOV phi start radian [Command] Write : proc command Target Parameter echo [st] [ed] > /proc/videograph/vpe/dctg/phi st: FOV phi start radian ed : FOV phi end radian \u203bangle range: -360 \\~ 360 Read : cat /proc/videograph/vpe/dctg/phi Output : echo \\<st> \\<ed> (range -360\\~360) phi_st degree= -40 phi_ed degree = 40","title":"\uf06c /proc/videograph/vpe/dctg/phi"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpedctgrot","text":"[Description] Set Z-axis and Y-zxis rotate radian. [Command] Write : proc command Target Parameter echo [z] [y] > /prc/videograph/vpe/dctg/rot z: Z-axis rotate radian. y: Y-zxis rotate radian \u203bangle range: -360 \\~ 360 Read : cat /proc/videograph/vpe/dctg/rot Output : echo \\<z> \\<y> (range -360\\~360) rot_z degree = 0 rot_y degree = 0","title":"\uf06c /proc/videograph/vpe/dctg/rot"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#procvideographvpedctgtheta","text":"[Description] Set FOV theta start radian. [Command] Write : proc command \u76ee\u6a19\u53c3\u6578 echo [st] [ed] > /prc/videograph/vpe/dctg/theta st: FOV theta start radian. ed : FOV theta end radian \u203bangle range: -180 \\~ 180 Read : cat /proc/videograph/vpe/dctg/theta Output : echo \\<st> \\<ed> (range -180\\~180) theta_st degree = 45 theda_ed degree = 90","title":"\uf06c /proc/videograph/vpe/dctg/theta"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#932-vendor-api","text":"[Description] Get and set the dctg parameters corresponding to current path_id. [Command] Get\uff1a HD_RESULT vendor_videoproc_get(HD_PATH_ID path_id, VENDOR_VIDEOPROC_DEWARP_DCTG_INFO, VENDOR_DEWARP_DCTG_INFO *p_param); Set\uff1a HD_RESULT vendor_videoproc_set(HD_PATH_ID path_id, VENDOR_VIDEOPROC_DEWARP_DCTG_INFO, VENDOR_DEWARP_DCTG_INFO *p_param); [Define] typedef struct _VENDOR_DEWARP_CTRL { BOOL dc_enable; BOOL dctg_enable; } VENDOR_DEWARP_CTRL; typedef struct _VENDOR_DEWARP_DCTG_INFO { VENDOR_DEWARP_DCTG_MODE mode; VENDOR_DEWARP_DCTG_LENS_PARM lens; VENDOR_DEWARP_DCTG_FOV_PARM fov; } VENDOR_DEWARP_DCTG_INFO; typedef enum _VENDOR_DEWARP_DCTG_MODE { VENDOR_DEWARP_DCTG_MODE_90 = 0, VENDOR_DEWARP_DCTG_MODE_360 = 1, ENUM_DUMMY4WORD(VENDOR_DEWARP_DCTG_MODE) } VENDOR_DEWARP_DCTG_MODE; typedef struct _VENDOR_DEWARP_DCTG_LENS_PARM { UINT8 mount_type; ///\\< Camera mount type. 0:Ceiling mount, 1:Floor mount UINT8 lut2d_sz; ///\\< Size selection of 2D look-up table, 0:9x9, 3:65x65, should the same with DCE setting. UINT32 lens_r; ///\\< Radius of Lens UINT32 lens_x_st; ///\\< Lens start x position at a source image UINT32 lens_y_st; ///\\< Lens start y position at a source image } VENDOR_DEWARP_DCTG_LENS_PARM; typedef struct _VENDOR_DEWARP_DCTG_FOV_PARM { INT32 theta_st; ///\\< FOV theta start radian (s4.16) Range: -*pi \\~ *pi INT32 theta_ed; ///\\< FOV theta end radian (s4.16) Range: -*pi \\~ *pi INT32 phi_st; ///\\< FOV phi start radian (s4.16) Range: -2*pi \\~ 2*pi INT32 phi_ed; ///\\< FOV phi end radian (s4.16) Range: -2*pi \\~ 2*pi INT32 rot_z; ///\\< Z-axis rotate radian (s4.16) Range: -2*pi \\~ 2*pi INT32 rot_y; ///\\< Y-axis rotate radian (s4.16) Range: -2*pi \\~ 2*pi } VENDOR_DEWARP_DCTG_FOV_PARM;","title":"9.3.2 Vendor API"},{"location":"Software/ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html#10-revise-history","text":"Version Date Advisor Description 0.1.00 2021/01/20 Allen Hsu First version. 0.2.00 2021/3/26 Allen Hsu Add description of Vendor command. 0.3.00 2022/4/11 Mina Wang Add description for dce and dctg","title":"10 Revise History"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_ISP_Programming_Guide_en.html","text":"Introduction \u00b6 Vendor_ad Function Parameter IDs and data structure definition \u00b6 Function Definition \u00b6 vendor_ad_init \u00b6 [Description] Initialize the unit [Syntax] HD_RESULT vendor_ad_init(CHAR *ad_dev_name) [Parameter] Value Description ad_dev_name the ad device file name [Return Value] Value Description HD_OK Success HD_ERR_SYS Open ad device file failure vendor_ad_uninit \u00b6 [Description] Uninitialize the unit [Syntax] HD_RESULT vendor_ad_uninit(VOID) [Parameter] Value Description VOID Not available [Return Value] Value Description HD_OK Success HD_ERR_NG Failure vendor_ad_get \u00b6 [Description] Get parameters from ad unit [Syntax] HD_RESULT vendor_ad_get(VENDOR_AD_PARAM_ID id, void *p_param); [Parameter] Value Description id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter vendor_ad_set \u00b6 [Description] Not support Parameters IDs and data structure definition \u00b6 The function vendor_ad_get provides the following parameter IDs: VENDOR_AD_PARAM_TP28XX_DEVICE_INFO support get with tp28xx device info using VENDOR_AD_TP28XX_DEVICE_INFO struct VENDOR_AD_PARAM_TP28XX_DEVICE_NORM support get with tp28xx device norm using VENDOR_AD_TP28XX_DEVICE_NORM struct VENDOR_AD_PARAM_TP28XX_DEVICE_LOSS support get with tp28xx device loss using VENDOR_AD_TP28XX_DEVICE_LOSS struct VENDOR_AD_PARAM_NVP61XX_DEVICE_INFO support get with nvp61xx device info using VENDOR_AD_NVP61XX_DEVICE_INFO struct VENDOR_AD_PARAM_ NVP61XX_DEVICE_NORM support get with nvp61xx device norm using VENDOR_AD_ NVP61XX_DEVICE_NORM struct VENDOR_AD_PARAM_NVP61XX_DEVICE_LOSS support get with nvp61xx device loss using VENDOR_AD_NVP61XX_DEVICE_LOSS struct VENDOR_AD_TP28XX_DEVICE_INFO \u00b6 [Description] Get tp28xx device information [Parameter] Value Description dev_num number of tp28xx device vout_mode chip video output port mode vout.xcap Backend X_CAP## => 0:None, 1\\~16:X_CAP#0\\~15 vout.vi Backend VI## => 0:None, 1\\~16: VI#0\\~15 vout.clk_dly Backend Video Port Clock Delay, 0 \\~ 0xff vout.clk_pdly Backend Video Port Clock Polarity Delay, 0 \\~ 0xff vout.clk_inv Backend Video Port Clock Inversion, 0:none 1:invertion vout.clk_pin Backend Video Port Clock Pin Selection, 0:pinmux#0 1:pinmux#1 vout.data_swap Backend Video Port Data Swap, 0:none 1:bit swap vin.active Device vin active, 0:no 1:yes vin.vch_id Device vin video channel index vin.vout Device vin video output port index vin.chip Backend chip index vin.vcap Backend vcap index of this chip vin.vi Backend vi index of this vcap vin.ch Backend ch index of this vi, vin grab via this vi channel VENDOR_AD_TP28XX_VIDEO_NORM \u00b6 [Description] Get tp28xx video norm [Parameter] Value Description dev_id device index vin_id device vin index src_width channel source width, video source width src_height channel source height, video source height src_fps channel source frame rate, must > 0 src_prog channel source progressive/interlace, 0:interlace 1:progressive out_width channel output width out_height channel output height out_fmt channel output format out_data_rate channel output data rate, for specify byte duplicate mode out_data_latch channel output data latch mode out_horiz_dup channel output horizontal pixel duplicate mode VENDOR_AD_TP28XX_VIDEO_LOSS \u00b6 [Description] Get tp28xx video loss [Parameter] Value Description chip device chip index ch channel index is_lost 1: is_lost, 0:present VENDOR_AD_NVP61XX_DEVICE_INFO \u00b6 [Description] Get nvp61xx device information [Parameter] Value Description dev_num number of nvp61xx device vout_mode chip video output port mode vout.xcap Backend X_CAP## => 0:None, 1\\~16:X_CAP#0\\~15 vout.vi Backend VI## => 0:None, 1\\~16: VI#0\\~15 vout.clk_dly Backend Video Port Clock Delay, 0 \\~ 0xff vout.clk_pdly Backend Video Port Clock Polarity Delay, 0 \\~ 0xff vout.clk_inv Backend Video Port Clock Inversion, 0:none 1:invertion vout.clk_pin Backend Video Port Clock Pin Selection, 0:pinmux#0 1:pinmux#1 vout.data_swap Backend Video Port Data Swap, 0:none 1:bit swap vin.active Device vin active, 0:no 1:yes vin.vch_id Device vin video channel index vin.vout Device vin video output port index vin.chip Backend chip index vin.vcap Backend vcap index of this chip vin.vi Backend vi index of this vcap vin.ch Backend ch index of this vi, vin grab via this vi channel VENDOR_AD_NVP61XX_VIDEO_NORM \u00b6 [Description] Get nvp61xx video norm [Parameter] Value Description dev_id device index vin_id device vin index src_width channel source width, video source width src_height channel source height, video source height src_fps channel source frame rate, must > 0 src_prog channel source progressive/interlace, 0:interlace 1:progressive out_width channel output width out_height channel output height out_fmt channel output format out_data_rate channel output data rate, for specify byte duplicate mode out_data_latch channel output data latch mode out_horiz_dup channel output horizontal pixel duplicate mode VENDOR_AD_NVP61XX_VIDEO_LOSS \u00b6 [Description] Get nvp61xx video loss [Parameter] Value Description chip device chip index ch channel index is_lost 1: is_lost, 0:present Vendor_video Function Parameter IDs and Data structure definition \u00b6 Please refer to document NT9833x_HDAL_Vendor_Media_Programming_Guide_en.doc. \u00b6","title":"Vendor ISP Programming Guide"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_ISP_Programming_Guide_en.html#introduction","text":"","title":"Introduction"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_ISP_Programming_Guide_en.html#vendor_ad-function-parameter-ids-and-data-structure-definition","text":"","title":"Vendor_ad Function Parameter IDs and data structure definition"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_ISP_Programming_Guide_en.html#function-definition","text":"","title":"Function Definition"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_ISP_Programming_Guide_en.html#vendor_ad_init","text":"[Description] Initialize the unit [Syntax] HD_RESULT vendor_ad_init(CHAR *ad_dev_name) [Parameter] Value Description ad_dev_name the ad device file name [Return Value] Value Description HD_OK Success HD_ERR_SYS Open ad device file failure","title":"vendor_ad_init"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_ISP_Programming_Guide_en.html#vendor_ad_uninit","text":"[Description] Uninitialize the unit [Syntax] HD_RESULT vendor_ad_uninit(VOID) [Parameter] Value Description VOID Not available [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"vendor_ad_uninit"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_ISP_Programming_Guide_en.html#vendor_ad_get","text":"[Description] Get parameters from ad unit [Syntax] HD_RESULT vendor_ad_get(VENDOR_AD_PARAM_ID id, void *p_param); [Parameter] Value Description id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter","title":"vendor_ad_get"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_ISP_Programming_Guide_en.html#vendor_ad_set","text":"[Description] Not support","title":"vendor_ad_set"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_ISP_Programming_Guide_en.html#parameters-ids-and-data-structure-definition","text":"The function vendor_ad_get provides the following parameter IDs: VENDOR_AD_PARAM_TP28XX_DEVICE_INFO support get with tp28xx device info using VENDOR_AD_TP28XX_DEVICE_INFO struct VENDOR_AD_PARAM_TP28XX_DEVICE_NORM support get with tp28xx device norm using VENDOR_AD_TP28XX_DEVICE_NORM struct VENDOR_AD_PARAM_TP28XX_DEVICE_LOSS support get with tp28xx device loss using VENDOR_AD_TP28XX_DEVICE_LOSS struct VENDOR_AD_PARAM_NVP61XX_DEVICE_INFO support get with nvp61xx device info using VENDOR_AD_NVP61XX_DEVICE_INFO struct VENDOR_AD_PARAM_ NVP61XX_DEVICE_NORM support get with nvp61xx device norm using VENDOR_AD_ NVP61XX_DEVICE_NORM struct VENDOR_AD_PARAM_NVP61XX_DEVICE_LOSS support get with nvp61xx device loss using VENDOR_AD_NVP61XX_DEVICE_LOSS struct","title":"Parameters IDs and data structure definition"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_ISP_Programming_Guide_en.html#vendor_ad_tp28xx_device_info","text":"[Description] Get tp28xx device information [Parameter] Value Description dev_num number of tp28xx device vout_mode chip video output port mode vout.xcap Backend X_CAP## => 0:None, 1\\~16:X_CAP#0\\~15 vout.vi Backend VI## => 0:None, 1\\~16: VI#0\\~15 vout.clk_dly Backend Video Port Clock Delay, 0 \\~ 0xff vout.clk_pdly Backend Video Port Clock Polarity Delay, 0 \\~ 0xff vout.clk_inv Backend Video Port Clock Inversion, 0:none 1:invertion vout.clk_pin Backend Video Port Clock Pin Selection, 0:pinmux#0 1:pinmux#1 vout.data_swap Backend Video Port Data Swap, 0:none 1:bit swap vin.active Device vin active, 0:no 1:yes vin.vch_id Device vin video channel index vin.vout Device vin video output port index vin.chip Backend chip index vin.vcap Backend vcap index of this chip vin.vi Backend vi index of this vcap vin.ch Backend ch index of this vi, vin grab via this vi channel","title":"VENDOR_AD_TP28XX_DEVICE_INFO"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_ISP_Programming_Guide_en.html#vendor_ad_tp28xx_video_norm","text":"[Description] Get tp28xx video norm [Parameter] Value Description dev_id device index vin_id device vin index src_width channel source width, video source width src_height channel source height, video source height src_fps channel source frame rate, must > 0 src_prog channel source progressive/interlace, 0:interlace 1:progressive out_width channel output width out_height channel output height out_fmt channel output format out_data_rate channel output data rate, for specify byte duplicate mode out_data_latch channel output data latch mode out_horiz_dup channel output horizontal pixel duplicate mode","title":"VENDOR_AD_TP28XX_VIDEO_NORM"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_ISP_Programming_Guide_en.html#vendor_ad_tp28xx_video_loss","text":"[Description] Get tp28xx video loss [Parameter] Value Description chip device chip index ch channel index is_lost 1: is_lost, 0:present","title":"VENDOR_AD_TP28XX_VIDEO_LOSS"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_ISP_Programming_Guide_en.html#vendor_ad_nvp61xx_device_info","text":"[Description] Get nvp61xx device information [Parameter] Value Description dev_num number of nvp61xx device vout_mode chip video output port mode vout.xcap Backend X_CAP## => 0:None, 1\\~16:X_CAP#0\\~15 vout.vi Backend VI## => 0:None, 1\\~16: VI#0\\~15 vout.clk_dly Backend Video Port Clock Delay, 0 \\~ 0xff vout.clk_pdly Backend Video Port Clock Polarity Delay, 0 \\~ 0xff vout.clk_inv Backend Video Port Clock Inversion, 0:none 1:invertion vout.clk_pin Backend Video Port Clock Pin Selection, 0:pinmux#0 1:pinmux#1 vout.data_swap Backend Video Port Data Swap, 0:none 1:bit swap vin.active Device vin active, 0:no 1:yes vin.vch_id Device vin video channel index vin.vout Device vin video output port index vin.chip Backend chip index vin.vcap Backend vcap index of this chip vin.vi Backend vi index of this vcap vin.ch Backend ch index of this vi, vin grab via this vi channel","title":"VENDOR_AD_NVP61XX_DEVICE_INFO"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_ISP_Programming_Guide_en.html#vendor_ad_nvp61xx_video_norm","text":"[Description] Get nvp61xx video norm [Parameter] Value Description dev_id device index vin_id device vin index src_width channel source width, video source width src_height channel source height, video source height src_fps channel source frame rate, must > 0 src_prog channel source progressive/interlace, 0:interlace 1:progressive out_width channel output width out_height channel output height out_fmt channel output format out_data_rate channel output data rate, for specify byte duplicate mode out_data_latch channel output data latch mode out_horiz_dup channel output horizontal pixel duplicate mode","title":"VENDOR_AD_NVP61XX_VIDEO_NORM"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_ISP_Programming_Guide_en.html#vendor_ad_nvp61xx_video_loss","text":"[Description] Get nvp61xx video loss [Parameter] Value Description chip device chip index ch channel index is_lost 1: is_lost, 0:present","title":"VENDOR_AD_NVP61XX_VIDEO_LOSS"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_ISP_Programming_Guide_en.html#vendor_video-function-parameter-ids-and-data-structure-definition","text":"Please refer to document NT9833x_HDAL_Vendor_Media_Programming_Guide_en.doc.","title":"Vendor_video Function Parameter IDs and Data structure definition"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_ISP_Programming_Guide_en.html#_1","text":"","title":""},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html","text":"Introduction \u00b6 Vendor API is an extended library for HDAL. Some features dedicated for the specific IC will not list in the HDAL API but in vendor API. Please refer to this document to know the detail. Parameter IDs and data structure definition \u00b6 Videocap None Videodec VENDOR_VIDEODEC_PARAM_JPEG_WORK_BUFFER support set/get with i/o path using VENDOR_VIDEODEC_JPEG_WORK_BUFFER struct VENDOR_VIDEODEC_PARAM_FREE_JPEG_WORK_BUFFER support set with i/o path using VENDOR_VIDEODEC_JPEG_WORK_BUFFER struct VENDOR_VIDEODEC_PARAM_SUB_YUV_RATIO support set/get with i/o path using VENDOR_VIDEODEC_SUB_YUV struct VENDOR_VIDEODEC_PARAM_QP_CONFIG support set/get with i/o path using VENDOR_VIDEODEC_QP_CONFIG struct VENDOR_VIDEODEC_PARAM_H26X_OUT support set/get with i/o path using VENDOR_VIDEODEC_H26X_OUT struct VENDOR_VIDEODEC_PARAM_SYSCAPS support get with i/o path using VENDOR_VIDEODEC_SYSCAPS struct Videoenc VENDOR_VIDEOENC_PARAM_OSG_SEL support get/set with i/o path using VENDOR_VIDEOENC_OSG struct VENDOR_VIDEOENC_PARAM_MIN_COMPRESS_RATIO support get/set with i/o path using VENDOR_VDOENC_MIN_COMPRESS_RATIO struct Videoout VENDOR_VIDEOOUT_PARAM_WRITEBACK support get/set with i/o path using VENDOR_VIDEOOUT_WRITEBACK struct VENDOR_VIDEOOUT_PARAM_WIN_LAYER_ATTR, support get/set with i/o path using VENDOR_VIDEOOUT_WIN_LAYER_ATTR struct VENDOR_VIDEOOUT_PARAM_MODE support get/set with i/o path using VENDOR_VIDEOOUT_MODE struct Videoprocess VENDOR_VIDEOPROC_STATUS support set with i/o path using VENDOR_VDOPROC_STATUS struct VENDOR_VIDEOPROC_USER_FLAG support set with i/o path using UINT32 struct VENDOR_VIDEOPROC_SUB_RATIO_THLD support set/get with i/o path using VENDOR_VDOPROC_SUB_RATIO_THLD struct VENDOR_VIDEOPROC_USR_INIT_FRAME support set with i/o path using VENDOR_VDOPROC_USR_INIT_FRAME_INFO struct Audioio VENDOR_UNDERRUN_CNT support get with i/o path using VENDOR_AUDIOIO_UNDERRUN_CONFIG struct VENDOR_AUDIOIO_PARAM_SYSCAPS support get with i/o path using VENDOR_AUDIOIO_PARAM_SYSCAPS struct VENDOR_AUDIOIO_STATUS support get with i/o path using VENDOR_AUDIOIO_STATUS struct VENDOR_AUDIOIO_INIT_CFG support set/get with i/o path using VENDOR_AUDIOIO_INIT_I2S_CFG struct VENDOR_AUDIOIO_AOUT_LB_DEV_ID support get with i/o path using VENDOR_AUDIOIO_AOUT_LB_DEV_INFO struct VENDOR_AUDIOIO_SYNC_TIME support set with i/o path using VENDOR_AUDIOIO_SYNC_TIME_INFO struct Videocap function and data structure definition \u00b6 Function: vendor_videocap_get \u00b6 [Description] Get parameters from unit by path id [Syntax] HD_RESULT vendor_videocap_get (HD_PATH_ID path_id, VENDOR_VIDEOENC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter Function: vendor_videocap_set \u00b6 [Description] Set parameters to unit by path id [Syntax] HD_RESULT vendor_videocap_set (HD_PATH_ID path_id, VENDOR_VIDEOENC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter Function: vendor_videocap_push_in_buf \u00b6 [Description] trigger mode: given a buffer to get yuv data out. flow mode: given an additional buffer to get yuv data out. (It will influence the already bound path.) It suggests that after 2 or more different buffers are pushed, then vendor_videocap_pull_out_buf starts to get done buffer. Note: There is another application to get yuv data out without given buffer, hd_videocap_pull_out_buf(). But, hd_videocap_release_out_buf() should be called to return yuv data buffer. [Syntax] HD_RESULT vendor_videocap_push_in_buf(HD_PATH_ID path_id, HD_VIDEO_FRAME* p_video_frame, INT32 wait_ms) [Parameter] Value Description path_id the path id p_video_frame settings for getting data, must including width/height/pxlfmt/physical address wait_ms mini-seconds to get callback result [Return Value] Value Description HD_OK Success HD_ERR_DEV Wrong device id HD_ERR_PARAM Wrong input settings HD_ERR_NOBUF Not enough buffer for outputting yuv data Function: vendor_videocap_pull_out_buf \u00b6 [Description] trigger mode: pull out the yuv data buffer. flow mode: pull out the yuv data buffer which is pushed-in by vendor_videocap_push_in_buf( ). [Syntax] HD_RESULT vendor_videocap_pull_out_buf(HD_PATH_ID path_id, HD_VIDEO_FRAME* p_video_frame, INT32 wait_ms) [Parameter] Value Description path_id the path id p_video_frame settings for getting data, must including width/height/pxlfmt/physical address wait_ms mini-seconds to get callback result [Return Value] Value Description HD_OK Success HD_ERR_DEV Wrong device id HD_ERR_PARAM Wrong input settings HD_ERR_TIMEDOUT Vcap module is still busy, need retry HD_ERR_SYS Vcap module is not ready HD_ERR_FAIL this job is failed from vcap driver Structure: VENDOR_VIDEOCAP_CROPCTRL_INFO \u00b6 [Description] Support an option to apply crop information. [Parameter] Value Description rect Crop rectangular, including x, y, w, h coord Background rectangular [Apply Require] open->set->get Structure: VENDOR_VIDEOCAP_SYSCAPS \u00b6 [Description] Get videocap system capability information through user-specified type/mode. [Parameter] Value Description wanted_pxlfmt [input] vcap out fmt min_dim [output] min width/height max_dim [output] max width/height crop_min_dim [output] min crop width/height output_align [output] alignment of width/height [Apply Require] open-> get Videodec function and data structure definition \u00b6 Function: vendor_videodec_get \u00b6 [Description] Get parameters from unit by path id [Syntax] HD_RESULT vendor_videodec_get (HD_PATH_ID path_id, VENDOR_VIDEODEC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter Function: vendor_videodec_set \u00b6 [Description] Set parameters to unit by path id [Syntax] HD_RESULT vendor_videodec_set (HD_PATH_ID path_id, VENDOR_VIDEODEC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter Structure: VENDOR_VIDEODEC_JPEG_WORK_BUFFER \u00b6 [Description] This function is not supported on NT9833x. Structure: VENDOR_VIDEODEC_FREE_JPEG_WORK_BUFFER \u00b6 [Description] This function is not supported on NT9833x. Structure: VENDOR_VIDEODEC_SUB_YUV \u00b6 [Description] Set/get videodec sub-yuv ratio. [Parameter] Value Description ratio Sub-yuv ratio [Apply Require] set / get Structure: VENDOR_VIDEODEC_QP_CONFIG \u00b6 [Description] Set/get videodec qp value configuration. [Parameter] Value Description qp_value Quantization parameter value [Apply Require] set / get Structure: VENDOR_VIDEODEC_H26X_OUT \u00b6 [Description] Set/get videodec H.26x output format configuration. [Parameter] Value Description first_out H.26x first output mode extra_out H.26x extra output mode [Apply Require] set / get Structure: VENDOR_VIDEODEC_SYSCAPS \u00b6 [Description] Get videodec system capability information through user-specified type/mode. [Parameter] Value Description usr_codec_type [user_input] user codec type to get system capabilitys usr_first_mode [user_input] user first output mode (compress / uncompress) usr_extra_mode [user_input] user extra output mode (compress / uncompress) first_align [output] first output buffer dimension alignment extra_align [output] extra output buffer dimension alignment first_pxlfmt [output] first output buffer pixel format extra_pxlfmt [output] extra output buffer pixel format min_dim [output] minimum dimension max_dim [output] maximum dimension [Apply Require] get Videoenc function and data structure definition \u00b6 Function: vendor_videoenc_get \u00b6 [Description] Get parameters from unit by path id [Syntax] HD_RESULT vendor_videoenc_get (HD_PATH_ID path_id, VENDOR_VIDEOENC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter Function: vendor_videoenc_set \u00b6 [Description] Set parameters to unit by path id [Syntax] HD_RESULT vendor_videoenc_set (HD_PATH_ID path_id, VENDOR_VIDEOENC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter Structure: VENDOR_VIDEOENC_OSG \u00b6 [Description] Support an option to choose internal or external OSG [Parameter] Value Description external_osg select which osg 1:3d osg 0:encode osg [Apply Require] stop -> close -> open -> set -> start Structure: VENDOR_VIDEOENC_MIN_COMPRESS_RATIO \u00b6 [Description] Set initial compress ratio for different QP [Parameter] Value Description codec_type select the codec by HD_VIDEO_CODEC type qp_ratio Set the qp ratio by VENDOR_VIDEOENC_QP_RATIO type [Apply Require] stop -> close -> open -> set -> start Structure: VENDOR_JPEGENC_PARAM_RATE_CONTROL \u00b6 [Description] JPEG rate control parameters [Parameter] Value Description Vbr_mode 0: CBR, 1: VBR, 2: FixQP base_qp Base qp value (range 1\\~100, not used when FixQP) min_quality Minimum quality (range 1\\~100, not used when FixQP) max_quality Maximum quality (range 1\\~100, not used when FixQP) bitrate bitrate (max 128M, not used when FixQP) frame_rate_base Frame rate base frame_rate_incr Frame rate incr (fps = frame_rate_base/frame_rate_incr) [Apply Require] stop -> close -> open -> set / get -> start Structure: VENDOR_VIDEOENC_SYSCAPS \u00b6 [Description] Get videoenc system capability information through user-specified codec type [Parameter] Value Description usr_codec_type [user_input] user codec type to get system capabilitys min_dim [output] minimum dimension max_dim [output] maximum dimension fmt_cnt [output] supported input format count fmt_align [output] supported input format and corresponding alignment [Apply Require] stop -> close -> open -> get -> start Videoout function and data structure definition \u00b6 Function: vendor_videoout_get \u00b6 [Description] Get parameters from unit by path id [Syntax] HD_RESULT vendor_videoout_get (HD_PATH_ID path_id, VENDOR_VIDEOOUT_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_SYS Operating system call failure Function: vendor_videoout_set \u00b6 [Description] Set parameters to unit by path id [Syntax] HD_RESULT vendor_videoout_set (HD_PATH_ID path_id, VENDOR_VIDEOOUT_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_SYS Operating system call failure Structure: VENDOR_VIDEOOUT_WRITEBACK \u00b6 [Description] Duplicate videoout0 image to dst_lcd_id [Parameter] Value Description enabled 0:disable 1:enable wb_lx x start pixel (two-pixel alignment), Left x wb_ty y start line, Top Y, range: 0 \\~ 12 wb_rx x start pixel (two-pixel alignment), Right x wb_by y start line, Bottom Y, range: 0 \\~ 12 wb_width write back width size wb_height write back height size dst_lcd_id write back to lcdid [Apply Require] stop -> close -> open -> set Structure: VENDOR_VIDEOOUT_WIN_LAYER_ATTR \u00b6 [Description] Set win order [Parameter] Value Description layer 0\\~7:layer number [Apply Require] stop -> close -> open -> set Structure: VENDOR_VIDEOOUT_MODE \u00b6 [Description] Set videoout mode for special mode:1440x900/1680x1050/1920x1200 [Parameter] Value Description output_type HD_COMMON_VIDEO_OUT_TYPE input_dim VENDOR_VIDEOOUT_INPUT_DIM output_mode VENDOR_VIDEOOUT_HDMI_ID VENDOR_VIDEOOUT_VGA_ID [Apply Require] stop -> close -> open -> set Structure: VENDOR_VIDEOOUT_EDID \u00b6 [Description] Get videoout support edid value [Parameter] Value Description val [VENDOR_VIDEOOUT_EDID_NU] Return edid value valid_num Get support edid number [Apply Require] open -> get Structure: VENDOR_VIDEOOUT_EDID_CAP \u00b6 [Description] Get monitor edid data [Parameter] Value Description hdmi_edid VENDOR_EDID_TBL VENDOR_EDID_TBL Store edid data and info edid_length Edid data size edid[512] Edid array is_valid Indicate edid info is valid w/h Valid edid info dim refresh_rate Valid edid info refresh rate is_progress Valid edid info progress format aspect_rate Valid edid info aspect rate [Apply Require] open -> get Structure: VENDOR_VIDEOOUT_SYSCAPS \u00b6 [Description] Get videoout system capability information through user-specified lcd_id. [Parameter] Value Description lcd_id [input] 0: lcd310, 1: lcd310 lite, 2: lcd210 pxlfmt_cnt [output] count of total pxlfmts support_pxlfmt1 [output] 1st supporting format support_pxlfmt2 [output] 2nd supporting format support_pxlfmt3 [output] 3rd supporting format [Apply Require] open-> get Videoprocess function and data structure definition \u00b6 Function: vendor_videoproc_get \u00b6 [Description] Get parameters from unit by path id [Syntax] HD_RESULT vendor_videoproc_get (HD_PATH_ID path_id, VENDOR_VIDEOPROC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter Function: vendor_videoproc_set \u00b6 [Description] Set parameters to unit by path id [Syntax] HD_RESULT vendor_videoproc_set (HD_PATH_ID path_id, VENDOR_VIDEOPROC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter Structure: VENDOR_VDOPROC_STATUS \u00b6 [Description] Get vproc available input buffer count [Parameter] Value Description dti_buf_cnt available input buffer count [Apply Require] open -> get Structure: VENDOR_VDOPROC_SUB_RATIO_THLD \u00b6 [Description] Get/set sub-yuv ratio threshold for vproc unit. [Parameter] Value Description numer numerator of sub-yuv ratio threshold denom denominator of sub-yuv ratio threshold [Apply Require] open -> get -> set Structure: VENDOR_VIDEOPROC_USR_INIT_FRAME_INFO \u00b6 [Description] Pre-specify the first input frame for this videoproc. This is used for playback feature, the frame is shown before decoder has started and the first bitstream data is decoded. [Parameter] Value Description image The pre-specified frame vendor_videoprocess_pull_in_buf \u00b6 [Description] Pull the input video buffer from unit [Syntax] HD_RESULT vendor_videoproc_pull_in_buf(HD_PATH_ID path_id, HD_VIDEO_FRAME* p_video_frame, INT32 wait_ms); [Parameter] Value Description path_id the path id p_video_frame pointer of the output video buffer wait_ms timeout value in ms [Return Value] Value Description HD_OK Success HD_ERR_NG Failure vendor_videoprocess_release_in_buf \u00b6 [Description] Release the video frame buffer which is get from unit [Syntax] HD_RESULT vendor_videoproc_release_in_buf(HD_PATH_ID path_id, HD_VIDEO_FRAME* p_video_frame) [Parameter] Value Description path_id the path id p_video_frame pointer of the output video buffer [Return Value] Value Description HD_OK Success HD_ERR_NG Failure Structure: VENDOR_DEWARP_2DLUT_TABLE \u00b6 [Description] 2D_lut table is made by the rsc tool. Set 2D_lut table for vpe module to map. [Parameter] Value Description tbl 65x68x UINT32 More details of 2D_lut and dctg, please refer to Chapter 3. [Apply Require] open -> get -> set 2D_lut example. Structure: VENDOR_DEWARP_MODE \u00b6 [Description] Not used now. Structure: VENDOR_DEWARP_DGC_PARM \u00b6 [Description] Gdc information. (DGC is a typo). User should get this information from vpe module. Only cent_x_s, cent_y_s, and lens_r parameters are suggested to be changed. [Parameter] Value Description cent_x_s lens center of x axis cent_y_s lens center of y axis lens_r the radius of image, half of pattern height xdist Fixed Ydist Fixed normfact Fixed normbit Fixed geo_lut[65] gdc look-up table More details of gdc parameters, please refer to Chapter 3. Structure: VENDOR_DEWARP_2DLUT_PARM \u00b6 [Description] 2D_lut parameters. Only lut2d_sz could be changed to 3 (65x65). [Parameter] Value Description lut2d_sz size selection, 0: 9x9, 3:65x65 hfact Fixed vfact Fixed xofs_i 2D-lut x offset (integer) xofs_f 2D-lut x offset (fraction) yofs_i 2D-lut y offset (integer) yofs_f 2D-lut y offset (fraction) Structure: VENDOR_DEWARP_FOV_PARM \u00b6 [Description] Fov parameters. Not used now. Structure: VENDOR_DEWARP_INFO \u00b6 [Description] Dewarp paramters. [Parameter] Value Description VENDOR_DEWARP_MODE Section 2.5.8 VENDOR_DEWARP_DGC_PARM Section 2.5.9 VENDOR_DEWARP_2DLUT_PARM Section 2.5.10 VENDOR_DEWARP_FOV_PARM Section 2.5.11 [Apply Require] open -> get -> set Structure: VENDOR_DEWARP_DCTG_MODE \u00b6 [Description] Set VENDOR_DEWARP_DCTG_MODE_360, when doing 2D_lut. [Parameter] Value Description VENDOR_DEWARP_DCTG_MODE_90 Do DCTG VENDOR_DEWARP_DCTG_MODE_360 Do 2D_lut Structure: VENDOR_DEWARP_DCTG_LENS_PARM \u00b6 [Description] DCTG lens parameters. [Parameter] Value Description mount_type 0: ceiling, 1: floor lut2d_sz size selection, 0: 9x9, 3:65x65 lens_r radius of lens lens_x_st lens start x position lens_y_st lens start y position lut2d_sz in VENDOR_DEWARP_DCTG_LENS_PARM should be equal to lut2d_sz in VENDOR_DEWARP_2DLUT_PARM. Structure: VENDOR_DEWARP_DCTG_FOV_PARM \u00b6 [Description] Not used now. Structure: VENDOR_DEWARP_DCTG_INFO \u00b6 [Description] DCTG information. [Parameter] Value Description VENDOR_DEWARP_DCTG_MODE Section 2.5.13 VENDOR_DEWARP_DCTG_LENS_PARM Section 2.5.14 VENDOR_DEWARP_DCTG_FOV_PARM Section 2.5.15 [Apply Require] open -> get -> set Structure: VENDOR_DEWARP_CTRL \u00b6 [Description] Dewarp engine on/off. After setting VENDOR_DEWARP_INFO and VENDOR_DEWARP_DCTG_INFO, set VENDOR_DEWARP_CTRL to start vpe dewarp action. [Parameter] Value Description dc_enable Use 2D_lut, On. Use dctg, On. dctg_enable Use dctg, On. Use 2D_lut, OFF The difference between 2D_lut and dctg, please refer to Chapter 3. [Apply Require] open -> get -> set Sample codes: liveview_with_dewarp.c and playback_with_dewarp.c show how the setting works. Audioio function and data structure definition \u00b6 Function: vendor_audioio_get \u00b6 [Description] Get parameters from unit by path id [Syntax] HD_RESULT vendor_audioio_get (HD_PATH_ID path_id, VENDOR_AUDIOIO_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter HD_ERR_PATH Invalid path id Function: vendor_audioio_set \u00b6 [Description] Set parameters to unit by path id [Syntax] HD_RESULT vendor_audioio_set (HD_PATH_ID path_id, VENDOR_AUDIOIO_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter Function: vendor_audioio_set_livesound \u00b6 [Description] This function supports to send command to lower driver to start/stop livesound function with specified pathid without any binding operation. You still need to set audio parameters such as HD_AUDIOCAP_PARAM_IN and HD_AUDIOOUT_PARAM_IN before using this function. [Syntax] HD_RESULT vendor_audioio_set_livesound(HD_PATH_ID acap_path_id, HD_PATH_ID aout_path_id, UINT on_off) [Parameter] Value Description acap_path_id The audiocapture path id aout_path_id The audioout path id on_off To start or stop livesound 0: stop livesound 1: start livesound [Return Value] Value Description HD_OK Success HD_ERR_PATH Wrong pathid HD_ERR_NG Fail to send command to lower driver. Structure: VENDOR_AUDIOIO_UNDERRUN_CONFIG \u00b6 [Description] This structure describes the internal audio status such as underrun, ongoing, and done counts. This structure is only used for audiocap or audioout. VENDOR_AUDIOIO_STATUS_INFO is an alias of this structure. [Parameter] Value Description underrun_cnt The times of buffer that underrun has happened. For audiocap, it means no buffer for receiving incoming audio PCM. You may lose audio data. For audioout, it means no PCM data for playing. You may hear nothing or staccato wave. ongoing_cnt The counts of buffers that doesn\u2019t process. For audiocap, it is the count of buffer that is waiting for receiving incoming PCM data. For audioout, it is the count of buffer in the queue waiting for playing. You can tell if the audio playback is done by checking this value until zero. done_cnt The count of buffers that is processed. For audiocap, it means the count of buffers already filled with PCM data but hasn\u2019t received by APP. For audioout, this value is meaningless. [Apply Require] open -> get Structure: VENDOR_AUDIOIO_STATUS_INFO \u00b6 VENDOR_AUDIOIO_STATUS_INFO is an alias of VENDOR_AUDIOIO_UNDERRUN_CONFIG. Please refer to 2.6.4 for details. Structure: VENDOR_AUDIOIO_AOUT_LB_DEV_INFO \u00b6 [Description] The structure fills the loopback HDAL dev_id of the calling path(audioout path). [Parameter] Value Description dev_id The loopback HDAL dev_id of this audioout path [Apply Require] open -> get Structure: VENDOR_AUDIOIO_SYNC_TIME_INFO \u00b6 [Description] Fill this structure to specify the target channel for synchronize time of output data. [Parameter] Value Description sync_target The target pathid for synchronizing time with. [Apply Require] open -> set Gfx function and data structe definition \u00b6 Structure: VENDOR_GFX_SYSCAPS \u00b6 [Description] Get gfx system capability information. [Parameter] Value Description scl_rate get system max scaling factor min_dim get min input /output dimension max_dim get max input /output dimension image_align get align limitation Function: vendor_gfx_get_syscaps \u00b6 [Description] Get VENDOR_GFX_SYSCAPS value [Syntax] HD_RESULT vendor_gfx_get_syscaps(VENDOR_GFX_SYSCAPS *p_param) [Parameter] Value Description p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter Vendor common function and data structe definition \u00b6 Function: vendor_common_mem_get_block_with_name \u00b6 [Description] Get memory block with name [Syntax] HD_COMMON_MEM_VB_BLK vendor_common_mem_get_block_with_name(HD_COMMON_MEM_POOL_TYPE pool_type, UINT32 blk_size, HD_COMMON_MEM_DDR_ID ddr, CHAR *usr_name) [Parameter] Value Description pool_type Value of pool type blk_size Value of memory size ddr Value of ddr id usr_name Block name [Return Value] Value Description HD_COMMON_MEM_VB_BLK Success HD_COMMON_MEM_VB_INVALID_BLK Failure Function: vendor_common_clear_pool_blk \u00b6 [Description] Free all memory block with pool type and ddrid [Syntax] HD_RESULT vendor_common_clear_pool_blk(HD_COMMON_MEM_POOL_TYPE pool_type, INT ddrid) [Parameter] Value Description pool_type Value of pool type ddrid Value of ddr id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure to find pool by type HD_ERR_SYS Failure to free all blk Distortion Correction Engine (DCE) \u00b6 Overview \u00b6 This is lens distortion calibration module, it can perform calibration on wide-angle lens and fish-eye lens. DCE Parameter Description \u00b6 Parameter Range Default Description dce_mode 0\\~1 0 Select distortion function 0: GDC lens calibration 1: 2DLUT self-define XY coordinate distortion lut2d_sz 0\\~3 0 Size selection of 2D look-up table. The larger the size, the more precision to describe distortion. 0: 9x9 1: (not supported) 2: (not supported) 3: 65x65 lsb_rand 0\\~1 0 LSB 2 bit random generation for internal 10 bit->8 bit image. 0: fixed fill 0 1: random generate 0\\~3 fovbound 0\\~1 0 FOV boundary process method selection. When the distortion result can not fill the total output image, select different way to proceed the exceed range. 0: Replace out of boundary pixels with duplicate nearest pixel 1: Replace out of boundary pixels with bound pixels boundy 0\\~1023 0 Bound value for Y component(u8.2) boundu 0\\~1023 0 Bound value for U component(u8.2) boundv 0\\~1023 0 Bound value for V component(u8.2) cent_x_s 213-1 0 Define lens center of x-axis. It is recommend to set width/2. cent_y_s 213-1 0 Define lens center of y-axis. It is recommend to set height/2. xdist 0\\~4095 0 X input distance factor, for oval shape modeling. It is recommend to set 4095, which is suitable for most situation. ydist 0\\~4095 0 Y input distance factor, for oval shape modeling. It is recommend to set 4095, which is suitable for most situation. normfact 0\\~255 128 Radius normalization factor. Normfact = 1 \\<\\< (normbit + 7) / R2 normbit 0\\~31 31 Radius normalization shift bit. R2 = (width/2)2+(height/2)2 The total bit number of R2 is normbit. Example: 9602+5402 = 1213200 (21 bits) fovgain 0\\~4095 0 Adjust the scaling ratio of the final distortion coordinate to preserve FOV. Scale down factor for FOV preservation. Due to it will effect the calibration performance, it is recommend to set 1024. hfact 0 \\~ 224 -1 0 Horizontal scaling factor for 2DLut scaling up(u0.24). ((2DLUT horizontal pixel number \u2013 1) \\<\\< 24) / (width \u2013 1) vfact 0 \\~ 224 -1 0 Vertical scaling factor for 2DLut scaling up(u0.24). ((2DLUT vertical pixel number \u2013 1) \\<\\< 24) / (height \u2013 1) xofs_i 0\\~127 0 2DLut x offset, integer part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. xofs_f 0\\~224-1 0 2DLut x offset, fraction part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. yofs_i 0\\~127 0 2DLut y offset, integer part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. yofs_f 0\\~224-1 0 2DLut y offset, fraction part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. DC Table Generator \u00b6 For perspective projection application, in order to increase the convenience of usage, DCTG module let user to set the desired angle and size with an instinct way to generate DCE parameters automatically. Overview \u00b6 DCTG generate DCE 2D-LUT for perspective projection. Whenever this function is enabled, manual set DCE 2D-LUT function will be invalid. Please refer to the following description: The \u201ctheta\u201d is the top/bottom angle. The \u201cphi\u201d is the rotate angle. The \u201crot_y\u201d is the rotate offset of (x, z) plane towards Y-axis. The \u201crot_z\u201d is the rotate offset of (x, y) plane towards Z-axis. Generate LUT: Define the rotate angle of FOV by phi_st/phi_ed, and then rotate to FOV location by rot_y. Define the top/bottom angle of FOV by theta_st/theta_ed, and then rotate to FOV location by rot_z. DCTG Parameter Description \u00b6 Parameter Range Default Description dctg_en 0\\~1 0 DCTG ON/OFF \u203b DCTG and dce_2d_lut_en cannot be enabled at the same time. mount_type 0\\~1 0 Camera mount type. 0: Ceiling mount 1: Floor mount lut2d_sz 0\\~1 0 Select size of 2D look-up table, this parameter must the same with DCE parameter. 0: 9x9 1: (not supported) 2: (not supported) 3: 65x65 lens_r 0\\~215-1 0 Valid radius of fish-eye lens, the unit is pixel. Please refer to advance description. lens_x_st 0\\~214-1 0 The start x position of fish-eye lens at the source image, the unit is pixel. lens_y_st 0\\~214-1 0 The start y position of fish-eye lens at the source image, the unit is pixel. theta_st s4.16 -220 \\~ 220-1 0 FOV theta start radian. (-*pi \\~ *pi) theta_ed s4.16 -220 \\~ 220-1 (-*pi \\~ *pi) 0 FOV theta end radian. (-*pi \\~ *pi) theta_end > theta_st: normal image theta_end \\< theta_st: flip image phi_st s4.16 -220 \\~ 220-1 0 FOV phi start radian. (-2*pi \\~ 2*pi) phi_ed s4.16 -220 \\~ 220-1 0 FOV phi end radian. (-2*pi \\~ 2*pi) phi_end > theta_st: normal image phi_end \\< theta_st: flip image rot_z s4.16 -220 \\~ 220-1 0 Z-axis rotate radian. (-2*pi \\~ 2*pi) rot_y s4.16 -220 \\~ 220-1 0 Y-zxis rotate radian. (-2*pi \\~ 2*pi) Advance description: \u00b6 lens_r: The valid radius of fish-eye device lens_x_ st : The start x position of fish-eye lens at the source image, the unit is pixel. lens_y_st : The start y position of fish-eye lens at the source image, the unit is pixel.","title":"Vendor Media Programming Guide"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#introduction","text":"Vendor API is an extended library for HDAL. Some features dedicated for the specific IC will not list in the HDAL API but in vendor API. Please refer to this document to know the detail.","title":"Introduction"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#parameter-ids-and-data-structure-definition","text":"Videocap None Videodec VENDOR_VIDEODEC_PARAM_JPEG_WORK_BUFFER support set/get with i/o path using VENDOR_VIDEODEC_JPEG_WORK_BUFFER struct VENDOR_VIDEODEC_PARAM_FREE_JPEG_WORK_BUFFER support set with i/o path using VENDOR_VIDEODEC_JPEG_WORK_BUFFER struct VENDOR_VIDEODEC_PARAM_SUB_YUV_RATIO support set/get with i/o path using VENDOR_VIDEODEC_SUB_YUV struct VENDOR_VIDEODEC_PARAM_QP_CONFIG support set/get with i/o path using VENDOR_VIDEODEC_QP_CONFIG struct VENDOR_VIDEODEC_PARAM_H26X_OUT support set/get with i/o path using VENDOR_VIDEODEC_H26X_OUT struct VENDOR_VIDEODEC_PARAM_SYSCAPS support get with i/o path using VENDOR_VIDEODEC_SYSCAPS struct Videoenc VENDOR_VIDEOENC_PARAM_OSG_SEL support get/set with i/o path using VENDOR_VIDEOENC_OSG struct VENDOR_VIDEOENC_PARAM_MIN_COMPRESS_RATIO support get/set with i/o path using VENDOR_VDOENC_MIN_COMPRESS_RATIO struct Videoout VENDOR_VIDEOOUT_PARAM_WRITEBACK support get/set with i/o path using VENDOR_VIDEOOUT_WRITEBACK struct VENDOR_VIDEOOUT_PARAM_WIN_LAYER_ATTR, support get/set with i/o path using VENDOR_VIDEOOUT_WIN_LAYER_ATTR struct VENDOR_VIDEOOUT_PARAM_MODE support get/set with i/o path using VENDOR_VIDEOOUT_MODE struct Videoprocess VENDOR_VIDEOPROC_STATUS support set with i/o path using VENDOR_VDOPROC_STATUS struct VENDOR_VIDEOPROC_USER_FLAG support set with i/o path using UINT32 struct VENDOR_VIDEOPROC_SUB_RATIO_THLD support set/get with i/o path using VENDOR_VDOPROC_SUB_RATIO_THLD struct VENDOR_VIDEOPROC_USR_INIT_FRAME support set with i/o path using VENDOR_VDOPROC_USR_INIT_FRAME_INFO struct Audioio VENDOR_UNDERRUN_CNT support get with i/o path using VENDOR_AUDIOIO_UNDERRUN_CONFIG struct VENDOR_AUDIOIO_PARAM_SYSCAPS support get with i/o path using VENDOR_AUDIOIO_PARAM_SYSCAPS struct VENDOR_AUDIOIO_STATUS support get with i/o path using VENDOR_AUDIOIO_STATUS struct VENDOR_AUDIOIO_INIT_CFG support set/get with i/o path using VENDOR_AUDIOIO_INIT_I2S_CFG struct VENDOR_AUDIOIO_AOUT_LB_DEV_ID support get with i/o path using VENDOR_AUDIOIO_AOUT_LB_DEV_INFO struct VENDOR_AUDIOIO_SYNC_TIME support set with i/o path using VENDOR_AUDIOIO_SYNC_TIME_INFO struct","title":"Parameter IDs and data structure definition"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#videocap-function-and-data-structure-definition","text":"","title":"Videocap function and data structure definition"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#function-vendor_videocap_get","text":"[Description] Get parameters from unit by path id [Syntax] HD_RESULT vendor_videocap_get (HD_PATH_ID path_id, VENDOR_VIDEOENC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter","title":"Function: vendor_videocap_get"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#function-vendor_videocap_set","text":"[Description] Set parameters to unit by path id [Syntax] HD_RESULT vendor_videocap_set (HD_PATH_ID path_id, VENDOR_VIDEOENC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter","title":"Function: vendor_videocap_set"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#function-vendor_videocap_push_in_buf","text":"[Description] trigger mode: given a buffer to get yuv data out. flow mode: given an additional buffer to get yuv data out. (It will influence the already bound path.) It suggests that after 2 or more different buffers are pushed, then vendor_videocap_pull_out_buf starts to get done buffer. Note: There is another application to get yuv data out without given buffer, hd_videocap_pull_out_buf(). But, hd_videocap_release_out_buf() should be called to return yuv data buffer. [Syntax] HD_RESULT vendor_videocap_push_in_buf(HD_PATH_ID path_id, HD_VIDEO_FRAME* p_video_frame, INT32 wait_ms) [Parameter] Value Description path_id the path id p_video_frame settings for getting data, must including width/height/pxlfmt/physical address wait_ms mini-seconds to get callback result [Return Value] Value Description HD_OK Success HD_ERR_DEV Wrong device id HD_ERR_PARAM Wrong input settings HD_ERR_NOBUF Not enough buffer for outputting yuv data","title":"Function: vendor_videocap_push_in_buf"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#function-vendor_videocap_pull_out_buf","text":"[Description] trigger mode: pull out the yuv data buffer. flow mode: pull out the yuv data buffer which is pushed-in by vendor_videocap_push_in_buf( ). [Syntax] HD_RESULT vendor_videocap_pull_out_buf(HD_PATH_ID path_id, HD_VIDEO_FRAME* p_video_frame, INT32 wait_ms) [Parameter] Value Description path_id the path id p_video_frame settings for getting data, must including width/height/pxlfmt/physical address wait_ms mini-seconds to get callback result [Return Value] Value Description HD_OK Success HD_ERR_DEV Wrong device id HD_ERR_PARAM Wrong input settings HD_ERR_TIMEDOUT Vcap module is still busy, need retry HD_ERR_SYS Vcap module is not ready HD_ERR_FAIL this job is failed from vcap driver","title":"Function: vendor_videocap_pull_out_buf"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_videocap_cropctrl_info","text":"[Description] Support an option to apply crop information. [Parameter] Value Description rect Crop rectangular, including x, y, w, h coord Background rectangular [Apply Require] open->set->get","title":"Structure: VENDOR_VIDEOCAP_CROPCTRL_INFO"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_videocap_syscaps","text":"[Description] Get videocap system capability information through user-specified type/mode. [Parameter] Value Description wanted_pxlfmt [input] vcap out fmt min_dim [output] min width/height max_dim [output] max width/height crop_min_dim [output] min crop width/height output_align [output] alignment of width/height [Apply Require] open-> get","title":"Structure: VENDOR_VIDEOCAP_SYSCAPS"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#videodec-function-and-data-structure-definition","text":"","title":"Videodec function and data structure definition"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#function-vendor_videodec_get","text":"[Description] Get parameters from unit by path id [Syntax] HD_RESULT vendor_videodec_get (HD_PATH_ID path_id, VENDOR_VIDEODEC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter","title":"Function: vendor_videodec_get"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#function-vendor_videodec_set","text":"[Description] Set parameters to unit by path id [Syntax] HD_RESULT vendor_videodec_set (HD_PATH_ID path_id, VENDOR_VIDEODEC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter","title":"Function: vendor_videodec_set"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_videodec_jpeg_work_buffer","text":"[Description] This function is not supported on NT9833x.","title":"Structure: VENDOR_VIDEODEC_JPEG_WORK_BUFFER"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_videodec_free_jpeg_work_buffer","text":"[Description] This function is not supported on NT9833x.","title":"Structure: VENDOR_VIDEODEC_FREE_JPEG_WORK_BUFFER"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_videodec_sub_yuv","text":"[Description] Set/get videodec sub-yuv ratio. [Parameter] Value Description ratio Sub-yuv ratio [Apply Require] set / get","title":"Structure: VENDOR_VIDEODEC_SUB_YUV"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_videodec_qp_config","text":"[Description] Set/get videodec qp value configuration. [Parameter] Value Description qp_value Quantization parameter value [Apply Require] set / get","title":"Structure: VENDOR_VIDEODEC_QP_CONFIG"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_videodec_h26x_out","text":"[Description] Set/get videodec H.26x output format configuration. [Parameter] Value Description first_out H.26x first output mode extra_out H.26x extra output mode [Apply Require] set / get","title":"Structure: VENDOR_VIDEODEC_H26X_OUT"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_videodec_syscaps","text":"[Description] Get videodec system capability information through user-specified type/mode. [Parameter] Value Description usr_codec_type [user_input] user codec type to get system capabilitys usr_first_mode [user_input] user first output mode (compress / uncompress) usr_extra_mode [user_input] user extra output mode (compress / uncompress) first_align [output] first output buffer dimension alignment extra_align [output] extra output buffer dimension alignment first_pxlfmt [output] first output buffer pixel format extra_pxlfmt [output] extra output buffer pixel format min_dim [output] minimum dimension max_dim [output] maximum dimension [Apply Require] get","title":"Structure: VENDOR_VIDEODEC_SYSCAPS"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#videoenc-function-and-data-structure-definition","text":"","title":"Videoenc function and data structure definition"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#function-vendor_videoenc_get","text":"[Description] Get parameters from unit by path id [Syntax] HD_RESULT vendor_videoenc_get (HD_PATH_ID path_id, VENDOR_VIDEOENC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter","title":"Function: vendor_videoenc_get"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#function-vendor_videoenc_set","text":"[Description] Set parameters to unit by path id [Syntax] HD_RESULT vendor_videoenc_set (HD_PATH_ID path_id, VENDOR_VIDEOENC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter","title":"Function: vendor_videoenc_set"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_videoenc_osg","text":"[Description] Support an option to choose internal or external OSG [Parameter] Value Description external_osg select which osg 1:3d osg 0:encode osg [Apply Require] stop -> close -> open -> set -> start","title":"Structure: VENDOR_VIDEOENC_OSG"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_videoenc_min_compress_ratio","text":"[Description] Set initial compress ratio for different QP [Parameter] Value Description codec_type select the codec by HD_VIDEO_CODEC type qp_ratio Set the qp ratio by VENDOR_VIDEOENC_QP_RATIO type [Apply Require] stop -> close -> open -> set -> start","title":"Structure: VENDOR_VIDEOENC_MIN_COMPRESS_RATIO"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_jpegenc_param_rate_control","text":"[Description] JPEG rate control parameters [Parameter] Value Description Vbr_mode 0: CBR, 1: VBR, 2: FixQP base_qp Base qp value (range 1\\~100, not used when FixQP) min_quality Minimum quality (range 1\\~100, not used when FixQP) max_quality Maximum quality (range 1\\~100, not used when FixQP) bitrate bitrate (max 128M, not used when FixQP) frame_rate_base Frame rate base frame_rate_incr Frame rate incr (fps = frame_rate_base/frame_rate_incr) [Apply Require] stop -> close -> open -> set / get -> start","title":"Structure: VENDOR_JPEGENC_PARAM_RATE_CONTROL"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_videoenc_syscaps","text":"[Description] Get videoenc system capability information through user-specified codec type [Parameter] Value Description usr_codec_type [user_input] user codec type to get system capabilitys min_dim [output] minimum dimension max_dim [output] maximum dimension fmt_cnt [output] supported input format count fmt_align [output] supported input format and corresponding alignment [Apply Require] stop -> close -> open -> get -> start","title":"Structure: VENDOR_VIDEOENC_SYSCAPS"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#videoout-function-and-data-structure-definition","text":"","title":"Videoout function and data structure definition"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#function-vendor_videoout_get","text":"[Description] Get parameters from unit by path id [Syntax] HD_RESULT vendor_videoout_get (HD_PATH_ID path_id, VENDOR_VIDEOOUT_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_SYS Operating system call failure","title":"Function: vendor_videoout_get"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#function-vendor_videoout_set","text":"[Description] Set parameters to unit by path id [Syntax] HD_RESULT vendor_videoout_set (HD_PATH_ID path_id, VENDOR_VIDEOOUT_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_SYS Operating system call failure","title":"Function: vendor_videoout_set"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_videoout_writeback","text":"[Description] Duplicate videoout0 image to dst_lcd_id [Parameter] Value Description enabled 0:disable 1:enable wb_lx x start pixel (two-pixel alignment), Left x wb_ty y start line, Top Y, range: 0 \\~ 12 wb_rx x start pixel (two-pixel alignment), Right x wb_by y start line, Bottom Y, range: 0 \\~ 12 wb_width write back width size wb_height write back height size dst_lcd_id write back to lcdid [Apply Require] stop -> close -> open -> set","title":"Structure: VENDOR_VIDEOOUT_WRITEBACK"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_videoout_win_layer_attr","text":"[Description] Set win order [Parameter] Value Description layer 0\\~7:layer number [Apply Require] stop -> close -> open -> set","title":"Structure: VENDOR_VIDEOOUT_WIN_LAYER_ATTR"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_videoout_mode","text":"[Description] Set videoout mode for special mode:1440x900/1680x1050/1920x1200 [Parameter] Value Description output_type HD_COMMON_VIDEO_OUT_TYPE input_dim VENDOR_VIDEOOUT_INPUT_DIM output_mode VENDOR_VIDEOOUT_HDMI_ID VENDOR_VIDEOOUT_VGA_ID [Apply Require] stop -> close -> open -> set","title":"Structure: VENDOR_VIDEOOUT_MODE"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_videoout_edid","text":"[Description] Get videoout support edid value [Parameter] Value Description val [VENDOR_VIDEOOUT_EDID_NU] Return edid value valid_num Get support edid number [Apply Require] open -> get","title":"Structure: VENDOR_VIDEOOUT_EDID"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_videoout_edid_cap","text":"[Description] Get monitor edid data [Parameter] Value Description hdmi_edid VENDOR_EDID_TBL VENDOR_EDID_TBL Store edid data and info edid_length Edid data size edid[512] Edid array is_valid Indicate edid info is valid w/h Valid edid info dim refresh_rate Valid edid info refresh rate is_progress Valid edid info progress format aspect_rate Valid edid info aspect rate [Apply Require] open -> get","title":"Structure: VENDOR_VIDEOOUT_EDID_CAP"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_videoout_syscaps","text":"[Description] Get videoout system capability information through user-specified lcd_id. [Parameter] Value Description lcd_id [input] 0: lcd310, 1: lcd310 lite, 2: lcd210 pxlfmt_cnt [output] count of total pxlfmts support_pxlfmt1 [output] 1st supporting format support_pxlfmt2 [output] 2nd supporting format support_pxlfmt3 [output] 3rd supporting format [Apply Require] open-> get","title":"Structure: VENDOR_VIDEOOUT_SYSCAPS"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#videoprocess-function-and-data-structure-definition","text":"","title":"Videoprocess function and data structure definition"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#function-vendor_videoproc_get","text":"[Description] Get parameters from unit by path id [Syntax] HD_RESULT vendor_videoproc_get (HD_PATH_ID path_id, VENDOR_VIDEOPROC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter","title":"Function: vendor_videoproc_get"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#function-vendor_videoproc_set","text":"[Description] Set parameters to unit by path id [Syntax] HD_RESULT vendor_videoproc_set (HD_PATH_ID path_id, VENDOR_VIDEOPROC_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter","title":"Function: vendor_videoproc_set"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_vdoproc_status","text":"[Description] Get vproc available input buffer count [Parameter] Value Description dti_buf_cnt available input buffer count [Apply Require] open -> get","title":"Structure: VENDOR_VDOPROC_STATUS"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_vdoproc_sub_ratio_thld","text":"[Description] Get/set sub-yuv ratio threshold for vproc unit. [Parameter] Value Description numer numerator of sub-yuv ratio threshold denom denominator of sub-yuv ratio threshold [Apply Require] open -> get -> set","title":"Structure: VENDOR_VDOPROC_SUB_RATIO_THLD"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_videoproc_usr_init_frame_info","text":"[Description] Pre-specify the first input frame for this videoproc. This is used for playback feature, the frame is shown before decoder has started and the first bitstream data is decoded. [Parameter] Value Description image The pre-specified frame","title":"Structure: VENDOR_VIDEOPROC_USR_INIT_FRAME_INFO"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#vendor_videoprocess_pull_in_buf","text":"[Description] Pull the input video buffer from unit [Syntax] HD_RESULT vendor_videoproc_pull_in_buf(HD_PATH_ID path_id, HD_VIDEO_FRAME* p_video_frame, INT32 wait_ms); [Parameter] Value Description path_id the path id p_video_frame pointer of the output video buffer wait_ms timeout value in ms [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"vendor_videoprocess_pull_in_buf"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#vendor_videoprocess_release_in_buf","text":"[Description] Release the video frame buffer which is get from unit [Syntax] HD_RESULT vendor_videoproc_release_in_buf(HD_PATH_ID path_id, HD_VIDEO_FRAME* p_video_frame) [Parameter] Value Description path_id the path id p_video_frame pointer of the output video buffer [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"vendor_videoprocess_release_in_buf"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_dewarp_2dlut_table","text":"[Description] 2D_lut table is made by the rsc tool. Set 2D_lut table for vpe module to map. [Parameter] Value Description tbl 65x68x UINT32 More details of 2D_lut and dctg, please refer to Chapter 3. [Apply Require] open -> get -> set 2D_lut example.","title":"Structure: VENDOR_DEWARP_2DLUT_TABLE"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_dewarp_mode","text":"[Description] Not used now.","title":"Structure: VENDOR_DEWARP_MODE"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_dewarp_dgc_parm","text":"[Description] Gdc information. (DGC is a typo). User should get this information from vpe module. Only cent_x_s, cent_y_s, and lens_r parameters are suggested to be changed. [Parameter] Value Description cent_x_s lens center of x axis cent_y_s lens center of y axis lens_r the radius of image, half of pattern height xdist Fixed Ydist Fixed normfact Fixed normbit Fixed geo_lut[65] gdc look-up table More details of gdc parameters, please refer to Chapter 3.","title":"Structure: VENDOR_DEWARP_DGC_PARM"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_dewarp_2dlut_parm","text":"[Description] 2D_lut parameters. Only lut2d_sz could be changed to 3 (65x65). [Parameter] Value Description lut2d_sz size selection, 0: 9x9, 3:65x65 hfact Fixed vfact Fixed xofs_i 2D-lut x offset (integer) xofs_f 2D-lut x offset (fraction) yofs_i 2D-lut y offset (integer) yofs_f 2D-lut y offset (fraction)","title":"Structure: VENDOR_DEWARP_2DLUT_PARM"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_dewarp_fov_parm","text":"[Description] Fov parameters. Not used now.","title":"Structure: VENDOR_DEWARP_FOV_PARM"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_dewarp_info","text":"[Description] Dewarp paramters. [Parameter] Value Description VENDOR_DEWARP_MODE Section 2.5.8 VENDOR_DEWARP_DGC_PARM Section 2.5.9 VENDOR_DEWARP_2DLUT_PARM Section 2.5.10 VENDOR_DEWARP_FOV_PARM Section 2.5.11 [Apply Require] open -> get -> set","title":"Structure: VENDOR_DEWARP_INFO"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_dewarp_dctg_mode","text":"[Description] Set VENDOR_DEWARP_DCTG_MODE_360, when doing 2D_lut. [Parameter] Value Description VENDOR_DEWARP_DCTG_MODE_90 Do DCTG VENDOR_DEWARP_DCTG_MODE_360 Do 2D_lut","title":"Structure: VENDOR_DEWARP_DCTG_MODE"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_dewarp_dctg_lens_parm","text":"[Description] DCTG lens parameters. [Parameter] Value Description mount_type 0: ceiling, 1: floor lut2d_sz size selection, 0: 9x9, 3:65x65 lens_r radius of lens lens_x_st lens start x position lens_y_st lens start y position lut2d_sz in VENDOR_DEWARP_DCTG_LENS_PARM should be equal to lut2d_sz in VENDOR_DEWARP_2DLUT_PARM.","title":"Structure: VENDOR_DEWARP_DCTG_LENS_PARM"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_dewarp_dctg_fov_parm","text":"[Description] Not used now.","title":"Structure: VENDOR_DEWARP_DCTG_FOV_PARM"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_dewarp_dctg_info","text":"[Description] DCTG information. [Parameter] Value Description VENDOR_DEWARP_DCTG_MODE Section 2.5.13 VENDOR_DEWARP_DCTG_LENS_PARM Section 2.5.14 VENDOR_DEWARP_DCTG_FOV_PARM Section 2.5.15 [Apply Require] open -> get -> set","title":"Structure: VENDOR_DEWARP_DCTG_INFO"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_dewarp_ctrl","text":"[Description] Dewarp engine on/off. After setting VENDOR_DEWARP_INFO and VENDOR_DEWARP_DCTG_INFO, set VENDOR_DEWARP_CTRL to start vpe dewarp action. [Parameter] Value Description dc_enable Use 2D_lut, On. Use dctg, On. dctg_enable Use dctg, On. Use 2D_lut, OFF The difference between 2D_lut and dctg, please refer to Chapter 3. [Apply Require] open -> get -> set Sample codes: liveview_with_dewarp.c and playback_with_dewarp.c show how the setting works.","title":"Structure: VENDOR_DEWARP_CTRL"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#audioio-function-and-data-structure-definition","text":"","title":"Audioio function and data structure definition"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#function-vendor_audioio_get","text":"[Description] Get parameters from unit by path id [Syntax] HD_RESULT vendor_audioio_get (HD_PATH_ID path_id, VENDOR_AUDIOIO_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter HD_ERR_PATH Invalid path id","title":"Function: vendor_audioio_get"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#function-vendor_audioio_set","text":"[Description] Set parameters to unit by path id [Syntax] HD_RESULT vendor_audioio_set (HD_PATH_ID path_id, VENDOR_AUDIOIO_PARAM_ID id, VOID* p_param) [Parameter] Value Description path_id the path id id id of parameters p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter","title":"Function: vendor_audioio_set"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#function-vendor_audioio_set_livesound","text":"[Description] This function supports to send command to lower driver to start/stop livesound function with specified pathid without any binding operation. You still need to set audio parameters such as HD_AUDIOCAP_PARAM_IN and HD_AUDIOOUT_PARAM_IN before using this function. [Syntax] HD_RESULT vendor_audioio_set_livesound(HD_PATH_ID acap_path_id, HD_PATH_ID aout_path_id, UINT on_off) [Parameter] Value Description acap_path_id The audiocapture path id aout_path_id The audioout path id on_off To start or stop livesound 0: stop livesound 1: start livesound [Return Value] Value Description HD_OK Success HD_ERR_PATH Wrong pathid HD_ERR_NG Fail to send command to lower driver.","title":"Function: vendor_audioio_set_livesound"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_audioio_underrun_config","text":"[Description] This structure describes the internal audio status such as underrun, ongoing, and done counts. This structure is only used for audiocap or audioout. VENDOR_AUDIOIO_STATUS_INFO is an alias of this structure. [Parameter] Value Description underrun_cnt The times of buffer that underrun has happened. For audiocap, it means no buffer for receiving incoming audio PCM. You may lose audio data. For audioout, it means no PCM data for playing. You may hear nothing or staccato wave. ongoing_cnt The counts of buffers that doesn\u2019t process. For audiocap, it is the count of buffer that is waiting for receiving incoming PCM data. For audioout, it is the count of buffer in the queue waiting for playing. You can tell if the audio playback is done by checking this value until zero. done_cnt The count of buffers that is processed. For audiocap, it means the count of buffers already filled with PCM data but hasn\u2019t received by APP. For audioout, this value is meaningless. [Apply Require] open -> get","title":"Structure: VENDOR_AUDIOIO_UNDERRUN_CONFIG"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_audioio_status_info","text":"VENDOR_AUDIOIO_STATUS_INFO is an alias of VENDOR_AUDIOIO_UNDERRUN_CONFIG. Please refer to 2.6.4 for details.","title":"Structure: VENDOR_AUDIOIO_STATUS_INFO"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_audioio_aout_lb_dev_info","text":"[Description] The structure fills the loopback HDAL dev_id of the calling path(audioout path). [Parameter] Value Description dev_id The loopback HDAL dev_id of this audioout path [Apply Require] open -> get","title":"Structure: VENDOR_AUDIOIO_AOUT_LB_DEV_INFO"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_audioio_sync_time_info","text":"[Description] Fill this structure to specify the target channel for synchronize time of output data. [Parameter] Value Description sync_target The target pathid for synchronizing time with. [Apply Require] open -> set","title":"Structure: VENDOR_AUDIOIO_SYNC_TIME_INFO"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#gfx-function-and-data-structe-definition","text":"","title":"Gfx function and data structe definition"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#structure-vendor_gfx_syscaps","text":"[Description] Get gfx system capability information. [Parameter] Value Description scl_rate get system max scaling factor min_dim get min input /output dimension max_dim get max input /output dimension image_align get align limitation","title":"Structure: VENDOR_GFX_SYSCAPS"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#function-vendor_gfx_get_syscaps","text":"[Description] Get VENDOR_GFX_SYSCAPS value [Syntax] HD_RESULT vendor_gfx_get_syscaps(VENDOR_GFX_SYSCAPS *p_param) [Parameter] Value Description p_param pointer of parameters [Return Value] Value Description HD_OK Success HD_ERR_NG Failure HD_ERR_NOT_SUPPORT Not support this parameter","title":"Function: vendor_gfx_get_syscaps"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#vendor-common-function-and-data-structe-definition","text":"","title":"Vendor common function and data structe definition"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#function-vendor_common_mem_get_block_with_name","text":"[Description] Get memory block with name [Syntax] HD_COMMON_MEM_VB_BLK vendor_common_mem_get_block_with_name(HD_COMMON_MEM_POOL_TYPE pool_type, UINT32 blk_size, HD_COMMON_MEM_DDR_ID ddr, CHAR *usr_name) [Parameter] Value Description pool_type Value of pool type blk_size Value of memory size ddr Value of ddr id usr_name Block name [Return Value] Value Description HD_COMMON_MEM_VB_BLK Success HD_COMMON_MEM_VB_INVALID_BLK Failure","title":"Function: vendor_common_mem_get_block_with_name"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#function-vendor_common_clear_pool_blk","text":"[Description] Free all memory block with pool type and ddrid [Syntax] HD_RESULT vendor_common_clear_pool_blk(HD_COMMON_MEM_POOL_TYPE pool_type, INT ddrid) [Parameter] Value Description pool_type Value of pool type ddrid Value of ddr id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure to find pool by type HD_ERR_SYS Failure to free all blk","title":"Function: vendor_common_clear_pool_blk"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#distortion-correction-engine-dce","text":"","title":"Distortion Correction Engine (DCE)"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#overview","text":"This is lens distortion calibration module, it can perform calibration on wide-angle lens and fish-eye lens.","title":"Overview"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#dce-parameter-description","text":"Parameter Range Default Description dce_mode 0\\~1 0 Select distortion function 0: GDC lens calibration 1: 2DLUT self-define XY coordinate distortion lut2d_sz 0\\~3 0 Size selection of 2D look-up table. The larger the size, the more precision to describe distortion. 0: 9x9 1: (not supported) 2: (not supported) 3: 65x65 lsb_rand 0\\~1 0 LSB 2 bit random generation for internal 10 bit->8 bit image. 0: fixed fill 0 1: random generate 0\\~3 fovbound 0\\~1 0 FOV boundary process method selection. When the distortion result can not fill the total output image, select different way to proceed the exceed range. 0: Replace out of boundary pixels with duplicate nearest pixel 1: Replace out of boundary pixels with bound pixels boundy 0\\~1023 0 Bound value for Y component(u8.2) boundu 0\\~1023 0 Bound value for U component(u8.2) boundv 0\\~1023 0 Bound value for V component(u8.2) cent_x_s 213-1 0 Define lens center of x-axis. It is recommend to set width/2. cent_y_s 213-1 0 Define lens center of y-axis. It is recommend to set height/2. xdist 0\\~4095 0 X input distance factor, for oval shape modeling. It is recommend to set 4095, which is suitable for most situation. ydist 0\\~4095 0 Y input distance factor, for oval shape modeling. It is recommend to set 4095, which is suitable for most situation. normfact 0\\~255 128 Radius normalization factor. Normfact = 1 \\<\\< (normbit + 7) / R2 normbit 0\\~31 31 Radius normalization shift bit. R2 = (width/2)2+(height/2)2 The total bit number of R2 is normbit. Example: 9602+5402 = 1213200 (21 bits) fovgain 0\\~4095 0 Adjust the scaling ratio of the final distortion coordinate to preserve FOV. Scale down factor for FOV preservation. Due to it will effect the calibration performance, it is recommend to set 1024. hfact 0 \\~ 224 -1 0 Horizontal scaling factor for 2DLut scaling up(u0.24). ((2DLUT horizontal pixel number \u2013 1) \\<\\< 24) / (width \u2013 1) vfact 0 \\~ 224 -1 0 Vertical scaling factor for 2DLut scaling up(u0.24). ((2DLUT vertical pixel number \u2013 1) \\<\\< 24) / (height \u2013 1) xofs_i 0\\~127 0 2DLut x offset, integer part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. xofs_f 0\\~224-1 0 2DLut x offset, fraction part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. yofs_i 0\\~127 0 2DLut y offset, integer part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value. yofs_f 0\\~224-1 0 2DLut y offset, fraction part. It is recommend to set 0, if user need to adjust the DCE performance, user need to change the 2DLUT value.","title":"DCE Parameter Description"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#dc-table-generator","text":"For perspective projection application, in order to increase the convenience of usage, DCTG module let user to set the desired angle and size with an instinct way to generate DCE parameters automatically.","title":"DC Table Generator"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#overview_1","text":"DCTG generate DCE 2D-LUT for perspective projection. Whenever this function is enabled, manual set DCE 2D-LUT function will be invalid. Please refer to the following description: The \u201ctheta\u201d is the top/bottom angle. The \u201cphi\u201d is the rotate angle. The \u201crot_y\u201d is the rotate offset of (x, z) plane towards Y-axis. The \u201crot_z\u201d is the rotate offset of (x, y) plane towards Z-axis. Generate LUT: Define the rotate angle of FOV by phi_st/phi_ed, and then rotate to FOV location by rot_y. Define the top/bottom angle of FOV by theta_st/theta_ed, and then rotate to FOV location by rot_z.","title":"Overview"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#dctg-parameter-description","text":"Parameter Range Default Description dctg_en 0\\~1 0 DCTG ON/OFF \u203b DCTG and dce_2d_lut_en cannot be enabled at the same time. mount_type 0\\~1 0 Camera mount type. 0: Ceiling mount 1: Floor mount lut2d_sz 0\\~1 0 Select size of 2D look-up table, this parameter must the same with DCE parameter. 0: 9x9 1: (not supported) 2: (not supported) 3: 65x65 lens_r 0\\~215-1 0 Valid radius of fish-eye lens, the unit is pixel. Please refer to advance description. lens_x_st 0\\~214-1 0 The start x position of fish-eye lens at the source image, the unit is pixel. lens_y_st 0\\~214-1 0 The start y position of fish-eye lens at the source image, the unit is pixel. theta_st s4.16 -220 \\~ 220-1 0 FOV theta start radian. (-*pi \\~ *pi) theta_ed s4.16 -220 \\~ 220-1 (-*pi \\~ *pi) 0 FOV theta end radian. (-*pi \\~ *pi) theta_end > theta_st: normal image theta_end \\< theta_st: flip image phi_st s4.16 -220 \\~ 220-1 0 FOV phi start radian. (-2*pi \\~ 2*pi) phi_ed s4.16 -220 \\~ 220-1 0 FOV phi end radian. (-2*pi \\~ 2*pi) phi_end > theta_st: normal image phi_end \\< theta_st: flip image rot_z s4.16 -220 \\~ 220-1 0 Z-axis rotate radian. (-2*pi \\~ 2*pi) rot_y s4.16 -220 \\~ 220-1 0 Y-zxis rotate radian. (-2*pi \\~ 2*pi)","title":"DCTG Parameter Description"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html#advance-description","text":"lens_r: The valid radius of fish-eye device lens_x_ st : The start x position of fish-eye lens at the source image, the unit is pixel. lens_y_st : The start y position of fish-eye lens at the source image, the unit is pixel.","title":"Advance description:"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html","text":"Introduction \u00b6 PCIE Bus connects RC to EPs. HDAL media flow could be centrally controlled by RC site. However, data could be transferred from RC to one EP, or from one EP to RC. Please refer to NT9833x_PCIe_User_Guide_en.doc to get some basic concepts about PCIe. Fig 1. PCIE Bus diagram Some features about data-transfer between different chips are defined in this document. Data in shared memory could be transferred through PCIe. \u201cDownstream\u201d means data from RC (Root Complex) to EP (End Point). \u201cUpstream\u201d means data from EP to RC. Please refer to the following figure. Fig 2. PCIe Proprietary Parameter IDs and data structure definition \u00b6 Vendor PCIe function and data structure definition \u00b6 Function: vendor_pcie_rc_init \u00b6 [Description] Initialize parameters in RC, such as buffers, and so on. Only be executed in RC. [Syntax] INT vendor_pcie_rc_init(void) [Parameter] Value Description void none [Return Value] Value Description 0 Success -1 Failure Function: vendor_pcie_ep_init \u00b6 [Description] Initialize parameters in EP. [Syntax] INT vendor_pcie_ep_init(void) [Parameter] Value Description void none [Return Value] Value Description 0 Success -1 Failure Function: vendor_pcie_rc_uninit \u00b6 [Description] Un-initialize parameters in RC. [Syntax] INT vendor_pcie_rc_init(void) [Parameter] Value Description void none [Return Value] Value Description 0 Success -1 Failure Function: vendor_pcie_ep_uninit \u00b6 [Description] Un-nitialize parameters in EP. [Syntax] INT vendor_pcie_ep_uninit(void) [Parameter] Value Description void none [Return Value] Value Description 0 Success -1 Failure Function: vendor_pcie_get_chipid \u00b6 [Description] Get self chipid. RC as 0. [Syntax] HD_RESULT vendor_pcie_get_chipid(unsigned int *p_id); [Parameter] Value Description p_id chip_id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure \u00b6 Function: vendor_pcie_get_shared_mem \u00b6 [Description] Get a specific buffer that RC and EP could both access. [Syntax] HD_RESULT vendor_pcie_get_shared_mem(UINTPTR *p_shmem, unsigned long *size); [Parameter] Value Description p_shmem pointer to buffer size pointer to size [Return Value] Value Description HD_OK Success HD_ERR_NG Failure Function: vendor_pcie_get_ep_count \u00b6 [Description] Get EP counts. If count is zero, it means only RC. [Syntax] INT vendor_pcie_get_ep_count(void); [Parameter] Value Description void none [Return Value] Value Description count If 0, only RC. Function: vendor_pcie_get_ddrid_map \u00b6 [Description] Input a ddr_id to lookup in which chip. [Syntax] HD_RESULT vendor_pcie_get_ddrid_map(unsigned int ddr_id, unsigned int *p_chipid, unsigned int *p_ddridx); [Parameter] Value Description ddr_id input ddr_id p_chipid output chip_id p_ddridx output ddr_idx [Return Value] Value Description HD_OK Success HD_ERR_NG Failure Function: vendor_pcie_mem_mmap \u00b6 [Description] Get virtual address by inputing physical address with size. [Syntax] void *vendor_pcie_mem_mmap(UINTPTR phy_addr, UINT32 size); [Parameter] Value Description phy_addr a physical address size mapping size [Return Value] Value Description void * return a virtual address. Function: vendor_pcie_mem_munmap \u00b6 [Description] Unmap vitual address with size. [Syntax] HD_RESULT vendor_pcie_mem_munmap(void *va_addr, UINT32 size); [Parameter] Value Description va_addr a vitual address size mapping size [Return Value] Value Description HD_OK Success HD_ERR_NG Failure Function: vendor_pcie_get_upstream_pa \u00b6 [Description] Input physical address in RC. It will be transferred to new physical address for EP to access. [Syntax] HD_RESULT vendor_pcie_get_upstream_pa(UINTPTR rc_pa, UINTPTR *ep_pa); [Parameter] Value Description rc_pa Input physical address in RC *ep_pa Output physical address for EP to access [Return Value] Value Description HD_OK Success HD_ERR_NG Failure Function: vendor_pcie_get_downstream_pa \u00b6 [Description] Input physical address in EP. It will be transferred to new physical address for RC to access. [Syntax] HD_RESULT vendor_pcie_get_downstream_pa(UINTPTR ep_pa, UINTPTR *rc_pa); [Parameter] Value Description ep_pa Input physical address in EP *rc_pa Output physical address for RC to access [Return Value] Value Description HD_OK Success HD_ERR_NG Failure Function: vendor_pcie_rc_wakeup \u00b6 [Description] It is executed in RC, and it wakes up a specific EP. [Syntax] HD_RESULT vendor_pcie_rc_wakeup(INT ep_chipid); [Parameter] Value Description INT ep_chipid [Return Value] Value Description HD_OK Success HD_ERR_NG Failure Function: vendor_pcie_ep_wakeup \u00b6 [Description] It is executed in EP, it wakes up RC. [Syntax] HD_RESULT vendor_pcie_ep_wakeup(void); [Parameter] Value Description void none [Return Value] Value Description HD_OK Success HD_ERR_NG Failure Function: vendor_pcie_rc_wait \u00b6 [Description] It is executed in RC, it waits for a specific EP. [Syntax] HD_RESULT vendor_pcie_rc_wakeup(INT ep_chipid); [Parameter] Value Description INT ep_chipid [Return Value] Value Description HD_OK Success HD_ERR_NG Failure Function: vendor_pcie_ep_wait \u00b6 [Description] It is executed in EP, and it waits for RC. [Syntax] HD_RESULT vendor_pcie_ep_wakeup(void); [Parameter] Value Description void none [Return Value] Value Description HD_OK Success HD_ERR_NG Failure Function: vendor_pcie_rc_send \u00b6 [Description] RC sends some data to a specific EP by a specific channel. Also, set timeout interval in mini-seconds. [Syntax] HD_RESULT vendor_pcie_rc_send(INT ep_chipid, INT ep_chan_id, INT param_sz, VOID *p_param,INT timeout); [Parameter] Value Description ep_chipid a chip id of EP ep_chan_id a channel id of EP param_sz size of data p_param some parameters timeout timeout interval in ms [Return Value] Value Description HD_OK Success HD_ERR_NG Failure Function: vendor_pcie_rc_recv \u00b6 [Description] RC receives some data from a specific EP by a specific channel. Also, set timeout interval in mini-seconds. [Syntax] HD_RESULT vendor_pcie_rc_recv(INT ep_chipid, INT ep_chan_id, INT *param_sz, VOID *p_param,INT timeout); [Parameter] Value Description ep_chipid a chip id of EP ep_chan_id a channel id of EP *param_sz get size of data p_param some parameters timeout timeout interval in ms [Return Value] Value Description HD_OK Success HD_ERR_NG Failure Function: vendor_pcie_ep_send \u00b6 [Description] EP sends some data to the RC by a specific channel. Also, set timeout interval in mini-seconds. [Syntax] HD_RESULT vendor_pcie_ep_send(INT rc_chan_id, INT param_sz, VOID *p_param,INT timeout); [Parameter] Value Description rc_chan_id a channel id of RC param_sz size of data p_param some parameters timeout timeout interval in ms [Return Value] Value Description HD_OK Success HD_ERR_NG Failure Function: vendor_pcie_ep_recv \u00b6 [Description] EP receives some data from the RC by a specific channel. Also, set timeout interval in mini-seconds. [Syntax] HD_RESULT vendor_pcie_rc_recv(INT ep_chipid, INT ep_chan_id, INT *param_sz, VOID *p_param,INT timeout); [Parameter] Value Description ep_chipid a chip id of EP ep_chan_id a channel id of EP *param_sz get size of data p_param some parameters timeout timeout interval in ms [Return Value] Value Description HD_OK Success HD_ERR_NG Failure Function: vendor_pcie_gettime_us \u00b6 [Description] Get system time in us. [Syntax] unsigned long vendor_pcie_gettime_us(void); [Parameter] Value Description void none [Return Value] Value Description unsigned long System time in micro-second. Summary \u00b6 A summary for API user shows as below. The functions in green rows are executed in RC only. The functions in yellow rows could be executed in RC/EPs. Pseudo code for Data Transfer \u00b6 The following figure shows pseudo code for data transfer freely. RC/EP could use wakeup/wait to transfer any data. It suggests that data is put in other buffer, just some messages are put in pcie shared memory to inform other users. How to change buffer size for PCIe \u00b6 Find the nvt-mem-tbl.dtsi for wanted product. For example, configs/Linux/cfg_TEST_FPGA/nvt-mem-tbl.dtsi /* Linux system memory region*/ memory { device_type = \"memory\"; reg = <0x0 0x00000000 0x0 0x08000000>; }; ... nvt-pcie-lib-cfg { compatible = \"nvt,nvt-pcie-lib\"; rc_shm_size = <0x0 0x00100000>; /* [SIZE-H] [SIZE-L] */ #default size is 1MB. ep_alloc_mem = <0x1 0x0 0x18000000 0x0 0x08000000 /* < [CHIPID] [ADDR-H] [ADDR-L] [SIZE-H] [SIZE-L] */ >; }; ... The default setting for using PCIe buffer shows as below, User could change the size of each block when inserting kdrv_cc_event.ko. For example, \u201cmodprobe kdrv_cc_event.ko ai_buffer_size=0 pcie_xfer_size=80000\u201d, set ai_buffer to 0KB, pcie_xfer_buffer to 512KB, then other_buffer will be 512KB.","title":"Vendor PCie Programming Guide"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#introduction","text":"PCIE Bus connects RC to EPs. HDAL media flow could be centrally controlled by RC site. However, data could be transferred from RC to one EP, or from one EP to RC. Please refer to NT9833x_PCIe_User_Guide_en.doc to get some basic concepts about PCIe. Fig 1. PCIE Bus diagram Some features about data-transfer between different chips are defined in this document. Data in shared memory could be transferred through PCIe. \u201cDownstream\u201d means data from RC (Root Complex) to EP (End Point). \u201cUpstream\u201d means data from EP to RC. Please refer to the following figure. Fig 2. PCIe Proprietary","title":"Introduction"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#parameter-ids-and-data-structure-definition","text":"","title":"Parameter IDs and data structure definition"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#vendor-pcie-function-and-data-structure-definition","text":"","title":"Vendor PCIe function and data structure definition"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_rc_init","text":"[Description] Initialize parameters in RC, such as buffers, and so on. Only be executed in RC. [Syntax] INT vendor_pcie_rc_init(void) [Parameter] Value Description void none [Return Value] Value Description 0 Success -1 Failure","title":"Function: vendor_pcie_rc_init"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_ep_init","text":"[Description] Initialize parameters in EP. [Syntax] INT vendor_pcie_ep_init(void) [Parameter] Value Description void none [Return Value] Value Description 0 Success -1 Failure","title":"Function: vendor_pcie_ep_init"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_rc_uninit","text":"[Description] Un-initialize parameters in RC. [Syntax] INT vendor_pcie_rc_init(void) [Parameter] Value Description void none [Return Value] Value Description 0 Success -1 Failure","title":"Function: vendor_pcie_rc_uninit"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_ep_uninit","text":"[Description] Un-nitialize parameters in EP. [Syntax] INT vendor_pcie_ep_uninit(void) [Parameter] Value Description void none [Return Value] Value Description 0 Success -1 Failure","title":"Function: vendor_pcie_ep_uninit"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_get_chipid","text":"[Description] Get self chipid. RC as 0. [Syntax] HD_RESULT vendor_pcie_get_chipid(unsigned int *p_id); [Parameter] Value Description p_id chip_id [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"Function: vendor_pcie_get_chipid"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#_1","text":"","title":""},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_get_shared_mem","text":"[Description] Get a specific buffer that RC and EP could both access. [Syntax] HD_RESULT vendor_pcie_get_shared_mem(UINTPTR *p_shmem, unsigned long *size); [Parameter] Value Description p_shmem pointer to buffer size pointer to size [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"Function: vendor_pcie_get_shared_mem"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_get_ep_count","text":"[Description] Get EP counts. If count is zero, it means only RC. [Syntax] INT vendor_pcie_get_ep_count(void); [Parameter] Value Description void none [Return Value] Value Description count If 0, only RC.","title":"Function: vendor_pcie_get_ep_count"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_get_ddrid_map","text":"[Description] Input a ddr_id to lookup in which chip. [Syntax] HD_RESULT vendor_pcie_get_ddrid_map(unsigned int ddr_id, unsigned int *p_chipid, unsigned int *p_ddridx); [Parameter] Value Description ddr_id input ddr_id p_chipid output chip_id p_ddridx output ddr_idx [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"Function: vendor_pcie_get_ddrid_map"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_mem_mmap","text":"[Description] Get virtual address by inputing physical address with size. [Syntax] void *vendor_pcie_mem_mmap(UINTPTR phy_addr, UINT32 size); [Parameter] Value Description phy_addr a physical address size mapping size [Return Value] Value Description void * return a virtual address.","title":"Function: vendor_pcie_mem_mmap"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_mem_munmap","text":"[Description] Unmap vitual address with size. [Syntax] HD_RESULT vendor_pcie_mem_munmap(void *va_addr, UINT32 size); [Parameter] Value Description va_addr a vitual address size mapping size [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"Function: vendor_pcie_mem_munmap"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_get_upstream_pa","text":"[Description] Input physical address in RC. It will be transferred to new physical address for EP to access. [Syntax] HD_RESULT vendor_pcie_get_upstream_pa(UINTPTR rc_pa, UINTPTR *ep_pa); [Parameter] Value Description rc_pa Input physical address in RC *ep_pa Output physical address for EP to access [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"Function: vendor_pcie_get_upstream_pa"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_get_downstream_pa","text":"[Description] Input physical address in EP. It will be transferred to new physical address for RC to access. [Syntax] HD_RESULT vendor_pcie_get_downstream_pa(UINTPTR ep_pa, UINTPTR *rc_pa); [Parameter] Value Description ep_pa Input physical address in EP *rc_pa Output physical address for RC to access [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"Function: vendor_pcie_get_downstream_pa"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_rc_wakeup","text":"[Description] It is executed in RC, and it wakes up a specific EP. [Syntax] HD_RESULT vendor_pcie_rc_wakeup(INT ep_chipid); [Parameter] Value Description INT ep_chipid [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"Function: vendor_pcie_rc_wakeup"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_ep_wakeup","text":"[Description] It is executed in EP, it wakes up RC. [Syntax] HD_RESULT vendor_pcie_ep_wakeup(void); [Parameter] Value Description void none [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"Function: vendor_pcie_ep_wakeup"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_rc_wait","text":"[Description] It is executed in RC, it waits for a specific EP. [Syntax] HD_RESULT vendor_pcie_rc_wakeup(INT ep_chipid); [Parameter] Value Description INT ep_chipid [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"Function: vendor_pcie_rc_wait"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_ep_wait","text":"[Description] It is executed in EP, and it waits for RC. [Syntax] HD_RESULT vendor_pcie_ep_wakeup(void); [Parameter] Value Description void none [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"Function: vendor_pcie_ep_wait"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_rc_send","text":"[Description] RC sends some data to a specific EP by a specific channel. Also, set timeout interval in mini-seconds. [Syntax] HD_RESULT vendor_pcie_rc_send(INT ep_chipid, INT ep_chan_id, INT param_sz, VOID *p_param,INT timeout); [Parameter] Value Description ep_chipid a chip id of EP ep_chan_id a channel id of EP param_sz size of data p_param some parameters timeout timeout interval in ms [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"Function: vendor_pcie_rc_send"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_rc_recv","text":"[Description] RC receives some data from a specific EP by a specific channel. Also, set timeout interval in mini-seconds. [Syntax] HD_RESULT vendor_pcie_rc_recv(INT ep_chipid, INT ep_chan_id, INT *param_sz, VOID *p_param,INT timeout); [Parameter] Value Description ep_chipid a chip id of EP ep_chan_id a channel id of EP *param_sz get size of data p_param some parameters timeout timeout interval in ms [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"Function: vendor_pcie_rc_recv"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_ep_send","text":"[Description] EP sends some data to the RC by a specific channel. Also, set timeout interval in mini-seconds. [Syntax] HD_RESULT vendor_pcie_ep_send(INT rc_chan_id, INT param_sz, VOID *p_param,INT timeout); [Parameter] Value Description rc_chan_id a channel id of RC param_sz size of data p_param some parameters timeout timeout interval in ms [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"Function: vendor_pcie_ep_send"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_ep_recv","text":"[Description] EP receives some data from the RC by a specific channel. Also, set timeout interval in mini-seconds. [Syntax] HD_RESULT vendor_pcie_rc_recv(INT ep_chipid, INT ep_chan_id, INT *param_sz, VOID *p_param,INT timeout); [Parameter] Value Description ep_chipid a chip id of EP ep_chan_id a channel id of EP *param_sz get size of data p_param some parameters timeout timeout interval in ms [Return Value] Value Description HD_OK Success HD_ERR_NG Failure","title":"Function: vendor_pcie_ep_recv"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#function-vendor_pcie_gettime_us","text":"[Description] Get system time in us. [Syntax] unsigned long vendor_pcie_gettime_us(void); [Parameter] Value Description void none [Return Value] Value Description unsigned long System time in micro-second.","title":"Function: vendor_pcie_gettime_us"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#summary","text":"A summary for API user shows as below. The functions in green rows are executed in RC only. The functions in yellow rows could be executed in RC/EPs.","title":"Summary"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#pseudo-code-for-data-transfer","text":"The following figure shows pseudo code for data transfer freely. RC/EP could use wakeup/wait to transfer any data. It suggests that data is put in other buffer, just some messages are put in pcie shared memory to inform other users.","title":"Pseudo code for Data Transfer"},{"location":"Software/MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html#how-to-change-buffer-size-for-pcie","text":"Find the nvt-mem-tbl.dtsi for wanted product. For example, configs/Linux/cfg_TEST_FPGA/nvt-mem-tbl.dtsi /* Linux system memory region*/ memory { device_type = \"memory\"; reg = <0x0 0x00000000 0x0 0x08000000>; }; ... nvt-pcie-lib-cfg { compatible = \"nvt,nvt-pcie-lib\"; rc_shm_size = <0x0 0x00100000>; /* [SIZE-H] [SIZE-L] */ #default size is 1MB. ep_alloc_mem = <0x1 0x0 0x18000000 0x0 0x08000000 /* < [CHIPID] [ADDR-H] [ADDR-L] [SIZE-H] [SIZE-L] */ >; }; ... The default setting for using PCIe buffer shows as below, User could change the size of each block when inserting kdrv_cc_event.ko. For example, \u201cmodprobe kdrv_cc_event.ko ai_buffer_size=0 pcie_xfer_size=80000\u201d, set ai_buffer to 0KB, pcie_xfer_buffer to 512KB, then other_buffer will be 512KB.","title":"How to change buffer size for PCIe"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html","text":"PCIe basic concepts \u00b6 PCIe cascade \u00b6 Two NT9833x can be cascaded over PCIe to perform more powerful functions. Jobs on the RC (root complex), can be dispatched to EP (endpoint) to accomplish. The communication of data is through shared memory and interrupt notification which implemented by HDAL. Once two chips are cascaded, it can be seen as a chip with double HW engines and double CPUs. However, to access memory of a remote chip, a remote memory address needs to be converted to a local mapped physical address, or called a PCIe address. The following sections will introduce the mapping concepts and remote read/write definitions. Mapping concepts \u00b6 To access memory of a remote chip, a remote address should be converted to a local PCIe address. A mapped PCIe address represents resources of outer PCIe devices, including a cascaded NT9833x EP. As the figure shown below, on RC side the lower addresses are used by local dram and peripheral IO, while the upper addresses are used for remote PCIe resources, such as EP dram or EP peripherals. On the other hand, the lower addresses on EP side are used by local dram and peripherals of EP. And the upper addresses are mapped to dram and peripherals of RC. We call the direction from RC to EP \u201cdownstream\u201d and the opposite direction as \u201cupstream\u201d. Because RC stands for \u201croot complex\u201d which is on the top of PCIe connections. Moreover, a dram region could be composed of multiple DDR blocks. The first DDR of dram is index 0, and the second DDR is index 1, etc. Remote read / write \u00b6 RC (Root Complex) and EP (Endpoint) either could be the role of local or remote. Where the driver or application is executing in, that side is called the local side. And its opposite side is called the remote side. If data is transferred from local to remote, it is called \u201cRemote write\u201d. On the contrary, if data is moved from remote to local, it is called \u201cRemote read\u201d. Kernel configurations \u00b6 The below introduces kernel configurations about NVT PCIe Library. CONFIG_NVT_PCIE_LIB is the configuration to enable NVT PCIe Library. NVT PCIe Library provides status querying, address conversion between RC and EP, and a common shared memory. It is transparent to PCIe HW. If EP does not exist, relative APIs will get an error returned, but not compiler errors. CONFIG_NVT_PCIE_CASCADE_DRV is the driver to handle HW dependent initialization of PCIe cascade. It is a proprietary driver of NVT. The implementation is different from Linux common framework. Please note that it depends on \u201cNVT_PCIE_LIB\u201d and \u201c!PCI\u201d. It means NVT PCIe cascade driver requires NVT PCIe Library to provide services for upper layers. And if Linux PCIe common framework is enabled, NVT PCIe cascade driver will be disabled automatically. CONFIG_NVT_PCIE_LIB: Novatek PCIe Library. Symbol: NVT_PCIE_LIB [=y] Type : bool Prompt: Novatek PCIe Library Location: -> Device Drivers -> SOC (System On Chip) specific Drivers -> NovaTek SoC drivers -> NovaTek SoC Basic drivers CONFIG_NVT_PCIE_CASCADE_DRV: Novatek PCIe cascade. Symbol: NVT_PCIE_CASCADE_DRV [=y] Type : bool Prompt: Novatek PCIe cascade Location: -> Device Drivers -> SOC (System On Chip) specific Drivers -> NovaTek SoC drivers -> NovaTek SoC Basic drivers -> Novatek PCIe Library (NVT_PCIE_LIB [=y]) Defined at drivers/soc/nvt/basic/Kconfig:24 Depends on: (ARCH_NVT_IVOT_V7 || ARCH_NVT_IVOT_V8 [=y]) && NVT_PCIE_LIB [=y] && NVT_IVOT_PLAT_NA51090 [=y] && !PCI [=n] Device tree configurations \u00b6 nvt-pcie-cascade-drv \u00b6 There are two device tree nodes (\u201cnvt_pcie: pcie@2,f04f0000\u201d and \u201cnvt_ep0\u201d) to describe pcie hw behavior in the file nvt-peri.dtsi. In most time, it is not needed/encouraged to modify these device tree nodes. Parameters may be modified are: \u201cdma-ranges\u201d in \u201cnvt_pcie: pcie@2,f04f0000\u201d \u00b6 \u201cdma-ranges\u201d is used to describe memory/register exported by RC to EP. Its format has 4 fields: type (don\u2019t care now), pcie address, system address, and size. For example, below line represents map pcie address 0xC_0000_0000 to 33x internal address 0x0_0000_0000 with size 0x2_0000_0000: 0x83000000 0x0C 0x00000000 0x00 0x00000000 0x02 0x00000000 /* RC MAU */ nvt_pcie: pcie@2,f04f0000 { compatible = \"nvt,nvt_pcie_drv\"; \u2026 #interrupt-cells = <3>; interrupt-controller; interrupt-parent = <&gic>; #address-cells = <3>; #size-cells = <2>; dma-ranges = <0x83000000 0x0C 0x00000000 0x00 0x00000000 0x02 0x00000000 /* RC MAU */ 0x83000001 0x0E 0x00000000 0x02 0xF0000000 0 0x10000000>; /* RC APB */ /* refclk-out = <0>; */ }; \u201creg\u201d in \u201cnvt_ep0\u201d \u00b6 \u201creg\u201d is used to describe pcie address mapping of EP internal resource. It expects fixed sequence to describe mapping of MAU, ATU, APB registers. Its format has 2 fields: pcie address, and size (The internal system address is not allowed to modify). For example, below line represents map pcie address 0x4_0000_0000 to EP MAU with size 0x2_0000_0000. 0x04 0x00000000 0x02 0x00000000 /* MAU */ nvt_ep0 { reg = <0x04 0x00000000 0x02 0x00000000 /* MAU */ 0x06 0x10000000 0x00 0x10000000 /* ATU */ 0x06 0x20000000 0x00 0x10000000>; /* APB */ }; \u201crefclk-out\u201d in \u201cnvt_pcie: pcie@2,f04f0000\u201d \u00b6 PCIe spec defines a differential clock signal as clock source of each pcie device (i.e. RC, EP). Novatek suggests use external clock buffer IC to generate 100 MHz refclk to 33x RC/EP 33x RC can be configured to output 100 MHz to cascaded EP by device tree parameter \u201crefclk-out\u201d. However, 33x refclk jitter may exceeds 300ppm defined by PCIe spec. Use it by your own risk!! Requirements of outputting REFCLK are: Bootstrap BS[10] should be tied to LOW (for detail bootstrap description, please refer to NT9833x datasheet) 10 PCIE_REFCLK_BOOT_SEL Select REFCLK source (This will effect default value of register PCIE_REFCLK_SRC) 0: from MPLL5 1: from REFCLK pad Enable refclk-out at device tree node: nvt_pcie: pcie@2,f04f0000 { compatible = \"nvt,nvt_pcie_drv\"; \u2026 #interrupt-cells = <3>; interrupt-controller; interrupt-parent = <&gic>; #address-cells = <3>; #size-cells = <2>; dma-ranges = <0x83000000 0x0C 0x00000000 0x00 0x00000000 0x02 0x00000000 /* RC MAU */ 0x83000001 0x0E 0x00000000 0x02 0xF0000000 0 0x10000000>; /* RC APB */ refclk-out = <1>; }; nvt-pcie-lib \u00b6 The relative configurations are defined by node \u201cnvt-pcie-lib-cfg\u201d in the file nvt-mem-tbl-common.dtsi. \u201crc_shm_size\u201d represents the shared memory size. This memory space is allocated from kernel memory at RC side. And the physical address will be passed to EP side through internal registers. \u201cep_alloc_mem\u201d represents EP memory regions which can be allocated by RC users. That means these memory regions belong to EP, but RC users can allocate and put some data directly to these regions through PCIe. This kind of allocation should use nvt-pcie-lib API to accomplish. nvt-pcie-lib-cfg { compatible = \"nvt,nvt-pcie-lib\"; rc_shm_size = <0x0 0x00100000>; /* [SIZE-H] [SIZE-L] */ ep_alloc_mem = <0x1 0x0 0x18000000 0x0 0x08000000>; /* < [CHIPID] [ADDR-H] [ADDR-L] [SIZE-H] [SIZE-L] */ }; nvt-pcie-lib API introduction \u00b6 Address conversion \u00b6 nvtpcie_get_upstream_pa \u00b6 [Description] From the view of EP side, get a mapped physical address to an upstream physical address of RC. [Syntax] phys_addr_t nvtpcie_get_upstream_pa(nvtpcie_chipid_t ep_chipid, phys_addr_t rc_pa); [Parameter] Value Description ep_chipid EP chip id rc_pa Physical address of RC [Return Value] Value Description NVTPCIE_INVALID_PA (-1) Failure Other values The mapped physical address nvtpcie_get_downstream_pa \u00b6 [Description] From the view of RC side, get a mapped physical address to a downstream physical address of EP. [Syntax] phys_addr_t nvtpcie_get_downstream_pa(nvtpcie_chipid_t ep_chipid, phys_addr_t ep_pa); [Parameter] Value Description ep_chipid EP chip id ep_pa Physical address of EP [Return Value] Value Description NVTPCIE_INVALID_PA (-1) Failure Other values The mapped physical address nvtpcie_get_pcie_addr \u00b6 [Description] Get a mapped physical address on the local chip. If the target DDR id is at the same chip as the local chip, the tar_pa is just returned. Otherwise, a mapped address will be returned, which is converted automatically by the given parameters. Please note that the returned address is on the view of the local chip. [Syntax] phys_addr_t nvtpcie_get_pcie_addr(nvtpcie_chipid_t loc_chipid, nvtpcie_ddrid_t tar_ddrid, phys_addr_t tar_pa); [Parameter] Value Description loc_chipid Local chip id tar_ddrid target DDR id tar_pa target physical address [Return Value] Value Description NVTPCIE_INVALID_PA (-1) Failure Other values The mapped physical address nvtpcie_get_mapped_pa \u00b6 [Description] Get a mapped physical address on the local chip automatically by the given parameters. The returned address could be upstream or downstream depending on the direction of the local chip id and the target chip id. [Syntax] phys_addr_t nvtpcie_get_mapped_pa(nvtpcie_chipid_t loc_chipid, nvtpcie_chipid_t tar_chipid, phys_addr_t tar_pa); [Parameter] Value Description loc_chipid Local chip id tar_chipid Target chip id tar_pa Target physical address [Return Value] Value Description NVTPCIE_INVALID_PA (-1) Failure Other values The mapped physical address nvtpcie_get_unmapped_pa \u00b6 [Description] Get an unmapped physical address by the given chip id and the mapped address. This is used to revert a mapped address to its original physical address of the target chip. The target chip id can be get from ret_map_chipid. If it is not needed, please set it NULL. [Syntax] phys_addr_t nvtpcie_get_unmapped_pa(nvtpcie_chipid_t loc_chipid, phys_addr_t mapped_pa, nvtpcie_chipid_t *ret_map_chipid); [Parameter] Value Description loc_chipid Local chip id mapped_pa A mapped physical address ret_map_chipid The mapped chip (optional, NULL if not needed) [Return Value] Value Description NVTPCIE_INVALID_PA (-1) Failure Other values The unmapped physical address Shared memory \u00b6 nvtpcie_shmem_dump \u00b6 [Description] Dump the shared memory data by a specific length. [Syntax] void nvtpcie_shmem_dump(unsigned long length); [Parameter] Value Description length The length size to be dumped [Return Value] None nvtpcie_shmem_get_va \u00b6 [Description] Get the virtual address of the shared memory. [Syntax] void *nvtpcie_shmem_get_va(void); [Parameter] None [Return Value] Value Description NULL Failure Other values The virtual address of shared memory nvtpcie_shmem_get_pa \u00b6 [Description] Get the physical address of the shared memory. [Syntax] phys_addr_t nvtpcie_shmem_get_pa(void); [Parameter] None [Return Value] Value Description NVTPCIE_INVALID_PA (-1) Failure Other values The physical address of shared memory nvtpcie_shmem_get_size \u00b6 [Description] Get the shared memory size. [Syntax] unsigned long nvtpcie_shmem_get_size(void); [Parameter] None [Return Value] Value Description 0 Failure. No shared memory. Other values The size of shared memory EP utility \u00b6 nvtpcie_alloc_epmem \u00b6 [Description] Allocate a memory region from EP to use at RC. The output parameter ret_ep_pa is the mapped physical address at RC side. And the returned value is the virtual address of that physical address. To get the virtual address, an \u201cioremap\u201d operation is applied when the API is called. You can use this address in kernel-space directly without mapping again. [Syntax] void *nvtpcie_alloc_epmem(nvtpcie_chipid_t ep_chipid, unsigned long alloc_size, phys_addr_t *ret_ep_pa); [Parameter] Value Description ep_chipid EP chip id alloc_size The size to be allocated ret_ep_pa The physical address of allocated memory [Return Value] Value Description NULL Failure Other values The virtual address of allocated memory nvtpcie_downstream_active \u00b6 [Description] Check whether the downstream EP is active or not at RC side. [Syntax] int nvtpcie_downstream_active(nvtpcie_chipid_t ep_chipid); [Parameter] Value Description ep_chipid EP chip id [Return Value] Value Description 1 active 0 inactive nvtpcie_get_ep_count \u00b6 [Description] Get the active EP count [Syntax] int nvtpcie_get_ep_count(void); [Parameter] None [Return Value] Value Description 0 Failure Other values EP numbers Mapping Info. \u00b6 nvtpcie_get_ddrid \u00b6 [Description] Get the DDR id by the given parameters. The input physical address \u201cloc_pa\u201d could be a real DDR region or a mapped PCIe region. [Syntax] nvtpcie_ddrid_t nvtpcie_get_ddrid(nvtpcie_chipid_t loc_chipid, phys_addr_t loc_pa); [Parameter] Value Description loc_chipid Local chip id loc_pa Local physical address [Return Value] Value Description DDR_ID_MAX Failure Other values DDR id nvtpcie_get_ddrid_map \u00b6 [Description] Convert a specific DDR id to its chip id and the DDR index. [Syntax] int nvtpcie_get_ddrid_map(nvtpcie_ddrid_t ddrid, nvtpcie_chipid_t *out_chipid, nvtpcie_ddrid_t *out_ddridx); [Parameter] Value Description ddrid DDR id out_chipid Output chip id out_ddridx Output DDR index [Return Value] Value Description 0 Success -1 Failure Misc. \u00b6 nvtpcie_get_my_chipid \u00b6 [Description] Get the current chip id. (RC or EPn) [Syntax] nvtpcie_chipid_t nvtpcie_get_my_chipid(void); [Parameter] None [Return Value] Value Description Chip id The chip id at the caller side nvtpcie_edma_copy \u00b6 [Description] Copy data across PCIe using eDMA. The source and destination chip ids are assumed to be different. [Syntax] int nvtpcie_edma_copy(nvtpcie_chipid_t src_chipid, phys_addr_t src_pa, nvtpcie_chipid_t dst_chipid, phys_addr_t dst_pa, unsigned long len); [Parameter] Value Description src_chipid Chip id of the source src_pa Physical address of the source dst_chipid Chip id of the destination dst_pa Physical address of the destination len Size to be copied [Return Value] Value Description 0 Success -1 Failure /proc interface \u00b6 A \u201c/proc\u201d interface is provided for debugging or dumping some information. To list all commands, you can \u201ccat\u201d the \u201c/proc/nvt-pcie-lib/help\u201d node. To trigger a command, please use \u201cecho [your command] >\u201d to the \u201c/proc/nvt-pcie-lib/cmd\u201d node. The below demonstrates how to use it. List all commands \u00b6 root@NVTEVM:/$ cat /proc/nvt-pcie-lib/help cmd_list: dump perf test version Show version \u00b6 root@NVTEVM:/$ echo version > /proc/nvt-pcie-lib/cmd [ 190.162430] PROC_CMD: [version], size 8 [ 190.168264] nvt-pcie-lib: 0.0.16 Show configurations \u00b6 root@NVTEVM:/$ echo dump > /proc/nvt-pcie-lib/cmd PROC_CMD: [dump], size 5 rc_dumpmap local_pa, size, name, ep_chipid, ep_pa [0] 0x0000000400000000, 0x0000000200000000, mau, 1, 0x0000000000000000 [1] 0x0000000620000000, 0x0000000010000000, apb, 1, 0x00000002F0000000 [2] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [3] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [4] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [5] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [6] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [7] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [8] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [9] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [10] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [11] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [12] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [13] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [14] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [15] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [16] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [17] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 ep_upmap local_pa, size, name, rc_pa [0] 0x0000000C00000000, 0x0000000200000000, mau, 0x0000000000000000 [1] 0x0000000E00000000, 0x0000000010000000, apb, 0x00000002F0000000 ddr_map ddrid, chipid, ddridx, chip_base, size [0] 0, 0, 0, 0x0000000000000000, 0x40000000 [1] 1, 0, 1, 0x0000000100000000, 0x40000000 [2] 2, 1, 0, 0x0000000000000000, 0x40000000 [3] 3, 1, 1, 0x0000000100000000, 0x40000000 [4] 0, 0, 0, 0x0000000000000000, 0x00000000 [5] 0, 0, 0, 0x0000000000000000, 0x00000000 [6] 0, 0, 0, 0x0000000000000000, 0x00000000 [7] 0, 0, 0, 0x0000000000000000, 0x00000000 ep_allocmem ep_chipid, ep_local_pa, size, rc_map_pa, rc_map_va [0] 1, 0x0000000018000000, 0x08000000, 0x0000000418000000, 0xFFFFFF8010000000 [1] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [2] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [3] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [4] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [5] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [6] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [7] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 dump va=FFFFFF8008D4D000, pa=2C100000 length=00000100 to console: 2C100000 : 00000000 00000000 00000000 00000000 ............... 2C100010 : 00000000 00000000 00000000 00000000 ............... 2C100020 : 00000000 00000000 00000000 00000000 ............... 2C100030 : 00000000 00000000 00000000 00000000 ............... 2C100040 : 00000000 00000000 00000000 00000000 ............... 2C100050 : 00000000 00000000 00000000 00000000 ............... 2C100060 : 00000000 00000000 00000000 00000000 ............... 2C100070 : 00000000 00000000 00000000 00000000 ............... 2C100080 : 00000000 00000000 00000000 00000000 ............... 2C100090 : 00000000 00000000 00000000 00000000 ............... 2C1000A0 : 00000000 00000000 00000000 00000000 ............... 2C1000B0 : 00000000 00000000 00000000 00000000 ............... 2C1000C0 : 00000000 00000000 00000000 00000000 ............... 2C1000D0 : 00000000 00000000 00000000 00000000 ............... 2C1000E0 : 00000000 00000000 00000000 00000000 ............... 2C1000F0 : 00000000 00000000 00000000 00000000 ............... nvtpcie_get_ep_count = 1 Run a self-test \u00b6 Please note that a self-test may occupy system resources or conflict with other running services. Only run a self-test under a debug environment. root@NVTEVM:/$ echo test > /proc/nvt-pcie-lib/cmd PROC_CMD: [test], size 5 nvtpcie_get_ddrid_map ddr_map ddrid, chipid, ddridx, chip_base, size [0] 0, 0, 0, 0x0000000000000000, 0x40000000 [1] 1, 0, 1, 0x0000000100000000, 0x40000000 [2] 2, 1, 0, 0x0000000000000000, 0x40000000 [3] 3, 1, 1, 0x0000000100000000, 0x40000000 [4] 0, 0, 0, 0x0000000000000000, 0x00000000 [5] 0, 0, 0, 0x0000000000000000, 0x00000000 [6] 0, 0, 0, 0x0000000000000000, 0x00000000 [7] 0, 0, 0, 0x0000000000000000, 0x00000000 nvtpcie_get_ep_count = 1 nvtpcie_get_ddrid test chipid 0, pa 0x0000000001110000 => ddrid 0 chipid 0, pa 0x0000000042220000 => ddrid 8 chipid 0, pa 0x00000002F0110084 => ddrid 8 chipid 0, pa 0x0000000401110000 => ddrid 2 chipid 0, pa 0x0000000442220000 => ddrid 8 chipid 0, pa 0x0000000620110000 => ddrid 8 chipid 1, pa 0x0000000001110000 => ddrid 2 chipid 1, pa 0x0000000042220000 => ddrid 8 chipid 1, pa 0x00000002F0110084 => ddrid 8 chipid 1, pa 0x0000000C01110000 => ddrid 0 chipid 1, pa 0x0000000C42220000 => ddrid 8 chipid 1, pa 0x0000000E00110000 => ddrid 8 nvtpcie_get_upstream_pa ep_chipid 1, rc_pa 0x0000000001110000, ep_ups_pa 0x0000000C01110000 ep_chipid 1, rc_pa 0x0000000042220000, ep_ups_pa 0x0000000C42220000 ep_chipid 1, rc_pa 0x00000002F0110084, ep_ups_pa 0x0000000E00110084 nvtpcie_get_downstream_pa ep_chipid 1, ep_pa 0x0000000001110000, rc_down_pa 0x0000000401110000 ep_chipid 1, ep_pa 0x0000000042220000, rc_down_pa 0x0000000442220000 ep_chipid 1, ep_pa 0x00000002F0110084, rc_down_pa 0x0000000620110084 _nvtpcie_reg_test pa 0x620110084 org_val = 0x0 new_val = 0x12345678 chk_val = 0x0 nvtpcie_get_pcie_addr local: loc_chipid 0, tar_ddrid 0, tar_pa 0x0000000001110000, pcie_pa 0x0000000001110000 downstream: loc_chipid 0, tar_ddrid 2, tar_pa 0x0000000001110000, pcie_pa 0x0000000401110000 upstream: loc_chipid 1, tar_ddrid 0, tar_pa 0x0000000001110000, pcie_pa 0x0000000C01110000 nvtpcie_get_mapped_pa and nvtpcie_get_unmapped_pa nvtpcie_shmem_xxx test shmem pa 0x000000002C100000, va 0xFFFFFF8008D4D000, size 0x100000 nvtpcie_alloc_epmem ep_allocmem ep_chipid, ep_local_pa, size, rc_map_pa, rc_map_va [0] 1, 0x0000000018000000, 0x08000000, 0x0000000418000000, 0xFFFFFF8010000000 [1] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [2] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [3] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [4] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [5] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [6] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [7] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 alloc_epmem 1: ep_chipid 1, len 65536, p_rc_va 0xFFFFFF8010282000, ret_ep_pa 0x0000000018282000 alloc_epmem 2: ep_chipid 1, len 65536, p_rc_va 0xFFFFFF8010292000, ret_ep_pa 0x0000000018292000 alloc_epmem 3: ep_chipid 1, len 65536, p_rc_va 0xFFFFFF80102A2000, ret_ep_pa 0x00000000182A2000 nvtpcie_downstream_active ep_chipid 1, is_active 1 nvtpcie_edma_copy test edma_copy: chip 0 pa 0x0000000001110000 => chip 1 pa 0x0000000001110000 edma_copy: chip 1 pa 0x0000000001110000 => chip 0 pa 0x0000000001110000 edma test done root@NVTEVM:/$ Run a performance test \u00b6 A series of performance tests will be performed sequentially. Each test is performed 10 times, and the average value will be shown at the end. root@NVTEVM:/$ echo perf > /proc/nvt-pcie-lib/cmd PROC_CMD: [perf], size 5 [REMOTE READ (edma)] loop_num 10, 1048576 bytes, dur_us 1202 loop_num 9, 1048576 bytes, dur_us 1199 loop_num 8, 1048576 bytes, dur_us 1200 loop_num 7, 1048576 bytes, dur_us 1199 loop_num 6, 1048576 bytes, dur_us 1199 loop_num 5, 1048576 bytes, dur_us 1200 loop_num 4, 1048576 bytes, dur_us 1199 loop_num 3, 1048576 bytes, dur_us 1199 loop_num 2, 1048576 bytes, dur_us 1199 loop_num 1, 1048576 bytes, dur_us 1199 avg: 953250 KB/s (10485760 bytes / 11995 us) [REMOTE READ (memcpy_fromio)] loop_num 10, 1048576 bytes, dur_us 139336 loop_num 9, 1048576 bytes, dur_us 139164 loop_num 8, 1048576 bytes, dur_us 139908 loop_num 7, 1048576 bytes, dur_us 140222 loop_num 6, 1048576 bytes, dur_us 139864 loop_num 5, 1048576 bytes, dur_us 139374 loop_num 4, 1048576 bytes, dur_us 139845 loop_num 3, 1048576 bytes, dur_us 140014 loop_num 2, 1048576 bytes, dur_us 139935 loop_num 1, 1048576 bytes, dur_us 140179 avg: 7505 KB/s (10485760 bytes / 1397841 us) [LOCAL READ (memcpy_fromio)] loop_num 10, 1048576 bytes, dur_us 764 loop_num 9, 1048576 bytes, dur_us 765 loop_num 8, 1048576 bytes, dur_us 718 loop_num 7, 1048576 bytes, dur_us 718 loop_num 6, 1048576 bytes, dur_us 700 loop_num 5, 1048576 bytes, dur_us 719 loop_num 4, 1048576 bytes, dur_us 806 loop_num 3, 1048576 bytes, dur_us 706 loop_num 2, 1048576 bytes, dur_us 805 loop_num 1, 1048576 bytes, dur_us 709 avg: 1497965 KB/s (10485760 bytes / 7410 us) [REMOTE WRITE (edma)] loop_num 10, 1048576 bytes, dur_us 1179 loop_num 9, 1048576 bytes, dur_us 1176 loop_num 8, 1048576 bytes, dur_us 1176 loop_num 7, 1048576 bytes, dur_us 1176 loop_num 6, 1048576 bytes, dur_us 1176 loop_num 5, 1048576 bytes, dur_us 1176 loop_num 4, 1048576 bytes, dur_us 1175 loop_num 3, 1048576 bytes, dur_us 1176 loop_num 2, 1048576 bytes, dur_us 1176 loop_num 1, 1048576 bytes, dur_us 1175 avg: 953250 KB/s (10485760 bytes / 11761 us) [REMOTE WRITE (memcpy_toio)] loop_num 10, 1048576 bytes, dur_us 4298 loop_num 9, 1048576 bytes, dur_us 4285 loop_num 8, 1048576 bytes, dur_us 4288 loop_num 7, 1048576 bytes, dur_us 4285 loop_num 6, 1048576 bytes, dur_us 4285 loop_num 5, 1048576 bytes, dur_us 4287 loop_num 4, 1048576 bytes, dur_us 4285 loop_num 3, 1048576 bytes, dur_us 4285 loop_num 2, 1048576 bytes, dur_us 4300 loop_num 1, 1048576 bytes, dur_us 4304 avg: 249660 KB/s (10485760 bytes / 42902 us) [LOCAL WRITE (memcpy_toio)] loop_num 10, 1048576 bytes, dur_us 716 loop_num 9, 1048576 bytes, dur_us 726 loop_num 8, 1048576 bytes, dur_us 743 loop_num 7, 1048576 bytes, dur_us 722 loop_num 6, 1048576 bytes, dur_us 714 loop_num 5, 1048576 bytes, dur_us 722 loop_num 4, 1048576 bytes, dur_us 714 loop_num 3, 1048576 bytes, dur_us 715 loop_num 2, 1048576 bytes, dur_us 714 loop_num 1, 1048576 bytes, dur_us 700 avg: 1497965 KB/s (10485760 bytes / 7186 us) uboot init flow \u00b6 PCIe link and mapping are initialized in uboot phase. It is located at u-boot/board/novatek/nvt-na51090-a64/nvt_pcie/nvt_pcie_mapping.c. In most cases, you are not required to touch this file. However, if you need to understand how it works, below flow chart can give you a brief view of PCIe init: Trouble shooting \u00b6 Which driver support running on RC and controlling hw on EP? \u00b6 Ans: These system drivers can support: GPIO, USB host, pinctrl, clock, I2C, wdt, PWM, adc, uart, DDR arbiter, efuse, thermal, SATA. For HDAL related driver, please refer to HDAL documents. I concern there are any error on PCIe bus. If there any way to observe errors below transaction layer? \u00b6 Ans: You can cat file pcie_sts under /proc/nvt_pcie. root@NVTEVM:/proc/nvt_pcie$ cat pcie_sts [ 448.049669] [ 448.051302] [ 448.051302] Error count: [ 448.055655] uncorr_error_cnt: 0 [ 448.058875] rx_error_cnt: 0 [ 448.061790] [ 448.061790] ===================== [ 448.066951] 0x2F08B301C: 0x 370004 [ 448.070535] 0x2F08B3018: 0x 1707 [ 448.074104] [ 448.074104] ===================== [ 448.079233] [ 448.079233] Test RAS D.E.S --- event count analysis function [ 448.086643] Grp 0 : [ 448.086651] 0 [EBUF Overflow ]: 0x 0, [ 448.088746] 1 [EBUF Under-run ]: 0x 0, [ 448.093978] 2 [Decode Error ]: 0x 0, [ 448.099194] 3 [Running Disparity Error ]: 0x 0, [ 448.104435] 4 [SKP OS Parity Error ]: 0x 0, [ 448.109649] 5 [SYNC Header Error ]: 0x 0, [ 448.114881] 6 [Rx Valid de-assertion ]: 0x 0, [ 448.120106] [ 448.126899] Grp 1 : [ 448.126904] 0 [Reserved ]: 0x 0, [ 448.128998] 1 [Reserved ]: 0x 0, [ 448.134228] 2 [Reserved ]: 0x 0, [ 448.139443] 3 [Reserved ]: 0x 0, [ 448.144683] 4 [Reserved ]: 0x 0, [ 448.149912] 5 [Detect EI Infer ]: 0x 0, [ 448.155127] 6 [Receiver Error ]: 0x 0, [ 448.160368] 7 [Rx Recovery Request ]: 0x 0, [ 448.165584] 8 [N_FTS Timeout ]: 0x 0, [ 448.170814] 9 [Framing Error ]: 0x 0, [ 448.176029] 10 [Deskew Error ]: 0x 0, [ 448.181266] [ 448.188132] Grp 2 : [ 448.188137] 0 [BAD TLP ]: 0x 0, [ 448.190247] 1 [LCRC Error ]: 0x 0, [ 448.195461] 2 [BAD DLLP ]: 0x 0, [ 448.200701] 3 [Replay Number Rollover ]: 0x 0, [ 448.205916] 4 [Replay Timeout ]: 0x 0, [ 448.211146] 5 [Rx Nak DLLP ]: 0x 0, [ 448.216360] 6 [Tx Nak DLLP ]: 0x 0, [ 448.221600] 7 [Retry TLP ]: 0x 0, [ 448.226812] [ 448.233607] Grp 3 : [ 448.233612] 0 [FC Timeout ]: 0x 0, [ 448.235707] 1 [Poisoned TLP ]: 0x 0, [ 448.240948] 2 [ECRC Error ]: 0x 0, [ 448.246163] 3 [Unsupported Request ]: 0x 0, [ 448.251393] 4 [Completer Abort ]: 0x 0, [ 448.256608] 5 [Completion Timeout ]: 0x 0, [ 448.261846]","title":"PCIe User Guide"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#pcie-basic-concepts","text":"","title":"PCIe basic concepts"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#pcie-cascade","text":"Two NT9833x can be cascaded over PCIe to perform more powerful functions. Jobs on the RC (root complex), can be dispatched to EP (endpoint) to accomplish. The communication of data is through shared memory and interrupt notification which implemented by HDAL. Once two chips are cascaded, it can be seen as a chip with double HW engines and double CPUs. However, to access memory of a remote chip, a remote memory address needs to be converted to a local mapped physical address, or called a PCIe address. The following sections will introduce the mapping concepts and remote read/write definitions.","title":"PCIe cascade"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#mapping-concepts","text":"To access memory of a remote chip, a remote address should be converted to a local PCIe address. A mapped PCIe address represents resources of outer PCIe devices, including a cascaded NT9833x EP. As the figure shown below, on RC side the lower addresses are used by local dram and peripheral IO, while the upper addresses are used for remote PCIe resources, such as EP dram or EP peripherals. On the other hand, the lower addresses on EP side are used by local dram and peripherals of EP. And the upper addresses are mapped to dram and peripherals of RC. We call the direction from RC to EP \u201cdownstream\u201d and the opposite direction as \u201cupstream\u201d. Because RC stands for \u201croot complex\u201d which is on the top of PCIe connections. Moreover, a dram region could be composed of multiple DDR blocks. The first DDR of dram is index 0, and the second DDR is index 1, etc.","title":"Mapping concepts"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#remote-read-write","text":"RC (Root Complex) and EP (Endpoint) either could be the role of local or remote. Where the driver or application is executing in, that side is called the local side. And its opposite side is called the remote side. If data is transferred from local to remote, it is called \u201cRemote write\u201d. On the contrary, if data is moved from remote to local, it is called \u201cRemote read\u201d.","title":"Remote read / write"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#kernel-configurations","text":"The below introduces kernel configurations about NVT PCIe Library. CONFIG_NVT_PCIE_LIB is the configuration to enable NVT PCIe Library. NVT PCIe Library provides status querying, address conversion between RC and EP, and a common shared memory. It is transparent to PCIe HW. If EP does not exist, relative APIs will get an error returned, but not compiler errors. CONFIG_NVT_PCIE_CASCADE_DRV is the driver to handle HW dependent initialization of PCIe cascade. It is a proprietary driver of NVT. The implementation is different from Linux common framework. Please note that it depends on \u201cNVT_PCIE_LIB\u201d and \u201c!PCI\u201d. It means NVT PCIe cascade driver requires NVT PCIe Library to provide services for upper layers. And if Linux PCIe common framework is enabled, NVT PCIe cascade driver will be disabled automatically. CONFIG_NVT_PCIE_LIB: Novatek PCIe Library. Symbol: NVT_PCIE_LIB [=y] Type : bool Prompt: Novatek PCIe Library Location: -> Device Drivers -> SOC (System On Chip) specific Drivers -> NovaTek SoC drivers -> NovaTek SoC Basic drivers CONFIG_NVT_PCIE_CASCADE_DRV: Novatek PCIe cascade. Symbol: NVT_PCIE_CASCADE_DRV [=y] Type : bool Prompt: Novatek PCIe cascade Location: -> Device Drivers -> SOC (System On Chip) specific Drivers -> NovaTek SoC drivers -> NovaTek SoC Basic drivers -> Novatek PCIe Library (NVT_PCIE_LIB [=y]) Defined at drivers/soc/nvt/basic/Kconfig:24 Depends on: (ARCH_NVT_IVOT_V7 || ARCH_NVT_IVOT_V8 [=y]) && NVT_PCIE_LIB [=y] && NVT_IVOT_PLAT_NA51090 [=y] && !PCI [=n]","title":"Kernel configurations"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#device-tree-configurations","text":"","title":"Device tree configurations"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvt-pcie-cascade-drv","text":"There are two device tree nodes (\u201cnvt_pcie: pcie@2,f04f0000\u201d and \u201cnvt_ep0\u201d) to describe pcie hw behavior in the file nvt-peri.dtsi. In most time, it is not needed/encouraged to modify these device tree nodes. Parameters may be modified are:","title":"nvt-pcie-cascade-drv"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#dma-ranges-in-nvt_pcie-pcie2f04f0000","text":"\u201cdma-ranges\u201d is used to describe memory/register exported by RC to EP. Its format has 4 fields: type (don\u2019t care now), pcie address, system address, and size. For example, below line represents map pcie address 0xC_0000_0000 to 33x internal address 0x0_0000_0000 with size 0x2_0000_0000: 0x83000000 0x0C 0x00000000 0x00 0x00000000 0x02 0x00000000 /* RC MAU */ nvt_pcie: pcie@2,f04f0000 { compatible = \"nvt,nvt_pcie_drv\"; \u2026 #interrupt-cells = <3>; interrupt-controller; interrupt-parent = <&gic>; #address-cells = <3>; #size-cells = <2>; dma-ranges = <0x83000000 0x0C 0x00000000 0x00 0x00000000 0x02 0x00000000 /* RC MAU */ 0x83000001 0x0E 0x00000000 0x02 0xF0000000 0 0x10000000>; /* RC APB */ /* refclk-out = <0>; */ };","title":"\u201cdma-ranges\u201d in \u201cnvt_pcie: pcie@2,f04f0000\u201d"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#reg-in-nvt_ep0","text":"\u201creg\u201d is used to describe pcie address mapping of EP internal resource. It expects fixed sequence to describe mapping of MAU, ATU, APB registers. Its format has 2 fields: pcie address, and size (The internal system address is not allowed to modify). For example, below line represents map pcie address 0x4_0000_0000 to EP MAU with size 0x2_0000_0000. 0x04 0x00000000 0x02 0x00000000 /* MAU */ nvt_ep0 { reg = <0x04 0x00000000 0x02 0x00000000 /* MAU */ 0x06 0x10000000 0x00 0x10000000 /* ATU */ 0x06 0x20000000 0x00 0x10000000>; /* APB */ };","title":"\u201creg\u201d in \u201cnvt_ep0\u201d"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#refclk-out-in-nvt_pcie-pcie2f04f0000","text":"PCIe spec defines a differential clock signal as clock source of each pcie device (i.e. RC, EP). Novatek suggests use external clock buffer IC to generate 100 MHz refclk to 33x RC/EP 33x RC can be configured to output 100 MHz to cascaded EP by device tree parameter \u201crefclk-out\u201d. However, 33x refclk jitter may exceeds 300ppm defined by PCIe spec. Use it by your own risk!! Requirements of outputting REFCLK are: Bootstrap BS[10] should be tied to LOW (for detail bootstrap description, please refer to NT9833x datasheet) 10 PCIE_REFCLK_BOOT_SEL Select REFCLK source (This will effect default value of register PCIE_REFCLK_SRC) 0: from MPLL5 1: from REFCLK pad Enable refclk-out at device tree node: nvt_pcie: pcie@2,f04f0000 { compatible = \"nvt,nvt_pcie_drv\"; \u2026 #interrupt-cells = <3>; interrupt-controller; interrupt-parent = <&gic>; #address-cells = <3>; #size-cells = <2>; dma-ranges = <0x83000000 0x0C 0x00000000 0x00 0x00000000 0x02 0x00000000 /* RC MAU */ 0x83000001 0x0E 0x00000000 0x02 0xF0000000 0 0x10000000>; /* RC APB */ refclk-out = <1>; };","title":"\u201crefclk-out\u201d in \u201cnvt_pcie: pcie@2,f04f0000\u201d"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvt-pcie-lib","text":"The relative configurations are defined by node \u201cnvt-pcie-lib-cfg\u201d in the file nvt-mem-tbl-common.dtsi. \u201crc_shm_size\u201d represents the shared memory size. This memory space is allocated from kernel memory at RC side. And the physical address will be passed to EP side through internal registers. \u201cep_alloc_mem\u201d represents EP memory regions which can be allocated by RC users. That means these memory regions belong to EP, but RC users can allocate and put some data directly to these regions through PCIe. This kind of allocation should use nvt-pcie-lib API to accomplish. nvt-pcie-lib-cfg { compatible = \"nvt,nvt-pcie-lib\"; rc_shm_size = <0x0 0x00100000>; /* [SIZE-H] [SIZE-L] */ ep_alloc_mem = <0x1 0x0 0x18000000 0x0 0x08000000>; /* < [CHIPID] [ADDR-H] [ADDR-L] [SIZE-H] [SIZE-L] */ };","title":"nvt-pcie-lib"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvt-pcie-lib-api-introduction","text":"","title":"nvt-pcie-lib API introduction"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#address-conversion","text":"","title":"Address conversion"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvtpcie_get_upstream_pa","text":"[Description] From the view of EP side, get a mapped physical address to an upstream physical address of RC. [Syntax] phys_addr_t nvtpcie_get_upstream_pa(nvtpcie_chipid_t ep_chipid, phys_addr_t rc_pa); [Parameter] Value Description ep_chipid EP chip id rc_pa Physical address of RC [Return Value] Value Description NVTPCIE_INVALID_PA (-1) Failure Other values The mapped physical address","title":"nvtpcie_get_upstream_pa"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvtpcie_get_downstream_pa","text":"[Description] From the view of RC side, get a mapped physical address to a downstream physical address of EP. [Syntax] phys_addr_t nvtpcie_get_downstream_pa(nvtpcie_chipid_t ep_chipid, phys_addr_t ep_pa); [Parameter] Value Description ep_chipid EP chip id ep_pa Physical address of EP [Return Value] Value Description NVTPCIE_INVALID_PA (-1) Failure Other values The mapped physical address","title":"nvtpcie_get_downstream_pa"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvtpcie_get_pcie_addr","text":"[Description] Get a mapped physical address on the local chip. If the target DDR id is at the same chip as the local chip, the tar_pa is just returned. Otherwise, a mapped address will be returned, which is converted automatically by the given parameters. Please note that the returned address is on the view of the local chip. [Syntax] phys_addr_t nvtpcie_get_pcie_addr(nvtpcie_chipid_t loc_chipid, nvtpcie_ddrid_t tar_ddrid, phys_addr_t tar_pa); [Parameter] Value Description loc_chipid Local chip id tar_ddrid target DDR id tar_pa target physical address [Return Value] Value Description NVTPCIE_INVALID_PA (-1) Failure Other values The mapped physical address","title":"nvtpcie_get_pcie_addr"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvtpcie_get_mapped_pa","text":"[Description] Get a mapped physical address on the local chip automatically by the given parameters. The returned address could be upstream or downstream depending on the direction of the local chip id and the target chip id. [Syntax] phys_addr_t nvtpcie_get_mapped_pa(nvtpcie_chipid_t loc_chipid, nvtpcie_chipid_t tar_chipid, phys_addr_t tar_pa); [Parameter] Value Description loc_chipid Local chip id tar_chipid Target chip id tar_pa Target physical address [Return Value] Value Description NVTPCIE_INVALID_PA (-1) Failure Other values The mapped physical address","title":"nvtpcie_get_mapped_pa"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvtpcie_get_unmapped_pa","text":"[Description] Get an unmapped physical address by the given chip id and the mapped address. This is used to revert a mapped address to its original physical address of the target chip. The target chip id can be get from ret_map_chipid. If it is not needed, please set it NULL. [Syntax] phys_addr_t nvtpcie_get_unmapped_pa(nvtpcie_chipid_t loc_chipid, phys_addr_t mapped_pa, nvtpcie_chipid_t *ret_map_chipid); [Parameter] Value Description loc_chipid Local chip id mapped_pa A mapped physical address ret_map_chipid The mapped chip (optional, NULL if not needed) [Return Value] Value Description NVTPCIE_INVALID_PA (-1) Failure Other values The unmapped physical address","title":"nvtpcie_get_unmapped_pa"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#shared-memory","text":"","title":"Shared memory"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvtpcie_shmem_dump","text":"[Description] Dump the shared memory data by a specific length. [Syntax] void nvtpcie_shmem_dump(unsigned long length); [Parameter] Value Description length The length size to be dumped [Return Value] None","title":"nvtpcie_shmem_dump"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvtpcie_shmem_get_va","text":"[Description] Get the virtual address of the shared memory. [Syntax] void *nvtpcie_shmem_get_va(void); [Parameter] None [Return Value] Value Description NULL Failure Other values The virtual address of shared memory","title":"nvtpcie_shmem_get_va"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvtpcie_shmem_get_pa","text":"[Description] Get the physical address of the shared memory. [Syntax] phys_addr_t nvtpcie_shmem_get_pa(void); [Parameter] None [Return Value] Value Description NVTPCIE_INVALID_PA (-1) Failure Other values The physical address of shared memory","title":"nvtpcie_shmem_get_pa"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvtpcie_shmem_get_size","text":"[Description] Get the shared memory size. [Syntax] unsigned long nvtpcie_shmem_get_size(void); [Parameter] None [Return Value] Value Description 0 Failure. No shared memory. Other values The size of shared memory","title":"nvtpcie_shmem_get_size"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#ep-utility","text":"","title":"EP utility"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvtpcie_alloc_epmem","text":"[Description] Allocate a memory region from EP to use at RC. The output parameter ret_ep_pa is the mapped physical address at RC side. And the returned value is the virtual address of that physical address. To get the virtual address, an \u201cioremap\u201d operation is applied when the API is called. You can use this address in kernel-space directly without mapping again. [Syntax] void *nvtpcie_alloc_epmem(nvtpcie_chipid_t ep_chipid, unsigned long alloc_size, phys_addr_t *ret_ep_pa); [Parameter] Value Description ep_chipid EP chip id alloc_size The size to be allocated ret_ep_pa The physical address of allocated memory [Return Value] Value Description NULL Failure Other values The virtual address of allocated memory","title":"nvtpcie_alloc_epmem"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvtpcie_downstream_active","text":"[Description] Check whether the downstream EP is active or not at RC side. [Syntax] int nvtpcie_downstream_active(nvtpcie_chipid_t ep_chipid); [Parameter] Value Description ep_chipid EP chip id [Return Value] Value Description 1 active 0 inactive","title":"nvtpcie_downstream_active"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvtpcie_get_ep_count","text":"[Description] Get the active EP count [Syntax] int nvtpcie_get_ep_count(void); [Parameter] None [Return Value] Value Description 0 Failure Other values EP numbers","title":"nvtpcie_get_ep_count"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#mapping-info","text":"","title":"Mapping Info."},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvtpcie_get_ddrid","text":"[Description] Get the DDR id by the given parameters. The input physical address \u201cloc_pa\u201d could be a real DDR region or a mapped PCIe region. [Syntax] nvtpcie_ddrid_t nvtpcie_get_ddrid(nvtpcie_chipid_t loc_chipid, phys_addr_t loc_pa); [Parameter] Value Description loc_chipid Local chip id loc_pa Local physical address [Return Value] Value Description DDR_ID_MAX Failure Other values DDR id","title":"nvtpcie_get_ddrid"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvtpcie_get_ddrid_map","text":"[Description] Convert a specific DDR id to its chip id and the DDR index. [Syntax] int nvtpcie_get_ddrid_map(nvtpcie_ddrid_t ddrid, nvtpcie_chipid_t *out_chipid, nvtpcie_ddrid_t *out_ddridx); [Parameter] Value Description ddrid DDR id out_chipid Output chip id out_ddridx Output DDR index [Return Value] Value Description 0 Success -1 Failure","title":"nvtpcie_get_ddrid_map"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#misc","text":"","title":"Misc."},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvtpcie_get_my_chipid","text":"[Description] Get the current chip id. (RC or EPn) [Syntax] nvtpcie_chipid_t nvtpcie_get_my_chipid(void); [Parameter] None [Return Value] Value Description Chip id The chip id at the caller side","title":"nvtpcie_get_my_chipid"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#nvtpcie_edma_copy","text":"[Description] Copy data across PCIe using eDMA. The source and destination chip ids are assumed to be different. [Syntax] int nvtpcie_edma_copy(nvtpcie_chipid_t src_chipid, phys_addr_t src_pa, nvtpcie_chipid_t dst_chipid, phys_addr_t dst_pa, unsigned long len); [Parameter] Value Description src_chipid Chip id of the source src_pa Physical address of the source dst_chipid Chip id of the destination dst_pa Physical address of the destination len Size to be copied [Return Value] Value Description 0 Success -1 Failure","title":"nvtpcie_edma_copy"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#proc-interface","text":"A \u201c/proc\u201d interface is provided for debugging or dumping some information. To list all commands, you can \u201ccat\u201d the \u201c/proc/nvt-pcie-lib/help\u201d node. To trigger a command, please use \u201cecho [your command] >\u201d to the \u201c/proc/nvt-pcie-lib/cmd\u201d node. The below demonstrates how to use it.","title":"/proc interface"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#list-all-commands","text":"root@NVTEVM:/$ cat /proc/nvt-pcie-lib/help cmd_list: dump perf test version","title":"List all commands"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#show-version","text":"root@NVTEVM:/$ echo version > /proc/nvt-pcie-lib/cmd [ 190.162430] PROC_CMD: [version], size 8 [ 190.168264] nvt-pcie-lib: 0.0.16","title":"Show version"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#show-configurations","text":"root@NVTEVM:/$ echo dump > /proc/nvt-pcie-lib/cmd PROC_CMD: [dump], size 5 rc_dumpmap local_pa, size, name, ep_chipid, ep_pa [0] 0x0000000400000000, 0x0000000200000000, mau, 1, 0x0000000000000000 [1] 0x0000000620000000, 0x0000000010000000, apb, 1, 0x00000002F0000000 [2] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [3] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [4] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [5] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [6] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [7] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [8] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [9] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [10] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [11] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [12] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [13] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [14] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [15] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [16] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 [17] 0x0000000000000000, 0x0000000000000000, (null), 0, 0x0000000000000000 ep_upmap local_pa, size, name, rc_pa [0] 0x0000000C00000000, 0x0000000200000000, mau, 0x0000000000000000 [1] 0x0000000E00000000, 0x0000000010000000, apb, 0x00000002F0000000 ddr_map ddrid, chipid, ddridx, chip_base, size [0] 0, 0, 0, 0x0000000000000000, 0x40000000 [1] 1, 0, 1, 0x0000000100000000, 0x40000000 [2] 2, 1, 0, 0x0000000000000000, 0x40000000 [3] 3, 1, 1, 0x0000000100000000, 0x40000000 [4] 0, 0, 0, 0x0000000000000000, 0x00000000 [5] 0, 0, 0, 0x0000000000000000, 0x00000000 [6] 0, 0, 0, 0x0000000000000000, 0x00000000 [7] 0, 0, 0, 0x0000000000000000, 0x00000000 ep_allocmem ep_chipid, ep_local_pa, size, rc_map_pa, rc_map_va [0] 1, 0x0000000018000000, 0x08000000, 0x0000000418000000, 0xFFFFFF8010000000 [1] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [2] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [3] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [4] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [5] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [6] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [7] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 dump va=FFFFFF8008D4D000, pa=2C100000 length=00000100 to console: 2C100000 : 00000000 00000000 00000000 00000000 ............... 2C100010 : 00000000 00000000 00000000 00000000 ............... 2C100020 : 00000000 00000000 00000000 00000000 ............... 2C100030 : 00000000 00000000 00000000 00000000 ............... 2C100040 : 00000000 00000000 00000000 00000000 ............... 2C100050 : 00000000 00000000 00000000 00000000 ............... 2C100060 : 00000000 00000000 00000000 00000000 ............... 2C100070 : 00000000 00000000 00000000 00000000 ............... 2C100080 : 00000000 00000000 00000000 00000000 ............... 2C100090 : 00000000 00000000 00000000 00000000 ............... 2C1000A0 : 00000000 00000000 00000000 00000000 ............... 2C1000B0 : 00000000 00000000 00000000 00000000 ............... 2C1000C0 : 00000000 00000000 00000000 00000000 ............... 2C1000D0 : 00000000 00000000 00000000 00000000 ............... 2C1000E0 : 00000000 00000000 00000000 00000000 ............... 2C1000F0 : 00000000 00000000 00000000 00000000 ............... nvtpcie_get_ep_count = 1","title":"Show configurations"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#run-a-self-test","text":"Please note that a self-test may occupy system resources or conflict with other running services. Only run a self-test under a debug environment. root@NVTEVM:/$ echo test > /proc/nvt-pcie-lib/cmd PROC_CMD: [test], size 5 nvtpcie_get_ddrid_map ddr_map ddrid, chipid, ddridx, chip_base, size [0] 0, 0, 0, 0x0000000000000000, 0x40000000 [1] 1, 0, 1, 0x0000000100000000, 0x40000000 [2] 2, 1, 0, 0x0000000000000000, 0x40000000 [3] 3, 1, 1, 0x0000000100000000, 0x40000000 [4] 0, 0, 0, 0x0000000000000000, 0x00000000 [5] 0, 0, 0, 0x0000000000000000, 0x00000000 [6] 0, 0, 0, 0x0000000000000000, 0x00000000 [7] 0, 0, 0, 0x0000000000000000, 0x00000000 nvtpcie_get_ep_count = 1 nvtpcie_get_ddrid test chipid 0, pa 0x0000000001110000 => ddrid 0 chipid 0, pa 0x0000000042220000 => ddrid 8 chipid 0, pa 0x00000002F0110084 => ddrid 8 chipid 0, pa 0x0000000401110000 => ddrid 2 chipid 0, pa 0x0000000442220000 => ddrid 8 chipid 0, pa 0x0000000620110000 => ddrid 8 chipid 1, pa 0x0000000001110000 => ddrid 2 chipid 1, pa 0x0000000042220000 => ddrid 8 chipid 1, pa 0x00000002F0110084 => ddrid 8 chipid 1, pa 0x0000000C01110000 => ddrid 0 chipid 1, pa 0x0000000C42220000 => ddrid 8 chipid 1, pa 0x0000000E00110000 => ddrid 8 nvtpcie_get_upstream_pa ep_chipid 1, rc_pa 0x0000000001110000, ep_ups_pa 0x0000000C01110000 ep_chipid 1, rc_pa 0x0000000042220000, ep_ups_pa 0x0000000C42220000 ep_chipid 1, rc_pa 0x00000002F0110084, ep_ups_pa 0x0000000E00110084 nvtpcie_get_downstream_pa ep_chipid 1, ep_pa 0x0000000001110000, rc_down_pa 0x0000000401110000 ep_chipid 1, ep_pa 0x0000000042220000, rc_down_pa 0x0000000442220000 ep_chipid 1, ep_pa 0x00000002F0110084, rc_down_pa 0x0000000620110084 _nvtpcie_reg_test pa 0x620110084 org_val = 0x0 new_val = 0x12345678 chk_val = 0x0 nvtpcie_get_pcie_addr local: loc_chipid 0, tar_ddrid 0, tar_pa 0x0000000001110000, pcie_pa 0x0000000001110000 downstream: loc_chipid 0, tar_ddrid 2, tar_pa 0x0000000001110000, pcie_pa 0x0000000401110000 upstream: loc_chipid 1, tar_ddrid 0, tar_pa 0x0000000001110000, pcie_pa 0x0000000C01110000 nvtpcie_get_mapped_pa and nvtpcie_get_unmapped_pa nvtpcie_shmem_xxx test shmem pa 0x000000002C100000, va 0xFFFFFF8008D4D000, size 0x100000 nvtpcie_alloc_epmem ep_allocmem ep_chipid, ep_local_pa, size, rc_map_pa, rc_map_va [0] 1, 0x0000000018000000, 0x08000000, 0x0000000418000000, 0xFFFFFF8010000000 [1] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [2] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [3] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [4] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [5] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [6] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 [7] 0, 0x0000000000000000, 0x00000000, 0x0000000000000000, 0x0000000000000000 alloc_epmem 1: ep_chipid 1, len 65536, p_rc_va 0xFFFFFF8010282000, ret_ep_pa 0x0000000018282000 alloc_epmem 2: ep_chipid 1, len 65536, p_rc_va 0xFFFFFF8010292000, ret_ep_pa 0x0000000018292000 alloc_epmem 3: ep_chipid 1, len 65536, p_rc_va 0xFFFFFF80102A2000, ret_ep_pa 0x00000000182A2000 nvtpcie_downstream_active ep_chipid 1, is_active 1 nvtpcie_edma_copy test edma_copy: chip 0 pa 0x0000000001110000 => chip 1 pa 0x0000000001110000 edma_copy: chip 1 pa 0x0000000001110000 => chip 0 pa 0x0000000001110000 edma test done root@NVTEVM:/$","title":"Run a self-test"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#run-a-performance-test","text":"A series of performance tests will be performed sequentially. Each test is performed 10 times, and the average value will be shown at the end. root@NVTEVM:/$ echo perf > /proc/nvt-pcie-lib/cmd PROC_CMD: [perf], size 5 [REMOTE READ (edma)] loop_num 10, 1048576 bytes, dur_us 1202 loop_num 9, 1048576 bytes, dur_us 1199 loop_num 8, 1048576 bytes, dur_us 1200 loop_num 7, 1048576 bytes, dur_us 1199 loop_num 6, 1048576 bytes, dur_us 1199 loop_num 5, 1048576 bytes, dur_us 1200 loop_num 4, 1048576 bytes, dur_us 1199 loop_num 3, 1048576 bytes, dur_us 1199 loop_num 2, 1048576 bytes, dur_us 1199 loop_num 1, 1048576 bytes, dur_us 1199 avg: 953250 KB/s (10485760 bytes / 11995 us) [REMOTE READ (memcpy_fromio)] loop_num 10, 1048576 bytes, dur_us 139336 loop_num 9, 1048576 bytes, dur_us 139164 loop_num 8, 1048576 bytes, dur_us 139908 loop_num 7, 1048576 bytes, dur_us 140222 loop_num 6, 1048576 bytes, dur_us 139864 loop_num 5, 1048576 bytes, dur_us 139374 loop_num 4, 1048576 bytes, dur_us 139845 loop_num 3, 1048576 bytes, dur_us 140014 loop_num 2, 1048576 bytes, dur_us 139935 loop_num 1, 1048576 bytes, dur_us 140179 avg: 7505 KB/s (10485760 bytes / 1397841 us) [LOCAL READ (memcpy_fromio)] loop_num 10, 1048576 bytes, dur_us 764 loop_num 9, 1048576 bytes, dur_us 765 loop_num 8, 1048576 bytes, dur_us 718 loop_num 7, 1048576 bytes, dur_us 718 loop_num 6, 1048576 bytes, dur_us 700 loop_num 5, 1048576 bytes, dur_us 719 loop_num 4, 1048576 bytes, dur_us 806 loop_num 3, 1048576 bytes, dur_us 706 loop_num 2, 1048576 bytes, dur_us 805 loop_num 1, 1048576 bytes, dur_us 709 avg: 1497965 KB/s (10485760 bytes / 7410 us) [REMOTE WRITE (edma)] loop_num 10, 1048576 bytes, dur_us 1179 loop_num 9, 1048576 bytes, dur_us 1176 loop_num 8, 1048576 bytes, dur_us 1176 loop_num 7, 1048576 bytes, dur_us 1176 loop_num 6, 1048576 bytes, dur_us 1176 loop_num 5, 1048576 bytes, dur_us 1176 loop_num 4, 1048576 bytes, dur_us 1175 loop_num 3, 1048576 bytes, dur_us 1176 loop_num 2, 1048576 bytes, dur_us 1176 loop_num 1, 1048576 bytes, dur_us 1175 avg: 953250 KB/s (10485760 bytes / 11761 us) [REMOTE WRITE (memcpy_toio)] loop_num 10, 1048576 bytes, dur_us 4298 loop_num 9, 1048576 bytes, dur_us 4285 loop_num 8, 1048576 bytes, dur_us 4288 loop_num 7, 1048576 bytes, dur_us 4285 loop_num 6, 1048576 bytes, dur_us 4285 loop_num 5, 1048576 bytes, dur_us 4287 loop_num 4, 1048576 bytes, dur_us 4285 loop_num 3, 1048576 bytes, dur_us 4285 loop_num 2, 1048576 bytes, dur_us 4300 loop_num 1, 1048576 bytes, dur_us 4304 avg: 249660 KB/s (10485760 bytes / 42902 us) [LOCAL WRITE (memcpy_toio)] loop_num 10, 1048576 bytes, dur_us 716 loop_num 9, 1048576 bytes, dur_us 726 loop_num 8, 1048576 bytes, dur_us 743 loop_num 7, 1048576 bytes, dur_us 722 loop_num 6, 1048576 bytes, dur_us 714 loop_num 5, 1048576 bytes, dur_us 722 loop_num 4, 1048576 bytes, dur_us 714 loop_num 3, 1048576 bytes, dur_us 715 loop_num 2, 1048576 bytes, dur_us 714 loop_num 1, 1048576 bytes, dur_us 700 avg: 1497965 KB/s (10485760 bytes / 7186 us)","title":"Run a performance test"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#uboot-init-flow","text":"PCIe link and mapping are initialized in uboot phase. It is located at u-boot/board/novatek/nvt-na51090-a64/nvt_pcie/nvt_pcie_mapping.c. In most cases, you are not required to touch this file. However, if you need to understand how it works, below flow chart can give you a brief view of PCIe init:","title":"uboot init flow"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#trouble-shooting","text":"","title":"Trouble shooting"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#which-driver-support-running-on-rc-and-controlling-hw-on-ep","text":"Ans: These system drivers can support: GPIO, USB host, pinctrl, clock, I2C, wdt, PWM, adc, uart, DDR arbiter, efuse, thermal, SATA. For HDAL related driver, please refer to HDAL documents.","title":"Which driver support running on RC and controlling hw on EP?"},{"location":"Software/OSDRV/NT9833x_PCIe_User_Guide_en.html#i-concern-there-are-any-error-on-pcie-bus-if-there-any-way-to-observe-errors-below-transaction-layer","text":"Ans: You can cat file pcie_sts under /proc/nvt_pcie. root@NVTEVM:/proc/nvt_pcie$ cat pcie_sts [ 448.049669] [ 448.051302] [ 448.051302] Error count: [ 448.055655] uncorr_error_cnt: 0 [ 448.058875] rx_error_cnt: 0 [ 448.061790] [ 448.061790] ===================== [ 448.066951] 0x2F08B301C: 0x 370004 [ 448.070535] 0x2F08B3018: 0x 1707 [ 448.074104] [ 448.074104] ===================== [ 448.079233] [ 448.079233] Test RAS D.E.S --- event count analysis function [ 448.086643] Grp 0 : [ 448.086651] 0 [EBUF Overflow ]: 0x 0, [ 448.088746] 1 [EBUF Under-run ]: 0x 0, [ 448.093978] 2 [Decode Error ]: 0x 0, [ 448.099194] 3 [Running Disparity Error ]: 0x 0, [ 448.104435] 4 [SKP OS Parity Error ]: 0x 0, [ 448.109649] 5 [SYNC Header Error ]: 0x 0, [ 448.114881] 6 [Rx Valid de-assertion ]: 0x 0, [ 448.120106] [ 448.126899] Grp 1 : [ 448.126904] 0 [Reserved ]: 0x 0, [ 448.128998] 1 [Reserved ]: 0x 0, [ 448.134228] 2 [Reserved ]: 0x 0, [ 448.139443] 3 [Reserved ]: 0x 0, [ 448.144683] 4 [Reserved ]: 0x 0, [ 448.149912] 5 [Detect EI Infer ]: 0x 0, [ 448.155127] 6 [Receiver Error ]: 0x 0, [ 448.160368] 7 [Rx Recovery Request ]: 0x 0, [ 448.165584] 8 [N_FTS Timeout ]: 0x 0, [ 448.170814] 9 [Framing Error ]: 0x 0, [ 448.176029] 10 [Deskew Error ]: 0x 0, [ 448.181266] [ 448.188132] Grp 2 : [ 448.188137] 0 [BAD TLP ]: 0x 0, [ 448.190247] 1 [LCRC Error ]: 0x 0, [ 448.195461] 2 [BAD DLLP ]: 0x 0, [ 448.200701] 3 [Replay Number Rollover ]: 0x 0, [ 448.205916] 4 [Replay Timeout ]: 0x 0, [ 448.211146] 5 [Rx Nak DLLP ]: 0x 0, [ 448.216360] 6 [Tx Nak DLLP ]: 0x 0, [ 448.221600] 7 [Retry TLP ]: 0x 0, [ 448.226812] [ 448.233607] Grp 3 : [ 448.233612] 0 [FC Timeout ]: 0x 0, [ 448.235707] 1 [Poisoned TLP ]: 0x 0, [ 448.240948] 2 [ECRC Error ]: 0x 0, [ 448.246163] 3 [Unsupported Request ]: 0x 0, [ 448.251393] 4 [Completer Abort ]: 0x 0, [ 448.256608] 5 [Completion Timeout ]: 0x 0, [ 448.261846]","title":"I concern there are any error on PCIe bus. If there any way to observe errors below transaction layer?"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html","text":"Board setup \u00b6 Single board (Without PCIE cascade) \u00b6 Dual board (With PCIE cascade) \u00b6 Boot from UART \u00b6 This mode will be responsible for the loader update when the flash of the board is new or can\u2019t boot conditions. Operation architecture \u00b6 We will transfer the write loader(WLD9833XA.bin) to EVB to do update process, and get every image through UART, loader will update each image to specific address. Due to uart speed is slow, we suggest you can update to uboot stage only. Other images can be updated by uboot. Update flow \u00b6 When you select the boot from uart setting in EVB, the boot flow is shown as below. PC FwUpgrade.exe tool will send write loader sram and jump into this entry. Write loader is incharge of raw image update process. Image generation \u00b6 WLD9833XA.bin is used to update other low level loader images, which is the boot from UART mode loader, it also can be compiled by loader source code. Update Tool \u00b6 Common Tools : FwUpgrade.exe: Running on your PC which can send write loader image to EVB Zadig-2.4.exe: DFU Windows driver Dfu-util-static: DFU tool on your PC NAND : WLD98336A.bin: write loader DfuBringUp.bat: Update image Windows script DfuBringUp_cascade.bat: Update image Windows script for PCIE cascade Image: The SDK image you want to update. Image_cascade: The SDK image you want to update for PCIE cascade EMMC : WLD98336A_for_emmc_4bit.bin: EMMC write loader for 4bit mode DfuBringUp_emmc.bat: Update image Windows script. DfuBringUp_emmc_cascade.bat: Update image Windows script for PCIE cascade. Image_emmc: The SDK image you want to update. Image_emmc_cascade: The SDK image you want to update for PCIE cascade. NOR : WLD98336A_nor.bin: EMMC write loader for 4bit mode DfuBringUp_nor.bat: Update image Windows script. Image_nor: The SDK image you want to update. Update SOP \u00b6 The major steps of the update flow are two parts. Boot from UART SOP \u2013 In order to update loader, atf and uboot.bin And then, you can use either one of below to update image. DFU SOP \u2013 In order to update images TFTP SOP \u2013 In order to update images Boot from UART SOP \u00b6 Using FwUpgrade.exe and select \u201cNEW INI\u201d Click non-all-in-one Select your com port and click upgrade button. Remember to turn off your com port tool (e.g. Teraterm or putty) Load WrLoader means that select your write loader NAND : WLD98336A.bin EMMC : WLD98336A_for_emmc_4bit.bin if update 4bit emmc system board NOR : WLD98336A_nor.bin It means that your com port is blocked if the message \u201d [HOST][ERR] COM3 open failed\u201d is shown. Please turn off your console tool. Setup partition and upgrade Refer to nvt-storage-partition.dtsi set loader, fdt, atf, uboot partition offset and size select images. Click the checkbox Loader size is fixed to 0x10000, tool will aotomaticlly write loader to emmc HW partition boot0 This message \u201c[HOST] finished\u201d means that update is success, you can switch jump and reboot to do further setup update. Switch jump with nand/nor/emmc boot mode and reboot You can use TFTP or DFU to do further update image procedures in uboot stage, we will introduce them separately in the following chapters. DFU SOP \u00b6 Setup uboot env (if your uboot env mtdparts is null or your layout is different with SDK partition table.) uboot $ setenv mtdparts \"spi_nand.0:0x40000@0x40000(fdt),0x40000@0xc0000(atf),0x1c0000@0x100000(uboot),0x40000@0x2c0000(uenv),0x500000@0x300000(linux),0x3160000@0x800000(rootfs0),0x2500000@0x3960000(rootfs1),0x21a0000@0x5e60000(app)\" uboot $ setenv mtdids \"nand0=spi_nand.0\" DFU init in uboot shell uboot $ dfu 0 nand 0 To check whether the USB download gadget in your device management of the PC\u2019s Windows is existed or not as below, please install the Windows drivers by zadig-2.4.exe if it does not exist. Running DFUBringUP.bat can update all partitions. You can edit this \u201cDFUBringUP.bat\u201d to control the update flow. For other partition layout or file type modification details can refer to software\\pc\\document\\DFUTools\\ NT9833x_DFU_User_Guide_en.pdf dfu-util-static.exe -d 07b4:0109 -a 0 -D image\\LD98336A.bin dfu-util-static.exe -d 07b4:0109 -a 1 -D image\\nvt-all.bin dfu-util-static.exe -d 07b4:0109 -a 2 -D image\\atf.bin dfu-util-static.exe -d 07b4:0109 -a 3 -D image\\uboot.bin dfu-util-static.exe -d 07b4:0109 -a 4 -D image\\Image.bin dfu-util-static.exe -d 07b4:0109 -a 5 -D image\\rootfs.ramdisk.bin.raw dfu-util-static.exe -d 07b4:0109 -a 6 -D image\\rootfs_1.rw.ubifs.bin.ubi.raw dfu-util-static.exe -d 07b4:0109 -a 7 -D image\\NVR_16CH.nand.ubifs.raw pause TFTP SOP \u00b6 Check if the serverip, ipadder, netmask and gatewayip settings are in the same LAN. Ping command to check network status uboot \\$ ping 192.168.1.11 Using the TFTP download Loader, ATF, DTB, Linux and rootfs images Please follow the document NT9833x Memory Map.xls to get Linux temp buffer address and partition table in nvt-storage-partition.dtsi. Partial load images command uboot $ setenv bootargs \u201cYOUR_EVB_BOOTARGS\u201d uboot $ setenv serverip server ip (set TFTP server IP address) uboot $ setenv ipaddr evb ip (set EVB IP address) uboot $ tftp <ddr_addr> <file_name> /* Download image to DDR */ /*Erase flash, must block alignment*/ uboot $ nand erase <flash_start_addr> <flash_end_addr> /* Write image from DDR to flash */ uboot $ nand write <ddr_addr> <flash_addr> <flash_size> /* Write ubifs/jffs2 image from DDR to flash */ uboot $ nand write.trimffs <ddr_addr> <flash_addr> <flash_size> Examples Loader uboot $ setenv bootargs \u201cYOUR_EVB_BOOTARGS\u201d uboot $ setenv serverip server 192.168.1.20 uboot $ setenv ipaddr 192.168.1.11 uboot $ tftp 0x200000 LD98336A uboot $ nand erase 0x0000000 0x40000 uboot $ nand write 0x200000 0x000000 FileSize(Hex) ATF uboot $ setenv bootargs \u201cYOUR_EVB_BOOTARGS\u201d uboot $ setenv serverip server 192.168.1.20 uboot $ setenv ipaddr 192.168.1.11 uboot $ tftp 0x200000 atf.bin uboot $ nand erase 0x0C0000 0x40000 uboot $ nand write 0x200000 0x0C0000 FileSize(Hex) uboot uboot $ setenv bootargs \u201cYOUR_EVB_BOOTARGS\u201d uboot $ setenv serverip server 192.168.1.20 uboot $ setenv ipaddr 192.168.1.11 uboot $ tftp 0x200000 uboot.bin uboot $ nand erase 0x100000 0x1C0000 uboot $ nand write 0x200000 0x100000 FileSize(Hex) Linux kernel uboot $ setenv bootargs \u201cYOUR_EVB_BOOTARGS\u201d uboot $ setenv serverip server 192.168.1.20 uboot $ setenv ipaddr 192.168.1.11 uboot $ tftp 0x200000 Image.bin uboot $ nand erase 0x300000 0x0500000 uboot $ nand write 0x200000 0x300000 FileSize(Hex) Ramdisk (SDK/output/raw/) uboot $ setenv bootargs \u201cYOUR_EVB_BOOTARGS\u201d uboot $ setenv serverip server 192.168.1.20 uboot $ setenv ipaddr 192.168.1.11 uboot $ tftp 0x200000 rootfs.ramdisk.bin.raw uboot $ nand erase 0x800000 0x3160000 uboot $ nand write 0x200000 0x800000 FileSize(Hex) UBIFS (SDK/output/raw/) uboot $ setenv bootargs \u201cYOUR_EVB_BOOTARGS\u201d uboot $ setenv serverip server 192.168.1.20 uboot $ setenv ipaddr 192.168.1.11 uboot $ tftp 0x200000 rootfs_1.rw.ubifs.bin.ubi.raw uboot $ nand erase 0x3960000 0x2500000 uboot $ nand write.trimffs 0x200000 0x3960000 FileSize(Hex) PCIE cascade update SOP (NAND) \u00b6 First step, it\u2019s to follow up chapter 2.5.1 \u201cBoot from UART SOP\u201d let the system booting to uboot shell. Setup uboot env (if your uboot env mtdparts is null or your layout is different with SDK partition table.) uboot $ setenv mtdparts \"spi_nand.0:0x40000@0x40000(fdt),0x40000@0xc0000(atf),0x1c0000@0x100000(uboot),0x40000@0x2c0000(uenv),0x500000@0x300000(linux),0x2100000@0x800000(rootfs0),0x2500000@0x2900000(rootfs1),0x1060000@0x4E00000(rootfs2),0x21a0000@0x5e60000(app)\" uboot $ setenv mtdids \"nand0=spi_nand.0\" DFU init in uboot shell uboot $ dfu 0 nand 0 To check whether the USB download gadget in your device management of the PC\u2019s Windows is existed or not as below, please install the Windows drivers by zadig-2.4.exe if it does not exist. Running DFUBringUP_cascade.bat can update all partitions. You can edit this \u201cDFUBringUP_cascade.bat\u201d to control the update flow. For other partition layout or file type modification details can refer to software\\pc\\document\\DFUTools\\ NT9833x_DFU_User_Guide_en.pdf dfu-util-static.exe -d 07b4:0109 -a 0 -D image_cascade\\LD98336A.bin dfu-util-static.exe -d 07b4:0109 -a 1 -D image_cascade\\nvt-all.bin dfu-util-static.exe -d 07b4:0109 -a 2 -D image_cascade\\atf.bin dfu-util-static.exe -d 07b4:0109 -a 3 -D image_cascade\\uboot.bin dfu-util-static.exe -d 07b4:0109 -a 4 -D image_cascade\\Image.bin dfu-util-static.exe -d 07b4:0109 -a 5 -D image_cascade\\rootfs.ramdisk.bin.raw dfu-util-static.exe -d 07b4:0109 -a 6 -D image_cascade\\rootfs_1.rw.ubifs.bin.ubi.raw dfu-util-static.exe -d 07b4:0109 -a 7 -D image_cascade\\rootfs.ep.ramdisk.bin.raw dfu-util-static.exe -d 07b4:0109 -a 8 -D image_cascade\\DVR_DUAL_32CH.nand.ubifs.raw pause Switch jump with nand boot mode and reboot EMMC update SOP \u00b6 First step, it\u2019s to follow up chapter 2.5.1 \u201cBoot from UART SOP\u201d let the system booting to uboot shell. Setup uboot env (if your uboot env mtdparts is null or your layout is different with SDK partition table.) uboot $ setenv nvtemmcpart \"0x200@0x0(loader),0x40000@0x40000(fdt)ro,0x40000@0x80000(fdt.restore),0x40000@0xc0000(atf)ro,0x200000@0x100000(uboot)ro,0x40000@0x300000(uenv),0x400000@0x340000(linux)ro,0xa000000@0x740000(rootfs0),0xa000000@0xa740000(rootfs1),0xc000000@0x14740000(rootfs2)\" DFU init in uboot shell uboot $ dfu 0 mmc 1 To check whether the USB download gadget in your device management of the PC\u2019s Windows is existed or not as below, please install the Windows drivers by zadig-2.4.exe if it does not exist. Check HW bootstrap setting is 4-bit or 8-bit mode, select the corresponding loader and put it into the image_emmc folder. Running DFUBringUP_emmc.bat can update all partitions. You can edit this \u201cDFUBringUP_emmc.bat\u201d to control the update flow. For other partition layout or file type modification details can refer to software\\pc\\document\\DFUTools\\ NT9833x_DFU_User_Guide_en.pdf dfu-util-static.exe -d 07b4:0109 -a 0 -D image_emmc\\LD98336A_4bit.bin dfu-util-static.exe -d 07b4:0109 -a 1 -D image_emmc\\nvt-all.bin dfu-util-static.exe -d 07b4:0109 -a 2 -D image_emmc\\atf.bin dfu-util-static.exe -d 07b4:0109 -a 3 -D image_emmc\\u-boot.bin dfu-util-static.exe -d 07b4:0109 -a 4 -D image_emmc\\Image.bin dfu-util-static.exe -d 07b4:0109 -a 5 -D image_emmc\\rootfs.ramdisk.bin.raw dfu-util-static.exe -d 07b4:0109 -a 6 -D image_emmc\\rootfs.rw.ext4.bin.raw dfu-util-static.exe -d 07b4:0109 -a 7 -D image_emmc\\DVR_16CH.emmc.ext4.bin.raw pause Switch jump with emmc boot mode and reboot PCIE cascade update SOP (EMMC) \u00b6 First step, it\u2019s to follow up chapter 2.5.1 \u201cBoot from UART SOP\u201d let the system booting to uboot shell. Setup uboot env (if your uboot env mtdparts is null or your layout is different with SDK partition table.) uboot $ setenv nvtemmcpart \"0x200@0x0(loader),0x40000@0x40000(fdt)ro,0x40000@0x80000(fdt.restore),0x40000@0xc0000(atf)ro,0x200000@0x100000(uboot)ro,0x40000@0x300000(uenv),0x400000@0x340000(linux)ro,0xa000000@0x740000(rootfs0),0xa000000@0xa740000(rootfs1),0xc000000@0x14740000(rootfs2),0x1060000@0x20740000(rootfs3)\" DFU init in uboot shell uboot $ dfu 0 mmc 1 To check whether the USB download gadget in your device management of the PC\u2019s Windows is existed or not as below, please install the Windows drivers by zadig-2.4.exe if it does not exist. Running DfuBringUp_emmc_cascade.bat can update all partitions. You can edit this \u201cDfuBringUp_emmc_cascade.bat\u201d to control the update flow. For other partition layout or file type modification details can refer to software\\pc\\document\\DFUTools\\ NT9833x_DFU_User_Guide_en.pdf dfu-util-static.exe -d 07b4:0109 -a 0 -D image_emmc_cascade\\LD98336A_4bit.bin dfu-util-static.exe -d 07b4:0109 -a 1 -D image_emmc_cascade\\nvt-all.bin dfu-util-static.exe -d 07b4:0109 -a 2 -D image_emmc_cascade\\atf.bin dfu-util-static.exe -d 07b4:0109 -a 3 -D image_emmc_cascade\\u-boot.bin dfu-util-static.exe -d 07b4:0109 -a 4 -D image_emmc_cascade\\Image.bin dfu-util-static.exe -d 07b4:0109 -a 5 -D image_emmc_cascade\\rootfs.ramdisk.bin.raw dfu-util-static.exe -d 07b4:0109 -a 6 -D image_emmc_cascade\\rootfs.rw.ext4.bin.raw dfu-util-static.exe -d 07b4:0109 -a 7 -D image_emmc_cascade\\DVR_DUAL_16CH.emmc.ext4.bin.raw dfu-util-static.exe -d 07b4:0109 -a 8 -D image_emmc_cascade\\rootfs.ep.ramdisk.bin.raw pause Switch jump with emmc boot mode and reboot NOR update SOP \u00b6 Setup uboot env (if your uboot env mtdparts is null or your layout is different with SDK partition table.) uboot $ setenv mtdparts \"spi_nor.0:0x20000@0x10000(fdt),0x20000@0x50000(atf),0x40000@0x70000(uboot),0x10000@0xb0000(uenv),0x300000@0xc0000(linux),0xd40000@0x3c0000(rootfs0),0xe20000@0x1100000(app)\" uboot $ setenv mtdids \"nor0=spi_nor.0\" DFU init in uboot shell uboot $ dfu 0 sf 0:0 To check whether the USB download gadget in your device management of the PC\u2019s Windows is existed or not as below, please install the Windows drivers by zadig-2.4.exe if it does not exist. Running DFUBringUP_nor.bat can update all partitions. You can edit this \u201cDFUBringUP_nor.bat\u201d to control the update flow. For other partition layout or file type modification details can refer to software\\pc\\document\\DFUTools\\ NT9833x_DFU_User_Guide_en.pdf dfu-util-static.exe -d 07b4:0109 -a 0 -D image_nor\\LD98336A.bin dfu-util-static.exe -d 07b4:0109 -a 1 -D image_nor\\nvt-all.bin dfu-util-static.exe -d 07b4:0109 -a 2 -D image_nor\\atf.bin dfu-util-static.exe -d 07b4:0109 -a 3 -D image_nor\\u-boot.lz.bin dfu-util-static.exe -d 07b4:0109 -a 4 -D image_nor\\Image.bin dfu-util-static.exe -d 07b4:0109 -a 5 -D image_nor\\rootfs.squash.bin.raw dfu-util-static.exe -d 07b4:0109 -a 6 -D image_nor\\DVR_16CH.nor.jffs2.bin.raw pause Trouble shooting \u00b6 Ping error on uboot shell \u00b6 Please follow steps as below to fix the problem : Check if your uboot config CONFIG_NOVATEK_MAC_ENET_NA51090 is enable Check if the serverip, ipadder, netmask and gatewayip settings are in the same LAN Check if your windows firewall is close DFU driver problem \u00b6 The following message is your dfu device driver problem, please install the DFU drivers.","title":"Quick Bringup User Guide"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#board-setup","text":"","title":"Board setup"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#single-board-without-pcie-cascade","text":"","title":"Single board (Without PCIE cascade)"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#dual-board-with-pcie-cascade","text":"","title":"Dual board (With PCIE cascade)"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#boot-from-uart","text":"This mode will be responsible for the loader update when the flash of the board is new or can\u2019t boot conditions.","title":"Boot from UART"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#operation-architecture","text":"We will transfer the write loader(WLD9833XA.bin) to EVB to do update process, and get every image through UART, loader will update each image to specific address. Due to uart speed is slow, we suggest you can update to uboot stage only. Other images can be updated by uboot.","title":"Operation architecture"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#update-flow","text":"When you select the boot from uart setting in EVB, the boot flow is shown as below. PC FwUpgrade.exe tool will send write loader sram and jump into this entry. Write loader is incharge of raw image update process.","title":"Update flow"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#image-generation","text":"WLD9833XA.bin is used to update other low level loader images, which is the boot from UART mode loader, it also can be compiled by loader source code.","title":"Image generation"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#update-tool","text":"Common Tools : FwUpgrade.exe: Running on your PC which can send write loader image to EVB Zadig-2.4.exe: DFU Windows driver Dfu-util-static: DFU tool on your PC NAND : WLD98336A.bin: write loader DfuBringUp.bat: Update image Windows script DfuBringUp_cascade.bat: Update image Windows script for PCIE cascade Image: The SDK image you want to update. Image_cascade: The SDK image you want to update for PCIE cascade EMMC : WLD98336A_for_emmc_4bit.bin: EMMC write loader for 4bit mode DfuBringUp_emmc.bat: Update image Windows script. DfuBringUp_emmc_cascade.bat: Update image Windows script for PCIE cascade. Image_emmc: The SDK image you want to update. Image_emmc_cascade: The SDK image you want to update for PCIE cascade. NOR : WLD98336A_nor.bin: EMMC write loader for 4bit mode DfuBringUp_nor.bat: Update image Windows script. Image_nor: The SDK image you want to update.","title":"Update Tool"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#update-sop","text":"The major steps of the update flow are two parts. Boot from UART SOP \u2013 In order to update loader, atf and uboot.bin And then, you can use either one of below to update image. DFU SOP \u2013 In order to update images TFTP SOP \u2013 In order to update images","title":"Update SOP"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#boot-from-uart-sop","text":"Using FwUpgrade.exe and select \u201cNEW INI\u201d Click non-all-in-one Select your com port and click upgrade button. Remember to turn off your com port tool (e.g. Teraterm or putty) Load WrLoader means that select your write loader NAND : WLD98336A.bin EMMC : WLD98336A_for_emmc_4bit.bin if update 4bit emmc system board NOR : WLD98336A_nor.bin It means that your com port is blocked if the message \u201d [HOST][ERR] COM3 open failed\u201d is shown. Please turn off your console tool. Setup partition and upgrade Refer to nvt-storage-partition.dtsi set loader, fdt, atf, uboot partition offset and size select images. Click the checkbox Loader size is fixed to 0x10000, tool will aotomaticlly write loader to emmc HW partition boot0 This message \u201c[HOST] finished\u201d means that update is success, you can switch jump and reboot to do further setup update. Switch jump with nand/nor/emmc boot mode and reboot You can use TFTP or DFU to do further update image procedures in uboot stage, we will introduce them separately in the following chapters.","title":"Boot from UART SOP"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#dfu-sop","text":"Setup uboot env (if your uboot env mtdparts is null or your layout is different with SDK partition table.) uboot $ setenv mtdparts \"spi_nand.0:0x40000@0x40000(fdt),0x40000@0xc0000(atf),0x1c0000@0x100000(uboot),0x40000@0x2c0000(uenv),0x500000@0x300000(linux),0x3160000@0x800000(rootfs0),0x2500000@0x3960000(rootfs1),0x21a0000@0x5e60000(app)\" uboot $ setenv mtdids \"nand0=spi_nand.0\" DFU init in uboot shell uboot $ dfu 0 nand 0 To check whether the USB download gadget in your device management of the PC\u2019s Windows is existed or not as below, please install the Windows drivers by zadig-2.4.exe if it does not exist. Running DFUBringUP.bat can update all partitions. You can edit this \u201cDFUBringUP.bat\u201d to control the update flow. For other partition layout or file type modification details can refer to software\\pc\\document\\DFUTools\\ NT9833x_DFU_User_Guide_en.pdf dfu-util-static.exe -d 07b4:0109 -a 0 -D image\\LD98336A.bin dfu-util-static.exe -d 07b4:0109 -a 1 -D image\\nvt-all.bin dfu-util-static.exe -d 07b4:0109 -a 2 -D image\\atf.bin dfu-util-static.exe -d 07b4:0109 -a 3 -D image\\uboot.bin dfu-util-static.exe -d 07b4:0109 -a 4 -D image\\Image.bin dfu-util-static.exe -d 07b4:0109 -a 5 -D image\\rootfs.ramdisk.bin.raw dfu-util-static.exe -d 07b4:0109 -a 6 -D image\\rootfs_1.rw.ubifs.bin.ubi.raw dfu-util-static.exe -d 07b4:0109 -a 7 -D image\\NVR_16CH.nand.ubifs.raw pause","title":"DFU SOP"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#tftp-sop","text":"Check if the serverip, ipadder, netmask and gatewayip settings are in the same LAN. Ping command to check network status uboot \\$ ping 192.168.1.11 Using the TFTP download Loader, ATF, DTB, Linux and rootfs images Please follow the document NT9833x Memory Map.xls to get Linux temp buffer address and partition table in nvt-storage-partition.dtsi. Partial load images command uboot $ setenv bootargs \u201cYOUR_EVB_BOOTARGS\u201d uboot $ setenv serverip server ip (set TFTP server IP address) uboot $ setenv ipaddr evb ip (set EVB IP address) uboot $ tftp <ddr_addr> <file_name> /* Download image to DDR */ /*Erase flash, must block alignment*/ uboot $ nand erase <flash_start_addr> <flash_end_addr> /* Write image from DDR to flash */ uboot $ nand write <ddr_addr> <flash_addr> <flash_size> /* Write ubifs/jffs2 image from DDR to flash */ uboot $ nand write.trimffs <ddr_addr> <flash_addr> <flash_size> Examples Loader uboot $ setenv bootargs \u201cYOUR_EVB_BOOTARGS\u201d uboot $ setenv serverip server 192.168.1.20 uboot $ setenv ipaddr 192.168.1.11 uboot $ tftp 0x200000 LD98336A uboot $ nand erase 0x0000000 0x40000 uboot $ nand write 0x200000 0x000000 FileSize(Hex) ATF uboot $ setenv bootargs \u201cYOUR_EVB_BOOTARGS\u201d uboot $ setenv serverip server 192.168.1.20 uboot $ setenv ipaddr 192.168.1.11 uboot $ tftp 0x200000 atf.bin uboot $ nand erase 0x0C0000 0x40000 uboot $ nand write 0x200000 0x0C0000 FileSize(Hex) uboot uboot $ setenv bootargs \u201cYOUR_EVB_BOOTARGS\u201d uboot $ setenv serverip server 192.168.1.20 uboot $ setenv ipaddr 192.168.1.11 uboot $ tftp 0x200000 uboot.bin uboot $ nand erase 0x100000 0x1C0000 uboot $ nand write 0x200000 0x100000 FileSize(Hex) Linux kernel uboot $ setenv bootargs \u201cYOUR_EVB_BOOTARGS\u201d uboot $ setenv serverip server 192.168.1.20 uboot $ setenv ipaddr 192.168.1.11 uboot $ tftp 0x200000 Image.bin uboot $ nand erase 0x300000 0x0500000 uboot $ nand write 0x200000 0x300000 FileSize(Hex) Ramdisk (SDK/output/raw/) uboot $ setenv bootargs \u201cYOUR_EVB_BOOTARGS\u201d uboot $ setenv serverip server 192.168.1.20 uboot $ setenv ipaddr 192.168.1.11 uboot $ tftp 0x200000 rootfs.ramdisk.bin.raw uboot $ nand erase 0x800000 0x3160000 uboot $ nand write 0x200000 0x800000 FileSize(Hex) UBIFS (SDK/output/raw/) uboot $ setenv bootargs \u201cYOUR_EVB_BOOTARGS\u201d uboot $ setenv serverip server 192.168.1.20 uboot $ setenv ipaddr 192.168.1.11 uboot $ tftp 0x200000 rootfs_1.rw.ubifs.bin.ubi.raw uboot $ nand erase 0x3960000 0x2500000 uboot $ nand write.trimffs 0x200000 0x3960000 FileSize(Hex)","title":"TFTP SOP"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#pcie-cascade-update-sop-nand","text":"First step, it\u2019s to follow up chapter 2.5.1 \u201cBoot from UART SOP\u201d let the system booting to uboot shell. Setup uboot env (if your uboot env mtdparts is null or your layout is different with SDK partition table.) uboot $ setenv mtdparts \"spi_nand.0:0x40000@0x40000(fdt),0x40000@0xc0000(atf),0x1c0000@0x100000(uboot),0x40000@0x2c0000(uenv),0x500000@0x300000(linux),0x2100000@0x800000(rootfs0),0x2500000@0x2900000(rootfs1),0x1060000@0x4E00000(rootfs2),0x21a0000@0x5e60000(app)\" uboot $ setenv mtdids \"nand0=spi_nand.0\" DFU init in uboot shell uboot $ dfu 0 nand 0 To check whether the USB download gadget in your device management of the PC\u2019s Windows is existed or not as below, please install the Windows drivers by zadig-2.4.exe if it does not exist. Running DFUBringUP_cascade.bat can update all partitions. You can edit this \u201cDFUBringUP_cascade.bat\u201d to control the update flow. For other partition layout or file type modification details can refer to software\\pc\\document\\DFUTools\\ NT9833x_DFU_User_Guide_en.pdf dfu-util-static.exe -d 07b4:0109 -a 0 -D image_cascade\\LD98336A.bin dfu-util-static.exe -d 07b4:0109 -a 1 -D image_cascade\\nvt-all.bin dfu-util-static.exe -d 07b4:0109 -a 2 -D image_cascade\\atf.bin dfu-util-static.exe -d 07b4:0109 -a 3 -D image_cascade\\uboot.bin dfu-util-static.exe -d 07b4:0109 -a 4 -D image_cascade\\Image.bin dfu-util-static.exe -d 07b4:0109 -a 5 -D image_cascade\\rootfs.ramdisk.bin.raw dfu-util-static.exe -d 07b4:0109 -a 6 -D image_cascade\\rootfs_1.rw.ubifs.bin.ubi.raw dfu-util-static.exe -d 07b4:0109 -a 7 -D image_cascade\\rootfs.ep.ramdisk.bin.raw dfu-util-static.exe -d 07b4:0109 -a 8 -D image_cascade\\DVR_DUAL_32CH.nand.ubifs.raw pause Switch jump with nand boot mode and reboot","title":"PCIE cascade update SOP (NAND)"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#emmc-update-sop","text":"First step, it\u2019s to follow up chapter 2.5.1 \u201cBoot from UART SOP\u201d let the system booting to uboot shell. Setup uboot env (if your uboot env mtdparts is null or your layout is different with SDK partition table.) uboot $ setenv nvtemmcpart \"0x200@0x0(loader),0x40000@0x40000(fdt)ro,0x40000@0x80000(fdt.restore),0x40000@0xc0000(atf)ro,0x200000@0x100000(uboot)ro,0x40000@0x300000(uenv),0x400000@0x340000(linux)ro,0xa000000@0x740000(rootfs0),0xa000000@0xa740000(rootfs1),0xc000000@0x14740000(rootfs2)\" DFU init in uboot shell uboot $ dfu 0 mmc 1 To check whether the USB download gadget in your device management of the PC\u2019s Windows is existed or not as below, please install the Windows drivers by zadig-2.4.exe if it does not exist. Check HW bootstrap setting is 4-bit or 8-bit mode, select the corresponding loader and put it into the image_emmc folder. Running DFUBringUP_emmc.bat can update all partitions. You can edit this \u201cDFUBringUP_emmc.bat\u201d to control the update flow. For other partition layout or file type modification details can refer to software\\pc\\document\\DFUTools\\ NT9833x_DFU_User_Guide_en.pdf dfu-util-static.exe -d 07b4:0109 -a 0 -D image_emmc\\LD98336A_4bit.bin dfu-util-static.exe -d 07b4:0109 -a 1 -D image_emmc\\nvt-all.bin dfu-util-static.exe -d 07b4:0109 -a 2 -D image_emmc\\atf.bin dfu-util-static.exe -d 07b4:0109 -a 3 -D image_emmc\\u-boot.bin dfu-util-static.exe -d 07b4:0109 -a 4 -D image_emmc\\Image.bin dfu-util-static.exe -d 07b4:0109 -a 5 -D image_emmc\\rootfs.ramdisk.bin.raw dfu-util-static.exe -d 07b4:0109 -a 6 -D image_emmc\\rootfs.rw.ext4.bin.raw dfu-util-static.exe -d 07b4:0109 -a 7 -D image_emmc\\DVR_16CH.emmc.ext4.bin.raw pause Switch jump with emmc boot mode and reboot","title":"EMMC update SOP"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#pcie-cascade-update-sop-emmc","text":"First step, it\u2019s to follow up chapter 2.5.1 \u201cBoot from UART SOP\u201d let the system booting to uboot shell. Setup uboot env (if your uboot env mtdparts is null or your layout is different with SDK partition table.) uboot $ setenv nvtemmcpart \"0x200@0x0(loader),0x40000@0x40000(fdt)ro,0x40000@0x80000(fdt.restore),0x40000@0xc0000(atf)ro,0x200000@0x100000(uboot)ro,0x40000@0x300000(uenv),0x400000@0x340000(linux)ro,0xa000000@0x740000(rootfs0),0xa000000@0xa740000(rootfs1),0xc000000@0x14740000(rootfs2),0x1060000@0x20740000(rootfs3)\" DFU init in uboot shell uboot $ dfu 0 mmc 1 To check whether the USB download gadget in your device management of the PC\u2019s Windows is existed or not as below, please install the Windows drivers by zadig-2.4.exe if it does not exist. Running DfuBringUp_emmc_cascade.bat can update all partitions. You can edit this \u201cDfuBringUp_emmc_cascade.bat\u201d to control the update flow. For other partition layout or file type modification details can refer to software\\pc\\document\\DFUTools\\ NT9833x_DFU_User_Guide_en.pdf dfu-util-static.exe -d 07b4:0109 -a 0 -D image_emmc_cascade\\LD98336A_4bit.bin dfu-util-static.exe -d 07b4:0109 -a 1 -D image_emmc_cascade\\nvt-all.bin dfu-util-static.exe -d 07b4:0109 -a 2 -D image_emmc_cascade\\atf.bin dfu-util-static.exe -d 07b4:0109 -a 3 -D image_emmc_cascade\\u-boot.bin dfu-util-static.exe -d 07b4:0109 -a 4 -D image_emmc_cascade\\Image.bin dfu-util-static.exe -d 07b4:0109 -a 5 -D image_emmc_cascade\\rootfs.ramdisk.bin.raw dfu-util-static.exe -d 07b4:0109 -a 6 -D image_emmc_cascade\\rootfs.rw.ext4.bin.raw dfu-util-static.exe -d 07b4:0109 -a 7 -D image_emmc_cascade\\DVR_DUAL_16CH.emmc.ext4.bin.raw dfu-util-static.exe -d 07b4:0109 -a 8 -D image_emmc_cascade\\rootfs.ep.ramdisk.bin.raw pause Switch jump with emmc boot mode and reboot","title":"PCIE cascade update SOP (EMMC)"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#nor-update-sop","text":"Setup uboot env (if your uboot env mtdparts is null or your layout is different with SDK partition table.) uboot $ setenv mtdparts \"spi_nor.0:0x20000@0x10000(fdt),0x20000@0x50000(atf),0x40000@0x70000(uboot),0x10000@0xb0000(uenv),0x300000@0xc0000(linux),0xd40000@0x3c0000(rootfs0),0xe20000@0x1100000(app)\" uboot $ setenv mtdids \"nor0=spi_nor.0\" DFU init in uboot shell uboot $ dfu 0 sf 0:0 To check whether the USB download gadget in your device management of the PC\u2019s Windows is existed or not as below, please install the Windows drivers by zadig-2.4.exe if it does not exist. Running DFUBringUP_nor.bat can update all partitions. You can edit this \u201cDFUBringUP_nor.bat\u201d to control the update flow. For other partition layout or file type modification details can refer to software\\pc\\document\\DFUTools\\ NT9833x_DFU_User_Guide_en.pdf dfu-util-static.exe -d 07b4:0109 -a 0 -D image_nor\\LD98336A.bin dfu-util-static.exe -d 07b4:0109 -a 1 -D image_nor\\nvt-all.bin dfu-util-static.exe -d 07b4:0109 -a 2 -D image_nor\\atf.bin dfu-util-static.exe -d 07b4:0109 -a 3 -D image_nor\\u-boot.lz.bin dfu-util-static.exe -d 07b4:0109 -a 4 -D image_nor\\Image.bin dfu-util-static.exe -d 07b4:0109 -a 5 -D image_nor\\rootfs.squash.bin.raw dfu-util-static.exe -d 07b4:0109 -a 6 -D image_nor\\DVR_16CH.nor.jffs2.bin.raw pause","title":"NOR update SOP"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#trouble-shooting","text":"","title":"Trouble shooting"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#ping-error-on-uboot-shell","text":"Please follow steps as below to fix the problem : Check if your uboot config CONFIG_NOVATEK_MAC_ENET_NA51090 is enable Check if the serverip, ipadder, netmask and gatewayip settings are in the same LAN Check if your windows firewall is close","title":"Ping error on uboot shell"},{"location":"Software/OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html#dfu-driver-problem","text":"The following message is your dfu device driver problem, please install the DFU drivers.","title":"DFU driver problem"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html","text":"Development Environment \u00b6 VirtualBox/Ubuntu OS installation \u00b6 This section will introduce how to install Ubuntu on Windows OS, ignore this section if your environment is under single OS. Please download from VirtualBox official website ( https://www.virtualbox.org/wiki/Downloads ) and follow below instructions to install. This step will install device driver, please select \u201cInstall\u201d: Create virtual machine (Version: Ubuntu 64-Bit): Select virtual machine memory size: Create virtual machine (If you have an existed Ubuntu image, you can select \u201cUse an existing virtual hard disk file\u201d): To configure virtual disk space (At least 40GB size): Select Optical drive and using Ubuntu ISO (Ubuntu 12.04/14.04/16.04/18.04 64-bit) startup: Linux environment setup \u00b6 In order to prevent some complaints in the SDK compilation of the 32 Bits OS, we will use 64 Bits Ubuntu OS as our development environment. The first of all, you should install an Ubuntu based server or Ubuntu on VirtualBox which is introduced in previous section, please download the image from ( http://releases.ubuntu.com/ ) to get Ubuntu 12.04/14.04/16.04/18.04 Desktop AMD64 version ISO image and use the following instructions to install necessary Ubuntu packages. Ubuntu 12.04: \\$ sudo apt-get install bc build-essential libc6-dev libncurses5-dev libgl1-mesa-dev g++-multilib mingw32 tofrodos ia32-libs uboot-mkimage zlib1g-dev mtd-utils vim squashfs-tools gawk cmake cmake-data libstdc++6 device-tree-compiler android-tools-fsutils texinfo libssl-dev python3-crypto python3-pyelftools python3-pycrypto \\$ sudo add-apt-repository ppa:nathan-renniewaldock/ppa \\$ sudo apt-get update \\$ sudo apt-get install liblz4-tool To install make-4.1 ( This will replace your original /bin/make tool ): Download https://ftp.gnu.org/gnu/make/make-4.1.tar.bz2 \\$ tar -jxvf make-4.1.tar.bz2 \\$ cd make-4.1; ./configure; make -j4 \\$ make install Ubuntu 14.04: \\$ sudo apt-get install bc build-essential libc6-dev lib32ncurses5 libncurses5-dev libncurses5:i386 libgl1-mesa-dev g++-multilib mingw32 tofrodos lib32z1 lib32bz2-1.0 u-boot-tools zlib1g-dev bison libbison-dev flex mtd-utils vim squashfs-tools gawk cmake cmake-data liblz4-tool libmpc3 libstdc++6 device-tree-compiler android-tools-fsutils texinfo libssl-dev python3-crypto python3-pyelftools python3-pycrypto To install make-4.1 ( This will replace your original /bin/make tool ): Download https://ftp.gnu.org/gnu/make/make-4.1.tar.bz2 \\$ tar -jxvf make-4.1.tar.bz2 \\$ cd make-4.1; ./configure; make -j4 \\$ make install Ubuntu 16.04: \\$ sudo apt-get install bc build-essential libc6-dev lib32ncurses5 libncurses5-dev libncurses5:i386 libgl1-mesa-dev g++-multilib mingw-w64 tofrodos lib32z1 u-boot-tools zlib1g-dev bison libbison-dev flex mtd-utils vim squashfs-tools gawk cmake cmake-data liblz4-tool libmpc3 libstdc++6 device-tree-compiler android-tools-fsutils texinfo libssl-dev python3-crypto python3-pyelftools python3-pycrypto Ubuntu 18.04: \\$ sudo apt-get install bc build-essential libc6-dev lib32ncurses5 libncurses5-dev libncurses5:i386 libgl1-mesa-dev g++-multilib mingw-w64 tofrodos lib32z1 u-boot-tools zlib1g-dev bison libbison-dev flex mtd-utils vim squashfs-tools gawk cmake cmake-data liblz4-tool libmpc3 libstdc++6 device-tree-compiler android-tools-fsutils texinfo libssl-dev python3-crypto python3-pyelftools python3-pycrypto Ubuntu default shell is dash, please reconfigure the default shell with bash: \\$ sudo dpkg-reconfigure dash, and choose \u201cNo\u201d in the window Or \\$ sudo rm /bin/sh && sudo ln -s /bin/bash /bin/sh Besides, the openssh-server is used to provide Windows Host PC connected to Linux server and remote building the Linux SDK, and the Samba server is to provide client get Linux SDK image from Linux server. \\$ apt-get install openssh-server \\$ apt-get install samba \\$ vim /etc/samba/smb.conf Please reference to related Samba configuration as below: https://help.ubuntu.com/12.04/serverguide/samba-fileserver.html Windows Host PC will also need Teraterm or putty to connect to Target board UART2 port with 115200/8/1/n configuration. Figure 1-1 Linux Development Environment How to install NT9833x Linux SDK \u00b6 Using the following instructions to decompress SDK pack under Linux: \\$ tar -jxvf na51090_linux_sdk_{version}.tar.bz2 You will get the folder tree as below: \u251c\u2500\u2500 na51090_linux_sdk Used to put unpacked SDK source code \u251c\u2500\u2500 BSP Including linux, busybox, uboot and rootfs source \u251c\u2500\u2500 build scripts for the environment setup \u251c\u2500\u2500 code HDAL, linux drivers and sample code \u251c\u2500\u2500 configs Model settings \u251c\u2500\u2500 Makefile Top level Makefile \u2514\u2500\u2500 tools target board tool \u251c\u2500\u2500 toolchains Toolchain folder \u251c\u2500\u2500 aarch64-ca53-linux-gnueabihf-8.4.tar.bz2 \u2514\u2500\u2500 aarch64-ca53-linux-uclibcgnueabihf-8.4.tar.bz2 How to install Cross compiler \u00b6 We support both glibc and uclibc cross compiler toolchain, please choose and install it by using below instructions: \\$ cd toolchain \\$ sudo tar -jxvf aarch64-ca53-linux-gnueabihf-8.4.tar.bz2 -C /opt or \\$ sudo tar -jxvf aarch64-ca53-linux-uclibcgnueabihf-8.4.tar.bz2 -C /opt Introduction to Compilation \u00b6 Environment setup \u00b6 Before each opened a new Terminal window needs to do compiler environment setting, the relevant variables set up, please follow the below instructions to finish it. \\$ cd na51090_linux_sdk/ \\$ source build/envsetup.sh Compilation \u00b6 Please do a complete compilation for first time. Select your model: \\$ lunch List your nvt build setting: \\$ get_stuff_for_environment Build overall system: \\$ make all It will generate the images under na51090_linux_sdk/output after the compilation. The details are listed as below. |\u2013 na51090_linux_sdk Put unpacked source code and image | |\u2013 Makefile Top level Makefile | |\u2013 output Compiled output images | |\u2013 packed | |\u2013 FW(SOC)A.bin nvtpack image (All-in-one image) | |\u2013 atf.bin ATF image | |\u2013 Image.bin Linux Image | |\u2013 u-boot.bin uboot image with NVT checksum | |\u2013 u-boot.lz.bin uboot image (LZ compressed) | |\u2013 rootfs.ramdisk.bin ramdisk image (rootfs) | `\u2013 rootfs_1.rw.ubifs.bin rootfs overlay Top level Makefile \u00b6 na51090_linux_sdk folder has a top level Makefile, it supports many of the make command, such as \u201cmake linux\u201d is to compile linux-kernel, \u201cmake uboot\u201d can compile u-boot, \u201cmake rootfs\u201d can compile root-fs \u2026 and so on, you can use \u201cmake help\u201d to find what its commands are supported. Please use top level Makefile to do SDK compilation to avoid some link error occurred. Its help description is as follows: \\$ make help ===================================================== make help -> show make command info make all -> build all make linux -> build linux-kernel make linuxram -> build linux-kernel with ramdisk support make modules -> build built-in kernel modules make driver -> build NVT linux driver modules make atf -> build ARM trusted firmware make uboot -> build loader(uboot) make optee_os -> build OPTEE kernel make optee_client -> build OPTEE client make library -> build library make busybox -> build busybox make rootfs -> build rootfs make app -> build applications make tools -> build tools make sample -> build sample code make post -> run postprocessing script make pack -> Generate nvtpack image and preburn images make publish -> remove some sources for publish ===================================================== make linux_config -> config linux-kernel make linux_config_gcov-> modify kernel config for code coverage tool make uboot_config -> config uboot make busybox_config -> config busybox make linux_header -> generate linux-kernel out of tree headers ===================================================== make clean -> clean all make linux_clean -> clean linux-kernel & built-in kernel modules make driver_clean -> clean NVT linux driver modules make atf_clean -> clean ARM trusted firmware make uboot_clean -> clean loader(uboot) make optee_os_clean -> clean optee kernel make optee_client_clean -> clean optee client application make library_clean -> clean library make busybox_clean -> clean busybox make rootfs_clean -> clean rootfs make app_clean -> clean applications make tools_clean -> clean tools make sample_clean -> clean sample code make post_clean -> run postprocessing clean script make pack_clean -> Remove nvtpack image ===================================================== Project configuration \u00b6 We provide the following file to control functionalities enable or disable, please refer to the below procedures to configure. Check model type: \\$ get_stuff_for_environment ======================================== NVT Setting ======================================== NVT_PRJCFG_MODEL_CFG = /home/user1/na51090_linux_sdk/configs/Linux/cfg_xxx_NAND_EVB/ModelConfig.mk NVT_PRJCFG_CFG = Linux NVT_PRJCFG_MODEL_MK = The ModelConfig.mk will be generated from configs/cfg_gen/nvt-info.dtsi Enable/disable function: \\$ cd na51090_linux_sdk/ \\$ vi configs/cfg_gen/nvt-info.dtsi To find Linux related options: /* * Novatek Ltd. BSP part of dts */ / { nvt_info { /* Get from ModelConfig.txt */ BIN_NAME = \"FW98336A\"; BIN_NAME_T = \"FW98336T\"; /* EMBMEM_BLK_SIZE, Normally, 2KPageNand=0x20000, 512PageNand=0x4000, SPI=0x10000 */ EMBMEM_BLK_SIZE = \"0x20000\"; /* * [EMBMEM] * EMBMEM_NONE * EMBMEM_NAND * EMBMEM_SPI_NOR * EMBMEM_SPI_NAND * EMBMEM_EMMC */ EMBMEM = \" EMBMEM_SPI_NAND\"; /* * ======= Linux common ========= * application/external */ NVT_CFG_APP_EXTERNAL = \"dhd_priv\"; /* application include list */ NVT_CFG_APP = \"\"; /* rootfs etc folder */ NVT_ROOTFS_ETC = \"\"; /* strip executable binary and library files: yes/no */ NVT_BINARY_FILE_STRIP = \"yes\"; /* Using customized kernel config */ NVT_CFG_KERNEL_CFG = \"\"; /* Using customized uboot config */ NVT_CFG_UBOOT_CFG = \"\"; /* * ======= Linux for different code setting ========= * [NVT_LINUX_SMP] * NVT_LINUX_SMP_ON * NVT_LINUX_SMP_OFF */ NVT_LINUX_SMP = \"NVT_LINUX_SMP_ON\"; /* * [NVT_DEFAULT_NETWORK_BOOT_PROTOCOL] * NVT_DEFAULT_NETWORK_BOOT_PROTOCOL_DHCP_SERVER * NVT_DEFAULT_NETWORK_BOOT_PROTOCOL_DHCP_CLIENT * NVT_DEFAULT_NETWORK_BOOT_PROTOCOL_STATIC_IP */ NVT_DEFAULT_NETWORK_BOOT_PROTOCOL = \"NVT_DEFAULT_NETWORK_BOOT_PROTOCOL_STATIC_IP\"; /* * [NVT_ROOTFS_TYPE] * NVT_ROOTFS_TYPE_NAND_UBI * NVT_ROOTFS_TYPE_NAND_SQUASH * NVT_ROOTFS_TYPE_NAND_JFFS2 * NVT_ROOTFS_TYPE_NOR_SQUASH * NVT_ROOTFS_TYPE_NOR_JFFS2 * NVT_ROOTFS_TYPE_RAMDISK * NVT_ROOTFS_TYPE_EMMC * NVT_ROOTFS_TYPE_NAND_SQUASH_NEW */ NVT_ROOTFS_TYPE = \"NVT_ROOTFS_TYPE_RAMDISK\"; /* * [NVT_ETHERNET] * NVT_ETHERNET_NONE * NVT_ETHERNET_EQOS */ NVT_ETHERNET = \"NVT_ETHERNET_EQOS\"; /* * [NVT_SDIO_WIFI]: Remember to update root-fs/rootfs/etc/init.d/S05_Net * NVT_SDIO_WIFI_NONE * NVT_SDIO_WIFI_RTK * NVT_SDIO_WIFI_BRCM * NVT_SDIO_WIFI_NVT */ NVT_SDIO_WIFI = \"NVT_SDIO_WIFI_NONE\"; /* * [NVT_USB_WIFI] * NVT_USB_WIFI_NONE */ NVT_USB_WIFI = \"NVT_USB_WIFI_NONE\"; /* * [NVT_USB_4G] * NVT_USB_4G_NONE */ NVT_USB_4G = \"NVT_USB_4G_NONE\"; /* * [WIFI_RTK_MDL] : sub item for NVT_SDIO_WIFI_RTK * WIFI_RTK_MDL_NONE * WIFI_RTK_MDL_8189 */ WIFI_RTK_MDL = \"WIFI_RTK_MDL_8189\"; /* * [WIFI_BRCM_MDL] : sub item for NVT_SDIO_WIFI_BRCM * WIFI_BRCM_MDL_43438a1_ampk6212axtal26 * WIFI_BRCM_MDL_43455c0_ampk6255c0 */ WIFI_BRCM_MDL = \"WIFI_BRCM_MDL_43438a1_ampk6212axtal26\"; /* * [WIFI_NVT_MDL] : sub item for NVT_SDIO_WIFI_NVT * WIFI_NVT_MDL_18202 * WIFI_NVT_MDL_18211 */ WIFI_NVT_MDL = \"WIFI_NVT_MDL_18211\"; /* * [NVT_CURL_SSL] * NVT_CURL_SSL_OPENSSL * NVT_CURL_SSL_WOLFSSL */ NVT_CURL_SSL = \"NVT_CURL_SSL_OPENSSL\"; /* * [NVT_UBOOT_ENV_IN_STORG_SUPPORT] * NVT_UBOOT_ENV_IN_STORG_SUPPORT_NAND * NVT_UBOOT_ENV_IN_STORG_SUPPORT_NOR * NVT_UBOOT_ENV_IN_STORG_SUPPORT_MMC * NVT_UBOOT_ENV_IN_STORG_SUPPORT_OFF */ NVT_UBOOT_ENV_IN_STORG_SUPPORT = \"NVT_UBOOT_ENV_IN_STORG_SUPPORT_OFF\"; }; }; Build U-boot \u00b6 Compilation \u00b6 The Uboot source code is placed on \u201cna51090_linux_sdk/u-boot\u201d, typing \u201cmake uboot\u201d can be used to compile Uboot, and we provide two images are u-boot.bin(non-compressed) and u-boot.lz.bin(compressed) under na51090_linux_sdk/output. U-boot build: \\$ cd na51090_linux_sdk/ \\$ make uboot U-boot config: \\$ cd na51090_linux_sdk/ \\$ make uboot_config U-boot clean build: \\$ make uboot_clean User customization \u00b6 The uboot have two config files will have different configured properties. One is for common function, the other is for the low level setting. The low level setting can modify this file \u201cinclude/configs/nvt-na51090-evb-a64.h\u201d directly when you have request for the Uboot related configuration. e.g. Uboot passed to Linux\u2019s cmdline can be changed with this variable #define CONFIG_USE_BOOTARGS #define CONFIG_BOOTARGS_COMMON \"earlycon=nvt_serial,0x2f0280000 rootwait console=ttyS0,115200 debug_boot_weak_hash \" #define CONFIG_BOOTARGS CONFIG_BOOTARGS_COMMON \"root=/dev/ram0 rootfstype=ramfs rdinit=/linuxrc \" Please reference to \u201cSDK_UBoot_Programming_Guide_en\u201d for more details. Build Kernel Code \u00b6 Compilation \u00b6 The Linux kernel source code is placed on \u201cna51090_linux_sdk/linux-kernel\u201d, typing \u201cmake linux\u201d can be used to compile Linux kernel, and the image name is Image.bin under na51090_linux_sdk. \\$ cd na51090_linux_sdk/ \\$ make linux Linux clean build: \\$ make linux_clean System configuration \u00b6 Menu configuration \u00b6 Top Makefile is already integrated the formal Linux menuconfig, to use the following instruction can do the function selection. Please avoid using formal Linux \u201cmake menuconfig\u201d under linux-kernel directly; it will cause error because the important variables are not set correctly. \\$ make linux_config Choose \u201cSave\u201d after finished function selection; it can generate a new .config for the Linux compilation usage. NA51090 SDK provides two Kernel configuration file under \u201cna51090_linux_sdk/BSP/linux-kernel/arch/arm64/configs/\u201d, one is for the debug mode, and the other is for the release mode. na51090_XXX_defconfig_debug, the debug mode will enable most of the functions for the development stage na51090_XXX_defconfig_release, the release mode will only enable boot necessary parts. Edit Top Makefile to switch the configuration file: \\$ cd na51090_linux_sdk/ \\$ vi Makefile ## kernel & modules CUSTBOARDCONFIG := $(strip $(shell echo $(NVT_PRJCFG_MODEL_CFG) | grep NVT_CFG_KERNEL_CFG | awk -F'=' '{print $$NF;}')) ifeq ($(EMBMEM), EMBMEM_SPI_NOR) #BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_nor_debug; fi) BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_nor_release; fi) else ifeq ($(EMBMEM), EMBMEM_EMMC) #BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_emmc_debug; fi) BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_emmc_release; fi) else #BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_debug; fi) BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_release; fi) endif Figure 4-1 Menu configuration Device tree \u00b6 The device tree can be generated by dtc(device tree compiler) tool as below, you can find the *.dtsi in \u201cna51090_linux_sdk/configs/cfg_xxx\u201d and users can set command \u201cmake cfg\u201d at \u201cna51090_linux_sdk/\u201d. Config items detail description put at na51090_linux_sdk/configs/doc. It can be used to compile device tree, and we will output image nvt-evb.dtb under na51090_linux_sdk/output. The merge method is Union, for example: configs/cfg_gen/nvt-basic.dtsi User can modify CPU clock-frequency from 1200000000(1.2GHz) to 1000000000(1GHz), or 1100000000(1.1GHz), or 1300000000(1.3GHz), or 1350000000(1.35GHz), and compiler again. Users can use new image to boot at new CPU clock-frequency. #include <dt-bindings/gpio/gpio.h> #include <dt-bindings/interrupt-controller/arm-gic.h> / { model = \"Novatek NA51090\"; compatible = \"novatek,na51090\", \"nvt,ca53\"; interrupt-parent = <&gic>; #address-cells = <2>; #size-cells = <2>; psci { compatible = \"arm,psci-0.2\"; method = \"smc\"; }; cpus { #address-cells = <2>; #size-cells = <0>; cpu0: cpu@0 { device_type = \"cpu\"; compatible = \"arm,cortex-a53\", \"arm,armv8\"; reg = <0x0 0x0>; next-level-cache = <&A53_L2>; clock-frequency = <1200000000>; enable-method = \"psci\"; }; cpu1: cpu@1 { device_type = \"cpu\"; compatible = \"arm,cortex-a53\", \"arm,armv8\"; reg = <0x0 0x1>; next-level-cache = <&A53_L2>; clock-frequency = <1200000000>; enable-method = \"psci\"; }; cpu2: cpu@2 { device_type = \"cpu\"; compatible = \"arm,cortex-a53\", \"arm,armv8\"; reg = <0x0 0x2>; next-level-cache = <&A53_L2>; clock-frequency = <1200000000>; enable-method = \"psci\"; }; cpu3: cpu@3 { device_type = \"cpu\"; compatible = \"arm,cortex-a53\", \"arm,armv8\"; reg = <0x0 0x3>; next-level-cache = <&A53_L2>; clock-frequency = <1200000000>; enable-method = \"psci\"; }; A53_L2: l2-cache0 { compatible = \"cache\"; }; }; \u2026 configs/cfg_gen/nvt-peri.dtsi #include <dt-bindings/gpio/nvt-gpio.h> #include \"nvt-basic.dtsi\" / { chosen { bootargs = \" \"; stdout-path = \"serial0:115200n8\"; }; aliases { serial0 = &uart0; serial1 = &uart1; serial2 = &uart2; serial3 = &uart3; serial4 = &uart4; mmc0 = &mmc0; /* Fixed to mmcblk0 for sdio1 */ }; uart0: uart@f0280000 { compatible = \"ns16550a\"; reg = <0x2 0xf0280000 0x0 0x1000>; interrupts = <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>; baud = <115200>; reg-shift = <2>; reg-io-width = <4>; no-loopback-test = <1>; clock-frequency = <24000000>; rx_trig_level = <3>; hw_flowctrl = <0>; }; uart1: uart@f0290000 { compatible = \"ns16550a\"; reg = <0x2 0xf0290000 0x0 0x1000>; interrupts = <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>; baud = <115200>; reg-shift = <2>; reg-io-width = <4>; no-loopback-test = <1>; clock-frequency = <48000000>; rx_trig_level = <3>; hw_flowctrl = <0>; }; uart2: uart@f02a0000 { compatible = \"ns16550a\"; reg = <0x2 0xf02a0000 0x0 0x1000>; interrupts = <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>; baud = <115200>; reg-shift = <2>; reg-io-width = <4>; no-loopback-test = <1>; clock-frequency = <48000000>; rx_trig_level = <3>; }; uart3: uart@f02b0000 { compatible = \"ns16550a\"; reg = <0x2 0xf02b0000 0x0 0x1000>; interrupts = <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>; baud = <115200>; reg-shift = <2>; reg-io-width = <4>; no-loopback-test = <1>; clock-frequency = <48000000>; rx_trig_level = <3>; }; uart4: uart@f02c0000 { compatible = \"ns16550a\"; reg = <0x2 0xf02c0000 0x0 0x1000>; interrupts = <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>; baud = <115200>; reg-shift = <2>; reg-io-width = <4>; no-loopback-test = <1>; clock-frequency = <48000000>; rx_trig_level = <3>; }; Partition table \u00b6 The Nand/EMMC driver of kernel will do for the set partition initialization process as shown below, Uboot will read the partition info(nvt-storage-partition.dtsi) from dts, and then the Kernel also read it from dts to do basic initialization. If you want to change flash partition size or add a partition, please configure device tree nvt-storage-partition.dtsi and build dtb image, burn into flash or load to dram again(default address at 0x1f00000). Figure 4-2 Partition initialization SPI NAND partition example: nvt-storage-partition.dtsi for flash partition &nand { partition_loader { label = \"loader\"; reg = <0x0 0x0000000 0x0 0x40000>; }; /* Fixed */ partition_fdt { label = \"fdt\"; reg = <0x0 0x40000 0x0 0x40000>; }; /* Fixed */ partition_fdt.restore { label = \"fdt.restore\"; reg = <0x0 0x80000 0x0 0x40000>; }; /* Fixed */ partition_atf { label = \"atf\"; reg = <0x0 0x0C0000 0x0 0x40000>; }; partition_uboot { label = \"uboot\"; reg = <0x0 0x100000 0x0 0x1C0000>; }; partition_uenv { label = \"uenv\"; reg = <0x0 0x2C0000 0x0 0x40000>; }; partition_kernel { label = \"kernel\"; reg = <0x0 0x300000 0x0 0x0500000>; }; partition_rootfs { label = \"rootfs\"; reg = <0x0 0x800000 0x0 0x5100000>; }; partition_rootfs1 { label = \"rootfs1\"; reg = <0x0 0x5900000 0x0 0x2700000>; }; }; If you want to change the partition size or add a partition, please configure it from the dts info. If users want to add user partition such as app1, users can add such as follow: partition_app1 { label = \"app1\"; reg = <0x0 start_addr 0x0 size>; }; Debug \u00b6 To debug the Kernel, you will need System.map or objects for the debug symbol loading, please get them from \u201clinux-kernel/\u201d as shown below: |\u2013 linux-kernel | |\u2013 Makefile | |\u2013 Module.symvers | |\u2013 System.map | |\u2013 arch | |\u2013 block | |\u2013 crypto | |\u2013 drivers | |\u2013 firmware | |\u2013 fs | |\u2013 include | |\u2013 init | |\u2013 ipc | |\u2013 kernel | |\u2013 lib | |\u2013 mm | |\u2013 modules.builtin | |\u2013 modules.order | |\u2013 net | |\u2013 scripts | |\u2013 security | |\u2013 sound | |\u2013 source | |\u2013 usr | |\u2013 vmlinux | `\u2013 vmlinux.o To add more debug information, we can turn on CONFIG_DEBUG_INFO option before compiling Linux kernel as below. \u201cKernel Hacking > Compile-time checks and compiler options > Compile the kernel with debug info\u201d \\$ cd na51090_linux_sdk/ \\$ make linux_config Rebuild all; this binary will contain debug symbol information. |\u2013 linux-kernel | |\u2013 vmlinux Build Kernel Modules \u00b6 In addition to build-in drivers, Linux had also provided an external load mode called Kernel module, can be loaded by \u201cmodprobe\u201d or \u201cinsmod\u201d. The below will introduce to build-in modules and the out-of-tree modules. Build-in module compilation \u00b6 Typing \u201cmake modules\u201d under na51090_linux_sdk can do build-in modules compilation and install path is root-fs/rootfs/lib/modules/{KER_VER}/kernel/. \\$ cd na51090_linux_sdk/ \\$ make modules Out-of-Tree module compilation \u00b6 This folder under \u201cna51090_linux_sdk/code\u201d provides NVT platform drivers, typing \u201cmake supplement\u201d to do the Out-of Tree modules compilation as below. And the modules will be installed on na51090_linux_sdk/BSP/root-fs/rootfs/lib/modules/{KER_VER}/extra/. \\$ cd na51090_linux_sdk/ \\$ make driver Linux Out-of-Tree driver module clean build: \\$ make driver_clean HDAL \u00b6 HDAL is the hardware abstraction layer driver and sample code, this one can be used to build proprietary driver modules, such as video process, video capture and video codec\u2026etc. We provide the following instructions to build. \\$ make hdal Clean build: \\$ make hdal_clean Please refer to the other documents for details. Installation \u00b6 The modules can be installed by \u201cmodprobe\u201d or \u201cinsmod/rmmod\u201d to install or uninstall, besides the modprobe will also install related modules automatically. Example: modprobe (Only needs the module name) modprobe ehci-hcd insmod/rmmod (This method needs a full path) insmod /lib/modules/{KER_VER}/extra/crypto/cryptodev-linux/cryptodev.ko Build tools \u00b6 This folder will integrate some Linux open source tools as the following description: htop - Linux process monitoring, to provide more than top information gdb - gdb server for the application debug ethtool - Utility for controlling network drivers and hardware bonnie++ - A benchmark suite that is aimed at performing a number of simple tests of hard drive and file system performance memtester - A userspace utility for testing the memory subsystem for faults mtd-utils - MTD device utilities procps - A tool set to provide system analysis tools (vmstat, slabtop,\u2026etc) stress - System performance testing tool stress-ng - Advanced system performance testing tool sdcard_test.sh- To do sd driver r/w testing iozone - IO r/w performance testing VDBench - CPU/io performance testing Compilation \u00b6 To select the tools what you want: mtd-utils, memtester, bonnie, ethtool, gdb, htop, netperf, iperf and procps and running below instructions: e.g. \\$ cd na51090_linux_sdk/ \\$ cd tools/ \\$ make stress Tools clean build: \\$ make clean Installation \u00b6 \\$ make install The tools will be installed on \u201cna51090_linux_sdk/BSP/root-fs\u201d. Build root-fs \u00b6 Introduction \u00b6 The root file system will be mounted by Linux kernel, the first process of the kernel is /sbin/init (PID=1). We provide several root file systems support for selection, the following are the summary features: UBIFS: readable/writable file system, support Nor and Nand flash, fast mounting speed, best bad block management and better IO performance. Suitable for low memory size and large flash size use condition. We have a detail introduction in OSDRV/NT9833x_UBI_Filesystem_User_Guide_en.doc Squashfs: read-only file system, high compression rate. Suitable for small size flash and readonly use condition. JFFS2: It is a log-structured file system which can support Nand and Nor flash devices. Providing zlib, lzo and rtime compression methods. Suitable for small flash size and readable/writable use condition. RAMDISK: To provide a ram based file system. Configuration \u00b6 The root file system will generate Nand flash type image format, we support squashfs and ubifs, please follow the Nand flash specification to modify the parameters: \\$ cd na51090_linux_sdk/BSP/root-fs/ \\$ vi ubi_max_leb.py To find below lines: W = 1024 SP = 128 * 1024 SL = 124 * 1024 According the Nand flash to modify the parameters: W is the entire flash chip Physical eraseblocks numbers SP is the Size of block page SL= (Size of block -2) * Size of page. e.g. 128MB Nand flash = 1024 eraseblocks = 1024 * 128KB W = 1024 SP = 64 * 2048 = 128 * 1024 SL = (64 \u2013 2) * 2048 = 124 * 1024 \\$ vi mtd_cfg.txt We can support two mtd_cfg.txt in BSP/root-fs/ and configs/cfg_gen, the build tool will search configs/cfg_gen/mtd_cfg.txt firstly, and the second is BSP/root-fs/mtd_cfg.txt. To find below lines: ROOTFS_UBI_SUB_PAGE_SIZE=2048 ## Same as page size ROOTFS_UBI_PAGE_SIZE=2048 ## Nand page size ROOTFS_UBI_ERASE_BLK_SIZE=126976 ## (64-2) * Page size=126976 ROOTFS_UBI_MAX_LEB_COUNT=361 ## Size = UBI_MAX_LEB_COUNT * UBI_BLK_SIZE; It's calculated by \"python ubi_max_leb.py Bytes\" ROOTFS_UBI_RW_MAX_LEB_COUNT=258 ## Size = UBI_MAX_LEB_COUNT * UBI_BLK_SIZE; It's calculated by \"python ubi_max_leb.py Bytes\" ROOTFS_UBI_BLK_SIZE=\"128KiB\" ## UBIFS Nand flash block size (KiB) ROOTFS_UBI_COMPRESS_MODE=\"lzo\" ## UBIFS compression type: \"lzo\", \"favor_lzo\", \"zlib\" \"none\" ROOTFS_SQ_COMPRESS_MODE=\"xz\" ## Squashfs compression type: \"gzip\", \"lzo\" and \"xz\" ROOTFS_SQ_BLK_SIZE=\"128K\" ## Squashfs Nand flash block size (KiB): e.g. spinand: 128K, spinor: 64K ROOTFS_JFFS2_COMPRESS_MODE=\"lzo\" ## jffs2 compression type: \"lzo\" \"zlib\" \"rtime\" ROOTFS_JFFS2_SIZE=0x3200000 ## jffs2 partition size: get from /proc/mtd ROOTFS_JFFS2_RW_SIZE=0x2500000 ## jffs2 partition size: get from /proc/mtd ROOTFS_JFFS2_BLK_SIZE=\"128KiB\" ## jffs2 block size (KiB): spinand: 128KiB, spinor: 64KiB ROOTFS_JFFS2_PAGE_SIZE=\"2048\" ## jffs2 page size (Bytes): only used by nand, nor flash can be ignored. ROOTFS_EXT4_SIZE=$(shell printf \"%d\\n\" 0x0A000000) ROOTFS_FAT_CACHE_SIZE=$(shell printf \"%d\\n\" 0x0A000000) #APPFS ROOTFS_JFFS2_APP_SIZE=0x01E0000 ROOTFS_JFFS2_APP_NOR_SIZE=0x0E20000 ROOTFS_UBI_APP_MAX_LEB_COUNT=231 The necessary parameters need to be modified as below description: ROOTFS_UBI_SUB_PAGE_SIZE: The sub-page size of the Nand flash ROOTFS_UBI_PAGE_SIZE: The page size of the Nand flash ROOTFS_UBI_ERASE_BLK_SIZE: (Nand flash block size \u2013 2) * Page size ROOTFS_UBI_MAX_LEB_COUNT: Use ubi_max_leb.py to calculate it \\$ Usage: ubi_max_leb.py PartitionSize (Bytes) ROOTFS_UBI_RW_MAX_LEB_COUNT: Use ubi_max_leb.py to calculate it \\$ Usage: ubi_max_leb.py PartitionSize (Bytes) ROOTFS_UBI_BLK_SIZE: Nand flash block size ROOTFS_UBI_COMPRESS_MODE: Compression method = LZO ROOTFS_SQ_COMPRESS_MODE: Squashfs compression mode ROOTFS_SQ_BLK_SIZE: Squashfs nand flsh block size ROOTFS_JFFS2_COMPRESS_MODE: jffs2 compression type: \u201clzo\u201d \u201czlib\u201d \u201crtime\u201d ROOTFS_JFFS2_SIZE: Rootfs partition size ROOTFS_EXT4_SIZE: EMMC boot partition size ROOTFS_FAT_CACHE_SIZE: EMMC boot FAT partition size (Optional) ROOTFS_JFFS2_APP_SIZE: The size of the app partition in nand flash ROOTFS_JFFS2_APP_NOR_SIZE: The size of the app partition in nor flash ROOTFS_UBI_APP_MAX_LEB_COUNT: The ubi image size in app partition (Use ubi_max_leb.py to calculate it) You can modify the ubi mount parameters with your requirement, e.g. BSP/root-fs/ubi_max_leb.py def get_ubifs_max_leb(partition_size): #Unit: Bytes P = partition_size/SP BR = math.ceil(30 * W/float(1024)) ## Sync with kernel B = max(BB, BR) ubi_overhead = (( B - BB + 4 ) * SP + O * ( P - B - 4 ))/float(SP) ubi_overhead = math.ceil(ubi_overhead) ubi_overhead = math.floor(((P - ubi_overhead) * SP) / float(SL)) if ubi_overhead < 0: return -1 else: return (ubi_overhead - 1) Note: linux menuconfig Maximum expected bad eraseblock count per 1024 eraseblocks value \u201c30\u201d must be the same with ubi_max_leb.py value \u201c30\u201d. This parameter will affect the bad block management, please reserve enough blocks(e.g. 10, 20) per 1024 erase blocks. Modify flash filesystem partition size \u00b6 Users must check mtd config definiton in configs/cfg_gen/mtd_cfg.txt, the parameters: ROOTFS_UBI_MAX_LEB_COUNT, ROOTFS_UBI_RW_MAX_LEB_COUNT and ROOTFS_UBI_APP_MAX_LEB_COUNT value must use ubi_max_leb.py to calculate. Compilation \u00b6 Using \u201cmake rootfs\u201d instruction to generate rootfs bin, the image type can be selected by nvt-info.dtsi in configs folder. They can be produced into \u201cna51090_linux_sdk/output/rootfs.ubifs.bin\u201d, \u201cna51090_linux_sdk/output/rootfs.squash.bin\u201d and \u201cna51090_linux_sdk/output/rootfs.jffs2.bin\u201d separately. The command \u201cmr\u201d also can be used to compile rootfs if you are not in na51090_linux_sdk root folder. \\$ cd na51090_linux_sdk/ \\$ source build/envsetup.sh \\$ make rootfs Rootfs clean build: \\$ make rootfs_clean This command will remove busybox tools, kernel modules\u2026etc., please follow below procedure to generate rootfs image: \\$ make busybox \\$ make app (\\$ make library if necessary) \\$ make hdal \\$ make rootfs Folder description \u00b6 Architecture Folder Description bin User binaries dev Device files etc System management configuration files home User home directories init -> bin/busybox It is used to kernel boot necessary init process, for the initial environment setup. lib Standard system libraries linuxrc -> bin/busybox mnt External storage device mount folder (/mnt/sd, /mnt/usb) proc RAM based FS to provide process information root Root\u2019s folder (The default shell will login here) sbin System management binaries srv Service data sys RAM based FS to provide user space and kernel space attribute/properties link. tmp RAM based temp folder usr User libraries, binaries var Service log message, including kernel, application, web server default folder(/var/www) and service\u2026etc /etc/passwd This file can setup user account environment, below is to introduce how to enable login password. \\$ vi /etc/inittab ::respawn:-/bin/login Replace \u201c::respawn:-/bin/login -f root\u201d with \u201c::respawn:-/bin/login\u201d as below Fill in the red part with the encryption password which can be generated by openssl tool: \\$ vi /etc/passwd root:EncryptionCode:0:0:root:/root:/bin/sh Openssl generation: \\$ openssl passwd -crypt YourPWD /etc/init.d System will execute the following shell scripts according sequence. rcS -> S00_PreReady -> S05_Net -> S10_SysInit -> S10_hdal_init -> S99_Sysctl Moreover, power off will execute deinitialization process as below. rcK -> K00_Sys -> K99_Sys /etc/sysctl.conf This file is handle sysctl parameters setup. UBIFS \u00b6 The UBIFS is our default rootfs format, UBIFS (Unsorted Block Image File System) was originally called JFFS3, is JFFS2 next generation version. The main capabilities are faster mounting, quicker access to large files, and improved write speeds. UBIFS also preserves or improves upon JFFS2\u2019s on-the-fly compression, recoverability and power fail tolerance, and data compression allows zlib or LZO. The filename is UBI.IMG after compilation. Squashfs \u00b6 Squashfs is a read-only file system which can support gzip, lzo and xz compression modes. The main features are high compression rate, stores full 32bits uid/gids and creation time, support block size up to 1Mbytes. The filename is SQ_ROOTFS.IMG after compilation. Jffs2 \u00b6 JFFS2 was developed by Red Hat, based on the work started in the original JFFS by Axis Communications, AB, it is a readable and writable file system. JFFS2 will scan rootfs partition during mounting; the mount time depends on the rootfs size. The main features are listed as below: Support compression mode Mounting time will be affected by flash size Not support all Nand flash devices with HW ecc, please refer to Linux driver application note The filename is rootfs.jffs2.bin after compilation. For the kernel configuration to add jffs2 support, you must add below configurations: File systems -> Miscellaneous filesystems -> [*] Journalling Flash File System v2 (JFFS2) support -> [*] Advanced compression options for JFFS2 -> [*] JFFS2 LZO compression support For the uboot configuration to choose root file system type, please refer to the UBoot_Programing_Guide. HDAL sample code \u00b6 We will pack one partition named DVR_xxx.bin is under na51090_linux_sdk/configs/Linux/cfg_xxx/nvt-nvtpack.dtsi partition_name = \u201capp\u201d field. You could modify the partition size and recalculate the related parameters to fill in the nvt -storage-partition.dtsi partition_app field. Please refer to 7.2 for mtd_cfg.txt description. Build App \u00b6 Compilation \u00b6 NVT platform needs the necessary applications to perform the requested actions, please using below instructions to compile (This part doesn\u2019t provide source code). \\$ cd na51090_linux_sdk/code/application \\$ make install Please execute \u201csource build/envsetup.sh\u201d firstly when you start to build it. Please reference to Application Note for the other details. We have fine-tuned some functions and the fpu related setting, please add \\$(PLATFORM_CFLAGS) to your Makefile to get more performance. e.g. nvt02854@oaalnx13:~/na51090_linux_sdk/na51090_linux_sdk$ get_stuff_for_environment ======================================== NVT Setting ======================================== NVT_PRJCFG_CFG = Linux NVT_PRJCFG_MODEL_CFG = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/configs/Linux/cfg_TEST_FPGA_a64/ModelConfig.mk LINUX_BUILD_TOP = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk UBOOT_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/u-boot OPTEE_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/optee KERNELDIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/linux-kernel BUSYBOX_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/busybox TOYBOX_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/toybox ROOTFS_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/root-fs APP_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/application LIBRARY_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/lib INCLUDE_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/lib/include NVT_DRIVER_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/driver NVT_HDAL_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/hdal NVT_VOS_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/vos NVT_RTOS_MAIN_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/rtos-main SAMPLE_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/sample TOOLS_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/tools OUTPUT_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/output LOGS_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/logs BUILD_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/build CONFIG_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/configs PLATFORM_CFLAGS = -march=armv8-a -mtune=cortex-a53 -ftree-vectorize -fno-builtin -fno-common -Wformat=1 -D_BSP_NA51090_ PLATFORM_AFLAGS = march=armv8-a -mtune=cortex-a53 -D_BSP_NA51090_ NVT_HOST = aarch64-ca53-linux-uclibc LINUX_CPU_TYPE = cortex-a53x64 NVT_LINUX_VER = 4.19.148 NVT_MULTI_CORES_FLAG = -j80 CROSS_COMPILE = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc- CROSS_TOOLCHAIN_PATH = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4 CROSS_TOOLCHAIN_BIN_PATH = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin SYSROOT_PATH = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/aarch64-ca53-linux-uclibc/sysroot UBOOT_CROSS_COMPILE = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc- AS = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-as CC = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-gcc CXX = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-g++ LD = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-ld LDD = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-ldd AR = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-ar NM = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-nm GDB = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-gdb STRIP = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-strip OBJCOPY = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-objcopy OBJDUMP = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-objdump PATH = /opt/CEVA-ToolBox/V17/XM4/CEVA-XM4:/opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin:/opt/utility/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/snap/bin:. LD_LIBRARY_PATH = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/local/lib ============================================================================================= Build Libraries \u00b6 Compilation \u00b6 na51090_linux_sdk provides some proprietary libraries and header files for the product customization (this part doesn\u2019t involve source code, we only provide you *.so), please according the following instruction to compile it. \\$ cd na51090_linux_sdk/ \\$ make library Libraries clean build: \\$ make library_clean Please execute \u201csource build/envsetup.sh\u201d firstly when you start to build it. Please reference to Application Note for the other details. Build busybox \u00b6 Compilation \u00b6 Busybox can provide rootfs necessary tools, using below instruction can compile it. And the tools will be installed to na51090_linux_sdk/BSP/root-fs. \\$ cd na51090_linux_sdk/ \\$ make busybox mybusybox clean build: \\$ make busybox_clean Menu configuration \u00b6 SDK will provide two busybox configuration files, one is normal version (busybox_cfg_normal), and the other is minimized version (busybox_cfg_small). Edit Top Makefile can change the busybox configuration, the default is normal version. Edit Top Makefile to switch the configuration file: \\$ cd na51090_linux_sdk/ \\$ vi Makefile BUSYBOX_CFG:=busybox_cfg_full #BUSYBOX_CFG:=busybox_cfg_small Below instruction can handle busybox features selection: \\$ make busybox_config Choose \u201cExit/Save\u201d after you finished function selection, it can generate new .config for the Busybox compilation usage. Build sample code \u00b6 Compilation \u00b6 The device driver testing applications will be used to test NVT peripheral devices; the following instructions can compile it. And it will be installed to na51090_linux_sdk/BSP/root-fs. \\$ cd na51090_linux_sdk/ \\$ make sample Driver test clean build: \\$ make sample_clean Update Firmware \u00b6 We provide two OS version nvtpack image could be used, one is Linux version will be generate by Linux version nvtpack tool, the images will be generated under the output folder. Another is Windows vesion nvtpack tool, the following section can get more clearly description. Linux version nvtpack for all-in-one image \u00b6 The nvt-nvtpack.dtsi is used to control what kinds of images want to be involved, and which files will be packed by all-in-one tool. If source_file = \u201c\u201d, it means we don\u2019t want to pack this image into all-in-one image. If id1 \u2026 source_file = \u201cnvt-evb.bin\u201d, it means nvt-evb.bin file will pack into all-in-one image partition 1, partition setting we can reference nvt-storage-partition.dtsi file. nvtpack { ver = \"NVTPACK_FW_INI_16072017\"; /* Fixed */ method = <1>; /* Fixed */ index { id0 { partition_name = \"loader\"; source_file = \"\"; }; /* Fixed */ id1 { partition_name = \"fdt\"; source_file = \"nvt-all.bin\"; }; /* Fixed */ id2 { partition_name = \"fdt.restore\"; source_file = \"\"; }; /* Fixed */ id3 { partition_name = \"atf\"; source_file = \"atf.bin\"; }; id4 { partition_name = \"uboot\"; source_file = \"u-boot.bin\"; }; id5 { partition_name = \"uenv\"; source_file = \"\"; }; id6 { partition_name = \"kernel\"; source_file = \"Image.bin\"; }; id7 { partition_name = \"rootfs\"; source_file = \"rootfs.ramdisk.bin\"; }; id8 { partition_name = \"rootfs1\"; source_file = \"rootfs_1.rw.ubifs.bin\"; }; }; }; Using \u201cmake all\u201d or \u201cmake pack\u201d can generate the packed image is under output/packed/FW(SOC).bin. Update Firmware \u00b6 Insert SD card including All-in-One bin to the target board and power on can update firmware. Update Loader \u00b6 For a blank Nand flash, you need to burn loader (LD98336A.bin), by first SD card format (be sure to format), and then immediately put LD98336A.bin, then placed all in one bin (FW98336A.bin). Power on \u00b6 How to power on \u00b6 To follow update steps to burn the desired Image, remove SD card can boot up directly. Debug \u00b6 The following list provides comparison and classification of the debugging tools. Name Classification Description Coredump AP debug Generated file for the further analysis when the program has terminated abnormally Messages AP/Kernel debug To record Linux kernel and AP booting log GDB AP debug To debug target board application from remote server printk Kernel debug Basic kernel/module debug usage kmemleak Kernel debug To analyze if Linux kernel has memory leak issue. OPENOCD Kernel debug To debug/ trace kernel or uboot Coredump \u00b6 Provide analytical application error log, the application does not properly terminated, it generates a file in /var/log. It can record the program name, PID and time, can be loaded for analysis through a cross compiler. You should build it with debug mode when you start application analysis. The following is related setting: \\$ cd na51090_linux_sdk/root-fs/rootfs/ \\$ vi etc/profile ## coredump setting echo 1 > /proc/sys/kernel/core_uses_pid ulimit -c unlimited echo \"/var/log/core-%e-%p-%t\" > /proc/sys/kernel/core_pattern If the user wants to store the dump file in SD card or USB disk, linux will check the file permission, fat can not support linux permission, please format to ext4 filesystem. Messages \u00b6 The boot log of the Linux will be stored in /var/log/messages, this file can involve Kernel and user space app. If the kernel crash occurred, please provide this file for the further analysis. GDB \u00b6 GDB (GNU Project Debugger) can support Remote and Target mode to debug AP. Target mode gdb/gdbserver can be generated by the following command: \\$ cd na51090_linux_sdk/tools \\$ make gdb The connection diagram as shown below, Figure 13-1: Figure 14-1 Target debug connection Remote mode can debug user space application through GDB server, and the connection architecture as below. Linux server is x86_64 compile server, target board is the EVB, they can be connected by serial or TCP/IP. Linux server will use cross compiler toolchain GDB to debug target board AP, this AP must be enabled debug symbol, and target board also needs to execute gdbserver which can be find in toolchain. The serial connection can connect USB-to-Serial cable to target board USB port, and check if there is /dev/ttyUSB0 existed. TCP/IP connection can use Wi-Fi or Ethernet, install necessary drivers and confirm whether it can ping to server. Figure 14-2 Remote debug connection GDB server needs to be executed on EVB. \\$ cp tools/__install/bin/gdbserver root-fs/rootfs/bin/ \\$ cp tools/__install/bin/gdb root-fs/rootfs/bin/ And then, running below procedures can debug your AP. Target Board target > gdbserver comm prog [args\u2026] The gdbserver doesn\u2019t loading debug symbol, all of the symbols will be loaded by the Linux server cross compiler gdb. It can reduce memory space in this way. Serial: target > gdbserver /dev/ttyUSB0 hello_world Net: target > gdbserver Host _IP:1234 hello_world Linux Server Serial: Server > {CROSS_COMPILE}-gdb hello_world Server > set remotebaud 115200 Server > target remote /dev/ttyUSB0 Net: Server > {CROSS_COMPILE}-gdb hello_world Server > target remote localhost:1234 Reference to below link can show you how to use command debug your AP: http://sourceware.org/gdb/current/onlinedocs/gdb/index.html In addition to command mode debug you also can use DDD, it is a framework on top of GDB debug visualization software, you can install and use by below command: \\$ sudo apt-get install ddd \\$ sudo ddd \u2013debugger aarch64-ca53-linux-uclibc-gdb Printk \u00b6 Linux provides seven levels of Log printk available in the following table: Level Description Usage KERN_EMERG system is unusable pr_emerg KERN_ALERT action must be taken immediately pr_alert KERN_CRIT critical conditions pr_crit KERN_ERR error conditions pr_err KERN_WARNING warning conditions pr_warning KERN_NOTICE normal but significant condition pr_notice KERN_INFO Informational pr_info KERN_DEBUG debug-level messages pr_debug Above the printk level is used to decide whether or not to print the message console, the below instruction can show you the printk level, current representative of the level of the boot to be printed, default is the default level, minimum is the lowest possible print level, boot-time-default is boot stage log: root@NVTEVM:\\~\\$ cat /proc/sys/kernel/printk 7 4 1 7 current default minimum boot-time-default Kernel will compare the printed message log level, if the value is less than the current will be printed out. Therefore, to change the output level so that all messages are printed out can use this command:Kernel hu\u00ec q\u00f9 b\u01d0ji\u00e0o y\u00ecn ch\u016b x\u00f9nx\u00ed de log level, r\u00fagu\u01d2 xi\u01ceoy\u00fa current de zh\u00ed ji\u00f9 hu\u00ec y\u00ecn ch\u016bl\u00e1i. Y\u012bnc\u01d0, y\u00e0o g\u01ceibi\u00e0n sh\u016bch\u016b j\u00edbi\u00e9 r\u00e0ng su\u01d2y\u01d2u x\u00f9nx\u00ed d\u014du k\u011by\u01d0 y\u00ecn ch\u016bl\u00e1i k\u011by\u01d0 y\u00f2ng d\u01d0xia f\u0101ngsh\u00ec:\u60a8\u662f\u4e0d\u662f\u8981\u67e5\uff1a Linux\u9664\u4e86 Built -in\u7684Driver\u4e4b\u5916,\u9084\u6709\u63d0\u4f9b\u5916\u90e8\u8f09\u5165\u7684\u65b9\u5f0f\u7a31\u4e4b\u70baKernel module,\u53ef\u900f\u904einsmod\u6216\u662fmodprobe\u505a\u8f09\u5165,\u5e95\u4e0b\u5206\u70babuild-in module\u8207out-of-tree module\u505a\u7de8\u8b6f\u4ecb\u7d39\u3002 root@NVTEVM:\\~\\$ echo 8 > /proc/sys/kernel/printk Kmemleak \u00b6 Linux Kmemleak is provided for detecting a memory leak tool, it will record detect report in /sys/kernel/debug/kmemleak, to use this function as long as enable the \u201cKernel Hacking\u201d, \u201cKernel Memory Leak Detector\u201d (CONFIG_DEBUG_KMEMLEAK) in the kernel option, and configure the \u201cMaximum kmemleak early log entires\u201d with 1200. Clear current record: root@NVTEVM:\\~\\$ echo clear > /sys/kernel/debug/kmemleak Testing your driver: root@NVTEVM:\\~\\$ insert YourModule.ko Scan: root@NVTEVM:\\~\\$ echo scan > /sys/kernel/debug/kmemleak Check the resules: root@NVTEVM:\\~\\$ cat /sys/kernel/debug/kmemleak FAQ \u00b6 This section will list frequently problems. Toolchain can\u2019t be found \u00b6 We have two toolchains to build overall SDK, one is for itron, another is for Linux. First, please use below command to check your environment setting. \\$ get_stuff_for_environment Operation not permitted \u00b6 The SDK installation path should be under your home folder, you should use the same owner to decompressing and building, otherwise you will get \u201c operation not permitted \u201d related message. Please use below command to check permission and owner. \\$ ls -al YOUR_FOLDER Linux kernel uImage can\u2019t be generated \u00b6 This is because our default setting is lz4 compression format, you should follow section 1.2 to check lz4 tool is installed. Try to use lz4 command to check your compiling environment. \\$ lz4","title":"Linux Programming Guide"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#development-environment","text":"","title":"Development Environment"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#virtualboxubuntu-os-installation","text":"This section will introduce how to install Ubuntu on Windows OS, ignore this section if your environment is under single OS. Please download from VirtualBox official website ( https://www.virtualbox.org/wiki/Downloads ) and follow below instructions to install. This step will install device driver, please select \u201cInstall\u201d: Create virtual machine (Version: Ubuntu 64-Bit): Select virtual machine memory size: Create virtual machine (If you have an existed Ubuntu image, you can select \u201cUse an existing virtual hard disk file\u201d): To configure virtual disk space (At least 40GB size): Select Optical drive and using Ubuntu ISO (Ubuntu 12.04/14.04/16.04/18.04 64-bit) startup:","title":"VirtualBox/Ubuntu OS installation"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#linux-environment-setup","text":"In order to prevent some complaints in the SDK compilation of the 32 Bits OS, we will use 64 Bits Ubuntu OS as our development environment. The first of all, you should install an Ubuntu based server or Ubuntu on VirtualBox which is introduced in previous section, please download the image from ( http://releases.ubuntu.com/ ) to get Ubuntu 12.04/14.04/16.04/18.04 Desktop AMD64 version ISO image and use the following instructions to install necessary Ubuntu packages. Ubuntu 12.04: \\$ sudo apt-get install bc build-essential libc6-dev libncurses5-dev libgl1-mesa-dev g++-multilib mingw32 tofrodos ia32-libs uboot-mkimage zlib1g-dev mtd-utils vim squashfs-tools gawk cmake cmake-data libstdc++6 device-tree-compiler android-tools-fsutils texinfo libssl-dev python3-crypto python3-pyelftools python3-pycrypto \\$ sudo add-apt-repository ppa:nathan-renniewaldock/ppa \\$ sudo apt-get update \\$ sudo apt-get install liblz4-tool To install make-4.1 ( This will replace your original /bin/make tool ): Download https://ftp.gnu.org/gnu/make/make-4.1.tar.bz2 \\$ tar -jxvf make-4.1.tar.bz2 \\$ cd make-4.1; ./configure; make -j4 \\$ make install Ubuntu 14.04: \\$ sudo apt-get install bc build-essential libc6-dev lib32ncurses5 libncurses5-dev libncurses5:i386 libgl1-mesa-dev g++-multilib mingw32 tofrodos lib32z1 lib32bz2-1.0 u-boot-tools zlib1g-dev bison libbison-dev flex mtd-utils vim squashfs-tools gawk cmake cmake-data liblz4-tool libmpc3 libstdc++6 device-tree-compiler android-tools-fsutils texinfo libssl-dev python3-crypto python3-pyelftools python3-pycrypto To install make-4.1 ( This will replace your original /bin/make tool ): Download https://ftp.gnu.org/gnu/make/make-4.1.tar.bz2 \\$ tar -jxvf make-4.1.tar.bz2 \\$ cd make-4.1; ./configure; make -j4 \\$ make install Ubuntu 16.04: \\$ sudo apt-get install bc build-essential libc6-dev lib32ncurses5 libncurses5-dev libncurses5:i386 libgl1-mesa-dev g++-multilib mingw-w64 tofrodos lib32z1 u-boot-tools zlib1g-dev bison libbison-dev flex mtd-utils vim squashfs-tools gawk cmake cmake-data liblz4-tool libmpc3 libstdc++6 device-tree-compiler android-tools-fsutils texinfo libssl-dev python3-crypto python3-pyelftools python3-pycrypto Ubuntu 18.04: \\$ sudo apt-get install bc build-essential libc6-dev lib32ncurses5 libncurses5-dev libncurses5:i386 libgl1-mesa-dev g++-multilib mingw-w64 tofrodos lib32z1 u-boot-tools zlib1g-dev bison libbison-dev flex mtd-utils vim squashfs-tools gawk cmake cmake-data liblz4-tool libmpc3 libstdc++6 device-tree-compiler android-tools-fsutils texinfo libssl-dev python3-crypto python3-pyelftools python3-pycrypto Ubuntu default shell is dash, please reconfigure the default shell with bash: \\$ sudo dpkg-reconfigure dash, and choose \u201cNo\u201d in the window Or \\$ sudo rm /bin/sh && sudo ln -s /bin/bash /bin/sh Besides, the openssh-server is used to provide Windows Host PC connected to Linux server and remote building the Linux SDK, and the Samba server is to provide client get Linux SDK image from Linux server. \\$ apt-get install openssh-server \\$ apt-get install samba \\$ vim /etc/samba/smb.conf Please reference to related Samba configuration as below: https://help.ubuntu.com/12.04/serverguide/samba-fileserver.html Windows Host PC will also need Teraterm or putty to connect to Target board UART2 port with 115200/8/1/n configuration. Figure 1-1 Linux Development Environment","title":"Linux environment setup"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#how-to-install-nt9833x-linux-sdk","text":"Using the following instructions to decompress SDK pack under Linux: \\$ tar -jxvf na51090_linux_sdk_{version}.tar.bz2 You will get the folder tree as below: \u251c\u2500\u2500 na51090_linux_sdk Used to put unpacked SDK source code \u251c\u2500\u2500 BSP Including linux, busybox, uboot and rootfs source \u251c\u2500\u2500 build scripts for the environment setup \u251c\u2500\u2500 code HDAL, linux drivers and sample code \u251c\u2500\u2500 configs Model settings \u251c\u2500\u2500 Makefile Top level Makefile \u2514\u2500\u2500 tools target board tool \u251c\u2500\u2500 toolchains Toolchain folder \u251c\u2500\u2500 aarch64-ca53-linux-gnueabihf-8.4.tar.bz2 \u2514\u2500\u2500 aarch64-ca53-linux-uclibcgnueabihf-8.4.tar.bz2","title":"How to install NT9833x Linux SDK"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#how-to-install-cross-compiler","text":"We support both glibc and uclibc cross compiler toolchain, please choose and install it by using below instructions: \\$ cd toolchain \\$ sudo tar -jxvf aarch64-ca53-linux-gnueabihf-8.4.tar.bz2 -C /opt or \\$ sudo tar -jxvf aarch64-ca53-linux-uclibcgnueabihf-8.4.tar.bz2 -C /opt","title":"How to install Cross compiler"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#introduction-to-compilation","text":"","title":"Introduction to Compilation"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#environment-setup","text":"Before each opened a new Terminal window needs to do compiler environment setting, the relevant variables set up, please follow the below instructions to finish it. \\$ cd na51090_linux_sdk/ \\$ source build/envsetup.sh","title":"Environment setup"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#compilation","text":"Please do a complete compilation for first time. Select your model: \\$ lunch List your nvt build setting: \\$ get_stuff_for_environment Build overall system: \\$ make all It will generate the images under na51090_linux_sdk/output after the compilation. The details are listed as below. |\u2013 na51090_linux_sdk Put unpacked source code and image | |\u2013 Makefile Top level Makefile | |\u2013 output Compiled output images | |\u2013 packed | |\u2013 FW(SOC)A.bin nvtpack image (All-in-one image) | |\u2013 atf.bin ATF image | |\u2013 Image.bin Linux Image | |\u2013 u-boot.bin uboot image with NVT checksum | |\u2013 u-boot.lz.bin uboot image (LZ compressed) | |\u2013 rootfs.ramdisk.bin ramdisk image (rootfs) | `\u2013 rootfs_1.rw.ubifs.bin rootfs overlay","title":"Compilation"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#top-level-makefile","text":"na51090_linux_sdk folder has a top level Makefile, it supports many of the make command, such as \u201cmake linux\u201d is to compile linux-kernel, \u201cmake uboot\u201d can compile u-boot, \u201cmake rootfs\u201d can compile root-fs \u2026 and so on, you can use \u201cmake help\u201d to find what its commands are supported. Please use top level Makefile to do SDK compilation to avoid some link error occurred. Its help description is as follows: \\$ make help ===================================================== make help -> show make command info make all -> build all make linux -> build linux-kernel make linuxram -> build linux-kernel with ramdisk support make modules -> build built-in kernel modules make driver -> build NVT linux driver modules make atf -> build ARM trusted firmware make uboot -> build loader(uboot) make optee_os -> build OPTEE kernel make optee_client -> build OPTEE client make library -> build library make busybox -> build busybox make rootfs -> build rootfs make app -> build applications make tools -> build tools make sample -> build sample code make post -> run postprocessing script make pack -> Generate nvtpack image and preburn images make publish -> remove some sources for publish ===================================================== make linux_config -> config linux-kernel make linux_config_gcov-> modify kernel config for code coverage tool make uboot_config -> config uboot make busybox_config -> config busybox make linux_header -> generate linux-kernel out of tree headers ===================================================== make clean -> clean all make linux_clean -> clean linux-kernel & built-in kernel modules make driver_clean -> clean NVT linux driver modules make atf_clean -> clean ARM trusted firmware make uboot_clean -> clean loader(uboot) make optee_os_clean -> clean optee kernel make optee_client_clean -> clean optee client application make library_clean -> clean library make busybox_clean -> clean busybox make rootfs_clean -> clean rootfs make app_clean -> clean applications make tools_clean -> clean tools make sample_clean -> clean sample code make post_clean -> run postprocessing clean script make pack_clean -> Remove nvtpack image =====================================================","title":"Top level Makefile"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#project-configuration","text":"We provide the following file to control functionalities enable or disable, please refer to the below procedures to configure. Check model type: \\$ get_stuff_for_environment ======================================== NVT Setting ======================================== NVT_PRJCFG_MODEL_CFG = /home/user1/na51090_linux_sdk/configs/Linux/cfg_xxx_NAND_EVB/ModelConfig.mk NVT_PRJCFG_CFG = Linux NVT_PRJCFG_MODEL_MK = The ModelConfig.mk will be generated from configs/cfg_gen/nvt-info.dtsi Enable/disable function: \\$ cd na51090_linux_sdk/ \\$ vi configs/cfg_gen/nvt-info.dtsi To find Linux related options: /* * Novatek Ltd. BSP part of dts */ / { nvt_info { /* Get from ModelConfig.txt */ BIN_NAME = \"FW98336A\"; BIN_NAME_T = \"FW98336T\"; /* EMBMEM_BLK_SIZE, Normally, 2KPageNand=0x20000, 512PageNand=0x4000, SPI=0x10000 */ EMBMEM_BLK_SIZE = \"0x20000\"; /* * [EMBMEM] * EMBMEM_NONE * EMBMEM_NAND * EMBMEM_SPI_NOR * EMBMEM_SPI_NAND * EMBMEM_EMMC */ EMBMEM = \" EMBMEM_SPI_NAND\"; /* * ======= Linux common ========= * application/external */ NVT_CFG_APP_EXTERNAL = \"dhd_priv\"; /* application include list */ NVT_CFG_APP = \"\"; /* rootfs etc folder */ NVT_ROOTFS_ETC = \"\"; /* strip executable binary and library files: yes/no */ NVT_BINARY_FILE_STRIP = \"yes\"; /* Using customized kernel config */ NVT_CFG_KERNEL_CFG = \"\"; /* Using customized uboot config */ NVT_CFG_UBOOT_CFG = \"\"; /* * ======= Linux for different code setting ========= * [NVT_LINUX_SMP] * NVT_LINUX_SMP_ON * NVT_LINUX_SMP_OFF */ NVT_LINUX_SMP = \"NVT_LINUX_SMP_ON\"; /* * [NVT_DEFAULT_NETWORK_BOOT_PROTOCOL] * NVT_DEFAULT_NETWORK_BOOT_PROTOCOL_DHCP_SERVER * NVT_DEFAULT_NETWORK_BOOT_PROTOCOL_DHCP_CLIENT * NVT_DEFAULT_NETWORK_BOOT_PROTOCOL_STATIC_IP */ NVT_DEFAULT_NETWORK_BOOT_PROTOCOL = \"NVT_DEFAULT_NETWORK_BOOT_PROTOCOL_STATIC_IP\"; /* * [NVT_ROOTFS_TYPE] * NVT_ROOTFS_TYPE_NAND_UBI * NVT_ROOTFS_TYPE_NAND_SQUASH * NVT_ROOTFS_TYPE_NAND_JFFS2 * NVT_ROOTFS_TYPE_NOR_SQUASH * NVT_ROOTFS_TYPE_NOR_JFFS2 * NVT_ROOTFS_TYPE_RAMDISK * NVT_ROOTFS_TYPE_EMMC * NVT_ROOTFS_TYPE_NAND_SQUASH_NEW */ NVT_ROOTFS_TYPE = \"NVT_ROOTFS_TYPE_RAMDISK\"; /* * [NVT_ETHERNET] * NVT_ETHERNET_NONE * NVT_ETHERNET_EQOS */ NVT_ETHERNET = \"NVT_ETHERNET_EQOS\"; /* * [NVT_SDIO_WIFI]: Remember to update root-fs/rootfs/etc/init.d/S05_Net * NVT_SDIO_WIFI_NONE * NVT_SDIO_WIFI_RTK * NVT_SDIO_WIFI_BRCM * NVT_SDIO_WIFI_NVT */ NVT_SDIO_WIFI = \"NVT_SDIO_WIFI_NONE\"; /* * [NVT_USB_WIFI] * NVT_USB_WIFI_NONE */ NVT_USB_WIFI = \"NVT_USB_WIFI_NONE\"; /* * [NVT_USB_4G] * NVT_USB_4G_NONE */ NVT_USB_4G = \"NVT_USB_4G_NONE\"; /* * [WIFI_RTK_MDL] : sub item for NVT_SDIO_WIFI_RTK * WIFI_RTK_MDL_NONE * WIFI_RTK_MDL_8189 */ WIFI_RTK_MDL = \"WIFI_RTK_MDL_8189\"; /* * [WIFI_BRCM_MDL] : sub item for NVT_SDIO_WIFI_BRCM * WIFI_BRCM_MDL_43438a1_ampk6212axtal26 * WIFI_BRCM_MDL_43455c0_ampk6255c0 */ WIFI_BRCM_MDL = \"WIFI_BRCM_MDL_43438a1_ampk6212axtal26\"; /* * [WIFI_NVT_MDL] : sub item for NVT_SDIO_WIFI_NVT * WIFI_NVT_MDL_18202 * WIFI_NVT_MDL_18211 */ WIFI_NVT_MDL = \"WIFI_NVT_MDL_18211\"; /* * [NVT_CURL_SSL] * NVT_CURL_SSL_OPENSSL * NVT_CURL_SSL_WOLFSSL */ NVT_CURL_SSL = \"NVT_CURL_SSL_OPENSSL\"; /* * [NVT_UBOOT_ENV_IN_STORG_SUPPORT] * NVT_UBOOT_ENV_IN_STORG_SUPPORT_NAND * NVT_UBOOT_ENV_IN_STORG_SUPPORT_NOR * NVT_UBOOT_ENV_IN_STORG_SUPPORT_MMC * NVT_UBOOT_ENV_IN_STORG_SUPPORT_OFF */ NVT_UBOOT_ENV_IN_STORG_SUPPORT = \"NVT_UBOOT_ENV_IN_STORG_SUPPORT_OFF\"; }; };","title":"Project configuration"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#build-u-boot","text":"","title":"Build U-boot"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#compilation_1","text":"The Uboot source code is placed on \u201cna51090_linux_sdk/u-boot\u201d, typing \u201cmake uboot\u201d can be used to compile Uboot, and we provide two images are u-boot.bin(non-compressed) and u-boot.lz.bin(compressed) under na51090_linux_sdk/output. U-boot build: \\$ cd na51090_linux_sdk/ \\$ make uboot U-boot config: \\$ cd na51090_linux_sdk/ \\$ make uboot_config U-boot clean build: \\$ make uboot_clean","title":"Compilation"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#user-customization","text":"The uboot have two config files will have different configured properties. One is for common function, the other is for the low level setting. The low level setting can modify this file \u201cinclude/configs/nvt-na51090-evb-a64.h\u201d directly when you have request for the Uboot related configuration. e.g. Uboot passed to Linux\u2019s cmdline can be changed with this variable #define CONFIG_USE_BOOTARGS #define CONFIG_BOOTARGS_COMMON \"earlycon=nvt_serial,0x2f0280000 rootwait console=ttyS0,115200 debug_boot_weak_hash \" #define CONFIG_BOOTARGS CONFIG_BOOTARGS_COMMON \"root=/dev/ram0 rootfstype=ramfs rdinit=/linuxrc \" Please reference to \u201cSDK_UBoot_Programming_Guide_en\u201d for more details.","title":"User customization"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#build-kernel-code","text":"","title":"Build Kernel Code"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#compilation_2","text":"The Linux kernel source code is placed on \u201cna51090_linux_sdk/linux-kernel\u201d, typing \u201cmake linux\u201d can be used to compile Linux kernel, and the image name is Image.bin under na51090_linux_sdk. \\$ cd na51090_linux_sdk/ \\$ make linux Linux clean build: \\$ make linux_clean","title":"Compilation"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#system-configuration","text":"","title":"System configuration"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#menu-configuration","text":"Top Makefile is already integrated the formal Linux menuconfig, to use the following instruction can do the function selection. Please avoid using formal Linux \u201cmake menuconfig\u201d under linux-kernel directly; it will cause error because the important variables are not set correctly. \\$ make linux_config Choose \u201cSave\u201d after finished function selection; it can generate a new .config for the Linux compilation usage. NA51090 SDK provides two Kernel configuration file under \u201cna51090_linux_sdk/BSP/linux-kernel/arch/arm64/configs/\u201d, one is for the debug mode, and the other is for the release mode. na51090_XXX_defconfig_debug, the debug mode will enable most of the functions for the development stage na51090_XXX_defconfig_release, the release mode will only enable boot necessary parts. Edit Top Makefile to switch the configuration file: \\$ cd na51090_linux_sdk/ \\$ vi Makefile ## kernel & modules CUSTBOARDCONFIG := $(strip $(shell echo $(NVT_PRJCFG_MODEL_CFG) | grep NVT_CFG_KERNEL_CFG | awk -F'=' '{print $$NF;}')) ifeq ($(EMBMEM), EMBMEM_SPI_NOR) #BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_nor_debug; fi) BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_nor_release; fi) else ifeq ($(EMBMEM), EMBMEM_EMMC) #BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_emmc_debug; fi) BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_emmc_release; fi) else #BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_debug; fi) BOARDCONFIG := $(shell if [ ! -z $(NVT_CFG_KERNEL_CFG) ]; then echo $(NVT_CFG_KERNEL_CFG); else echo $(SDK_CODENAME)_evb_defconfig_release; fi) endif Figure 4-1 Menu configuration","title":"Menu configuration"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#device-tree","text":"The device tree can be generated by dtc(device tree compiler) tool as below, you can find the *.dtsi in \u201cna51090_linux_sdk/configs/cfg_xxx\u201d and users can set command \u201cmake cfg\u201d at \u201cna51090_linux_sdk/\u201d. Config items detail description put at na51090_linux_sdk/configs/doc. It can be used to compile device tree, and we will output image nvt-evb.dtb under na51090_linux_sdk/output. The merge method is Union, for example: configs/cfg_gen/nvt-basic.dtsi User can modify CPU clock-frequency from 1200000000(1.2GHz) to 1000000000(1GHz), or 1100000000(1.1GHz), or 1300000000(1.3GHz), or 1350000000(1.35GHz), and compiler again. Users can use new image to boot at new CPU clock-frequency. #include <dt-bindings/gpio/gpio.h> #include <dt-bindings/interrupt-controller/arm-gic.h> / { model = \"Novatek NA51090\"; compatible = \"novatek,na51090\", \"nvt,ca53\"; interrupt-parent = <&gic>; #address-cells = <2>; #size-cells = <2>; psci { compatible = \"arm,psci-0.2\"; method = \"smc\"; }; cpus { #address-cells = <2>; #size-cells = <0>; cpu0: cpu@0 { device_type = \"cpu\"; compatible = \"arm,cortex-a53\", \"arm,armv8\"; reg = <0x0 0x0>; next-level-cache = <&A53_L2>; clock-frequency = <1200000000>; enable-method = \"psci\"; }; cpu1: cpu@1 { device_type = \"cpu\"; compatible = \"arm,cortex-a53\", \"arm,armv8\"; reg = <0x0 0x1>; next-level-cache = <&A53_L2>; clock-frequency = <1200000000>; enable-method = \"psci\"; }; cpu2: cpu@2 { device_type = \"cpu\"; compatible = \"arm,cortex-a53\", \"arm,armv8\"; reg = <0x0 0x2>; next-level-cache = <&A53_L2>; clock-frequency = <1200000000>; enable-method = \"psci\"; }; cpu3: cpu@3 { device_type = \"cpu\"; compatible = \"arm,cortex-a53\", \"arm,armv8\"; reg = <0x0 0x3>; next-level-cache = <&A53_L2>; clock-frequency = <1200000000>; enable-method = \"psci\"; }; A53_L2: l2-cache0 { compatible = \"cache\"; }; }; \u2026 configs/cfg_gen/nvt-peri.dtsi #include <dt-bindings/gpio/nvt-gpio.h> #include \"nvt-basic.dtsi\" / { chosen { bootargs = \" \"; stdout-path = \"serial0:115200n8\"; }; aliases { serial0 = &uart0; serial1 = &uart1; serial2 = &uart2; serial3 = &uart3; serial4 = &uart4; mmc0 = &mmc0; /* Fixed to mmcblk0 for sdio1 */ }; uart0: uart@f0280000 { compatible = \"ns16550a\"; reg = <0x2 0xf0280000 0x0 0x1000>; interrupts = <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>; baud = <115200>; reg-shift = <2>; reg-io-width = <4>; no-loopback-test = <1>; clock-frequency = <24000000>; rx_trig_level = <3>; hw_flowctrl = <0>; }; uart1: uart@f0290000 { compatible = \"ns16550a\"; reg = <0x2 0xf0290000 0x0 0x1000>; interrupts = <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>; baud = <115200>; reg-shift = <2>; reg-io-width = <4>; no-loopback-test = <1>; clock-frequency = <48000000>; rx_trig_level = <3>; hw_flowctrl = <0>; }; uart2: uart@f02a0000 { compatible = \"ns16550a\"; reg = <0x2 0xf02a0000 0x0 0x1000>; interrupts = <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>; baud = <115200>; reg-shift = <2>; reg-io-width = <4>; no-loopback-test = <1>; clock-frequency = <48000000>; rx_trig_level = <3>; }; uart3: uart@f02b0000 { compatible = \"ns16550a\"; reg = <0x2 0xf02b0000 0x0 0x1000>; interrupts = <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>; baud = <115200>; reg-shift = <2>; reg-io-width = <4>; no-loopback-test = <1>; clock-frequency = <48000000>; rx_trig_level = <3>; }; uart4: uart@f02c0000 { compatible = \"ns16550a\"; reg = <0x2 0xf02c0000 0x0 0x1000>; interrupts = <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>; baud = <115200>; reg-shift = <2>; reg-io-width = <4>; no-loopback-test = <1>; clock-frequency = <48000000>; rx_trig_level = <3>; };","title":"Device tree"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#partition-table","text":"The Nand/EMMC driver of kernel will do for the set partition initialization process as shown below, Uboot will read the partition info(nvt-storage-partition.dtsi) from dts, and then the Kernel also read it from dts to do basic initialization. If you want to change flash partition size or add a partition, please configure device tree nvt-storage-partition.dtsi and build dtb image, burn into flash or load to dram again(default address at 0x1f00000). Figure 4-2 Partition initialization SPI NAND partition example: nvt-storage-partition.dtsi for flash partition &nand { partition_loader { label = \"loader\"; reg = <0x0 0x0000000 0x0 0x40000>; }; /* Fixed */ partition_fdt { label = \"fdt\"; reg = <0x0 0x40000 0x0 0x40000>; }; /* Fixed */ partition_fdt.restore { label = \"fdt.restore\"; reg = <0x0 0x80000 0x0 0x40000>; }; /* Fixed */ partition_atf { label = \"atf\"; reg = <0x0 0x0C0000 0x0 0x40000>; }; partition_uboot { label = \"uboot\"; reg = <0x0 0x100000 0x0 0x1C0000>; }; partition_uenv { label = \"uenv\"; reg = <0x0 0x2C0000 0x0 0x40000>; }; partition_kernel { label = \"kernel\"; reg = <0x0 0x300000 0x0 0x0500000>; }; partition_rootfs { label = \"rootfs\"; reg = <0x0 0x800000 0x0 0x5100000>; }; partition_rootfs1 { label = \"rootfs1\"; reg = <0x0 0x5900000 0x0 0x2700000>; }; }; If you want to change the partition size or add a partition, please configure it from the dts info. If users want to add user partition such as app1, users can add such as follow: partition_app1 { label = \"app1\"; reg = <0x0 start_addr 0x0 size>; };","title":"Partition table"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#debug","text":"To debug the Kernel, you will need System.map or objects for the debug symbol loading, please get them from \u201clinux-kernel/\u201d as shown below: |\u2013 linux-kernel | |\u2013 Makefile | |\u2013 Module.symvers | |\u2013 System.map | |\u2013 arch | |\u2013 block | |\u2013 crypto | |\u2013 drivers | |\u2013 firmware | |\u2013 fs | |\u2013 include | |\u2013 init | |\u2013 ipc | |\u2013 kernel | |\u2013 lib | |\u2013 mm | |\u2013 modules.builtin | |\u2013 modules.order | |\u2013 net | |\u2013 scripts | |\u2013 security | |\u2013 sound | |\u2013 source | |\u2013 usr | |\u2013 vmlinux | `\u2013 vmlinux.o To add more debug information, we can turn on CONFIG_DEBUG_INFO option before compiling Linux kernel as below. \u201cKernel Hacking > Compile-time checks and compiler options > Compile the kernel with debug info\u201d \\$ cd na51090_linux_sdk/ \\$ make linux_config Rebuild all; this binary will contain debug symbol information. |\u2013 linux-kernel | |\u2013 vmlinux","title":"Debug"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#build-kernel-modules","text":"In addition to build-in drivers, Linux had also provided an external load mode called Kernel module, can be loaded by \u201cmodprobe\u201d or \u201cinsmod\u201d. The below will introduce to build-in modules and the out-of-tree modules.","title":"Build Kernel Modules"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#build-in-module-compilation","text":"Typing \u201cmake modules\u201d under na51090_linux_sdk can do build-in modules compilation and install path is root-fs/rootfs/lib/modules/{KER_VER}/kernel/. \\$ cd na51090_linux_sdk/ \\$ make modules","title":"Build-in module compilation"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#out-of-tree-module-compilation","text":"This folder under \u201cna51090_linux_sdk/code\u201d provides NVT platform drivers, typing \u201cmake supplement\u201d to do the Out-of Tree modules compilation as below. And the modules will be installed on na51090_linux_sdk/BSP/root-fs/rootfs/lib/modules/{KER_VER}/extra/. \\$ cd na51090_linux_sdk/ \\$ make driver Linux Out-of-Tree driver module clean build: \\$ make driver_clean","title":"Out-of-Tree module compilation"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#hdal","text":"HDAL is the hardware abstraction layer driver and sample code, this one can be used to build proprietary driver modules, such as video process, video capture and video codec\u2026etc. We provide the following instructions to build. \\$ make hdal Clean build: \\$ make hdal_clean Please refer to the other documents for details.","title":"HDAL"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#installation","text":"The modules can be installed by \u201cmodprobe\u201d or \u201cinsmod/rmmod\u201d to install or uninstall, besides the modprobe will also install related modules automatically. Example: modprobe (Only needs the module name) modprobe ehci-hcd insmod/rmmod (This method needs a full path) insmod /lib/modules/{KER_VER}/extra/crypto/cryptodev-linux/cryptodev.ko","title":"Installation"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#build-tools","text":"This folder will integrate some Linux open source tools as the following description: htop - Linux process monitoring, to provide more than top information gdb - gdb server for the application debug ethtool - Utility for controlling network drivers and hardware bonnie++ - A benchmark suite that is aimed at performing a number of simple tests of hard drive and file system performance memtester - A userspace utility for testing the memory subsystem for faults mtd-utils - MTD device utilities procps - A tool set to provide system analysis tools (vmstat, slabtop,\u2026etc) stress - System performance testing tool stress-ng - Advanced system performance testing tool sdcard_test.sh- To do sd driver r/w testing iozone - IO r/w performance testing VDBench - CPU/io performance testing","title":"Build tools"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#compilation_3","text":"To select the tools what you want: mtd-utils, memtester, bonnie, ethtool, gdb, htop, netperf, iperf and procps and running below instructions: e.g. \\$ cd na51090_linux_sdk/ \\$ cd tools/ \\$ make stress Tools clean build: \\$ make clean","title":"Compilation"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#installation_1","text":"\\$ make install The tools will be installed on \u201cna51090_linux_sdk/BSP/root-fs\u201d.","title":"Installation"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#build-root-fs","text":"","title":"Build root-fs"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#introduction","text":"The root file system will be mounted by Linux kernel, the first process of the kernel is /sbin/init (PID=1). We provide several root file systems support for selection, the following are the summary features: UBIFS: readable/writable file system, support Nor and Nand flash, fast mounting speed, best bad block management and better IO performance. Suitable for low memory size and large flash size use condition. We have a detail introduction in OSDRV/NT9833x_UBI_Filesystem_User_Guide_en.doc Squashfs: read-only file system, high compression rate. Suitable for small size flash and readonly use condition. JFFS2: It is a log-structured file system which can support Nand and Nor flash devices. Providing zlib, lzo and rtime compression methods. Suitable for small flash size and readable/writable use condition. RAMDISK: To provide a ram based file system.","title":"Introduction"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#configuration","text":"The root file system will generate Nand flash type image format, we support squashfs and ubifs, please follow the Nand flash specification to modify the parameters: \\$ cd na51090_linux_sdk/BSP/root-fs/ \\$ vi ubi_max_leb.py To find below lines: W = 1024 SP = 128 * 1024 SL = 124 * 1024 According the Nand flash to modify the parameters: W is the entire flash chip Physical eraseblocks numbers SP is the Size of block page SL= (Size of block -2) * Size of page. e.g. 128MB Nand flash = 1024 eraseblocks = 1024 * 128KB W = 1024 SP = 64 * 2048 = 128 * 1024 SL = (64 \u2013 2) * 2048 = 124 * 1024 \\$ vi mtd_cfg.txt We can support two mtd_cfg.txt in BSP/root-fs/ and configs/cfg_gen, the build tool will search configs/cfg_gen/mtd_cfg.txt firstly, and the second is BSP/root-fs/mtd_cfg.txt. To find below lines: ROOTFS_UBI_SUB_PAGE_SIZE=2048 ## Same as page size ROOTFS_UBI_PAGE_SIZE=2048 ## Nand page size ROOTFS_UBI_ERASE_BLK_SIZE=126976 ## (64-2) * Page size=126976 ROOTFS_UBI_MAX_LEB_COUNT=361 ## Size = UBI_MAX_LEB_COUNT * UBI_BLK_SIZE; It's calculated by \"python ubi_max_leb.py Bytes\" ROOTFS_UBI_RW_MAX_LEB_COUNT=258 ## Size = UBI_MAX_LEB_COUNT * UBI_BLK_SIZE; It's calculated by \"python ubi_max_leb.py Bytes\" ROOTFS_UBI_BLK_SIZE=\"128KiB\" ## UBIFS Nand flash block size (KiB) ROOTFS_UBI_COMPRESS_MODE=\"lzo\" ## UBIFS compression type: \"lzo\", \"favor_lzo\", \"zlib\" \"none\" ROOTFS_SQ_COMPRESS_MODE=\"xz\" ## Squashfs compression type: \"gzip\", \"lzo\" and \"xz\" ROOTFS_SQ_BLK_SIZE=\"128K\" ## Squashfs Nand flash block size (KiB): e.g. spinand: 128K, spinor: 64K ROOTFS_JFFS2_COMPRESS_MODE=\"lzo\" ## jffs2 compression type: \"lzo\" \"zlib\" \"rtime\" ROOTFS_JFFS2_SIZE=0x3200000 ## jffs2 partition size: get from /proc/mtd ROOTFS_JFFS2_RW_SIZE=0x2500000 ## jffs2 partition size: get from /proc/mtd ROOTFS_JFFS2_BLK_SIZE=\"128KiB\" ## jffs2 block size (KiB): spinand: 128KiB, spinor: 64KiB ROOTFS_JFFS2_PAGE_SIZE=\"2048\" ## jffs2 page size (Bytes): only used by nand, nor flash can be ignored. ROOTFS_EXT4_SIZE=$(shell printf \"%d\\n\" 0x0A000000) ROOTFS_FAT_CACHE_SIZE=$(shell printf \"%d\\n\" 0x0A000000) #APPFS ROOTFS_JFFS2_APP_SIZE=0x01E0000 ROOTFS_JFFS2_APP_NOR_SIZE=0x0E20000 ROOTFS_UBI_APP_MAX_LEB_COUNT=231 The necessary parameters need to be modified as below description: ROOTFS_UBI_SUB_PAGE_SIZE: The sub-page size of the Nand flash ROOTFS_UBI_PAGE_SIZE: The page size of the Nand flash ROOTFS_UBI_ERASE_BLK_SIZE: (Nand flash block size \u2013 2) * Page size ROOTFS_UBI_MAX_LEB_COUNT: Use ubi_max_leb.py to calculate it \\$ Usage: ubi_max_leb.py PartitionSize (Bytes) ROOTFS_UBI_RW_MAX_LEB_COUNT: Use ubi_max_leb.py to calculate it \\$ Usage: ubi_max_leb.py PartitionSize (Bytes) ROOTFS_UBI_BLK_SIZE: Nand flash block size ROOTFS_UBI_COMPRESS_MODE: Compression method = LZO ROOTFS_SQ_COMPRESS_MODE: Squashfs compression mode ROOTFS_SQ_BLK_SIZE: Squashfs nand flsh block size ROOTFS_JFFS2_COMPRESS_MODE: jffs2 compression type: \u201clzo\u201d \u201czlib\u201d \u201crtime\u201d ROOTFS_JFFS2_SIZE: Rootfs partition size ROOTFS_EXT4_SIZE: EMMC boot partition size ROOTFS_FAT_CACHE_SIZE: EMMC boot FAT partition size (Optional) ROOTFS_JFFS2_APP_SIZE: The size of the app partition in nand flash ROOTFS_JFFS2_APP_NOR_SIZE: The size of the app partition in nor flash ROOTFS_UBI_APP_MAX_LEB_COUNT: The ubi image size in app partition (Use ubi_max_leb.py to calculate it) You can modify the ubi mount parameters with your requirement, e.g. BSP/root-fs/ubi_max_leb.py def get_ubifs_max_leb(partition_size): #Unit: Bytes P = partition_size/SP BR = math.ceil(30 * W/float(1024)) ## Sync with kernel B = max(BB, BR) ubi_overhead = (( B - BB + 4 ) * SP + O * ( P - B - 4 ))/float(SP) ubi_overhead = math.ceil(ubi_overhead) ubi_overhead = math.floor(((P - ubi_overhead) * SP) / float(SL)) if ubi_overhead < 0: return -1 else: return (ubi_overhead - 1) Note: linux menuconfig Maximum expected bad eraseblock count per 1024 eraseblocks value \u201c30\u201d must be the same with ubi_max_leb.py value \u201c30\u201d. This parameter will affect the bad block management, please reserve enough blocks(e.g. 10, 20) per 1024 erase blocks.","title":"Configuration"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#modify-flash-filesystem-partition-size","text":"Users must check mtd config definiton in configs/cfg_gen/mtd_cfg.txt, the parameters: ROOTFS_UBI_MAX_LEB_COUNT, ROOTFS_UBI_RW_MAX_LEB_COUNT and ROOTFS_UBI_APP_MAX_LEB_COUNT value must use ubi_max_leb.py to calculate.","title":"Modify flash filesystem partition size"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#compilation_4","text":"Using \u201cmake rootfs\u201d instruction to generate rootfs bin, the image type can be selected by nvt-info.dtsi in configs folder. They can be produced into \u201cna51090_linux_sdk/output/rootfs.ubifs.bin\u201d, \u201cna51090_linux_sdk/output/rootfs.squash.bin\u201d and \u201cna51090_linux_sdk/output/rootfs.jffs2.bin\u201d separately. The command \u201cmr\u201d also can be used to compile rootfs if you are not in na51090_linux_sdk root folder. \\$ cd na51090_linux_sdk/ \\$ source build/envsetup.sh \\$ make rootfs Rootfs clean build: \\$ make rootfs_clean This command will remove busybox tools, kernel modules\u2026etc., please follow below procedure to generate rootfs image: \\$ make busybox \\$ make app (\\$ make library if necessary) \\$ make hdal \\$ make rootfs","title":"Compilation"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#folder-description","text":"Architecture Folder Description bin User binaries dev Device files etc System management configuration files home User home directories init -> bin/busybox It is used to kernel boot necessary init process, for the initial environment setup. lib Standard system libraries linuxrc -> bin/busybox mnt External storage device mount folder (/mnt/sd, /mnt/usb) proc RAM based FS to provide process information root Root\u2019s folder (The default shell will login here) sbin System management binaries srv Service data sys RAM based FS to provide user space and kernel space attribute/properties link. tmp RAM based temp folder usr User libraries, binaries var Service log message, including kernel, application, web server default folder(/var/www) and service\u2026etc /etc/passwd This file can setup user account environment, below is to introduce how to enable login password. \\$ vi /etc/inittab ::respawn:-/bin/login Replace \u201c::respawn:-/bin/login -f root\u201d with \u201c::respawn:-/bin/login\u201d as below Fill in the red part with the encryption password which can be generated by openssl tool: \\$ vi /etc/passwd root:EncryptionCode:0:0:root:/root:/bin/sh Openssl generation: \\$ openssl passwd -crypt YourPWD /etc/init.d System will execute the following shell scripts according sequence. rcS -> S00_PreReady -> S05_Net -> S10_SysInit -> S10_hdal_init -> S99_Sysctl Moreover, power off will execute deinitialization process as below. rcK -> K00_Sys -> K99_Sys /etc/sysctl.conf This file is handle sysctl parameters setup.","title":"Folder description"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#ubifs","text":"The UBIFS is our default rootfs format, UBIFS (Unsorted Block Image File System) was originally called JFFS3, is JFFS2 next generation version. The main capabilities are faster mounting, quicker access to large files, and improved write speeds. UBIFS also preserves or improves upon JFFS2\u2019s on-the-fly compression, recoverability and power fail tolerance, and data compression allows zlib or LZO. The filename is UBI.IMG after compilation.","title":"UBIFS"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#squashfs","text":"Squashfs is a read-only file system which can support gzip, lzo and xz compression modes. The main features are high compression rate, stores full 32bits uid/gids and creation time, support block size up to 1Mbytes. The filename is SQ_ROOTFS.IMG after compilation.","title":"Squashfs"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#jffs2","text":"JFFS2 was developed by Red Hat, based on the work started in the original JFFS by Axis Communications, AB, it is a readable and writable file system. JFFS2 will scan rootfs partition during mounting; the mount time depends on the rootfs size. The main features are listed as below: Support compression mode Mounting time will be affected by flash size Not support all Nand flash devices with HW ecc, please refer to Linux driver application note The filename is rootfs.jffs2.bin after compilation. For the kernel configuration to add jffs2 support, you must add below configurations: File systems -> Miscellaneous filesystems -> [*] Journalling Flash File System v2 (JFFS2) support -> [*] Advanced compression options for JFFS2 -> [*] JFFS2 LZO compression support For the uboot configuration to choose root file system type, please refer to the UBoot_Programing_Guide.","title":"Jffs2"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#hdal-sample-code","text":"We will pack one partition named DVR_xxx.bin is under na51090_linux_sdk/configs/Linux/cfg_xxx/nvt-nvtpack.dtsi partition_name = \u201capp\u201d field. You could modify the partition size and recalculate the related parameters to fill in the nvt -storage-partition.dtsi partition_app field. Please refer to 7.2 for mtd_cfg.txt description.","title":"HDAL sample code"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#build-app","text":"","title":"Build App"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#compilation_5","text":"NVT platform needs the necessary applications to perform the requested actions, please using below instructions to compile (This part doesn\u2019t provide source code). \\$ cd na51090_linux_sdk/code/application \\$ make install Please execute \u201csource build/envsetup.sh\u201d firstly when you start to build it. Please reference to Application Note for the other details. We have fine-tuned some functions and the fpu related setting, please add \\$(PLATFORM_CFLAGS) to your Makefile to get more performance. e.g. nvt02854@oaalnx13:~/na51090_linux_sdk/na51090_linux_sdk$ get_stuff_for_environment ======================================== NVT Setting ======================================== NVT_PRJCFG_CFG = Linux NVT_PRJCFG_MODEL_CFG = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/configs/Linux/cfg_TEST_FPGA_a64/ModelConfig.mk LINUX_BUILD_TOP = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk UBOOT_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/u-boot OPTEE_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/optee KERNELDIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/linux-kernel BUSYBOX_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/busybox TOYBOX_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/toybox ROOTFS_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/BSP/root-fs APP_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/application LIBRARY_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/lib INCLUDE_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/lib/include NVT_DRIVER_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/driver NVT_HDAL_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/hdal NVT_VOS_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/vos NVT_RTOS_MAIN_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/rtos-main SAMPLE_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/code/sample TOOLS_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/tools OUTPUT_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/output LOGS_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/logs BUILD_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/build CONFIG_DIR = /home/nvt02854/na51090_linux_sdk/na51090_linux_sdk/configs PLATFORM_CFLAGS = -march=armv8-a -mtune=cortex-a53 -ftree-vectorize -fno-builtin -fno-common -Wformat=1 -D_BSP_NA51090_ PLATFORM_AFLAGS = march=armv8-a -mtune=cortex-a53 -D_BSP_NA51090_ NVT_HOST = aarch64-ca53-linux-uclibc LINUX_CPU_TYPE = cortex-a53x64 NVT_LINUX_VER = 4.19.148 NVT_MULTI_CORES_FLAG = -j80 CROSS_COMPILE = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc- CROSS_TOOLCHAIN_PATH = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4 CROSS_TOOLCHAIN_BIN_PATH = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin SYSROOT_PATH = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/aarch64-ca53-linux-uclibc/sysroot UBOOT_CROSS_COMPILE = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc- AS = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-as CC = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-gcc CXX = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-g++ LD = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-ld LDD = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-ldd AR = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-ar NM = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-nm GDB = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-gdb STRIP = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-strip OBJCOPY = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-objcopy OBJDUMP = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin/aarch64-ca53-linux-uclibc-objdump PATH = /opt/CEVA-ToolBox/V17/XM4/CEVA-XM4:/opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/bin:/opt/utility/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/snap/bin:. LD_LIBRARY_PATH = /opt/ivot/aarch64-ca53-linux-uclibcgnueabihf-8.4/usr/local/lib =============================================================================================","title":"Compilation"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#build-libraries","text":"","title":"Build Libraries"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#compilation_6","text":"na51090_linux_sdk provides some proprietary libraries and header files for the product customization (this part doesn\u2019t involve source code, we only provide you *.so), please according the following instruction to compile it. \\$ cd na51090_linux_sdk/ \\$ make library Libraries clean build: \\$ make library_clean Please execute \u201csource build/envsetup.sh\u201d firstly when you start to build it. Please reference to Application Note for the other details.","title":"Compilation"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#build-busybox","text":"","title":"Build busybox"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#compilation_7","text":"Busybox can provide rootfs necessary tools, using below instruction can compile it. And the tools will be installed to na51090_linux_sdk/BSP/root-fs. \\$ cd na51090_linux_sdk/ \\$ make busybox mybusybox clean build: \\$ make busybox_clean","title":"Compilation"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#menu-configuration_1","text":"SDK will provide two busybox configuration files, one is normal version (busybox_cfg_normal), and the other is minimized version (busybox_cfg_small). Edit Top Makefile can change the busybox configuration, the default is normal version. Edit Top Makefile to switch the configuration file: \\$ cd na51090_linux_sdk/ \\$ vi Makefile BUSYBOX_CFG:=busybox_cfg_full #BUSYBOX_CFG:=busybox_cfg_small Below instruction can handle busybox features selection: \\$ make busybox_config Choose \u201cExit/Save\u201d after you finished function selection, it can generate new .config for the Busybox compilation usage.","title":"Menu configuration"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#build-sample-code","text":"","title":"Build sample code"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#compilation_8","text":"The device driver testing applications will be used to test NVT peripheral devices; the following instructions can compile it. And it will be installed to na51090_linux_sdk/BSP/root-fs. \\$ cd na51090_linux_sdk/ \\$ make sample Driver test clean build: \\$ make sample_clean","title":"Compilation"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#update-firmware","text":"We provide two OS version nvtpack image could be used, one is Linux version will be generate by Linux version nvtpack tool, the images will be generated under the output folder. Another is Windows vesion nvtpack tool, the following section can get more clearly description.","title":"Update Firmware"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#linux-version-nvtpack-for-all-in-one-image","text":"The nvt-nvtpack.dtsi is used to control what kinds of images want to be involved, and which files will be packed by all-in-one tool. If source_file = \u201c\u201d, it means we don\u2019t want to pack this image into all-in-one image. If id1 \u2026 source_file = \u201cnvt-evb.bin\u201d, it means nvt-evb.bin file will pack into all-in-one image partition 1, partition setting we can reference nvt-storage-partition.dtsi file. nvtpack { ver = \"NVTPACK_FW_INI_16072017\"; /* Fixed */ method = <1>; /* Fixed */ index { id0 { partition_name = \"loader\"; source_file = \"\"; }; /* Fixed */ id1 { partition_name = \"fdt\"; source_file = \"nvt-all.bin\"; }; /* Fixed */ id2 { partition_name = \"fdt.restore\"; source_file = \"\"; }; /* Fixed */ id3 { partition_name = \"atf\"; source_file = \"atf.bin\"; }; id4 { partition_name = \"uboot\"; source_file = \"u-boot.bin\"; }; id5 { partition_name = \"uenv\"; source_file = \"\"; }; id6 { partition_name = \"kernel\"; source_file = \"Image.bin\"; }; id7 { partition_name = \"rootfs\"; source_file = \"rootfs.ramdisk.bin\"; }; id8 { partition_name = \"rootfs1\"; source_file = \"rootfs_1.rw.ubifs.bin\"; }; }; }; Using \u201cmake all\u201d or \u201cmake pack\u201d can generate the packed image is under output/packed/FW(SOC).bin.","title":"Linux version nvtpack for all-in-one image"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#update-firmware_1","text":"Insert SD card including All-in-One bin to the target board and power on can update firmware.","title":"Update Firmware"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#update-loader","text":"For a blank Nand flash, you need to burn loader (LD98336A.bin), by first SD card format (be sure to format), and then immediately put LD98336A.bin, then placed all in one bin (FW98336A.bin).","title":"Update Loader"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#power-on","text":"","title":"Power on"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#how-to-power-on","text":"To follow update steps to burn the desired Image, remove SD card can boot up directly.","title":"How to power on"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#debug_1","text":"The following list provides comparison and classification of the debugging tools. Name Classification Description Coredump AP debug Generated file for the further analysis when the program has terminated abnormally Messages AP/Kernel debug To record Linux kernel and AP booting log GDB AP debug To debug target board application from remote server printk Kernel debug Basic kernel/module debug usage kmemleak Kernel debug To analyze if Linux kernel has memory leak issue. OPENOCD Kernel debug To debug/ trace kernel or uboot","title":"Debug"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#coredump","text":"Provide analytical application error log, the application does not properly terminated, it generates a file in /var/log. It can record the program name, PID and time, can be loaded for analysis through a cross compiler. You should build it with debug mode when you start application analysis. The following is related setting: \\$ cd na51090_linux_sdk/root-fs/rootfs/ \\$ vi etc/profile ## coredump setting echo 1 > /proc/sys/kernel/core_uses_pid ulimit -c unlimited echo \"/var/log/core-%e-%p-%t\" > /proc/sys/kernel/core_pattern If the user wants to store the dump file in SD card or USB disk, linux will check the file permission, fat can not support linux permission, please format to ext4 filesystem.","title":"Coredump"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#messages","text":"The boot log of the Linux will be stored in /var/log/messages, this file can involve Kernel and user space app. If the kernel crash occurred, please provide this file for the further analysis.","title":"Messages"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#gdb","text":"GDB (GNU Project Debugger) can support Remote and Target mode to debug AP. Target mode gdb/gdbserver can be generated by the following command: \\$ cd na51090_linux_sdk/tools \\$ make gdb The connection diagram as shown below, Figure 13-1: Figure 14-1 Target debug connection Remote mode can debug user space application through GDB server, and the connection architecture as below. Linux server is x86_64 compile server, target board is the EVB, they can be connected by serial or TCP/IP. Linux server will use cross compiler toolchain GDB to debug target board AP, this AP must be enabled debug symbol, and target board also needs to execute gdbserver which can be find in toolchain. The serial connection can connect USB-to-Serial cable to target board USB port, and check if there is /dev/ttyUSB0 existed. TCP/IP connection can use Wi-Fi or Ethernet, install necessary drivers and confirm whether it can ping to server. Figure 14-2 Remote debug connection GDB server needs to be executed on EVB. \\$ cp tools/__install/bin/gdbserver root-fs/rootfs/bin/ \\$ cp tools/__install/bin/gdb root-fs/rootfs/bin/ And then, running below procedures can debug your AP. Target Board target > gdbserver comm prog [args\u2026] The gdbserver doesn\u2019t loading debug symbol, all of the symbols will be loaded by the Linux server cross compiler gdb. It can reduce memory space in this way. Serial: target > gdbserver /dev/ttyUSB0 hello_world Net: target > gdbserver Host _IP:1234 hello_world Linux Server Serial: Server > {CROSS_COMPILE}-gdb hello_world Server > set remotebaud 115200 Server > target remote /dev/ttyUSB0 Net: Server > {CROSS_COMPILE}-gdb hello_world Server > target remote localhost:1234 Reference to below link can show you how to use command debug your AP: http://sourceware.org/gdb/current/onlinedocs/gdb/index.html In addition to command mode debug you also can use DDD, it is a framework on top of GDB debug visualization software, you can install and use by below command: \\$ sudo apt-get install ddd \\$ sudo ddd \u2013debugger aarch64-ca53-linux-uclibc-gdb","title":"GDB"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#printk","text":"Linux provides seven levels of Log printk available in the following table: Level Description Usage KERN_EMERG system is unusable pr_emerg KERN_ALERT action must be taken immediately pr_alert KERN_CRIT critical conditions pr_crit KERN_ERR error conditions pr_err KERN_WARNING warning conditions pr_warning KERN_NOTICE normal but significant condition pr_notice KERN_INFO Informational pr_info KERN_DEBUG debug-level messages pr_debug Above the printk level is used to decide whether or not to print the message console, the below instruction can show you the printk level, current representative of the level of the boot to be printed, default is the default level, minimum is the lowest possible print level, boot-time-default is boot stage log: root@NVTEVM:\\~\\$ cat /proc/sys/kernel/printk 7 4 1 7 current default minimum boot-time-default Kernel will compare the printed message log level, if the value is less than the current will be printed out. Therefore, to change the output level so that all messages are printed out can use this command:Kernel hu\u00ec q\u00f9 b\u01d0ji\u00e0o y\u00ecn ch\u016b x\u00f9nx\u00ed de log level, r\u00fagu\u01d2 xi\u01ceoy\u00fa current de zh\u00ed ji\u00f9 hu\u00ec y\u00ecn ch\u016bl\u00e1i. Y\u012bnc\u01d0, y\u00e0o g\u01ceibi\u00e0n sh\u016bch\u016b j\u00edbi\u00e9 r\u00e0ng su\u01d2y\u01d2u x\u00f9nx\u00ed d\u014du k\u011by\u01d0 y\u00ecn ch\u016bl\u00e1i k\u011by\u01d0 y\u00f2ng d\u01d0xia f\u0101ngsh\u00ec:\u60a8\u662f\u4e0d\u662f\u8981\u67e5\uff1a Linux\u9664\u4e86 Built -in\u7684Driver\u4e4b\u5916,\u9084\u6709\u63d0\u4f9b\u5916\u90e8\u8f09\u5165\u7684\u65b9\u5f0f\u7a31\u4e4b\u70baKernel module,\u53ef\u900f\u904einsmod\u6216\u662fmodprobe\u505a\u8f09\u5165,\u5e95\u4e0b\u5206\u70babuild-in module\u8207out-of-tree module\u505a\u7de8\u8b6f\u4ecb\u7d39\u3002 root@NVTEVM:\\~\\$ echo 8 > /proc/sys/kernel/printk","title":"Printk"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#kmemleak","text":"Linux Kmemleak is provided for detecting a memory leak tool, it will record detect report in /sys/kernel/debug/kmemleak, to use this function as long as enable the \u201cKernel Hacking\u201d, \u201cKernel Memory Leak Detector\u201d (CONFIG_DEBUG_KMEMLEAK) in the kernel option, and configure the \u201cMaximum kmemleak early log entires\u201d with 1200. Clear current record: root@NVTEVM:\\~\\$ echo clear > /sys/kernel/debug/kmemleak Testing your driver: root@NVTEVM:\\~\\$ insert YourModule.ko Scan: root@NVTEVM:\\~\\$ echo scan > /sys/kernel/debug/kmemleak Check the resules: root@NVTEVM:\\~\\$ cat /sys/kernel/debug/kmemleak","title":"Kmemleak"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#faq","text":"This section will list frequently problems.","title":"FAQ"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#toolchain-cant-be-found","text":"We have two toolchains to build overall SDK, one is for itron, another is for Linux. First, please use below command to check your environment setting. \\$ get_stuff_for_environment","title":"Toolchain can\u2019t be found"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#operation-not-permitted","text":"The SDK installation path should be under your home folder, you should use the same owner to decompressing and building, otherwise you will get \u201c operation not permitted \u201d related message. Please use below command to check permission and owner. \\$ ls -al YOUR_FOLDER","title":"Operation not permitted"},{"location":"Software/OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html#linux-kernel-uimage-cant-be-generated","text":"This is because our default setting is lz4 compression format, you should follow section 1.2 to check lz4 tool is installed. Try to use lz4 command to check your compiling environment. \\$ lz4","title":"Linux kernel uImage can\u2019t be generated"}]}