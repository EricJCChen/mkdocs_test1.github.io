
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.3.1, mkdocs-material-8.5.3">
    
    
      
        <title>Quick Start - NT98336/NT98633 Documents</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.7a952b86.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.cbb835fc.min.css">
        
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#1-introduction" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="NT98336/NT98633 Documents" class="md-header__button md-logo" aria-label="NT98336/NT98633 Documents" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            NT98336/NT98633 Documents
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Quick Start
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  
    
  


  
  
  
    <li class="md-tabs__item">
      <a href="NT9833x_DVR_NVR_SDK_Quick_Start.html" class="md-tabs__link md-tabs__link--active">
        Software
      </a>
    </li>
  

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../not_ready - not_reay.md" class="md-tabs__link">
        Hardware(Not Ready)
      </a>
    </li>
  

  

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../not_ready - not_reay.md" class="md-tabs__link">
        For Reference(Not Ready)
      </a>
    </li>
  

  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="NT98336/NT98633 Documents" class="md-nav__button md-logo" aria-label="NT98336/NT98633 Documents" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    NT98336/NT98633 Documents
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" checked>
      
      
      
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1">
          Software
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Software" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          Software
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Quick Start
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="NT9833x_DVR_NVR_SDK_Quick_Start.html" class="md-nav__link md-nav__link--active">
        Quick Start
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-introduction" class="md-nav__link">
    1 Introduction
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-environment-overview" class="md-nav__link">
    2 Environment Overview
  </a>
  
    <nav class="md-nav" aria-label="2 Environment Overview">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-general-description" class="md-nav__link">
    2.1 General Description
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-sdk-package" class="md-nav__link">
    2.2 SDK Package
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23-system-board-connection" class="md-nav__link">
    2.3 System Board Connection
  </a>
  
    <nav class="md-nav" aria-label="2.3 System Board Connection">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#231-98633-evb" class="md-nav__link">
    2.3.1 98633 EVB
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-environment-setup" class="md-nav__link">
    3 Environment Setup
  </a>
  
    <nav class="md-nav" aria-label="3 Environment Setup">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-cross-compiler-setup" class="md-nav__link">
    3.1 Cross Compiler Setup
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-sdk-setup" class="md-nav__link">
    3.2 SDK Setup
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-build-image" class="md-nav__link">
    3.3 Build Image
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34-run-the-first-sample" class="md-nav__link">
    3.4 Run the First Sample
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-boot-up-sequence" class="md-nav__link">
    4 Boot-up Sequence
  </a>
  
    <nav class="md-nav" aria-label="4 Boot-up Sequence">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41-overview-of-booting-procedure" class="md-nav__link">
    4.1 Overview of Booting Procedure
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42-vg_bootsh" class="md-nav__link">
    4.2 vg_boot.sh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43-module_initc" class="md-nav__link">
    4.3 module_init.c
  </a>
  
    <nav class="md-nav" aria-label="4.3 module_init.c">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#431-memory-pool-setup" class="md-nav__link">
    4.3.1 Memory Pool Setup
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#432-video-output-setup" class="md-nav__link">
    4.3.2 Video Output Setup
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#433-video-input-setup" class="md-nav__link">
    4.3.3 Video Input Setup
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-hardware-device-abstraction-layer-hdal" class="md-nav__link">
    5 Hardware Device Abstraction Layer (HDAL)
  </a>
  
    <nav class="md-nav" aria-label="5 Hardware Device Abstraction Layer (HDAL)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51-concept" class="md-nav__link">
    5.1 Concept
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52-sample-codes" class="md-nav__link">
    5.2 Sample Codes
  </a>
  
    <nav class="md-nav" aria-label="5.2 Sample Codes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#521-encode" class="md-nav__link">
    5.2.1 Encode
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#522-liveview" class="md-nav__link">
    5.2.2 Liveview
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#523-playback" class="md-nav__link">
    5.2.3 Playback
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#524-display-to-encode" class="md-nav__link">
    5.2.4 Display to Encode
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-appendix" class="md-nav__link">
    6 Appendix
  </a>
  
    <nav class="md-nav" aria-label="6 Appendix">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61-video-format" class="md-nav__link">
    6.1 Video Format
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_2" type="checkbox" id="__nav_1_2" >
      
      
      
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1_2">
          CVAI
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="CVAI" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_2">
          <span class="md-nav__icon md-icon"></span>
          CVAI
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="CVAI/NT9833X_MD_User_Guide_en.html" class="md-nav__link">
        MD User Guide
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="CVAI/NT9833X_IVE_User_Guide_en.html" class="md-nav__link">
        IVE User Guide
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="CVAI/NT9833X_MD_Tuning_Guide_en.html" class="md-nav__link">
        MD Tuning Guide
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_3" type="checkbox" id="__nav_1_3" >
      
      
      
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1_3">
          ISPQ
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="ISPQ" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_3">
          <span class="md-nav__icon md-icon"></span>
          ISPQ
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="ISP/NT9833x_VPE_IQ_Tuning_Guide_en.html" class="md-nav__link">
        VPE IQ Tuning Guide
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="ISP/NT9833x_LCD_IQ_Tuning_Guide_en.html" class="md-nav__link">
        LCD IQ Tuning Guide
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="ISP/NT9833x_DI_Tuning_Guide_en.html" class="md-nav__link">
        DI Tuning Guide
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_4" type="checkbox" id="__nav_1_4" >
      
      
      
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1_4">
          MEDIA
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="MEDIA" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_4">
          <span class="md-nav__icon md-icon"></span>
          MEDIA
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="MEDIA/NT9833x_HDAL_Vendor_ISP_Programming_Guide_en.html" class="md-nav__link">
        Vendor ISP Programming Guide
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="MEDIA/NT9833x_HDAL_Vendor_Media_Programming_Guide_en.html" class="md-nav__link">
        Vendor Media Programming Guide
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="MEDIA/NT9833x_HDAL_Vendor_PCIe_Programming_Guide_en.html" class="md-nav__link">
        Vendor PCie Programming Guide
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_5" type="checkbox" id="__nav_1_5" >
      
      
      
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1_5">
          OSDRV
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="OSDRV" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_5">
          <span class="md-nav__icon md-icon"></span>
          OSDRV
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="OSDRV/NT9833x_SDK_Pure_Linux_Programming_Guide_en.html" class="md-nav__link">
        Linux Programming Guide
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="OSDRV/NT9833x_Quick_Bringup_User_Guide_en.html" class="md-nav__link">
        Quick Bringup User Guide
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="OSDRV/NT9833x_PCIe_User_Guide_en.html" class="md-nav__link">
        PCIe User Guide
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
        
          
        
      
      
        <label class="md-nav__link" for="__nav_2">
          Hardware(Not Ready)
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Hardware(Not Ready)" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          Hardware(Not Ready)
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_1" type="checkbox" id="__nav_2_1" >
      
      
      
        
          
        
      
      
        <label class="md-nav__link" for="__nav_2_1">
          Not Ready
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Not Ready" data-md-level="2">
        <label class="md-nav__title" for="__nav_2_1">
          <span class="md-nav__icon md-icon"></span>
          Not Ready
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../not_ready - not_reay.md" class="md-nav__link">
        None
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
        
          
        
      
      
        <label class="md-nav__link" for="__nav_3">
          For Reference(Not Ready)
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="For Reference(Not Ready)" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          For Reference(Not Ready)
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3_1" type="checkbox" id="__nav_3_1" >
      
      
      
        
          
        
      
      
        <label class="md-nav__link" for="__nav_3_1">
          Not Ready
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Not Ready" data-md-level="2">
        <label class="md-nav__title" for="__nav_3_1">
          <span class="md-nav__icon md-icon"></span>
          Not Ready
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../not_ready - not_reay.md" class="md-nav__link">
        None
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-introduction" class="md-nav__link">
    1 Introduction
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-environment-overview" class="md-nav__link">
    2 Environment Overview
  </a>
  
    <nav class="md-nav" aria-label="2 Environment Overview">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-general-description" class="md-nav__link">
    2.1 General Description
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-sdk-package" class="md-nav__link">
    2.2 SDK Package
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23-system-board-connection" class="md-nav__link">
    2.3 System Board Connection
  </a>
  
    <nav class="md-nav" aria-label="2.3 System Board Connection">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#231-98633-evb" class="md-nav__link">
    2.3.1 98633 EVB
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-environment-setup" class="md-nav__link">
    3 Environment Setup
  </a>
  
    <nav class="md-nav" aria-label="3 Environment Setup">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-cross-compiler-setup" class="md-nav__link">
    3.1 Cross Compiler Setup
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-sdk-setup" class="md-nav__link">
    3.2 SDK Setup
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-build-image" class="md-nav__link">
    3.3 Build Image
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34-run-the-first-sample" class="md-nav__link">
    3.4 Run the First Sample
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-boot-up-sequence" class="md-nav__link">
    4 Boot-up Sequence
  </a>
  
    <nav class="md-nav" aria-label="4 Boot-up Sequence">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41-overview-of-booting-procedure" class="md-nav__link">
    4.1 Overview of Booting Procedure
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42-vg_bootsh" class="md-nav__link">
    4.2 vg_boot.sh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43-module_initc" class="md-nav__link">
    4.3 module_init.c
  </a>
  
    <nav class="md-nav" aria-label="4.3 module_init.c">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#431-memory-pool-setup" class="md-nav__link">
    4.3.1 Memory Pool Setup
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#432-video-output-setup" class="md-nav__link">
    4.3.2 Video Output Setup
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#433-video-input-setup" class="md-nav__link">
    4.3.3 Video Input Setup
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-hardware-device-abstraction-layer-hdal" class="md-nav__link">
    5 Hardware Device Abstraction Layer (HDAL)
  </a>
  
    <nav class="md-nav" aria-label="5 Hardware Device Abstraction Layer (HDAL)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51-concept" class="md-nav__link">
    5.1 Concept
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52-sample-codes" class="md-nav__link">
    5.2 Sample Codes
  </a>
  
    <nav class="md-nav" aria-label="5.2 Sample Codes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#521-encode" class="md-nav__link">
    5.2.1 Encode
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#522-liveview" class="md-nav__link">
    5.2.2 Liveview
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#523-playback" class="md-nav__link">
    5.2.3 Playback
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#524-display-to-encode" class="md-nav__link">
    5.2.4 Display to Encode
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-appendix" class="md-nav__link">
    6 Appendix
  </a>
  
    <nav class="md-nav" aria-label="6 Appendix">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61-video-format" class="md-nav__link">
    6.1 Video Format
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  <h1>Quick Start</h1>

<h2 id="1-introduction">1 Introduction<a class="headerlink" href="#1-introduction" title="Permanent link">&para;</a></h2>
<p>This document describes the overview of the NT9833x DVR/NVR SDK. It introduces the software/hardware requirements, step-by-step instructions to setup the development environment and how to build and run the image. Chapter 4 introduces the boot up sequence. Chapter 5 introduces the concept of HDAL APIs and gives several sample codes to explain these APIs usage.</p>
<h2 id="2-environment-overview">2 Environment Overview<a class="headerlink" href="#2-environment-overview" title="Permanent link">&para;</a></h2>
<h3 id="21-general-description">2.1 General Description<a class="headerlink" href="#21-general-description" title="Permanent link">&para;</a></h3>
<p>This SDK will use Linux OS as development environment. To install Ubuntu OS, please refer <em>NT9833x_SDK_Pure_Linux_Programming_Guide_en.pdf</em>.</p>
<p>After Linux OS installed, unpack SDK package under Linux, then you can build your DVR/NVR firmware. When your Firmware is ready, connect EVB to PC, and upgrade it to EVB.</p>
<h3 id="22-sdk-package">2.2 SDK Package<a class="headerlink" href="#22-sdk-package" title="Permanent link">&para;</a></h3>
<p>Using the following instructions to decompress SDK package under Linux:</p>
<p><strong>\$ tar -jxvf NT9833x_SDK_release_{VERSION}.tar.bz2</strong></p>
<p>You will get the folder tree as below:</p>
<p>├── hardware hardware document folder</p>
<p>├── board</p>
<p>├── document HW application note, and PCB/EVB document</p>
<p>├── chip</p>
<p>├── document chip datasheet</p>
<p>├── software software folder</p>
<p>├── board Linux SDK package and loader</p>
<p>├── document Linux and HDAL library document</p>
<p>├── chip</p>
<p>├── document chip document</p>
<p>├── pc PC upgrade, display and IQ tools.</p>
<p>├── document PC tool document</p>
<p>├──Disclaimer.pdf Disclaimer document</p>
<h3 id="23-system-board-connection">2.3 System Board Connection<a class="headerlink" href="#23-system-board-connection" title="Permanent link">&para;</a></h3>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image003.jpg" src="nvt_media/85ff9924040871dc0933eb670c2039b1.jpg" /></p>
<p>1. 12V input</p>
<p>2. eth1</p>
<p>3. Top: eth0; middle: Not use; bottom: USB 2.0</p>
<p>4. USB 3.0</p>
<p>5. VGA output</p>
<p>6. HDMI output</p>
<p>7. USB 2.0</p>
<p>8. UART console</p>
<p>9. Boot sequence switch</p>
<p>To update FW on the system board, please follow the following steps.</p>
<p>1. Connect UART console port to PC.</p>
<p>2. Connect 12V to power connector.</p>
<p>3. Connect the bottom USB port to PC.</p>
<p>4. Set J20 to 0, J21 to 1 and J22 to 0 to enter UART FW upgrade mode. And set J20 to 0, J21 to 0 and J22 to 1 to boot from NAND flash.</p>
<p>5. Connect HDMI output to your display device.</p>
<p>Please refer to <em>NT9833x_Quick_Bringup_User_Guide_en.pdf</em> for detail information about the FW update.</p>
<h4 id="231-98633-evb">2.3.1 98633 EVB<a class="headerlink" href="#231-98633-evb" title="Permanent link">&para;</a></h4>
<p>The 98633 board is different from the 98336 board, please refer to the below figure or refer to <em>NT98633_NVR_EVB_User Guide_V1.0.pdf</em> to setup the hardware environment.</p>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image004.png" src="nvt_media/957fb7ab0ac6be253c494ae5a17748ef.png" /></p>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image005.jpg" src="nvt_media/0a843c4c042bfce2f78478e1d84200d8.jpg" /></p>
<h2 id="3-environment-setup">3 Environment Setup<a class="headerlink" href="#3-environment-setup" title="Permanent link">&para;</a></h2>
<h3 id="31-cross-compiler-setup">3.1 Cross Compiler Setup<a class="headerlink" href="#31-cross-compiler-setup" title="Permanent link">&para;</a></h3>
<p>Toolchain:</p>
<p> glib: aarch64-ca53-linux-gnueabihf-8.4</p>
<p>Please install the toolchain as following command</p>
<p><strong>\$ sudo tar –jxvf aarch64-ca53-linux-gnueabihf-8.4.tar.bz2 -C /opt</strong></p>
<p>If you want to change path, please modify the <em>CROSS_TOOLCHAIN_PATH</em> parameter in the <em>build/envsetup.sh</em>.</p>
<h3 id="32-sdk-setup">3.2 SDK Setup<a class="headerlink" href="#32-sdk-setup" title="Permanent link">&para;</a></h3>
<p>Using the following instructions to decompress SDK pack under Linux.</p>
<p><strong>\$tar –jxvf na51090_linux_sdk.tar.bz2</strong></p>
<p>You will get the folder tree as below:</p>
<p>├──na51090_linux_sdk…………………………..Used to put unpacked SDK source code,</p>
<p>├── BSP ……………………………………………&hellip;Include linux, busybox, uboot and rootfs source</p>
<p>├── build ……………………………………………..scripts for the environment setup</p>
<p>├── code ………………………………………………HDAL linux drivers and sample code</p>
<p>├── configs……………………………………………Model settings</p>
<p>├── Makefile…………………………………………Top level Makefile</p>
<p>├── tools……………………………………………….target board tool</p>
<p>Before each opened a new Terminal window needs to compiler environment setting, the relevant variables set up, please follow the below instructions to finish it,</p>
<p><strong>\$ cd na51090_linux_sdk</strong></p>
<p><strong>\$ source build/envsetup.sh</strong></p>
<p>Please do a complete compilation for first time.</p>
<p>Select your model:</p>
<p><strong>\$lunch</strong></p>
<p>List your nvt build setting</p>
<p><strong>\$get_stuff_forenvironment</strong></p>
<p>Build overall system:</p>
<p><strong>\$make all</strong></p>
<h3 id="33-build-image">3.3 Build Image<a class="headerlink" href="#33-build-image" title="Permanent link">&para;</a></h3>
<p>After the <em>“make all”</em> command. It will generate the images under <em>“na51090_linux_sdk/output”</em> folder. The details are listed as below:</p>
<p>├── na51090_linux_sdk/………………………………… Put unpacked source code and image</p>
<p>├── Makefile………………………………………. Top level Makefile</p>
<p>├── output/………………………………………….. Compiled output image</p>
<p>├── packed/</p>
<p>├── FW98336A.bin………………… nvtpack image (All-in-one image)</p>
<p>├── preburn_image/ …………………….… the pre-burn images, you can copy these files into \DFUTools\image, and burn into the system board via DFU tool.</p>
<p>├── raw/ …………………………………………. raw format of the output image</p>
<p>├── Image.bin……………………………….. Linux Image</p>
<p>├── u-boot.bin………………………………… uboot image with nvt checksum</p>
<p>├── u-boot.lz.bin…………………………… uboot image (LZ compressed)</p>
<p>├── u-boot.lzma.bin……………………… uboot image (LZMA compressed)</p>
<p>├── rootfs.ramdisk.bin……………………. ramdisk image (rootfs)</p>
<p>├── rootfs_1.rw.ubifs.bin…………………. rootfs overlay</p>
<p>├── DVRxxxxxxx.bin………………………… mnt\mtd partition</p>
<p>├── nvt-all.bin…………………………………. linux kernel fdt</p>
<p>├── atf.bin…………………………..…………. arm-trusted-​firmware</p>
<p>├── FW98336A.ini……………..…………. the layout to pack to FW98336A.bin</p>
<p>The na51090_linux_sdk folder has a top level <em>Makefile</em>, it supports many of the make command, such as “<em>make linux</em>” is to compile linux-kernel, “<em>make uboot</em>” can compile u-boot, “<em>make rootfs</em>”…you can use “<em>make help</em>” to find what its commands are support. <strong>Please use top level Makefile to do SDK compilation to avoid some link error occurred</strong>. Its help description is as follows:</p>
<p>\$ make help</p>
<p>make help -> show make command info</p>
<p>make all -> build all</p>
<p>make linux -> build linux-kernel</p>
<p>make linuxram -> build linux-kernel with ramdisk support</p>
<p>make modules -> build built-in kernel modules</p>
<p>make driver -> build NVT linux driver modules</p>
<p>make atf -> build ARM trusted firmware</p>
<p>make uboot -> build loader(uboot)</p>
<p>make optee_os -> build OPTEE kernel</p>
<p>make optee_client -> build OPTEE client</p>
<p>make library -> build library</p>
<p>make busybox -> build busybox</p>
<p>make rootfs -> build rootfs</p>
<p>make app -> build applications</p>
<p>make tools -> build tools</p>
<p>make sample -> build sample code</p>
<p>make post -> run postprocessing script</p>
<p>make pack -> Generate nvtpack image and preburn images</p>
<p>make publish -> remove some sources for publish</p>
<p>=====================================================</p>
<p>make linux_config -> config linux-kernel</p>
<p>make linux_config_gcov-> modify kernel config for code coverage tool</p>
<p>make uboot_config -> config uboot</p>
<p>make busybox_config -> config busybox</p>
<p>make linux_header -> generate linux-kernel out of tree headers</p>
<p>=====================================================</p>
<p>make clean -> clean all</p>
<p>make linux_clean -> clean linux-kernel &amp; built-in kernel modules</p>
<p>make driver_clean -> clean NVT linux driver modules</p>
<p>make atf_clean -> clean ARM trusted firmware</p>
<p>make uboot_clean -> clean loader(uboot)</p>
<p>make optee_os_clean -> clean optee kernel</p>
<p>make optee_client_clean -> clean optee client application</p>
<p>make library_clean -> clean library</p>
<p>make busybox_clean -> clean busybox</p>
<p>make rootfs_clean -> clean rootfs</p>
<p>make app_clean -> clean applications</p>
<p>make tools_clean -> clean tools</p>
<p>make sample_clean -> clean sample code</p>
<p>make post_clean -> run postprocessing clean script</p>
<p>make pack_clean -> Remove nvtpack image</p>
<p>=====================================================</p>
<h3 id="34-run-the-first-sample">3.4 Run the First Sample<a class="headerlink" href="#34-run-the-first-sample" title="Permanent link">&para;</a></h3>
<p>After “<em>make all</em>”, you can get the images in <em>“na51090_linux_sdk/output”</em>. And to try the images, you can select the jumper setting in EVB to enter FW upgrade mode first, and then use the following tool “<em>FwUpgrade.exe</em>” to burn the images into the flash memory.</p>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image006.jpg" src="nvt_media/0b18db23c16d74408ff1e005cb30cb46.jpg" /></p>
<p>The all-in-one image (\na51090_linux_sdk\output\packed\FW98336A.bin) is packed by the description in \na51090_linux_sdk\configs\Linux\cfg_XXX\nvt-nvtpack.dtsi:</p>
<table>
<thead>
<tr>
<th>/*  * Novatek Ltd. BSP part of dts  */   \&amp;nand {   /**   * partition_name is \$1 as in partition_\$1 is referred   * to nvt-na51090-storage-partition. dtsi  */  nvtpack {  ver = &ldquo;NVTPACK_FW_INI_16072017&rdquo;; /* Fixed */  method = \&lt;1>; /* Fixed */  index {  id0 { partition_name = &ldquo;loader&rdquo;; source_file = &ldquo;&rdquo;; }; /* Fixed */  id1 { partition_name = &ldquo;fdt&rdquo;; source_file = &ldquo;nvt-all.bin&rdquo;; }; /* Fixed */  id2 { partition_name = &ldquo;fdt.restore&rdquo;; source_file = &ldquo;&rdquo;; }; /* Fixed */  id3 { partition_name = &ldquo;atf&rdquo;; source_file = &ldquo;atf.bin&rdquo;; };  id4 { partition_name = &ldquo;uboot&rdquo;; source_file = &ldquo;u-boot.bin&rdquo;; };  id5 { partition_name = &ldquo;uenv&rdquo;; source_file = &ldquo;&rdquo;; };  id6 { partition_name = &ldquo;kernel&rdquo;; source_file = &ldquo;Image.bin&rdquo;; };  id7 { partition_name = &ldquo;rootfs&rdquo;; source_file = &ldquo;rootfs.ramdisk.bin&rdquo;; };  id8 { partition_name = &ldquo;rootfs1&rdquo;; source_file = &ldquo;rootfs_1.rw.ubifs.bin&rdquo;; };  id9 { partition_name = &ldquo;app&rdquo;; source_file = &ldquo;DVR_16CH.nand.ubifs.bin&rdquo;; };  };  }; };</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>And the partition order must be the same as \na51090_linux_sdk\configs\Linux\cfg_XXX\nvt-storage-partition.dtsi.</p>
<p>After the upgrade is done, power on the target board, you can get the sample in the “<em>/mnt/mtd</em>” folder. And you can run the first sample code:</p>
<p><em>root@NVTEVM:/mnt/mtd\$ ./liveview_1div_to_4div</em></p>
<p><strong>Note: You may run the “display_with_change_mode” first to select your LCD resolution.</strong></p>
<p>The more sample codes are placed in “<em>na51090_linux_sdk/code/hdal/samples</em>”.</p>
<p>For more information about the firmware upgrade tool, you can refer to the document “<em>NT9833x_Quick_Bringup_User_Guide_en.pdf</em>”.</p>
<h2 id="4-boot-up-sequence">4 Boot-up Sequence<a class="headerlink" href="#4-boot-up-sequence" title="Permanent link">&para;</a></h2>
<h3 id="41-overview-of-booting-procedure">4.1 Overview of Booting Procedure<a class="headerlink" href="#41-overview-of-booting-procedure" title="Permanent link">&para;</a></h3>
<p>The following figure shows the booting sequence of NT9833x SDK. When the NT9833x system is powered on, the embedded ROM code is executed. The ROM code loads the loader code from the flash into the embedded SRAM and then executes the loader. The loader initializes DDR and loads FDT, ATF, OPTEE(optional) and uboot from the flash into DDR and jump into ATF. The ATF runs the arm trusted firmware and boot OPTEE(optional) and then jump into the uboot. The uboot initializes the basic hardware and loads linux image from the flash into DDR, and then bring up the linux kernel. Two stages during the linux bring up: the vg_boot.sh add the device modules into the linux kernel and the module_init initiates the external devices, such as AD, audio and the displayer.</p>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image007.jpg" src="nvt_media/f8ca21621e52c54d182bf2194b506ba3.jpg" /></p>
<h3 id="42-vg_bootsh">4.2 vg_boot.sh<a class="headerlink" href="#42-vg_bootsh" title="Permanent link">&para;</a></h3>
<p>The script file “vg_boot.sh”:</p>
<table>
<thead>
<tr>
<th>#boot_ver=v1.5 #chipver=`head -1 /proc/pmu/chipver` #chipid=`echo \$chipver | cut -c 1-4` echo ----------------------------------------------------------- echo &rdquo; Boot DVR_16CH&rdquo; echo ----------------------------------------------------------- echo &ldquo;/sbin/mdev&rdquo; > /proc/sys/kernel/hotplug   MODEL_PATH=\$(dirname \$MODEL) MODEL_NAME=&rdquo;\${MODEL_PATH##*/}&rdquo; AD_MODULE=&rdquo;techpoint&rdquo; echo This model is \$MODEL_NAME   modprobe nvt_dmasys modprobe log log_ksize=4096 crash_notify=/mnt/mtd/crash.sh #crash to execute /mnt/mtd/crash.sh echo /tmp > /proc/videograph/dumplog #change log path to /tmp   modprobe kdrv_cc_event modprobe ms max_channels=16 modprobe em max_channels=16   modprobe lcd_codec modprobe nvt_tve100 modprobe nvt_hdmi20 modprobe flcd300-common modprobe flcd300-pip gui_ddr=0 suspend_state=1  modprobe flcd300-pip1 gui_ddr=0 suspend_state=1 modprobe flcd200-common modprobe flcd200-pip gui_ddr=0 suspend_state=1     echo i2c 0x10011 > /proc/nvt_info/nvt_pinmux/pinmux_set ## [NT98336 SYS] 16CH, camera support to 1080P@30, 4M@15, 5M@10 #if [ &ldquo;\$AD_MODULE&rdquo; == &ldquo;techpoint&rdquo; ]; then  ## modprobe tp28xx_kdrv drv_mode=0 dev_num=2 ibus=0,1 iaddr=0x88,0x8a vout_mode=3,3 video_mux=1 vout_xcap=0x03040000,0x01020000 vout_vi=0x03040000,0x01020000 clk_dly=0x00000000,0x00000000 clk_inv=0x01010000,0x01010000 ch_map=2 clk_used=0x1 rstb_used=106 clk_driving=2  #else  ## modprobe nvp6158_kdrv drv_mode=0 dev_num=2 ibus=0,0 iaddr=0x60,0x62 vout_mode=4,4 vout_xcap=0x0201,0x0403 vout_vi=0x0201,0x0403 vout_cdly=0x0606,0x0606 clk_dly=0x0000,0x0000 clk_inv=0x0000,0x0000 ch_map=1 clk_used=0x1 rstb_used=106 clk_driving=2 #fi  modprobe tp28xx_kdrv dev_num=4 ibus=0,0,1,1 iaddr=0x88,0x8a,0x8c,0x8e vout_mode=3,3,3,3 video_mux=1 vout_xcap=0x0201,0x0304,0x0506,0x0708 vout_vi=0x0201,0x0304,0x0506,0x0708 vout_cdly=0x0300,0x0300,0x0300,0x0200 ch_map=1 clk_used=0xf clk_driving=2    modprobe vcap316_common modprobe vcap316_host0 sync_time_div=90   modprobe kdrv_vpe modprobe kflow_vpe mod_init=1 max_chip_num=1 max_eng_num=2 max_minor_num=127 max_md_lv_num=16 max_total_cam_ch=85 sw_bal_mode=1   modprobe nvt_audio modprobe kflow_audio   modprobe kdrv_dei modprobe kflow_dei max_chip_num=2 max_eng_num=1 max_minor_num=64 max_total_cam_ch=85   modprobe kdrv_jpg jpeg_enc_max_chn=53 jpeg_dec_max_chn=32 modprobe kdrv_venc h26x_enc_max_width=2560 h26x_enc_max_height=1440 max_total_cam_ch=53 modprobe nvt_vencrc modprobe kflow_videoenc modprobe h26xdec h26xd_max_width=2560 h26xd_max_height=1440 max_total_cam_ch=32 modprobe kflow_videodec   modprobe kdrv_osg modprobe kflow_osg modprobe kdrv_ssca modprobe kdrv_age modprobe kflow_gfx   modprobe kdrv_ai modprobe kflow_cnn modprobe kflow_nue modprobe kflow_nue2 modprobe kflow_cpu modprobe kflow_dsp modprobe kflow_ai_net   modprobe gs max_channels=16 modprobe usr_proc modprobe vpd quiet=0 max_channels=16 modprobe ddr_arb echo doing mdev-s mdev -s echo done!!   ## Syntax: module_init [dtb_file] [is_dump_dts] [is_init_videocap] [is_init_videoout] [is_init_audio] [is_show_logo] if [ &ldquo;\$AD_MODULE&rdquo; == &ldquo;techpoint&rdquo; ]; then  /mnt/mtd/module_init /mnt/mtd/cfg_DVR_16CH.dtb 0 1 1 1 0 &amp; else  /mnt/mtd/module_init /mnt/mtd/cfg_DVR_16CH.dtb 0 2 1 1 0 &amp; fi</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>The vg_boot.sh insert the device modules into the linux kernel and finally run the module_init program to initiate the video input/output. For more information about the parameters of the device module, please refer to <em>NT9833x_Module_Parameters_en.pdf</em>.</p>
<h3 id="43-module_initc">4.3 module_init.c<a class="headerlink" href="#43-module_initc" title="Permanent link">&para;</a></h3>
<p>The main functions of <em>module_init.c</em> are the buffer management and the external devices handling. The following figure shows the program flow of <em>module_init.c</em>.</p>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image008.jpg" src="nvt_media/e40f0842e2e684698f2781e4bca16f66.jpg" /></p>
<h4 id="431-memory-pool-setup">4.3.1 Memory Pool Setup<a class="headerlink" href="#431-memory-pool-setup" title="Permanent link">&para;</a></h4>
<p>9833x system memory placement descripts in the file <em>nvt-mem-tbl.dtsi</em>:</p>
<table>
<thead>
<tr>
<th>/* Linux system memory region*/ memory { device_type = &ldquo;memory&rdquo;; reg = \&lt;0x0 0x00000000 0x0 0x2FD00000>; /* [addr-H] [addr-L] [size-H] [size-L] */ };   hdal-memory {  #address-cells = \&lt;4>;  #size-cells = \&lt;2>;  media {  reg = \&lt; 0x0 0x0 0x0 0x2FD00000 0x0 0x10300000 /* DDR ID H, L ADDR H, L, SIZE H, L */  0x0 0x1 0x1 0x00000000 0x0 0x40000000 /* DDR ID H, L ADDR H, L, SIZE H, L */  >;  }; };   /* To config the nvt chip mapping relationship */ nvt_chip_mapping { #address-cells = \&lt;4>; #size-cells = \&lt;2>;  dram_map {  reg = \&lt;  0x0 0x0 0x0 0x00000000 0x0 0x40000000 /* DDR ID, CHIPID, ADDR H, L, SIZE H, L */  0x1 0x0 0x1 0x00000000 0x0 0x40000000 /* DDR ID, CHIPID, ADDR H, L, SIZE H, L */  >;  }; };</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>And about the memory pool placement in HDAL, you can use <em>DVR_XXX.xls</em> to calculate the pool size, and then copy the results into the <em>cfg_DVR_XXX.dts</em>.</p>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image009.jpg" src="nvt_media/573e479e7832824386719fc281441fd2.jpg" /></p>
<p>The HDAL memory is used in the HDAL and the module drivers. The following figure shows three scenarios for using the HDAL memory.</p>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image010.jpg" src="nvt_media/40d4ac5bb77f8e28e8743840a445abf4.jpg" /></p>
<p>The <em>assign_pool_addr()</em> in <em>module_init.c</em> will assign the physical address to each pool, and the memory placement will be as:</p>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image011.jpg" src="nvt_media/92a0f2d78ed97fdf0657aa7e36507ba6.jpg" /></p>
<h4 id="432-video-output-setup">4.3.2 Video Output Setup<a class="headerlink" href="#432-video-output-setup" title="Permanent link">&para;</a></h4>
<p>The <em>videoout0_setup()</em>, <em>videoout1_setup()</em> and <em>videoout2_setup()</em> setup the video output for HDMI/VGA/CVBS:</p>
<p>1. <em>hd_videoout_set(, HD_VIDEOOUT_PARAM_DEV_CONFIG, )</em> to setup the control parameters, such as the width, the height, the buffer address of the video plane and the GUI plane.</p>
<p>2. <em>hd_videoout_set(, HD_VIDEOOUT_PARAM_FB_FMT,)</em> to set the video format of the frame buffer of the plane.</p>
<p>3. <em>hd_videoout_set(, HD_VIDEOOUT_PARAM_FB_ENABLE, )</em> to enable the plane.</p>
<p>To set the video output for the same and different source, you can modify the <em>mode</em> and the <em>homology</em> parameters in the file <em>cfg_DVR_XXX.dts</em>.</p>
<table>
<thead>
<tr>
<th>HDMI and VGA are from the same source.</th>
<th>HDMI and VGA are from the different source.</th>
</tr>
</thead>
<tbody>
<tr>
<td>videoout0 {/*lcd300*/ mode = &ldquo;HD_COMMON_VIDEO_OUT_HDMI&rdquo;, … homology = &ldquo;HD_COMMON_VIDEO_OUT_VGA&rdquo;; … }</td>
<td>videoout0 {/*lcd300*/ mode = &ldquo;HD_COMMON_VIDEO_OUT_HDMI&rdquo;, … homology = &ldquo;&rdquo;; … } videoout1 {/*lcd300 lite*/ mode = &ldquo;HD_COMMON_VIDEO_OUT_VGA&rdquo;, … homology = &ldquo;&rdquo;; … }</td>
</tr>
</tbody>
</table>
<h4 id="433-video-input-setup">4.3.3 Video Input Setup<a class="headerlink" href="#433-video-input-setup" title="Permanent link">&para;</a></h4>
<p>The main procedure of the <em>videocap_module_init_tp()/videocap_module_init_nvp()</em> are as the following:</p>
<p>1. Initiate the AD device. For example, open <em>&ldquo;/dev/tp2823dev&rdquo;</em> device node.</p>
<table>
<thead>
<tr>
<th>ret = vendor_ad_init(ad_dev_name); if (ret != HD_OK) goto exit;</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2. Get the AD information, and organize this information as host, vi and channel information, and set them to the capture.</p>
<table>
<thead>
<tr>
<th>ret = vendor_ad_get(VENDOR_AD_PARAM_TP28XX_DEVICE_INFO, \&amp;dev_info); … /* vcap host init, to specify vcap system vi usage and prepare requirement memory */ memset(&amp;vcap_host, 0, sizeof(vcap_host)); vcap_host.host = 0;//only support 0 vcap_host.md.enable = dt_hdal_spec.vcap_host.md.enable; vcap_host.md.mb_x_num_max = dt_hdal_spec.vcap_host.md.mb_x_num_max; vcap_host.md.mb_y_num_max = dt_hdal_spec.vcap_host.md.mb_y_num_max; vcap_host.md.buf_src = dt_hdal_spec.vcap_host.md.buf_src; for (i = 0; i\&lt; dev_info.dev_num; i++) {  for(j = 0; j\&lt; VENDOR_AD_TP28XX_VOUT_MAX; j++) {  &hellip;  vcap_host.vi[vcap_host.nr_of_vi].chip = VENDOR_AD_PLAT_VI_TO_CHIP_ID(dev_info.dev[i].vout[j].vi - 1);  vcap_host.vi[vcap_host.nr_of_vi].vcap = VENDOR_AD_PLAT_VI_TO_CHIP_VCAP_ID(dev_info.dev[i].vout[j].vi - 1);  vcap_host.vi[vcap_host.nr_of_vi].vi = VENDOR_AD_PLAT_VI_TO_VCAP_VI_ID(dev_info.dev[i].vout[j].vi - 1);   &hellip;  } } &hellip; ret = hd_videocap_drv_set(HD_VIDEOCAP_DRV_PARAM_INIT_HOST, \&amp;vcap_host); &hellip; /* VCAP VI Register */ for (i=0; i\&lt;dev_info.dev_num; i++) {  for (j=0; j\&lt;VENDOR_AD_TP28XX_CHANNELS_PER_CHIP; j++) {  &hellip;  memset(&amp;vcap_vi, 0, sizeof(vcap_vi));  vcap_vi.chip = VENDOR_AD_PLAT_VI_TO_CHIP_ID(dev_info.dev[i].vout[j].vi - 1);  vcap_vi.vcap = VENDOR_AD_PLAT_VI_TO_CHIP_VCAP_ID(dev_info.dev[i].vout[j].vi - 1);  vcap_vi.vi = VENDOR_AD_PLAT_VI_TO_VCAP_VI_ID(dev_info.dev[i].vout[j].vi - 1);  vcap_vi.global.src = dev_info.dev[i].vout[j].xcap - 1;  vcap_vi.global.format = HD_VIDEOCAP_VI_FMT_BT656;  vcap_vi.global.id_extract = HD_VIDEOCAP_VI_CHID_EAV_SAV;  &hellip;  ret = hd_videocap_drv_set(HD_VIDEOCAP_DRV_PARAM_REGISTER_VI, \&amp;vcap_vi);  } } &hellip; /* VCH ID */ for (i=0; i\&lt;dev_info.dev_num; i++) {  for (j=0; j\&lt;VENDOR_AD_TP28XX_CHANNELS_PER_CHIP; j++) {  &hellip;  memset(&amp;ch_param, 0, sizeof(ch_param));  ch_param.chip = dev_info.dev[i].vin[j].chip;  ch_param.vcap = dev_info.dev[i].vin[j].vcap;  ch_param.vi = dev_info.dev[i].vin[j].vi;  ch_param.ch = dev_info.dev[i].vin[j].ch;  ch_param.value = dev_info.dev[i].vin[j].vch_id;  ch_param.pid = HD_VIDEOCAP_VI_CH_PARAM_VCH_ID;  &hellip;  ret = hd_videocap_drv_set(HD_VIDEOCAP_DRV_PARAM_VI_CH_PARAM, \&amp;ch_param);  } }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>3. Polling and notify the channel video norm switch.</p>
<table>
<thead>
<tr>
<th>ret = vendor_ad_get(VENDOR_AD_PARAM_TP28XX_VIDEO_NORM, \&amp;video_norm); &hellip; /* check video norm */ if (memcmp(&amp;video_norm, \&amp;p_init_info->g_ch_norm[i][j], sizeof(video_norm)) == 0)  goto chk_loss;   ch_norm.chip = dev_info.dev[i].vin[j].chip; ch_norm.vcap = dev_info.dev[i].vin[j].vcap; ch_norm.vi = dev_info.dev[i].vin[j].vi; &hellip; ret = hd_videocap_drv_set(HD_VIDEOCAP_DRV_PARAM_VI_CH_NORM3, \&amp;ch_norm); &hellip; memcpy(&amp;p_init_info->g_ch_norm[i][j], \&amp;video_norm, sizeof(video_norm));</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>4. Polling and notify the channel video loss.</p>
<table>
<thead>
<tr>
<th>ret = vendor_ad_get(VENDOR_AD_PARAM_TP28XX_VIDEO_LOSS, \&amp;ch_loss); &hellip; /* check video loss */ if (ch_loss.is_lost == p_init_info->g_ch_loss[i][j])  continue; ch_param.chip = dev_info.dev[i].vin[j].chip; ch_param.vcap = dev_info.dev[i].vin[j].vcap; ch_param.vi = dev_info.dev[i].vin[j].vi; ch_param.pid = HD_VIDEOCAP_VI_CH_PARAM_VLOS; &hellip; ret = hd_videocap_drv_set(HD_VIDEOCAP_DRV_PARAM_VI_CH_PARAM, \&amp;ch_param); &hellip; p_init_info->g_ch_loss[i][j] = ch_loss.is_lost;</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h2 id="5-hardware-device-abstraction-layer-hdal">5 Hardware Device Abstraction Layer (HDAL)<a class="headerlink" href="#5-hardware-device-abstraction-layer-hdal" title="Permanent link">&para;</a></h2>
<h3 id="51-concept">5.1 Concept<a class="headerlink" href="#51-concept" title="Permanent link">&para;</a></h3>
<p>HDAL is the acronym of Hardware Device Abstraction Layer. It replaces the part being occupied by HAL (Hardware Abstraction Layer) in existing SW Architecture for the device transparent from independent devices and platforms, including the product, IP Camera, DVR and NVR.</p>
<p>For the existing HAL, it is created in the Chip-dependent structure, therefore when the chip is changed to Novatek or others, the APIs of HAL have to be changed depending on the change of chip at times. It is the object of HDAL to replace HAL and perform the function using Chip-independent Common API. Moreover, by providing only the header of HDAL API to chip venders and letting them implement the contents by themselves, the Middleware developers can implement this even though they are not aware of technological details. That is the HDAL is the common modules with common reused APIs, there is vendor interfaces for the customization for the dependent appliance, like AI or image quality modules.</p>
<p>There are 2 types of modules, the streaming and utility modules. The streaming modules defined for audio input, video input, audio output, video output, audio encoder, video encoder, audio decoder, video decoder and video processing. The streaming module is the code to control the flow of video or audio content sent in compressed or raw form over the Internet or device. If the modules are not related with streaming, we called utility modules. That is to perform, like initialize the HDAL, graphics functions, debug functions and etc.</p>
<p>Streaming modules:</p>
<table>
<thead>
<tr>
<th>Module</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>HD_VIDEOCAP</td>
<td>As it is for the video input features, it performs the feature of informing the video input state information.</td>
</tr>
<tr>
<td>HD_VIDEOOUT</td>
<td>It performs the controlling related to Video output which is connected like to the Panel or HDMI and the Video Post controlling features</td>
</tr>
<tr>
<td>HD_VIDEOENC</td>
<td>It provides the APIs which can control the Video Encoder.</td>
</tr>
<tr>
<td>HD_VIDEODEC</td>
<td>It takes the charge of filtering the Video, Video Decoding and the feature of controlling video Decoder.</td>
</tr>
<tr>
<td>HD_VIDEOPROC</td>
<td>Being divided as the video processing feature separately, it is the API which sets the Resolution, Video Size and Video Position and performs the frame rate conversion feature. The main feature is video process controlling however, the features of which the video out are controlled separately should be performed by this instance.</td>
</tr>
<tr>
<td>HD_AUDIOCAP</td>
<td>As it is for the audio input features, it performs the feature of informing the audio input setting and state information.</td>
</tr>
<tr>
<td>HD_AUDIOOUT</td>
<td>It performs the auxiliary output features of Audio. The Audio auxiliary output refers like to Analog Audio output and HDMI digital output.</td>
</tr>
<tr>
<td>HD_AUDIOENC</td>
<td>It provides the APIs which can control the Audio Encoder.</td>
</tr>
<tr>
<td>HD_AUDIODEC</td>
<td>It takes the charge of Audio Decoding and the feature of controlling Audio Decoder flow and format.</td>
</tr>
</tbody>
</table>
<p>Utility modules:</p>
<table>
<thead>
<tr>
<th>Module</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>hd_gfx</td>
<td>In charge of functions related to Graphic plane.</td>
</tr>
<tr>
<td>hd_debug</td>
<td>In charge of debug function, like HDAL Debug Menu entry point.</td>
</tr>
<tr>
<td>hd_logger</td>
<td>Directive printf function to difference interfaces.</td>
</tr>
<tr>
<td>hd_util</td>
<td>Supplies utility function which could be used in HDAL such as key input, Print etc.</td>
</tr>
</tbody>
</table>
<p>Basic APIs:</p>
<table>
<thead>
<tr>
<th>API name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>hd_xxx_init()</td>
<td>Responsible for initializing the class, especially for the global setting. Generally it is Called only once at system initialization, or when memory state changes.</td>
</tr>
<tr>
<td>hd_xxx_uninit()</td>
<td>Responsible for un-initializing the global setting of the class. Generally it is Called only once at system un-initialization, or when memory state changes.</td>
</tr>
<tr>
<td>hd_xxx_open()</td>
<td>Responsible for opening an instance from the class. Generally it is Called after the class was initialized. The function is used to call for opening multiple instances.</td>
</tr>
<tr>
<td>hd_xxx_close()</td>
<td>Responsible for closing an instance of the class. Generally it is Called to close the instance setting. The instance will be removed after calling this function.</td>
</tr>
<tr>
<td>hd_xxx_bind()</td>
<td>Each Instance is called up when it is connected with fore-end or back-end of Instance. Generally, relevant Instance ID and front terminal Instance ID are used for input parameter, but for some instances, additional input parameter is needed.  Call for hd_xxx_bind() function is only valid under Disconnect status and if tried to Connect to change connection status without disconnecting at Bind status, Error will occur.</td>
</tr>
<tr>
<td>hd_xxx_unbind()</td>
<td>It is called up when unbind is required after each instance is connected. Since only the concerned instance’s ID will be given as parameter, the hd_xxx_unbind() disconnects the front and back connection as referring to the concerned Instance’s ID.</td>
</tr>
<tr>
<td>hd_xxx_get()</td>
<td>It is used upon taking the information of each Instance’s settings. This API is used when taking the previous setting information before calling up the hd_xxx_set() and then changing only the settings value to be changed. The using method will be displayed along with the hd_xxx_set() example.</td>
</tr>
<tr>
<td>hd_xxx_set()</td>
<td>It is used upon setting the information for each instance settings. There is the structure for the instance-wise setting information, in order to change the setting information, call the hd_xxx_get() to get the structure for the previous setting information and then change only the value which is wished to be changed and then call up the hd_xxx_set().  If the hd_xxx_get() is called up after calling up hd_xxx_init(), the settings value will be all entered in to the HD_INVALID. If the setting variable in the implementation part of the hd_xxx_set() is HD_INVALID, it should be implemented not to set the variable but to skip it.</td>
</tr>
</tbody>
</table>
<p>For more information, please refer to the document “<em>Novatek HDAL Programmer&rsquo;s Guide.pdf</em>”.</p>
<h3 id="52-sample-codes">5.2 Sample Codes<a class="headerlink" href="#52-sample-codes" title="Permanent link">&para;</a></h3>
<h4 id="521-encode">5.2.1 Encode<a class="headerlink" href="#521-encode" title="Permanent link">&para;</a></h4>
<p><strong>I. encode_with_nr.c</strong></p>
<p>Stream Flow:</p>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image012.jpg" src="nvt_media/d5b74ffb2aa37e99c1614be5ceb795c9.jpg" /></p>
<table>
<thead>
<tr>
<th>root@NVTEVM:\~\$ <strong>cat /proc/videograph/graph</strong> entity (jobs) pool name (done buffers/max buffers) ----------------------------------------------------------- vcap0_0_4_0 (4) (enc_cap_out_ddr0, &ndash;, &ndash;, &ndash;) (0/4)  ->*kflow_osg_0_0_10 (0) (enc_cap_out_ddr0, &ndash;, &ndash;, &ndash;) (0/0)  ->h26xenc_0_0_0 (0) (enc_out_ddr0, &ndash;, &ndash;, &ndash;) (0/4)  ->dataout_0_0_0 (0)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>Sample code flow:</p>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image013.png" src="nvt_media/2b56a44a0ce5ac5e18bbf296ec727dcd.png" /></p>
<p>1. Initiate the HDAL.</p>
<table>
<thead>
<tr>
<th>ret = hd_common_init(1); //the parameter is reserved for the future.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2. Initiate the capture and the encoder modules.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videocap_init()) != HD_OK) {  return ret; } if ((ret = hd_videoenc_init()) != HD_OK) {  return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>3. Open the capture and the encoder modules.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videocap_open(SAMPLE_VCAP_IN_ID, SAMPLE_VCAP_OUT_ID, \&amp;p_streams->cap0_path_id)) != HD_OK) {  return ret; } if ((ret = hd_videoenc_open(SAMPLE_VENC_IN_ID, SAMPLE_VENC_OUT_ID, \&amp;p_streams->enc0_path_id)) != HD_OK) {  return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>4. Initiate the video process, such as Noise Reduction.</p>
<table>
<thead>
<tr>
<th>ret = vendor_video_init(streams.videoenc_path); if (ret != HD_OK) {  goto exit; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>5. Set the capture configure and parameters. <strong>The data_pool (the buffer name is enc_cap_out_ddr0) is allocated from the HD_COMMON_MEM_ENC_CAP_OUT_POOL, the buffer size of the capture output is fixed and the counts/max_counts should not be larger than “YUV buffer count” in the “encode” sheet of DVR_xch.xls. Only one data_pool is valid for the capture, so data_pool[1\~3].mode must set to disable.</strong></p>
<table>
<thead>
<tr>
<th><em>//use HD_VIDEOCAP_PARAM_PATH_CONFIG to set the memory pool configure.</em> cap_config.data_pool[0].mode = HD_VIDEOCAP_POOL_ENABLE; cap_config.data_pool[0].ddr_id = SAMPLE_VCAP_DDR_ID; cap_config.data_pool[0].counts = HD_VIDEOCAP_SET_COUNT(4, 0); cap_config.data_pool[0].max_counts = HD_VIDEOCAP_SET_COUNT(4, 0);   cap_config.data_pool[1].mode = HD_VIDEOCAP_POOL_DISABLE; cap_config.data_pool[2].mode = HD_VIDEOCAP_POOL_DISABLE; cap_config.data_pool[3].mode = HD_VIDEOCAP_POOL_DISABLE;   ret = hd_videocap_set(cap_path_id, HD_VIDEOCAP_PARAM_PATH_CONFIG, \&amp;cap_config);   <em>//use HD_VIDEOCAP_PARAM_OUT to set the output dimension and the pixel format.</em> ret = hd_videocap_set(cap_path_id, HD_VIDEOCAP_PARAM_OUT, \&amp;cap_out);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>6. Set the encoder configure and parameters. <strong>The data_pool (the buffer name is enc_out_ddr0) is allocated from the HD_COMMON_MEM_ENC_OUT_POOL. And only one data_pool is valid for the encoder, so data_pool[1\~3].mode must set to disable.</strong></p>
<table>
<thead>
<tr>
<th><em>//use HD_VIDEOENC_PARAM_PATH_CONFIG to set the memory pool configure.</em> enc_config.data_pool[0].mode = HD_VIDEOENC_POOL_ENABLE; enc_config.data_pool[0].ddr_id = 0; enc_config.data_pool[0].counts = HD_VIDEOENC_SET_COUNT(4, 0); enc_config.data_pool[0].max_counts = HD_VIDEOENC_SET_COUNT(4, 0); enc_config.data_pool[1].mode = HD_VIDEOENC_POOL_DISABLE; enc_config.data_pool[2].mode = HD_VIDEOENC_POOL_DISABLE; enc_config.data_pool[3].mode = HD_VIDEOENC_POOL_DISABLE;   ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_PATH_CONFIG, \&amp;enc_config);   <em>//use HD_VIDEOENC_PARAM_IN to set the input dimension and the pixel format.</em> ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_IN, \&amp;video_in_param); <em>//use HD_VIDEOENC_PARAM_OUT_ENC_PARAM to set the parameters of the codec.</em> ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_OUT_ENC_PARAM, \&amp;enc_param); <em>//use HD_VIDEOENC_PARAM_OUT_RATE_CONTROL to set the parameters of the rate control.</em> ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_OUT_RATE_CONTROL, \&amp;rc_param);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>7. Bind the capture and the encoder modules, and then the stream will flow from the capture to the encoder.</p>
<table>
<thead>
<tr>
<th>ret = hd_videocap_bind(SAMPLE_VCAP_OUT_ID, SAMPLE_VENC_IN_ID); if (ret != HD_OK) {  printf(&ldquo;videocap bind fail\n&rdquo;);  goto exit; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>8. Start the capture and the encoder modules.</p>
<table>
<thead>
<tr>
<th>ret = hd_videocap_start(streams.cap0_path_id); if (ret != HD_OK) {  printf(&ldquo;start cap fail\n&rdquo;);  goto exit; } ret = hd_videoenc_start(streams.enc0_path_id); if (ret != HD_OK) {  printf(&ldquo;start enc fail\n&rdquo;);  goto exit; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>9. Create a thread to encode the stream from the capture. The main procedure in this thread is using the <em>hd_videoenc_poll_list()</em> API to check the stream is ready or not. If the stream is ready, use <em>hd_videoenc_recv_list()</em> API to receive it.</p>
<table>
<thead>
<tr>
<th>static void *encode_thread(void *arg) {  &hellip;  while (0 == p_streams->enc_exit) {  ret = hd_videoenc_poll_list(poll_list, MAX_BITSTREAM_NUM, 500);  &hellip;  if ((ret = hd_videoenc_recv_list(recv_list, MAX_BITSTREAM_NUM)) \&lt; 0) {  printf(&ldquo;Error return value %d\n&rdquo;, ret);  } else {  for (i = 0; i \&lt; MAX_BITSTREAM_NUM; i++) {  //process the receive the encoded bitstreams  }  }  }  &hellip; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>10. Wait the key press ‘q’ to exit the thread.</p>
<p>11. Stop the capture and the encoder modules.</p>
<table>
<thead>
<tr>
<th>if (HD_OK != hd_videocap_stop(streams.cap0_path_id)) {  printf(&ldquo;stop cap fail\n&rdquo;); } if (HD_OK != hd_videoenc_stop(streams.enc0_path_id)) {  printf(&ldquo;stop enc fail\n&rdquo;); }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>12. Unbind the capture and the encoder modules.</p>
<table>
<thead>
<tr>
<th>if (HD_OK != hd_videocap_unbind(SAMPLE_VCAP_OUT_ID)) {  printf(&ldquo;hd_videocap_unbind fail\n&rdquo;); }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>13. Close the capture and the encoder modules.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videocap_close(p_streams->cap0_path_id)) != HD_OK) {  return ret; } if ((ret = hd_videoenc_close(p_streams->enc0_path_id)) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>14. Un-initiate the capture and the encoder modules.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videocap_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoenc_uninit()) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>15. Un-initiate the HDAL.</p>
<table>
<thead>
<tr>
<th>ret = hd_common_uninit();</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p><strong>II. encode_with_osg.c</strong></p>
<p>Stream flow:</p>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image014.jpg" src="nvt_media/10c31dc9f9faf8fd10cfbc114f4fd154.jpg" /></p>
<table>
<thead>
<tr>
<th>root@NVTEVM:\~\$ <strong>cat /proc/videograph/graph</strong> entity (jobs) pool name (done buffers/max buffers) ----------------------------------------------------------- vcap0_0_4_0 (4) (enc_cap_out_ddr0, &ndash;, &ndash;, &ndash;) (0/4)  ->*kflow_osg_0_0_10 (0) (enc_cap_out_ddr0, &ndash;, &ndash;, &ndash;) (0/0)  ->h26xenc_0_0_0 (0) (enc_out_ddr0, &ndash;, &ndash;, &ndash;) (0/4)  ->dataout_0_0_0 (1)   root@NVTEVM:\~\$ <strong>cat /proc/hdal/flow</strong> &hellip;  hd_videoenc_set(IN_STAMP_IMG):  path_id(0x22008201)  pxlfmt(0x21101555) dim(400,100) ddr(0) pa(0x1655a000) hd_videoenc_set(IN_STAMP_ATTR):  path_id(0x22008201)  type(0) alpha(7) pos(0,0)  gcac_en(0) gcac_w(64) gcac_h(32)  pa(0x1655a000) ddr(0)  &hellip;</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>The sample code flow is the same as the “<em>encode_with_nr.c</em>”, except for the additional function of OSG.</p>
<p>1. Open the OSG stamp module.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videoenc_open(HD_VIDEOENC_IN(SAMPLE_VENC_DEV_ID, HD_STAMP(i)), SAMPLE_VENC_OUT_ID, \&amp;p_streams->stamp_path_id[i])) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2. Set the OSG parameters.</p>
<table>
<thead>
<tr>
<th><em>//use HD_VIDEOENC_PARAM_IN_STAMP_IMG to set OSG image dimension and the pixel format.</em> img.p_addr = p_stamp->pa; img.dim.w = p_stamp->dim.w; img.dim.h = p_stamp->dim.h; img.ddr_id = SAMPLE_STAMP_DDR_ID; img.fmt = HD_VIDEO_PXLFMT_ARGB1555; ret = hd_videoenc_set(stamp_path_id, HD_VIDEOENC_PARAM_IN_STAMP_IMG, \&amp;img);   <em>//use HD_VIDEOENC_PARAM_IN_STAMP_ATTR to set alpha, align, background dimension…</em> attr.align_type = HD_OSG_ALIGN_TYPE_TOP_LEFT; attr.alpha = ALPHA_100; attr.position.x = p_pos->x; attr.position.y = p_pos->y; attr.gcac_enable = 0; attr.gcac_blk_width = 64; attr.gcac_blk_height = 32; ret = hd_videoenc_set(stamp_path_id, HD_VIDEOENC_PARAM_IN_STAMP_ATTR, \&amp;attr);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>3. Start the OSG module. After starting the module, the OSG image will paste on the encoded stream.</p>
<table>
<thead>
<tr>
<th>ret = hd_videoenc_start(streams.stamp_path_id[idx]); if (ret != HD_OK) { printf(&ldquo;start enc stamp fail = %d\n&rdquo;, ret); goto exit; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>4. Run the <em>encode_thread()</em> and wait ‘q’ key to exit the program.</p>
<p>5. Stop the OSG module.</p>
<table>
<thead>
<tr>
<th>if (HD_OK != hd_videoenc_stop(streams.stamp_path_id[idx])) { printf(&ldquo;stop enc stamp [%ld] fail\n&rdquo;, idx); }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>6. Close the OSG stamp module.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videoenc_close(p_streams->stamp_path_id[i])) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p><strong>III. encode_with_mask.c</strong></p>
<p>Stream flow:</p>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image015.jpg" src="nvt_media/a418f1695cff2c02487cb0dd87d009d9.jpg" /></p>
<table>
<thead>
<tr>
<th>root@NVTEVM:\~\$ <strong>cat /proc/videograph/graph</strong> entity (jobs) pool name (done buffers/max buffers) ----------------------------------------------------------- vcap0_0_4_0 (4) (enc_cap_out_ddr0, &ndash;, &ndash;, &ndash;) (0/4)  ->*kflow_osg_0_0_10 (0) (enc_cap_out_ddr0, &ndash;, &ndash;, &ndash;) (0/0)  ->h26xenc_0_0_0 (0) (enc_out_ddr0, &ndash;, &ndash;, &ndash;) (0/4)  ->dataout_0_0_0 (1)   root@NVTEVM:\~\$ <strong>cat /proc/hdal/flow</strong> &hellip; hd_videoenc_set(IN_MASK_ATTR):  path_id(0x2200e201)  type(0x1) alpha(128) color(0)  pos0(0,0) pos1(64,0) pos2(64,32) pos3(0,32) hd_videoenc_start:  path_id(0x2200e201) &hellip; hd_videoenc_set(IN_MOSAIC_ATTR):  path_id(0x2200e601)  type(0x1) alpha(256) blk_wh(32,32)  pos0(240,135) pos1(368,135) pos2(368,263) pos3(240,263) hd_videoenc_start:  path_id(0x2200e601) &hellip;</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>The sample code flow is the same as the “<em>encode_with_nr.c</em>”, except for the additional functions of the capture mask and the encode mask.</p>
<p>1. Open the modules of the capture mask and the encode mask.</p>
<table>
<thead>
<tr>
<th><em>//Open the module of the capture make.</em> if ((ret = hd_videocap_open(SAMPLE_VCAP_IN_ID, HD_VIDEOCAP_OUT(SAMPLE_VCAP_DEV_ID, HD_MASK(i)), \&amp;p_streams->cap0_mask_path[i])) != HD_OK) { return ret; }   <em>//Open the module of the encoder make.</em> if ((ret = hd_videoenc_open(HD_VIDEOENC_IN(SAMPLE_VENC_DEV_ID, HD_MASK(i)), SAMPLE_VENC_OUT_ID, \&amp;p_streams->mask_mosaic_id[i])) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2. Set the parameters of the capture mask and the encode mask.</p>
<table>
<thead>
<tr>
<th><em>//use HD_VIDEOCAP_PARAM_OUT_MASK_ATTR to set the capture mask type, alpha, color, position…</em> HD_OSG_MASK_ATTR mask = {0}; mask.type = HD_OSG_MASK_TYPE_SOLID; mask.alpha = 255; mask.color = idx; mask.position[0].x = (idx % 2) * (p_dim->w / 2) + p_dim->w / 8; mask.position[0].y = (idx / 2) * (p_dim->h / 2); mask.position[1].x = mask.position[0].x + 64; mask.position[1].y = mask.position[0].y; mask.position[2].x = mask.position[1].x; mask.position[2].y = mask.position[1].y + 64; mask.position[3].x = mask.position[0].x; mask.position[3].y = mask.position[2].y; ret = hd_videocap_set(vcap_mask_path_id, HD_VIDEOCAP_PARAM_OUT_MASK_ATTR, \&amp;mask);   <em>//use HD_VIDEOENC_PARAM_IN_MASK_ATTR to set the encoder mask type, alpha, color, position…</em> HD_OSG_MASK_ATTR mask_attr = {0}; mask_attr.type = HD_OSG_MASK_TYPE_SOLID; mask_attr.color = idx; mask_attr.alpha = 128; //50% transparent mask_attr.position[0].x = (idx % 2) * (p_dim->w / 2); mask_attr.position[0].y = (idx / 2) * (p_dim->h / 2); mask_attr.position[1].x = mask_attr.position[0].x + (mask_w); mask_attr.position[1].y = mask_attr.position[0].y; mask_attr.position[2].x = mask_attr.position[1].x; mask_attr.position[2].y = mask_attr.position[1].y + (mask_h); mask_attr.position[3].x = mask_attr.position[2].x - (mask_w); mask_attr.position[3].y = mask_attr.position[2].y ; ret = hd_videoenc_set(mask_path_id, HD_VIDEOENC_PARAM_IN_MASK_ATTR, \&amp;mask_attr);   <em>//use HD_VIDEOENC_PARAM_IN_MOSAIC_ATTR to set the encoder mosaic type, alpha, background color, position…</em> HD_OSG_MOSAIC_ATTR mosaic_attr = {0}; mosaic_attr.type = HD_OSG_MASK_TYPE_SOLID; mosaic_attr.alpha = 256; //100% background mosaic_attr.mosaic_blk_w = mosaic_blk_w; mosaic_attr.mosaic_blk_h = mosaic_blk_h; mosaic_attr.position[0].x = (idx % 2) * (p_dim->w / 2) + (p_dim->w / 8) + 100; mosaic_attr.position[0].y = (idx / 2) * (p_dim->h / 2) + (p_dim->h / 8) + 100; mosaic_attr.position[1].x = mosaic_attr.position[0].x + (mosaic_blk_w)*4; mosaic_attr.position[1].y = mosaic_attr.position[0].y; mosaic_attr.position[2].x = mosaic_attr.position[1].x; mosaic_attr.position[2].y = mosaic_attr.position[1].y + (mosaic_blk_h)*4; mosaic_attr.position[3].x = mosaic_attr.position[2].x - (mosaic_blk_w)*4; mosaic_attr.position[3].y = mosaic_attr.position[2].y; ret = hd_videoenc_set(mosaic_path_id, HD_VIDEOENC_PARAM_IN_MOSAIC_ATTR, \&amp;mosaic_attr);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>3. Start the modules of the capture mask and the encode mask. After starting these modules, the mask images will paste on the encoded stream.</p>
<table>
<thead>
<tr>
<th><em>//Start the module of the capture make.</em> cur_path_id = p_path_id_list[mask_idx]; ret = hd_videocap_start(cur_path_id);   <em>//Start the module of the encoder make.</em> ret = hd_videoenc_start(p_path_id[idx]);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>4. Run the <em>encode_thread()</em> and wait ‘q’ key to exit the program. And you can press ‘e’ key to use <em>hd_videocap_start()</em>/<em>hd_videocap_stop()</em> to switch the capture mask to ON or OFF. And you can also press ‘y’ key to use <em>hd_videoenc_set()</em> to update the position of the encode mask, and then use <em>hd_videoenc_start()</em> to activate the new position parameters.</p>
<p>5. Stop the modules of the capture mask and the encode mask.</p>
<table>
<thead>
<tr>
<th><em>//Stop the module of the capture make.</em> if (HD_OK != hd_videocap_stop(streams.cap0_mask_path[mask_idx])) { printf(&ldquo;stop vcap mask [%d] fail\n&rdquo;, mask_idx); }   <em>//Stop the module of the encoder make.</em> if (HD_OK != hd_videoenc_stop(streams.mask_mosaic_id[mask_idx])) { printf(&ldquo;stop enc mask [%d] fail\n&rdquo;, mask_idx); }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>6. Close the modules of the capture mask and the encode mask.</p>
<table>
<thead>
<tr>
<th><em>//Close the module of the capture make.</em> if ((ret = hd_videocap_close(p_streams->cap0_mask_path[i])) != HD_OK) { return ret; }   <em>//Close the module of the encoder make.</em> if ((ret = hd_videoenc_close(p_streams->mask_mosaic_id[i])) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h4 id="522-liveview">5.2.2 Liveview<a class="headerlink" href="#522-liveview" title="Permanent link">&para;</a></h4>
<p>The stream flow of the sample code “<em>liveview_1div_to_4div.c</em>”:</p>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image016.jpg" src="nvt_media/e4105436efb74df58f16383ccf090878.jpg" /></p>
<table>
<thead>
<tr>
<th>root@NVTEVM:\~\$ <strong>cat /proc/videograph/graph</strong> entity (jobs) pool name (done buffers/max buffers) ----------------------------------------------------------- vcap0_0_4_0 (3) (disp0_cap_out_ddr0, &ndash;, &ndash;, &ndash;) (0/4)  ->kflow_vpe_0_0_0 (0) (disp0_in_ddr0, &ndash;, &ndash;, &ndash;) (0/3)  ->*kflow_osg_0_0_0 (0) (disp0_in_ddr0, &ndash;, &ndash;, &ndash;) (0/0)  ->lcd0vg_0_0_0 (2) vcap0_0_6_0 (3) (disp0_cap_out_ddr0, &ndash;, &ndash;, &ndash;) (0/4)  ->kflow_vpe_0_0_1 (0) (disp0_in_ddr0, &ndash;, &ndash;, &ndash;) (0/3) vcap0_0_0_0 (3) (disp0_cap_out_ddr0, &ndash;, &ndash;, &ndash;) (0/4)  ->kflow_vpe_0_0_2 (0) (disp0_in_ddr0, &ndash;, &ndash;, &ndash;) (0/3) vcap0_0_2_0 (3) (disp0_cap_out_ddr0, &ndash;, &ndash;, &ndash;) (0/4)  ->kflow_vpe_0_0_3 (0) (disp0_in_ddr0, &ndash;, &ndash;, &ndash;) (0/3)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>Sample code flow:</p>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image017.png" src="nvt_media/b7ad50db990302675cabbf7cf8c5f5fc.png" /></p>
<p>1. Initiate the HDAL.</p>
<table>
<thead>
<tr>
<th>ret = hd_common_init(1); //the parameter is reserved for the future.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2. Initiate the capture, the video process and the video out modules.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videocap_init()) != HD_OK) {  return ret; } if ((ret = hd_videoproc_init()) != HD_OK) { return ret; } if ((ret = hd_videoout_init()) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>3. Open the capture, the video process and the video out modules. <strong>HD_VIDEOOUT_OUT(0, 0) indicates the video output 0 (LCD300) and HD_VIDEOOUT_OUT(1, 0) indicates the video output 1 (LCD200). In cfg_DVR_xxx.dts, the default setting ‘videoout0…homology = &ldquo;HD_COMMON_VIDEO_OUT_VGA&rdquo;;’ of the HDMI and VGA are set to homology, it means HD_VIDEOOUT_OUT(0, 0) indicates to output to HDMI and VGA simultaneously.</strong> <em>HD_VIDEOOUT_0_CTRL</em> indicates the HDMI control, and we can use <em>hd_videoout_get()</em> to get LCD capability.</p>
<table>
<thead>
<tr>
<th>for (i = 0; i \&lt; SAMPLE_LV_COUNT; i++) { if((ret = hd_videocap_open(HD_VIDEOCAP_IN(i, 0), HD_VIDEOCAP_OUT(i, 0), \&amp;p_liveview_info->cap_path[i])) != HD_OK) return ret; if((ret = hd_videoproc_open(HD_VIDEOPROC_IN(i, 0), HD_VIDEOPROC_OUT(i, 0), \&amp;p_liveview_info->proc_path[i])) != HD_OK) return ret; if((ret = hd_videoout_open(HD_VIDEOOUT_IN(0, i), HD_VIDEOOUT_OUT(0, 0), \&amp;p_liveview_info->out_path[i])) != HD_OK) return ret; } if ((ret = hd_videoout_open(0, HD_VIDEOOUT_0_CTRL, \&amp;p_liveview_info->out_ctrl)) != HD_OK) return ret;</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>4. Set the capture configure and parameters. <strong>The data_pool (the buffer name is disp0_cap_out_ddr0) is allocated from the HD_COMMON_MEM_DISP0_CAP_OUT_POOL, the buffer size of the capture output is fixed and the counts/max_counts should not be larger than “Capture Count” in the “Display” sheet of DVR_xch.xls. Only one data_pool is valid for the capture, so data_pool[1\~3].mode must set to disable.</strong></p>
<table>
<thead>
<tr>
<th><em>//use HD_VIDEOCAP_PARAM_PATH_CONFIG to set the memory pool configure.</em> cap_config.data_pool[0].mode = HD_VIDEOCAP_POOL_ENABLE; cap_config.data_pool[0].ddr_id = 0; cap_config.data_pool[0].counts = HD_VIDEOCAP_SET_COUNT(4, 0); cap_config.data_pool[0].max_counts = HD_VIDEOCAP_SET_COUNT(4, 0); cap_config.data_pool[1].mode = HD_VIDEOCAP_POOL_DISABLE; cap_config.data_pool[2].mode = HD_VIDEOCAP_POOL_DISABLE; cap_config.data_pool[3].mode = HD_VIDEOCAP_POOL_DISABLE; ret = hd_videocap_set(liveview_info.cap_path[i], HD_VIDEOCAP_PARAM_PATH_CONFIG, \&amp;cap_config);   <em>//use HD_VIDEOCAP_PARAM_OUT to set the output dimension and the pixel format.</em> ret = hd_videocap_set(cap_path_id, HD_VIDEOCAP_PARAM_OUT, \&amp;cap_out);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p><strong>5.</strong> Set the video process configure and parameters. <strong>The data_pool (the buffer name is disp0_in_ddr0) is allocated from the HD_COMMON_MEM_DISPLAY_IN_POOL, the buffer size of the video process output is fixed and the counts/max_counts should not be larger than “Display Count” in the “Display” sheet of DVR_xch.xls. And only one data_pool is valid for the video process, so data_pool[1\~3].mode must set to disable.</strong></p>
<table>
<thead>
<tr>
<th><em>//use HD_VIDEOPROC_PARAM_DEV_CONFIG to set the memory pool configure.</em> vpe_config.data_pool[0].mode = HD_VIDEOPROC_POOL_ENABLE; vpe_config.data_pool[0].ddr_id = 0; vpe_config.data_pool[0].counts = HD_VIDEOPROC_SET_COUNT(3, 0); vpe_config.data_pool[0].max_counts = HD_VIDEOPROC_SET_COUNT(3, 0); vpe_config.data_pool[1].mode = HD_VIDEOPROC_POOL_DISABLE; vpe_config.data_pool[2].mode = HD_VIDEOPROC_POOL_DISABLE; vpe_config.data_pool[3].mode = HD_VIDEOPROC_POOL_DISABLE; ret = hd_videoproc_set(liveview_info.proc_path[i], HD_VIDEOPROC_PARAM_DEV_CONFIG, \&amp;vpe_config);   <em>//use HD_VIDEOPROC_PARAM_OUT to set the position, dimension, background dimension…</em> proc_out.rect.x = 0; proc_out.rect.y = 0; proc_out.rect.w = liveview_info.lcd_syscaps.input_dim.w; proc_out.rect.h = liveview_info.lcd_syscaps.input_dim.h; proc_out.bg.w = liveview_info.lcd_syscaps.input_dim.w; proc_out.bg.h = liveview_info.lcd_syscaps.input_dim.h; proc_out.pxlfmt = fb_fmt.fmt; proc_out.dir = HD_VIDEO_DIR_NONE; ret = hd_videoproc_set(liveview_info.proc_path[i], HD_VIDEOPROC_PARAM_OUT, \&amp;proc_out);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>6. Set the parameters of the video out module.</p>
<table>
<thead>
<tr>
<th><em>//use HD_VIDEOOUT_PARAM_IN_WIN_ATTR to set the position, dimension, and visible.</em> win.rect.x = 0; win.rect.y = 0; win.rect.w = liveview_info.lcd_syscaps.input_dim.w; win.rect.h = liveview_info.lcd_syscaps.input_dim.h; win.visible = 1; ret = hd_videoout_set(liveview_info.out_path[i], HD_VIDEOOUT_PARAM_IN_WIN_ATTR, \&amp;win);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>7. Bind the capture, the video process and the video out modules, and then the video stream will flow from the capture to the video out.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videocap_bind(HD_VIDEOCAP_OUT(i, 0), HD_VIDEOPROC_IN(i, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_bind(HD_VIDEOPROC_OUT(i, 0), HD_VIDEOOUT_IN(0, i))) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>8. Start the capture, the video process and the video out modules. The different between <em>hd_videoXXX_start_list()</em> and <em>hd_videoXXX_start()</em> is that <em>hd_videoXXX_start_list()</em> will start a “list” of XXX modules.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videocap_start_list(liveview_info.cap_path, SAMPLE_LV_COUNT)) != HD_OK) { return ret; } if ((ret = hd_videoproc_start_list(liveview_info.proc_path, SAMPLE_LV_COUNT)) != HD_OK) { return ret; } if ((ret = hd_videoout_start_list(liveview_info.out_path, SAMPLE_LV_COUNT)) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>9. After starting the modules, the video stream will flow from the capture module via the video process module to the video out module. If you press ‘y’ key, it will toggle single window and 2x2 grid windows by changing the parameters of the video process and the video out modules. And then use <em>hd_videoXXX_start_list()</em> to activate the new parameters.</p>
<p>10. Wait the key press ‘q’ to exit the thread.</p>
<p>11. Stop the capture, the video process and the video out modules.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videocap_stop_list(liveview_info.cap_path, SAMPLE_LV_COUNT)) != HD_OK) { return ret; } if ((ret = hd_videoproc_stop_list(liveview_info.proc_path, SAMPLE_LV_COUNT)) != HD_OK) { return ret; } if ((ret = hd_videoout_stop_list(liveview_info.out_path, SAMPLE_LV_COUNT)) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>12. Unbind the capture, the video process and the video out modules.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videocap_unbind(HD_VIDEOCAP_OUT(i, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_unbind(HD_VIDEOPROC_OUT(i, 0))) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>13. Close the capture, the video process and the video out modules.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videocap_close(liveview_info.cap_path[i])) != HD_OK) { return ret; } if ((ret = hd_videoproc_close(liveview_info.proc_path[i])) != HD_OK) { return ret; } if ((ret = hd_videoout_close(liveview_info.out_path[i])) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>14. Un-initiate the capture, the video process and the video out modules.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videocap_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoproc_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoout_uninit()) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>15. Un-initiate the HDAL.</p>
<table>
<thead>
<tr>
<th>ret = hd_common_uninit();</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h4 id="523-playback">5.2.3 Playback<a class="headerlink" href="#523-playback" title="Permanent link">&para;</a></h4>
<p>The stream flow of the sample code “<em>playback_1div_to_4div.c</em>”:</p>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image018.jpg" src="nvt_media/2847265d48d26eb03cdbfe6aaf47ec77.jpg" /></p>
<table>
<thead>
<tr>
<th>root@NVTEVM:\~\$ <strong>cat /proc/videograph/graph</strong> entity (jobs) pool name (done buffers/max buffers) ----------------------------------------------------------- datain_0_0_0 (1) (disp_dec_in_ddr0, &ndash;, &ndash;, &ndash;) (5/8)  ->decode_0_0_0 (1) (disp_dec_out_ddr0, disp_dec_out_ratio_ddr0, &ndash;, &ndash;) (2/3)  ->kflow_vpe_0_0_0 (0) (disp0_in_ddr0, &ndash;, &ndash;, &ndash;) (0/3)  ->*kflow_osg_0_0_0 (0) (disp0_in_ddr0, &ndash;, &ndash;, &ndash;) (0/0)  ->lcd0vg_0_0_0 (2) datain_0_0_1 (0) (disp_dec_in_ddr0, &ndash;, &ndash;, &ndash;) (5/8)  ->decode_0_0_1 (1) (disp_dec_out_ddr0, disp_dec_out_ratio_ddr0, &ndash;, &ndash;) (2/3)  ->kflow_vpe_0_0_1 (0) (disp0_in_ddr0, &ndash;, &ndash;, &ndash;) (0/3) datain_0_0_2 (0) (disp_dec_in_ddr0, &ndash;, &ndash;, &ndash;) (5/8)  ->decode_0_0_2 (1) (disp_dec_out_ddr0, disp_dec_out_ratio_ddr0, &ndash;, &ndash;) (2/3)  ->kflow_vpe_0_0_2 (0) (disp0_in_ddr0, &ndash;, &ndash;, &ndash;) (0/3) datain_0_0_3 (0) (disp_dec_in_ddr0, &ndash;, &ndash;, &ndash;) (5/8)  ->decode_0_0_3 (1) (disp_dec_out_ddr0, disp_dec_out_ratio_ddr0, &ndash;, &ndash;) (2/3)  ->kflow_vpe_0_0_3 (0) (disp0_in_ddr0, &ndash;, &ndash;, &ndash;) (0/3)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>Sample code flow:</p>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image019.png" src="nvt_media/1b32ed82a375f85adf158a1d245ca301.png" /></p>
<p>1. Initiate the HDAL.</p>
<table>
<thead>
<tr>
<th>ret = hd_common_init(1); //the parameter is reserved for the future.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2. Initiate the video decoder, the video process, the video out and the video encoder modules.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videodec_init()) != HD_OK) { return ret; } if ((ret = hd_videoproc_init()) != HD_OK) { return ret; } if ((ret = hd_videoout_init()) != HD_OK) { return ret; } if ((ret = hd_videoenc_init()) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>3. Open the video decoder, the video process, the video out and the video encoder modules. The video process 0 \~ (<em>MAX_BITSTREAM_NUM</em> – 1) are used for the bitstream decode to the video out, and the video process <em>MAX_BITSTREAM_NUM</em> is used for the bitstream decode to the video encoder for JPEG.</p>
<table>
<thead>
<tr>
<th>for (i = 0; i \&lt; MAX_BITSTREAM_NUM; i++) { if ((ret = hd_videodec_open(HD_VIDEODEC_IN(0, i), HD_VIDEODEC_OUT(0, i), \&amp;p_playback_info->video_dec[i])) != HD_OK) return ret; if ((ret = hd_videoproc_open(HD_VIDEOPROC_IN(i, 0), HD_VIDEOPROC_OUT(i, 0), \&amp;p_playback_info->video_proc[i])) != HD_OK) return ret; if ((ret = hd_videoout_open(HD_VIDEOOUT_IN(0, i), HD_VIDEOOUT_OUT(0, 0), \&amp;p_playback_info->video_out[i])) != HD_OK) return ret; } if ((ret = hd_videoproc_open(HD_VIDEOPROC_IN(MAX_BITSTREAM_NUM, 0), HD_VIDEOPROC_OUT(MAX_BITSTREAM_NUM, 0), \&amp;p_playback_info->video_proc[MAX_BITSTREAM_NUM])) != HD_OK) { return ret; } if ((ret = hd_videoenc_open(HD_VIDEOENC_0_IN_0, HD_VIDEOENC_0_OUT_0, \&amp;p_playback_info->video_enc)) != HD_OK) { return ret; } if ((ret = hd_videoout_open(0, HD_VIDEOOUT_0_CTRL, \&amp;p_playback_info->video_out_ctrl)) != HD_OK) //open this for device control return ret;</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p><strong>4.</strong> Set the decoder configure and parameters. <strong>The max_mem (the buffer name is disp_dec_in_ddr0) is allocated from the HD_COMMON_MEM_DISP_DEC_IN_POOL. Only two data_pool are valid for the decoder, so data_pool[2\~3].mode must set to disable. The first data_pool (the buffer name is disp_dec_out_ddr0) is allocated from the HD_COMMON_MEM_DISP_DEC_OUT_POOL, the counts/max_counts should not be larger than “YUV Buffer count” in the “decode” sheet of DVR_xch.xls. The second data_pool (the buffer name is disp_dec_out_ratio_ddr0) is allocated from the HD_COMMON_MEM_DISP_DEC_OUT_RATIO_POOL, the counts/max_counts should not be larger than “YUV Buffer count” in the “decode” sheet of DVR_xch.xls. While enable data_pool[1].mode, the decoder will output two different sizes of the frame, one is original size, the other is 1/4 of the original size (the decode ratio frame must set to 0.25 in the “decode” sheet of DVR_xch.xls.). The small size frame is used for the multi-grid display on LCD to reduce the VPE scaling bandwidth.</strong></p>
<table>
<thead>
<tr>
<th>dec_config.max_mem.dim.w = ALIGN_CEIL(playback_info.video_pattern[i].img_width); dec_config.max_mem.dim.h = ALIGN_CEIL(playback_info.video_pattern[i].img_height); dec_config.max_mem.frame_rate = playback_info.video_pattern[i].frame_rate; dec_config.max_mem.bs_counts = 8; dec_config.max_mem.codec_type = HD_CODEC_TYPE_H265; dec_config.max_mem.max_ref_num = 1;   dec_config.data_pool[0].mode = HD_VIDEODEC_POOL_ENABLE; dec_config.data_pool[0].ddr_id = 0; dec_config.data_pool[0].counts = HD_VIDEODEC_SET_COUNT(3, 0); dec_config.data_pool[0].max_counts = HD_VIDEODEC_SET_COUNT(3, 0); dec_config.data_pool[1].mode = HD_VIDEODEC_POOL_ENABLE; dec_config.data_pool[1].ddr_id = 0; dec_config.data_pool[1].counts = HD_VIDEODEC_SET_COUNT(3, 0); dec_config.data_pool[1].max_counts = HD_VIDEODEC_SET_COUNT(3, 0); dec_config.data_pool[2].mode = HD_VIDEODEC_POOL_DISABLE; dec_config.data_pool[3].mode = HD_VIDEODEC_POOL_DISABLE; ret = hd_videodec_set(playback_info.video_dec[i], HD_VIDEODEC_PARAM_PATH_CONFIG, \&amp;dec_config);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>5. Set the video process configure and parameters.</p>
<table>
<thead>
<tr>
<th><em>//use HD_VIDEOPROC_PARAM_DEV_CONFIG to set the memory pool configure.</em> vpe_config.data_pool[0].mode = HD_VIDEOPROC_POOL_ENABLE; vpe_config.data_pool[0].ddr_id = 0; vpe_config.data_pool[0].counts = HD_VIDEOPROC_SET_COUNT(3, 0); vpe_config.data_pool[0].max_counts = HD_VIDEOPROC_SET_COUNT(3, 0); vpe_config.data_pool[1].mode = HD_VIDEOPROC_POOL_DISABLE; vpe_config.data_pool[2].mode = HD_VIDEOPROC_POOL_DISABLE; vpe_config.data_pool[3].mode = HD_VIDEOPROC_POOL_DISABLE; ret = hd_videoproc_set(playback_info.video_proc[i], HD_VIDEOPROC_PARAM_DEV_CONFIG, \&amp;vpe_config);   <em>//use HD_VIDEOPROC_PARAM_OUT to set the position, dimension, background dimension…</em> proc_out.rect.x = 0; proc_out.rect.y = 0; proc_out.rect.w = playback_info.lcd_syscaps.input_dim.w; proc_out.rect.h = playback_info.lcd_syscaps.input_dim.h; proc_out.bg.w = playback_info.lcd_syscaps.input_dim.w; proc_out.bg.h = playback_info.lcd_syscaps.input_dim.h; proc_out.pxlfmt = fb_fmt.fmt; proc_out.dir = HD_VIDEO_DIR_NONE; ret = hd_videoproc_set(playback_info.video_proc[i], HD_VIDEOPROC_PARAM_OUT, \&amp;proc_out);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>6. Set the parameters of the video out module.</p>
<table>
<thead>
<tr>
<th><em>//use HD_VIDEOOUT_PARAM_IN_WIN_ATTR to set the position, dimension, and visible.</em> win.rect.x = 0; win.rect.y = 0; win.rect.w = playback_info.lcd_syscaps.input_dim.w; win.rect.h = playback_info.lcd_syscaps.input_dim.h; win.visible = 1; ret = hd_videoout_set(playback_info.video_out[i], HD_VIDEOOUT_PARAM_IN_WIN_ATTR, \&amp;win);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>7. Set the encoder parameters.</p>
<table>
<thead>
<tr>
<th><em>//use HD_VIDEOENC_PARAM_IN to set the input dimension and the pixel format.</em> ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_IN, \&amp;video_in_param); <em>//use HD_VIDEOENC_PARAM_OUT_ENC_PARAM to set the parameters of the codec.</em> ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_OUT_ENC_PARAM, \&amp;enc_param); <em>//use HD_VIDEOENC_PARAM_OUT_RATE_CONTROL to set the parameters of the rate control.</em> ret = hd_videoenc_set(enc_path_id, HD_VIDEOENC_PARAM_OUT_RATE_CONTROL, \&amp;rc_param);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>8. Bind the video decoder, the video process and the video out modules, and then the video stream will flow from the decoder to the video out.</p>
<table>
<thead>
<tr>
<th>for (i = 0; i \&lt; MAX_BITSTREAM_NUM; i++) { if ((ret = hd_videodec_bind(HD_VIDEODEC_OUT(0, i), HD_VIDEOPROC_IN(i, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_bind(HD_VIDEOPROC_OUT(i, 0), HD_VIDEOOUT_IN(0, i))) != HD_OK) { return ret; } }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>9. Start the video decoder, the video process and the video out modules.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videodec_start_list(playback_info.video_dec, MAX_BITSTREAM_NUM)) != HD_OK) { return ret; } if ((ret = hd_videoproc_start_list(playback_info.video_proc, MAX_BITSTREAM_NUM)) != HD_OK) { return ret; } if ((ret = hd_videoout_start_list(playback_info.video_out, MAX_BITSTREAM_NUM)) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>10. Create a thread to read the h.265 bitstream files, and then uses <em>hd_videodec_send_list()</em> to send the bitstream to the decode module. The YUV output from the decode module will flow to the video out module via the video process module.</p>
<table>
<thead>
<tr>
<th>static void *playback_thread(void *arg) {  &hellip;  while (1) {  &hellip;  fread(data[ch], 1, length, bs_fd[ch]);  video_bs[ch].path_id = playback_info->video_dec[ch]; video_bs[ch].user_bs.p_bs_buf = data[ch]; video_bs[ch].user_bs.bs_buf_size = length; … hd_videodec_send_list(video_bs, MAX_BITSTREAM_NUM, 1000); …  }  &hellip; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>11. If you press ‘y’ key, it will toggle single window and 2x2 grid windows by changing the parameters of the video process and the video out modules.</p>
<p>12. If you press ‘p’ key, it will snapshot one JPEG file. <strong>This sample will demo how to use the push/pull APIs to scale and encode a single frame.</strong> Compare with the binding mode, this single mode must prepare the input/output buffer of the modules first.</p>
<table>
<thead>
<tr>
<th>HD_RESULT pull_decout_and_scale_jpg(VIDEO_PLAYBACK playback_info, int enc_num) {  …  <em>// Pull out the output buffer of the decoder module</em> ret = hd_videodec_pull_out_buf(dec_path_id, \&amp;out_buffer, 500); … <em>// prepare the input buffer of the video process for scaling</em>  scale_in_va = (UINT32)hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_NONCACHE, scale_in_pa, scale_in_blk_size); … <em>// set the crop input parameters of the video process</em> ret = hd_videoproc_set(proc_path_id, HD_VIDEOPROC_PARAM_IN_CROP, (void *)&amp;crop); … <em>// set the output parameters of the video process</em> ret = hd_videoproc_set(proc_path_id, HD_VIDEOPROC_PARAM_OUT, (void *)&amp;out); … <em>// Push the decode output buffer into the video process module</em> scale_out_va = (UINT32)hd_common_mem_mmap(HD_COMMON_MEM_MEM_TYPE_NONCACHE, scale_out_pa, scale_out_blk_size); scale_in_buffer.phy_addr[0] = scale_in_pa; scale_out_buffer.phy_addr[0] = scale_out_pa; ret = hd_videoproc_push_in_buf(proc_path_id, \&amp;scale_in_buffer, \&amp;scale_out_buffer, 500);  …   <em>// Pull out the output buffer of the video process module</em> ret = hd_videoproc_pull_out_buf(proc_path_id, \&amp;scale_out_buffer, 500); … <em>// Push the video process output buffer into the encode module</em> ret = hd_videoenc_push_in_buf(videoenc_path_id, \&amp;enc_in_buffer.frame, &amp;(bs_out_buffer.bs), 500);  …   <em>// pull out the output buffer of the encode module</em> ret = hd_videoenc_pull_out_buf(videoenc_path_id, \&amp;video_bitstream, 500); <em>// save to the JPEG file</em> fwrite(bs_out_buffer.va, 1, video_bitstream.video_pack[0].size, bs_file);  … }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>13. Wait the key press ‘q’ to exit the thread.</p>
<p>14. Stop the video decoder, the video process and the video out modules.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videodec_stop_list(playback_info.video_dec, MAX_BITSTREAM_NUM)) != HD_OK) { return ret; } if ((ret = hd_videoproc_stop_list(playback_info.video_proc, MAX_BITSTREAM_NUM)) != HD_OK) { return ret; } if ((ret = hd_videoout_stop_list(playback_info.video_out, MAX_BITSTREAM_NUM)) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>15. Unbind the video decoder, the video process and the video out modules.</p>
<table>
<thead>
<tr>
<th>for (i = 0; i \&lt; MAX_BITSTREAM_NUM; i++) { if ((ret = hd_videodec_unbind(HD_VIDEODEC_OUT(0, i))) != HD_OK) { return ret; } if ((ret = hd_videoproc_unbind(HD_VIDEOPROC_OUT(i, 0))) != HD_OK) { return ret; } }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>16. Close the video decoder, the video process, the video out and the video encoder modules.</p>
<table>
<thead>
<tr>
<th>for (i = 0; i \&lt; MAX_BITSTREAM_NUM; i++) { if ((ret = hd_videodec_close(p_playback_info.video_dec[i])) != HD_OK) { return ret; } if ((ret = hd_videoproc_close(p_playback_info.video_proc[i])) != HD_OK) { return ret; } if ((ret = hd_videoout_close(p_playback_info.video_out[i])) != HD_OK) { return ret; } } if ((ret = hd_videoproc_close(p_playback_info.video_proc[MAX_BITSTREAM_NUM])) != HD_OK) { return ret; } if ((ret = hd_videoenc_close(p_playback_info.video_enc)) != HD_OK) { return ret; } if ((ret = hd_videoout_close(p_playback_info.video_out_ctrl)) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>17. Un-initiate the video decoder, the video process, the video out and the video encoder modules.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videodec_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoproc_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoout_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoenc_uninit()) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>18. Un-initiate the HDAL.</p>
<table>
<thead>
<tr>
<th>ret = hd_common_uninit();</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h4 id="524-display-to-encode">5.2.4 Display to Encode<a class="headerlink" href="#524-display-to-encode" title="Permanent link">&para;</a></h4>
<p>The stream flow of the sample code “<em>display_to_encode.c</em>”:</p>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image020.jpg" src="nvt_media/93da28623f522226620b04df9d2534f0.jpg" /></p>
<table>
<thead>
<tr>
<th>root@NVTEVM:\~\$ <strong>cat /proc/videograph/graph</strong> entity (jobs) pool name (done buffers/max buffers) ----------------------------------------------------------- vcap0_0_4_0 (2) (disp0_cap_out_ddr0, &ndash;, &ndash;, &ndash;) (1/4)  ->kflow_vpe_0_0_0 (0) (disp0_in_ddr0, &ndash;, &ndash;, &ndash;) (0/3)  ->*kflow_osg_0_0_0 (0) (disp0_in_ddr0, &ndash;, &ndash;, &ndash;) (0/0)  ->lcd0vg_0_0_0 (2)  ->kflow_vpe_0_0_4 (0) (enc_scl_out_ddr0, &ndash;, &ndash;, &ndash;) (0/4)  ->*kflow_osg_0_0_10 (0)(enc_scl_out_ddr0, &ndash;, &ndash;, &ndash;) (0/0)  ->h26xenc_0_0_0 (0) (enc_out_ddr0, &ndash;, &ndash;, &ndash;) (0/4)  ->dataout_0_0_0 (1) vcap0_0_6_0 (3) (disp0_cap_out_ddr0, &ndash;, &ndash;, &ndash;) (0/4)  ->kflow_vpe_0_0_1 (0) (disp0_in_ddr0, &ndash;, &ndash;, &ndash;) (0/3) vcap0_0_0_0 (3) (disp0_cap_out_ddr0, &ndash;, &ndash;, &ndash;) (0/4)  ->kflow_vpe_0_0_2 (0) (disp0_in_ddr0, &ndash;, &ndash;, &ndash;) (0/3) vcap0_0_2_0 (3) (disp0_cap_out_ddr0, &ndash;, &ndash;, &ndash;) (0/4)  ->kflow_vpe_0_0_3 (0) (disp0_in_ddr0, &ndash;, &ndash;, &ndash;) (0/3)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>Sample code flow:</p>
<p><img alt="D:\work6\636\fhtml\NT9833x_DVR_NVR_SDK_Quick_Start.files\image021.png" src="nvt_media/7c4e05717ecfc666ba5a57c10dd67a7b.png" /></p>
<p>1. Initiate the HDAL.</p>
<table>
<thead>
<tr>
<th>ret = hd_common_init(1); //the parameter is reserved for the future.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2. Initiate the capture, the video process, the video out and the video encoder modules.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videocap_init()) != HD_OK) { return ret; } if ((ret = hd_videoproc_init()) != HD_OK) { return ret; } if ((ret = hd_videoout_init()) != HD_OK) { return ret; } if ((ret = hd_videoenc_init()) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>3. Open the capture, the video process, the video out and the video encoder modules. 0 \~ (<em>MAX_BITSTREAM_NUM</em> – 1) modules are used for capturing the video frames and display on LCD, and <em>MAX_BITSTREAM_NUM</em> modules are used for encoding the video out to be as h.265 file.</p>
<table>
<thead>
<tr>
<th>for (i = 0; i \&lt; MAX_VI_NU; i++) { if((ret = hd_videocap_open(HD_VIDEOCAP_IN(i, 0), HD_VIDEOCAP_OUT(i, 0), \&amp;p_disp_to_enc->video_cap[i])) != HD_OK) return ret; if((ret = hd_videoproc_open(HD_VIDEOPROC_IN(i, 0), HD_VIDEOPROC_OUT(i, 0), \&amp;p_disp_to_enc->video_proc[i])) != HD_OK) return ret; if((ret = hd_videoout_open(HD_VIDEOOUT_IN(p_disp_to_enc->lcd_devid, i), HD_VIDEOOUT_OUT(p_disp_to_enc->lcd_devid, 0), \&amp;p_disp_to_enc->video_out[i])) != HD_OK) return ret; } if ((ret = hd_videoproc_open(HD_VIDEOPROC_IN(i, 0), HD_VIDEOPROC_OUT(i, 0), \&amp;p_disp_to_enc->vpe_path[0])) != HD_OK) { return ret; } if ((ret = hd_videoenc_open(HD_VIDEOENC_IN(0, 0), HD_VIDEOENC_OUT(0, 0), \&amp;p_disp_to_enc->enc_path[0])) != HD_OK) { return ret; } if ((ret = hd_videoout_open(0, HD_VIDEOOUT_CTRL(p_disp_to_enc->lcd_devid), \&amp;p_disp_to_enc->video_out_ctrl)) != HD_OK) //open this for device control return ret;</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>4. Set the capture configure and parameters.</p>
<table>
<thead>
<tr>
<th><em>//use HD_VIDEOCAP_PARAM_PATH_CONFIG to set the memory pool configure.</em> cap_config.data_pool[0].mode = HD_VIDEOCAP_POOL_ENABLE; cap_config.data_pool[0].ddr_id = SAMPLE_VCAP_DDR_ID; cap_config.data_pool[0].counts = HD_VIDEOCAP_SET_COUNT(4, 0); cap_config.data_pool[0].max_counts = HD_VIDEOCAP_SET_COUNT(4, 0); cap_config.data_pool[1].mode = HD_VIDEOCAP_POOL_DISABLE; cap_config.data_pool[2].mode = HD_VIDEOCAP_POOL_DISABLE; cap_config.data_pool[3].mode = HD_VIDEOCAP_POOL_DISABLE;   ret = hd_videocap_set(cap_path_id, HD_VIDEOCAP_PARAM_PATH_CONFIG, \&amp;cap_config);   <em>//use HD_VIDEOCAP_PARAM_OUT to set the output dimension and the pixel format.</em> ret = hd_videocap_set(cap_path_id, HD_VIDEOCAP_PARAM_OUT, \&amp;cap_out);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>5. Set the video process configure and parameters.</p>
<table>
<thead>
<tr>
<th><em>//use HD_VIDEOPROC_PARAM_DEV_CONFIG to set the memory pool configure.</em> vpe_config.data_pool[0].mode = HD_VIDEOPROC_POOL_ENABLE; vpe_config.data_pool[0].ddr_id = 0; vpe_config.data_pool[0].counts = HD_VIDEOPROC_SET_COUNT(3, 0); vpe_config.data_pool[0].max_counts = HD_VIDEOPROC_SET_COUNT(3, 0); vpe_config.data_pool[1].mode = HD_VIDEOPROC_POOL_DISABLE; vpe_config.data_pool[2].mode = HD_VIDEOPROC_POOL_DISABLE; vpe_config.data_pool[3].mode = HD_VIDEOPROC_POOL_DISABLE; ret = hd_videoproc_set(p_disp_to_enc->video_proc[i], HD_VIDEOPROC_PARAM_DEV_CONFIG, \&amp;vpe_config);   <em>//use HD_VIDEOPROC_PARAM_OUT to set the position, dimension, background dimension…</em> ret = hd_videoproc_set(playback_info.video_proc[i], HD_VIDEOPROC_PARAM_OUT, \&amp;proc_out);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>6. Set the parameters of the video out module.</p>
<table>
<thead>
<tr>
<th><em>//use HD_VIDEOOUT_PARAM_IN_WIN_ATTR to set the position, dimension, and visible.</em> win.rect.x = (i % 2) * (p_disp_to_enc->lcd_syscaps.input_dim.w / 2); win.rect.y = (i / 2) * (p_disp_to_enc->lcd_syscaps.input_dim.h / 2); win.rect.w = (p_disp_to_enc->lcd_syscaps.input_dim.w / 2); win.rect.h = (p_disp_to_enc->lcd_syscaps.input_dim.h / 2); win.visible = 1; ret = hd_videoout_set(p_disp_to_enc->video_out[i], HD_VIDEOOUT_PARAM_IN_WIN_ATTR, \&amp;win);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>7. Set the encoder parameters.</p>
<table>
<thead>
<tr>
<th><em>//use HD_VIDEOENC_PARAM_IN to set the input dimension and the pixel format.</em> ret = hd_videoenc_set(p_disp_to_enc->enc_path[0], HD_VIDEOENC_PARAM_IN, \&amp;video_in_param); <em>//use HD_VIDEOENC_PARAM_OUT_ENC_PARAM to set the parameters of the codec.</em> ret = hd_videoenc_set(p_disp_to_enc->enc_path[0], HD_VIDEOENC_PARAM_OUT_ENC_PARAM, \&amp;enc_param); <em>//use HD_VIDEOENC_PARAM_OUT_RATE_CONTROL to set the parameters of the rate control.</em> ret = hd_videoenc_set(p_disp_to_enc->enc_path[0], HD_VIDEOENC_PARAM_OUT_RATE_CONTROL, \&amp;rc_param);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>8. First, bind the capture, the video process and the video out modules, and then the video stream will flow from the capture to the video out. Second, bind the video out, the video process and the video encoder modules, and then the video stream will flow from the video out to the video encoder module.</p>
<table>
<thead>
<tr>
<th>for (i = 0; i \&lt; MAX_VI_NU; i++) { if ((ret = hd_videocap_bind(HD_VIDEOCAP_OUT(i, 0), HD_VIDEOPROC_IN(i, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_bind(HD_VIDEOPROC_OUT(i, 0), HD_VIDEOOUT_IN(p_disp_to_enc->lcd_devid, i))) != HD_OK) { return ret; } }   //connect liveview to encode if ((ret = hd_videoout_bind(HD_VIDEOOUT_OUT(p_disp_to_enc->lcd_devid, 0), HD_VIDEOPROC_IN(i, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_bind(HD_VIDEOPROC_OUT(i, 0), HD_VIDEOENC_IN(0, 0))) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>9. Start the capture, the video process, the video out and the video encoder modules.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videocap_start_list(p_disp_to_enc->video_cap, MAX_VI_NU)) != HD_OK) { return ret; }   if ((ret = hd_videoproc_start_list(p_disp_to_enc->video_proc, MAX_VI_NU)) != HD_OK) { return ret; }   if ((ret = hd_videoout_start_list(p_disp_to_enc->video_out, MAX_VI_NU)) != HD_OK) { return ret; } if ((ret = hd_videoproc_start_list(p_disp_to_enc->vpe_path, 1)) != HD_OK) { return ret; }   if ((ret = hd_videoenc_start_list(p_disp_to_enc->enc_path, 1)) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>10. Create a thread to encode the stream from the video output. The main procedure in this thread is using the <em>hd_videoenc_poll_list()</em> API to check the stream is ready or not. If the stream is ready, use <em>hd_videoenc_recv_list()</em> API to receive it.</p>
<table>
<thead>
<tr>
<th>static void *encode_thread(void *arg) {  &hellip;  while (p_disp_to_enc->enc_exit == 0) { //check bitstream status before receiving ret = hd_videoenc_poll_list(poll_list, MAX_BITSTREAM_NUM, 500);  &hellip;  if ((ret = hd_videoenc_recv_list(recv_list, MAX_BITSTREAM_NUM)) \&lt; 0) { printf(&ldquo;Error return value %d\n&rdquo;, ret); } else { for (i = 0; i \&lt; MAX_BITSTREAM_NUM; i++) {  //Write the receive the encoded bitstreams to file  }  }  }  &hellip;</th>
</tr>
</thead>
<tbody>
<tr>
<td>}</td>
</tr>
</tbody>
</table>
<p>11. Wait the key press ‘q’ to exit the thread.</p>
<p>12. Stop the capture, the video process, the video out and the video encoder modules.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videocap_stop_list(p_disp_to_enc->video_cap, MAX_VI_NU)) != HD_OK) { return ret; } if ((ret = hd_videoproc_stop_list(p_disp_to_enc->video_proc, MAX_VI_NU)) != HD_OK) { return ret; } if ((ret = hd_videoout_stop_list(p_disp_to_enc->video_out, MAX_VI_NU)) != HD_OK) { return ret; } if ((ret = hd_videoproc_stop_list(p_disp_to_enc->vpe_path, 1)) != HD_OK) { return ret; } if ((ret = hd_videoenc_stop_list(p_disp_to_enc->enc_path, 1)) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>13. Unbind the capture and the encoder modules.</p>
<table>
<thead>
<tr>
<th>for (i = 0; i \&lt; MAX_VI_NU; i++) { if ((ret = hd_videocap_unbind(HD_VIDEOCAP_OUT(i, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_unbind(HD_VIDEOPROC_OUT(i, 0))) != HD_OK) { return ret; } } if ((ret = hd_videoout_unbind(HD_VIDEOOUT_OUT(p_disp_to_enc->lcd_devid, 0))) != HD_OK) { return ret; } if ((ret = hd_videoproc_unbind(HD_VIDEOPROC_OUT(i, 0))) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>14. Close the capture, the video process, the video out and the video encoder modules.</p>
<table>
<thead>
<tr>
<th>for (i = 0; i \&lt; MAX_VI_NU; i++) { if ((ret = hd_videocap_close(p_disp_to_enc->video_cap[i])) != HD_OK) { return ret; } if ((ret = hd_videoproc_close(p_disp_to_enc->video_proc[i])) != HD_OK) { return ret; } if ((ret = hd_videoout_close(p_disp_to_enc->video_out[i])) != HD_OK) { return ret; } } if ((ret = hd_videoproc_close(p_disp_to_enc->vpe_path[0])) != HD_OK) { return ret; } if ((ret = hd_videoenc_close(p_disp_to_enc->enc_path[0])) != HD_OK) { return ret; } if ((ret = hd_videoout_close(p_disp_to_enc->video_out_ctrl)) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>15. Un-initiate the capture, the video process, the video out and the video encoder modules.</p>
<table>
<thead>
<tr>
<th>if ((ret = hd_videocap_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoproc_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoout_uninit()) != HD_OK) { return ret; } if ((ret = hd_videoenc_uninit()) != HD_OK) { return ret; }</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>16. Un-initiate the HDAL.</p>
<table>
<thead>
<tr>
<th>ret = hd_common_uninit();</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h2 id="6-appendix">6 Appendix<a class="headerlink" href="#6-appendix" title="Permanent link">&para;</a></h2>
<h3 id="61-video-format">6.1 Video Format<a class="headerlink" href="#61-video-format" title="Permanent link">&para;</a></h3>
<p>The following table lists the available video formats for the video path and HDAL APIs.</p>
<table>
<thead>
<tr>
<th><strong>Path/APIs</strong></th>
<th><strong>Available Video Format (HD_VIDEO_PXLFMT_XXX)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>VCAP_OUT</td>
<td>YUV422_ONE, YUV420</td>
</tr>
<tr>
<td>VCAP_OUT (compress mode)</td>
<td>YUV420_NVX3, YUV422_NVX3</td>
</tr>
<tr>
<td>VOUT_IN</td>
<td>YUV420, YUV422_ONE</td>
</tr>
<tr>
<td>VOUT_IN (compress mode)</td>
<td>YUV420_NVX3, YUV422_NVX3</td>
</tr>
<tr>
<td>VPE_IN</td>
<td>YUV420, YUV422_ONE</td>
</tr>
<tr>
<td>VPE_IN (compress mode)</td>
<td>YUV420_NVX3, YUV420_NVX4</td>
</tr>
<tr>
<td>VPE_OUT</td>
<td>YUV420, YUV422_ONE</td>
</tr>
<tr>
<td>VPE_OUT (compress mode)</td>
<td>YUV420_NVX3</td>
</tr>
<tr>
<td>VENC_IN (JPEG)</td>
<td>YUV420</td>
</tr>
<tr>
<td>VENC_IN (JPEG) (compress mode)</td>
<td>YUV420_NVX3</td>
</tr>
<tr>
<td>VENC_IN (H.265)</td>
<td>YUV420</td>
</tr>
<tr>
<td>VENC_IN (H.265) (compress mode)</td>
<td>YUV420_NVX3</td>
</tr>
<tr>
<td>VENC_IN (H.264)</td>
<td>YUV420</td>
</tr>
<tr>
<td>VENC_IN (H.264) (compress mode)</td>
<td>YUV420_NVX3</td>
</tr>
<tr>
<td>VENC OSG</td>
<td>ARGB1555</td>
</tr>
<tr>
<td>VDEC_OUT (JPEG)</td>
<td>YUV420</td>
</tr>
<tr>
<td>VDEC_OUT (H.265)</td>
<td>YUV420_NVX4, YUV420_NVX3 (ratio)</td>
</tr>
<tr>
<td>VDEC_OUT (H.264)</td>
<td>YUV420_NVX4, YUV420_NVX3 (ratio)</td>
</tr>
<tr>
<td>OSG IN</td>
<td>ARGB1555, ARGB8888</td>
</tr>
<tr>
<td>OSG OUT</td>
<td>YUV420, YUV422_NVX3</td>
</tr>
<tr>
<td>hd_gfx_xxx() APIs</td>
<td>ARGB1555, ARGB8888, YUV422_ONE, YUV420</td>
</tr>
<tr>
<td>HD_VIDEOPROC_PARAM_PATTERN_IMG</td>
<td>YUV422_ONE</td>
</tr>
<tr>
<td>HD_VIDEOENC_PARAM_IN_STAMP_IMG</td>
<td>ARGB1555, ARGB8888</td>
</tr>
<tr>
<td>HD_VIDEOOUT_PARAM_OUT_STAMP_IMG</td>
<td>ARGB1555, ARGB8888</td>
</tr>
<tr>
<td>HD_VIDEOOUT_PARAM_CLEAR_WIN</td>
<td>YUV422_ONE</td>
</tr>
</tbody>
</table>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="Footer" >
      
      
        
        <a href="CVAI/NT9833X_MD_User_Guide_en.html" class="md-footer__link md-footer__link--next" aria-label="Next: MD User Guide" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              MD User Guide
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
      
      
    
    <a href="https://github.com" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": ["search.highlight", "navigation.tabs", "content.code.annotate", "navigation.indexes", "toc.follow"], "search": "../assets/javascripts/workers/search.5bf1dace.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.37e9125f.min.js"></script>
      
    
  </body>
</html>